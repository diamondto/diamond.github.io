<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     爱产品，爱前端！
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="../../css/style.css">

  
<script src="../../js/pace.min.js"></script>


  

  

<link rel="alternate" href="atom.xml" title="爱产品，爱前端！" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/diamondto.github.io"
        target="_blank"><img width="149" height="149" src="../../images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="../../index.html">爱产品，爱前端！</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-多人姿态估计研究进展报告" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2020/02/18/%E5%A4%9A%E4%BA%BA%E5%A7%BF%E6%80%81%E4%BC%B0%E8%AE%A1%E7%A0%94%E7%A9%B6%E8%BF%9B%E5%B1%95%E6%8A%A5%E5%91%8A/"
    >多人姿态估计研究进展报告</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2020/02/18/%E5%A4%9A%E4%BA%BA%E5%A7%BF%E6%80%81%E4%BC%B0%E8%AE%A1%E7%A0%94%E7%A9%B6%E8%BF%9B%E5%B1%95%E6%8A%A5%E5%91%8A/" class="article-date">
  <time datetime="2020-02-17T16:00:00.000Z" itemprop="datePublished">2020-02-18</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/Artificial-Intelligence/">Artificial Intelligence</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="SimplePose-Rethinking-and-Improving-a-Bottom-upApproach-for-Multi-Person-Pose-Estimation"><a href="#SimplePose-Rethinking-and-Improving-a-Bottom-upApproach-for-Multi-Person-Pose-Estimation" class="headerlink" title="SimplePose:Rethinking and Improving a Bottom-upApproach for Multi-Person Pose Estimation"></a>SimplePose:Rethinking and Improving a Bottom-upApproach for Multi-Person Pose Estimation</h2><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的:"></a>实验目的:</h2><p> 1.将Spatial Attention Mechanism和Channel Attention Mechanism融 合到Stacked Hourglass中，使用多尺度监督学习的方法引导网络生成高质 量高分辨率的热图，并且提高网络检测人体姿态的尺度变化的鲁棒性。<br><img src="https://img-blog.csdnimg.cn/20200311232601643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>                                                                                         整体网络模型架构（图一）<br>                                                          导入空间注意力机制和渠道注意力机制的具体分支（图二）</p>
<h2 id="实验原理："><a href="#实验原理：" class="headerlink" title="实验原理："></a>实验原理：</h2><p>  让网络直接预测输入图像空间下的gaussian peak的采样。在下文的网络模 型和实验流程、难点中会详细推导。<br>  网络模型解析：<br>  1.从图一每个沙漏模块中提取5个不同尺度的特征图，这里的特征图指的是 所有下采样路径中被蓝色虚线框包围的特征图，用于生成不同尺度的热图。<br>   2.举例来说：图一中抽离了1/4比例尺的热图回归，前一阶段的回归特征图 和热图将在下一阶段根据身份ID来映射，通过 element-wise addition 的方法进行融合和复用。<br>  3.图二分为上下两个分支，提取了不同尺度的空间特征，生成Hourglass Network整个结构中所有分辨率的ground truth heatmap，网络内部在低 分辨率下做了多次前向推理，生成某个通道下的body part heatmap在各 个尺度的标签，实验结果中展示了5个scale下的热图。 </p>
<h2 id="实验对比"><a href="#实验对比" class="headerlink" title="实验对比:"></a>实验对比:</h2><p>1.在低分辨率下生成精确热度图的难度是很大的，先前的工作都是重新生成 在其他分辨率下的精确热图，采用特征金字塔的架构构建高级语义特征图。<br> 2.而本次实验方案是：汲取空间注意力机制的思想，使用自适应平均池化后 的“热度图”作为关键点定位信息的引导，先生成平均池化后的热度图，再 放置到网络输出的不同分辨率特征空间下做直接监督。 </p>
<h2 id="实验难点（一）"><a href="#实验难点（一）" class="headerlink" title="实验难点（一）"></a>实验难点（一）</h2><p>1.要对所引入的不同分辨率特征的监督损失做好平衡，否则容易出现训练失败（主要是梯度爆炸或者某个分辨率下学习不良）的情况。<br> 解决方案 : 1.对不同尺度下的损失进行加权，依据是根据输出特征图的面积进行数值上 的超参数调节。</p>
<h2 id="实验难点（二）"><a href="#实验难点（二）" class="headerlink" title="实验难点（二）"></a>实验难点（二）</h2><p> 2.解决数据预处理、坐标点变换和生成ground truth heatmap过程中的中 心点对齐问题，只有解决了这个问题才能让网络直接预测输入图像空间下的 gaussian peak的采样。 解决方案: 2.按照经典的图像缩放原则(比如opencv和PIL的resize函数)，将像素当作 是位于一个1*1单元格(cell)的中心，最终的目的是为了得出缩放前后某个像 素位置和原始位置的精确坐标值，这时候就需要考虑几何中心点对齐。 缩放过程中，必须要为目标图像dstImg上的每个像素位置找到与之对应的 原图像srcImg的位置，并把原图像srcImg上对应的像素值填入目标图像 dstImg的该坐标位置处。 注意：如果映射回原图srcImg的坐标位置不是整数，那么就需要做插值， 算出映射回去的非整数坐标位置上的原图上的像素值是多少，所以在缩放过 程中要选择使用几阶的插值算法 。<br> 实验中生成keypoint Gaussian heatmap和body part Gaussian heatmap的核心代码： </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 # x, y coordinates of centers of bigger grid, stride / 2 ‐0.5是为了在计算 响应图时，使用grid的中心 2 self.grid_x = np.arange(width) * stride + stride / 2 ‐ 0.5 # x ‐&gt; width</span><br><span class="line">3 self.grid_y = np.arange(height) * stride + stride / 2 ‐ 0.5 # y ‐&gt; heigh t4 # x ,y indexes (type: int) of heatmap feature maps 5 self.Y, self.X = np.mgrid[0:self.config.height:stride, 0:self.config.wid th:stride] 6 # 对&lt;numpy.lib.index_tricks.MGridClass object&gt; slice操作，比如L[:10:2]前1 0个数，每隔两个取一个 7 # # basically we should use center of grid, but in this place classic im plementation uses left‐top point. 8 self.X = self.X + stride / 2 ‐ 0.5 9 self.Y = self.Y + stride / 2 ‐ 0.5</span><br></pre></td></tr></table></figure>

<p> 实验难点（三）<br> 3.有多少个limb,就有多少个connection,相对应地就有多少个 paf channel。在处理某一个channel上limb的响应热图前，要保证它的长 宽与原始输入图片大小一致，必须要经过resize处理，具体处理时标号默认 从0开始而不是1。<br> 最终从收集的peaks中取出某类关键点（part)的集合。当出现不同节点相 互覆盖在同一个位置上时，代码中要做特殊边界处理，跳出本次检测的循 环。<br>实验结果： <img src="https://img-blog.csdnimg.cn/20200311232837586.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200311232853418.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="实验小结："><a href="#实验小结：" class="headerlink" title="实验小结："></a>实验小结：</h2><p>1.测试发现这种网络架构使用自适应平均池化后的“热度图”作为关键点定 位信息，将减少网络多尺度监督学习的难度，在低分辨率特征空间下只预测 关键点响应的大致区域。<br>2.实验结果显示：在多尺度特征融合的基础上，加入Spatial Attention Mechanism引导机制后，带来了1+%AP的精度提升。 实验改进方向： 对于预测body part area和keypoint area，回归gaussian peak比直接回 归两个相邻关键点之间的offset更加容易，但是要进一步提高AP，就要不 断优化不同关键点之间连接信息的挖掘策略，在代码中设计好逻辑判断，优 化预测limb的置信度迭代方案</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/Human-Pose-Estimination/" rel="tag">Human  Pose  Estimination</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-webpack学习笔记" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2020/01/15/webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
    >Webpack学习笔记</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2020/01/15/webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-01-14T16:00:00.000Z" itemprop="datePublished">2020-01-15</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7Webpack/">打怪升级Webpack</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p>
<h2 id="四个核心概念："><a href="#四个核心概念：" class="headerlink" title="四个核心概念："></a>四个核心概念：</h2><p>入口(entry)<br>输出(output)<br>loader：实现非js文件的打包，比如css, img, html等，通过loader功能<br>插件(plugins)：有效地打包压缩css/img/html等文件<br>loader和plugins配合使用。</p>
<p>更多👉：官方文档</p>
<h2 id="1-全局安装"><a href="#1-全局安装" class="headerlink" title="1.全局安装"></a>1.全局安装</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">npm/cnpm install webpack -g</span><br><span class="line">npm/cnpm install webpack-cli -g</span><br><span class="line">或者</span><br><span class="line">npm/cnpm install webpack webpack-cli -g</span><br></pre></td></tr></table></figure>

<h2 id="2-项目初始化，生成package-json"><a href="#2-项目初始化，生成package-json" class="headerlink" title="2. 项目初始化，生成package.json"></a>2. 项目初始化，生成package.json</h2><p>进入项目目录project_dir<br>执行npm init，一路回车，默认即可<br>项目文件夹下，会生成文件夹node_modules和文件package.json</p>
<h2 id="3-局部安装"><a href="#3-局部安装" class="headerlink" title="3. 局部安装"></a>3. 局部安装</h2><p>在项目目录下打开cmd<br>执行命令：<br>npm/cnpm install webpack webpack-cli -S</p>
<h2 id="4-打包测试"><a href="#4-打包测试" class="headerlink" title="4. 打包测试"></a>4. 打包测试</h2><p>webpack4打包命令为：webpack</p>
<p>D:\wpack&gt;webpack<br>默认entry：src/index.js</p>
<p>默认output：dist/main.js</p>
<p>默认打包模式为生成环境production</p>
<p>开发模式（不压缩格式）：webpack –mode development</p>
<p>生产模式（压缩格式）：webpack –mode production</p>
<h2 id="5-基本配置-webpack-config-js"><a href="#5-基本配置-webpack-config-js" class="headerlink" title="5. 基本配置: webpack.config.js"></a>5. 基本配置: webpack.config.js</h2><p>5.1 webpack.config.js配置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">"production"</span>, <span class="comment">// 两种模式：production和development，默认prodcution</span></span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">'main.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，mode模式设置，亦可在package.json中设置，选一种方法即可。</p>
<p>5.2 package.json配置</p>
<p>在package.json文件中可以进行一些配置，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置为如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="string">"scripts"</span>: &#123;</span><br><span class="line">        <span class="comment">// test等脚本名字随意自定义</span></span><br><span class="line">        <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</span><br><span class="line">        <span class="comment">// 定义一个build脚本，指定config文件名称，可以更改配置文件的名字，例如改为webpack.config.my.js</span></span><br><span class="line">        <span class="string">"build"</span>: <span class="string">"webpack --config webpack.config.js"</span></span><br><span class="line">        <span class="comment">// mode设置，webpack.config.js中设置过mode后，此处可不用重复设置</span></span><br><span class="line">        <span class="string">"start"</span>: <span class="string">"webpack --mode development"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">执行脚本：</span><br><span class="line"></span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<h2 id="6-安装本地服务器（dev-server）："><a href="#6-安装本地服务器（dev-server）：" class="headerlink" title="6 安装本地服务器（dev-server）："></a>6 安装本地服务器（dev-server）：</h2><p>在项目目录下执行命令：npm/cnpm install webpack-dev-server -S</p>
<p>webpack.config.js中相关配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">'main2.js'</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<pre><code>// 配置dev-server</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase:<span class="string">"./dist"</span>,</span><br><span class="line">        <span class="comment">// 本地服务器打包后文件保存路径</span></span><br><span class="line">        inline:<span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 实时刷新开启</span></span><br><span class="line">        port: <span class="number">3000</span>,</span><br><span class="line">        <span class="comment">// 端口设置</span></span><br><span class="line">        progress: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 打包进度条开启</span></span><br><span class="line">        compress: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 启动压缩</span></span><br><span class="line">        open: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 自动打开浏览器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>devServer中还有很多配置项目，如port端口等。</p>
<p><strong>package.json中相关配置：</strong>添加dev脚本，通过执行npm run dev实现自动打开浏览器并在更新js文件后自动刷新浏览器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">     <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</span><br><span class="line">     <span class="string">"build"</span>: <span class="string">"webpack --config webpack.config.js"</span>,</span><br><span class="line">     <span class="string">"start"</span>: <span class="string">"webpack --mode development"</span>,</span><br><span class="line">     <span class="comment">// 定义一个dev脚本，启动服务器</span></span><br><span class="line">     <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --open --inline"</span></span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<p>dev脚本说明：</p>
<p>webpack-dev-server：”启动webpack本地服务器”<br>–open: “自动打开浏览器”<br>–inline: “更新js后实时刷新浏览器”<br>注：总结：模块打包机，分析项目结构，找到JS模块和一些浏览器不能直接运行的拓展语言  scss  typescript，并将其打包为合适的格式给浏览器使用.优化产出，解析JS的模块，以当前的JS为准，查找所有相关的依赖文件，把文件打包成一个文件，解决了require问题。目录是dist<br>命令是npx webpack<br>手动配置，webpage.config.js<br>webpack是node写出来 的,自己配置入口和出口，路劲必须是绝对路径<br>path.resolve可以把相对路径解析成绝对路径</p>
<h2 id="7-loader配置"><a href="#7-loader配置" class="headerlink" title="7. loader配置"></a>7. loader配置</h2><p>7.1 测试无loader时的打包</p>
<p>首先在/src下创建一个style.css文件，然后在入口文件index.js中引入，方法如下：</p>
<p>import ‘./style.css’;<br>保存后，dev-server自动打包并刷新，但会报错，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Version: webpack <span class="number">4.41</span><span class="number">.2</span></span><br><span class="line">Time: <span class="number">28</span>ms</span><br><span class="line">Built at: <span class="number">2019</span><span class="number">-12</span><span class="number">-15</span> <span class="number">3</span>:<span class="number">04</span>:<span class="number">36</span> PM</span><br><span class="line">   Asset     Size  Chunks             Chunk Names</span><br><span class="line">main2.js  <span class="number">366</span> KiB    main  [emitted]  main</span><br><span class="line">Entrypoint main = main2.js</span><br><span class="line">[./src/index.js] <span class="number">200</span> bytes &#123;main&#125; [built]</span><br><span class="line">[./src/style.css] <span class="number">274</span> bytes &#123;main&#125; [built] [failed] [<span class="number">1</span> error]</span><br><span class="line">    + <span class="number">32</span> hidden modules</span><br><span class="line"></span><br><span class="line">ERROR <span class="keyword">in</span> ./src/style.css <span class="number">1</span>:<span class="number">4</span></span><br><span class="line">Module parse failed: Unexpected token (<span class="number">1</span>:<span class="number">4</span>)</span><br><span class="line">You may need an appropriate loader to handle <span class="keyword">this</span> file type, currently no loaders are configured to process <span class="keyword">this</span> file. See https:<span class="comment">//webpack.js.org/concepts#loaders</span></span><br><span class="line">&gt; body&#123;</span><br><span class="line">|     background-color: orange;</span><br><span class="line">| &#125;</span><br><span class="line"> @ ./src/index.js <span class="number">6</span>:<span class="number">0</span><span class="number">-21</span></span><br><span class="line">i ｢wdm｣: Failed to compile.</span><br><span class="line">原因为：没有相应的loader。</span><br></pre></td></tr></table></figure>

<p>7.2 配置loader</p>
<p>根据loader列表，找到对应的loader并下载安装（注意在项目目录下）。</p>
<p>安装常用的loader：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cnpm install style-loader css-loader -S</span><br><span class="line">cnpm install less less-loader -S</span><br><span class="line">cnpm install file-loader -S</span><br><span class="line">配置webpack.config.js：</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">       contentBase:<span class="string">"./dist"</span>,</span><br><span class="line">       <span class="comment">// 本地服务器路径</span></span><br><span class="line">       inline:<span class="literal">true</span>,</span><br><span class="line">       <span class="comment">// 实时刷新开启</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="built_in">module</span>: &#123;</span><br><span class="line">       rules: [</span><br><span class="line">           <span class="comment">// 配置打包css文件的loader，use定义使用到的loader，注意顺序</span></span><br><span class="line">         	&#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>] &#125;,</span><br><span class="line">           <span class="comment">// 配置图片的loader</span></span><br><span class="line">           &#123; <span class="attr">test</span>: <span class="regexp">/\.(jpg|png|jpeg)$/</span>, <span class="attr">use</span>: [<span class="string">'file-loader'</span>] &#125;</span><br><span class="line">           <span class="comment">// 根据需要配置其他文件的loader</span></span><br><span class="line">       ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>注意：style-loader必须放在css-loader前面，执行有顺序（链式传递），否则报错。<br>从上到下、从右至左，顺序执行。<br>bundle是打包后的结果<br>bundle.js是一个匿名自执行函数，默认执行会传入一个对象，key  value<br>当前模块的路径是key   value函数是对象，对象中找到名字，call传入当前模块，require的返回结果就是模块的导出，把解析的所有模块变成一个对象，通过入口加载，依次去递归实现依赖关系。<br>入口文件，检查一下是不是在缓存中，安装模块，<br>dev:server:可以配置端口，加进度条progress<br>contentbase:找到文件夹<br>实现静态服务，npm run dev<br>插件：<br>打包后叫bundle.js<br>HTMLWebpackPlugin<br>yarn add<br>插件是一个数组，放着所有的插件<br>先new 一下，告诉模板和打包后的名字 npm run dev<br>哈希戳，在minify里面配置<br>hash可以产生新的时间标志，文件有更改，每次打包都不一样防止覆盖，加hash指定位数。<br>默认只认定JS模块， 模块解析失败  需要loader处理CSS模块<br>把源代码转换，转化成一个模块，配置module<br>找到以CSS结尾的，写正则，写个规则数组，去匹配不同的文件，<br>匹配CSS，/.css$/<br>css-loader 接续@import<br>style-loader  把CSS插入到head的标签中<br><strong>loader单一职责，多个loader需要数组，有顺序 的，默认从右向左，从下到上执行，先CSS再插入  loader还可以写成对象的方式，对象可以多传参数</strong><br>less-loader  style-loader<br>options里面可以写配置参数，写插入的位置<br>less-loader把less-&gt;css<br>yarn add less-loader<br>sass stylus sass-loader<br><strong>插件没有顺序<br>单独抽离文件 mini-css-extract-plugin</strong><br>插件都是类，new一下，写上名字<br>post-css-loader<br>插件有:mini -css-extract-plugin<br>optimize-css-assets-webpack-plugin<br>sourcemap源码映射</p>
<p>rule的另一种丰富配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.(css|less)$/</span>, <span class="attr">use</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: <span class="string">"style-loader"</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">						<span class="comment">// 此处可以进行其他设置</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                    <span class="string">'css-loader'</span>, <span class="comment">// 解析@import路径</span></span><br><span class="line">                    <span class="string">'less-loader'</span> <span class="comment">// 把less解析为css</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">如上rule的执行顺序为：less-loader &gt; css-loader &gt; style-loader &gt; options</span><br></pre></td></tr></table></figure>

<h2 id="8-插件plugins"><a href="#8-插件plugins" class="headerlink" title="8. 插件plugins"></a>8. 插件plugins</h2><p>插件在webpack.config.js中不区分顺序。</p>
<p>8.1 Html文件处理</p>
<p>，打包html文件，安装插件（注意在项目目录下安装）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">cnpm install html-webpack-plugin -S</span><br><span class="line">配置webpack.config.js：</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">"html-webpack-plugin"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// 配置loader</span></span><br><span class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>] &#125;,</span><br><span class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.(jpg|png|jpeg)$/</span>, <span class="attr">use</span>: [<span class="string">'file-loader'</span>] &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 配置插件</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: <span class="string">"./src/index.html"</span>, <span class="comment">// 打包前的html文件</span></span><br><span class="line">            filename: <span class="string">"index.html"</span>, <span class="comment">// 打包后的html文件名</span></span><br><span class="line">            minify: &#123;</span><br><span class="line">                removeAttributeQuotes: <span class="literal">true</span>, <span class="comment">// 去除引号</span></span><br><span class="line">                removeComments: <span class="literal">true</span>, <span class="comment">// 去除注意</span></span><br><span class="line">                removeEmptyAttributes: <span class="literal">true</span>,<span class="comment">// 去除空属性</span></span><br><span class="line">                collapseWhitespace: <span class="literal">true</span> <span class="comment">// 去除空格</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p>8.2 样式抽离</p>
<p>安装抽离css插件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --save-dev mini-css-extract-plugin</span><br><span class="line">配置webpack.config.js：</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">"html-webpack-plugin"</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">"mini-css-extract-plugin"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 方法三： 使用抽离</span></span><br><span class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [</span><br><span class="line">                    MiniCssExtractPlugin.loader,</span><br><span class="line">                    <span class="string">'css-loader'</span>, <span class="comment">// 解析@import路径</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.less$/</span>, <span class="attr">use</span>: [</span><br><span class="line">                    MiniCssExtractPlugin.loader,</span><br><span class="line">                    <span class="string">'css-loader'</span>, <span class="comment">// 解析@import路径</span></span><br><span class="line">                    <span class="string">'less-loader'</span> <span class="comment">// 把less解析为css</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.(jpg|png|jpeg)$/</span>, <span class="attr">use</span>: [<span class="string">'file-loader'</span>] &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 添加css抽离插件</span></span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: <span class="string">"main.css"</span>, <span class="comment">// 设置文件，css抽离为main.css文件中</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p>抽离出的main.css没有被压缩，需安装插件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --save-dev terser-webpack-plugin <span class="comment">// 压缩js</span></span><br><span class="line">cnpm install --save-dev optimize-css-assets-webpack-plugin  <span class="comment">// 压缩抽离的css</span></span><br><span class="line">注意：以上两个插件需配合使用，同时配置，如只配置css插件，则js不会被压缩。</span><br></pre></td></tr></table></figure>

<p>并配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">"html-webpack-plugin"</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">"mini-css-extract-plugin"</span>);</span><br><span class="line"><span class="keyword">const</span> TerserJSPlugin = <span class="built_in">require</span>(<span class="string">"terser-webpack-plugin"</span>);</span><br><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">"optimize-css-assets-webpack-plugin"</span>);</span><br><span class="line"><span class="comment">// 此处省略...</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">"production"</span>, <span class="comment">//此处必须设置为production模式，否则抽离的css文件不会被压缩</span></span><br><span class="line">    <span class="comment">// 此处省略...</span></span><br><span class="line">    optimization: &#123; <span class="comment">// 优化项</span></span><br><span class="line">        minimizer: [</span><br><span class="line">            <span class="comment">// 同时实现js文件的压缩，与css抽离压缩插件同时配合使用，替代uglify</span></span><br><span class="line">            <span class="keyword">new</span> TerserJSPlugin(&#123;&#125;),</span><br><span class="line">            <span class="comment">// 压缩抽离后的css文件，此优化仅在production模式有效，development模式下不压缩</span></span><br><span class="line">            <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;&#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        <span class="comment">// 此处省略...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:&#123;</span><br><span class="line">        <span class="comment">// 此处省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">优化项配置完成后，抽离的css文件和js文件即可正常同时被压缩。</span><br></pre></td></tr></table></figure>

<h2 id="9-JS语法转化"><a href="#9-JS语法转化" class="headerlink" title="9. JS语法转化"></a>9. JS语法转化</h2><p>使用babel模块。<br>安装基础loader：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">npm install -D babel-loader @babel/core @babel/preset-env webpack</span><br><span class="line">安装转化<span class="class"><span class="keyword">class</span>定义的对象的<span class="title">loader</span>：</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">npm</span> <span class="title">install</span> --<span class="title">save</span>-<span class="title">dev</span> @<span class="title">babel</span>/<span class="title">plugin</span>-<span class="title">proposal</span>-<span class="title">class</span>-<span class="title">properties</span></span></span><br><span class="line"><span class="class">安装转化装饰器用法的<span class="title">loader</span>：</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">npm</span> <span class="title">install</span> --<span class="title">save</span>-<span class="title">dev</span> @<span class="title">babel</span>/<span class="title">plugin</span>-<span class="title">proposal</span>-<span class="title">decorators</span></span></span><br><span class="line"><span class="class">配置<span class="title">webpack</span>.<span class="title">config</span>.<span class="title">js</span>：</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 此处省略...</span></span><br><span class="line"><span class="class"><span class="title">module</span>.<span class="title">exports</span> </span>= &#123;</span><br><span class="line"><span class="comment">// 此处省略...</span></span><br><span class="line">    rules: [</span><br><span class="line">            <span class="comment">// 此处省略...</span></span><br><span class="line">            <span class="comment">// js语法转化</span></span><br><span class="line">            &#123;<span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">use</span>: &#123;</span><br><span class="line">                loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                  presets: [<span class="string">'@babel/preset-env'</span>],</span><br><span class="line">                  plugins: [  <span class="comment">// 参考文档配置</span></span><br><span class="line">                      <span class="comment">// '@babel/plugin-proposal-object-rest-spread',</span></span><br><span class="line">                      [<span class="string">"@babel/plugin-proposal-decorators"</span>, &#123; <span class="string">"legacy"</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">                      [<span class="string">"@babel/plugin-proposal-class-properties"</span>, &#123; <span class="string">"loose"</span> : <span class="literal">true</span> &#125;]</span><br><span class="line">                  ]</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br><span class="line">如有需要其他babel-loader，可通过官网查找安装并配置。</span><br></pre></td></tr></table></figure>
<p>转化ES6语法<br>babel转换JS转成ES5 核心模块可以转换源代码<br>yarn add babel-loader @babel/core  @babel/preset-env  转化JS语法<br>promise也不会转化，要安装babel代码运行的包<br>@Babel/plugin-transform-runtime<br>@Babel-polyfill<br>js语法校验器：ESLint   校验语法规范<br>yarn add eslint eslint-loader   自己选择公司需要的环境和规则，下载json 文件放到配置中<br>enforce:”pre”   可以强制改变执行顺序</p>
<h2 id="10-图片处理"><a href="#10-图片处理" class="headerlink" title="10. 图片处理"></a>10. 图片处理</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>&gt; 在js中创建图片来引入:</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> bgimg <span class="keyword">from</span> <span class="string">'./2.png'</span>; <span class="comment">// 引入图片并返回新的图片地址</span></span><br><span class="line"><span class="keyword">let</span> image = <span class="keyword">new</span> Image();</span><br><span class="line"><span class="built_in">console</span>.log(image);</span><br><span class="line">image.src = bgimg;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line"><span class="number">2</span>&gt; 在CSS中引入图片:</span><br><span class="line"></span><br><span class="line">body&#123;</span><br><span class="line">    background-color: yellow;</span><br><span class="line">    background-image: url(<span class="string">"2.png"</span>);</span><br><span class="line">&#125;</span><br><span class="line">div&#123;</span><br><span class="line">    background-image: url(<span class="string">'./1.jpg'</span>);</span><br><span class="line">    width: <span class="number">500</span>px;</span><br><span class="line">    height: <span class="number">700</span>px;</span><br><span class="line">&#125;</span><br><span class="line">然后由js导入：</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./style.css'</span>;</span><br><span class="line"><span class="number">3</span>&gt; html中img标签引入图片：</span><br><span class="line"></span><br><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.(jpg|png|jpeg)$/</span>, <span class="attr">use</span>: &#123;</span><br><span class="line">                loader: <span class="string">'file-loader'</span>,</span><br><span class="line">                options:&#123;</span><br><span class="line">                    esModule: <span class="literal">false</span>, <span class="comment">// 此处必须加，否则无法压缩图片路径</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; &#125;,</span><br><span class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.html$/</span>, <span class="attr">use</span>: &#123;</span><br><span class="line">                loader: <span class="string">'html-loader'</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    attrs: [<span class="string">':src'</span>, <span class="string">':data-src'</span>],</span><br><span class="line">                    minimize:<span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; &#125;,</span><br><span class="line">            <span class="comment">// &#123; test: /\.html$/, use: 'html-withimg-loader' &#125;,</span></span><br></pre></td></tr></table></figure>

<h2 id="11-指定路径"><a href="#11-指定路径" class="headerlink" title="11. 指定路径"></a>11. 指定路径</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>&gt; 单独位img路径添加域名前缀：</span><br><span class="line"></span><br><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.(jpg|png|jpeg)$/</span>, <span class="attr">use</span>: &#123;</span><br><span class="line">                loader: <span class="string">'file-loader'</span>,</span><br><span class="line">                options:&#123;</span><br><span class="line">                    esModule: <span class="literal">false</span>,</span><br><span class="line">                    outputPath: <span class="string">'/img/'</span>,  <span class="comment">// 存放在img文件夹下</span></span><br><span class="line">                    publicPath: <span class="string">'htpp://localhost'</span> <span class="comment">// 路径前添加域名，此时/img/文件夹失效；</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; &#125;,</span><br><span class="line">故，其他文件可进行类似单独设置。 <span class="number">2</span>&gt; 为img/css/js等文件统一添加域名前缀：</span><br><span class="line"></span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">'bundle-[hash:8].js'</span>,  <span class="comment">// bundle-[hash].js 给文件名增加hash值,[hash:8]显示前8位</span></span><br><span class="line">        publicPath: <span class="string">'http://localhost'</span>  <span class="comment">// 为所有路径添加域名前缀</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>3&gt;为css指定存放文件夹：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">      <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">          filename: <span class="string">"css/main.css"</span>, <span class="comment">// css抽离为main.css文件中,并存放只dist/css文件夹下</span></span><br><span class="line">      &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>

<h2 id="12-多页面打包"><a href="#12-多页面打包" class="headerlink" title="12. 多页面打包"></a>12. 多页面打包</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>&gt; 多入口entry、多出口output设置：</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单入口</span></span><br><span class="line">    <span class="comment">// entry: './src/index.js',</span></span><br><span class="line">    <span class="comment">// 多入口</span></span><br><span class="line">    entry: &#123;</span><br><span class="line">        home: <span class="string">'./src/index.js'</span>,</span><br><span class="line">        other: <span class="string">'./src/other.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 对应多出口</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        <span class="comment">// 单出口设置</span></span><br><span class="line">        <span class="comment">// filename: 'bundle-[hash:8].js',  // bundle-[hash].js 给文件名增加hash值,[hash:8]显示前8位</span></span><br><span class="line">        <span class="comment">// path: path.resolve(__dirname, 'dist'),</span></span><br><span class="line">        <span class="comment">// 多出口设置, [name]代表多入口变量名home,other，逐一打包</span></span><br><span class="line">        filename: <span class="string">'[name].js'</span>, <span class="comment">// 仍可以加hash值</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">        <span class="comment">// publicPath: 'http://localhost'</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>2&gt; html-webpack-plugin设置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: <span class="string">"./index.html"</span>,</span><br><span class="line">            filename: <span class="string">"index.html"</span>,</span><br><span class="line">            chunks: [<span class="string">'home'</span>], <span class="comment">// 多页面打包设置，对应入口js</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="comment">// 多页面打包，多个new，单页面可以引入多个入口js</span></span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: <span class="string">"./other.html"</span>,</span><br><span class="line">            filename: <span class="string">"other.html"</span>,</span><br><span class="line">            chunks: [<span class="string">'other'</span>, <span class="string">'home'</span>], <span class="comment">// 多页面打包设置，对应入口js, 先引入home再other</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<h2 id="13-配置source-map"><a href="#13-配置source-map" class="headerlink" title="13. 配置source-map"></a>13. 配置source-map</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">tips：source-map会明显增加打包时间。 需要安装的包： @babel/core @babel/preset-env babel-loader webpack-dev-server 设置：</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        home: <span class="string">'./src/index.js'</span>,</span><br><span class="line">        other: <span class="string">'./src/other.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 对应多出口</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name].js'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1）源码映射，单独生成一个sourcemap文件，出错时会直接提示报错行</span></span><br><span class="line">    <span class="comment">// devtool: 'source-map', // 大而全的设置</span></span><br><span class="line">    <span class="comment">// 2）源码映射，不会产生单独的文件，单会直接显示错误的行列</span></span><br><span class="line">    <span class="comment">// devtool: 'eval-source-map',</span></span><br><span class="line">    <span class="comment">// 3) 不会产生列，但是会生成一个单独的映射文件</span></span><br><span class="line">    <span class="comment">// devtool: 'cheap-module-source-map', // 产生后可以保留起来</span></span><br><span class="line">    <span class="comment">// 4) 不会产生文件，集成再打包后的文件中，也不会产生列</span></span><br><span class="line">    devtool: <span class="string">'cheap-module-source-map'</span>, <span class="comment">// 产生后可以保留起来</span></span><br><span class="line">&#125;</span><br><span class="line">ps：以上<span class="number">4</span>个方法貌似都生成map文件了</span><br></pre></td></tr></table></figure>

<h2 id="14-watch实时打包"><a href="#14-watch实时打包" class="headerlink" title="14. watch实时打包"></a>14. watch实时打包</h2><p>希望实时打包，开启监控，<br>设置如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    devtool: <span class="string">'cheap-module-source-map'</span>, <span class="comment">// 产生后可以保留起来</span></span><br><span class="line">    <span class="comment">// 开启监控，实时打包设置</span></span><br><span class="line">    watch: <span class="literal">true</span>,<span class="comment">//</span></span><br><span class="line">    watchOptions:&#123; <span class="comment">// 设置监控选项</span></span><br><span class="line">        poll: <span class="number">1000</span>, <span class="comment">// 每秒查询1000次，我需要更新吗？</span></span><br><span class="line">        aggregateTimeout: <span class="number">500</span>, <span class="comment">// 防抖，ctrl+s后多久开始打包  500 MS内我输入的代码只打包一次</span></span><br><span class="line">        ignored: <span class="regexp">/node_modules/</span>, <span class="comment">// 忽略不需要监控的文件夹，不用监控</span></span><br><span class="line">    &#125;,</span><br><span class="line">    devServer: &#123;&#125;<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-常用插件（3个）"><a href="#15-常用插件（3个）" class="headerlink" title="15. 常用插件（3个）"></a>15. 常用插件（3个）</h2><p>安装：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --save-dev clean-webpack-plugin</span><br><span class="line">cnpm install --save-dev copy-webpack-plugin</span><br><span class="line">cleanwebpackPlugin -- 打包前清除dist目录</span><br><span class="line">copywebpackPlugin -- copy目录中的文件到指定目录</span><br><span class="line">bannerPlugin -- 版权声明插件，webpack内部插件，无需安装 引入：</span><br><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">"clean-webpack-plugin"</span>);</span><br><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">"copy-webpack-plugin"</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>); <span class="comment">// 内置bannerPlugin插件</span></span><br><span class="line"></span><br><span class="line">plugins:[</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(), <span class="comment">// 先删除dist目录再打包，不用填参数</span></span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin([ <span class="comment">// 可以设置多组from to</span></span><br><span class="line">        &#123;<span class="attr">from</span>:<span class="string">'doc'</span>, <span class="attr">to</span>:<span class="string">'./'</span>&#125;</span><br><span class="line">    ]),</span><br><span class="line">    <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">"Make 2019 by Hanoso"</span>), <span class="comment">// 声明版权信息</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>ps：常用插件可以根据需要自行决定安装~</p>
<h2 id="16-webpack跨域问题"><a href="#16-webpack跨域问题" class="headerlink" title="16. webpack跨域问题"></a>16. webpack跨域问题</h2><p>跨域：请求端和响应端域名/端口不一致，即为跨域。 默认访问的路径<a href="http://localhost:8081" target="_blank" rel="noopener">http://localhost:8081</a> webpack-dev-serer服务路径 =&gt; 服务器端口3000端口 –&gt;跨域</p>
<p>1） 方法一：配置代理</p>
<p>首先在项目根目录创建server.js服务端文件；<br>配置devServer代理；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">在index.js中配置Ajax请求响应。</span><br><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="comment">// express</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);   <span class="comment">// 引入express，默认会启用服务</span></span><br><span class="line"><span class="keyword">let</span> app = express(); <span class="comment">// 创建app服务，让express执行</span></span><br><span class="line"><span class="comment">// /api/user, /test/user，请求路径中的mock被替换为空</span></span><br><span class="line">app.get(<span class="string">'/user'</span>,(req,res)=&gt;&#123; <span class="comment">// 写接口，请求req响应res，get请求路径/user，回调函数</span></span><br><span class="line">    res.json(&#123;<span class="attr">name</span>:<span class="string">'Hanoso666'</span>&#125;) <span class="comment">// 返回的响应json</span></span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>); <span class="comment">// 监听3000端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">devServer&#123;</span><br><span class="line">            <span class="comment">// 配置代理</span></span><br><span class="line">        proxy:&#123;</span><br><span class="line">            <span class="string">'/api'</span>: &#123;</span><br><span class="line">                <span class="comment">// webpack默认首页打开未8081端口，配置target转至3000端口，与</span></span><br><span class="line">                <span class="comment">// server.js端口保持一致，从而解决跨域问题</span></span><br><span class="line">                target: <span class="string">'http://localhost:3000'</span>,<span class="comment">//告诉去3000找API的user</span></span><br><span class="line">                pathRewrite: &#123;<span class="string">'^/api'</span>:<span class="string">''</span>&#125;, <span class="comment">// 将请求路径中开头/api替换为空，通过重写的方法把请求代理到express服务器上，前提是有服务器。</span></span><br><span class="line">                <span class="comment">// 请求端路径/api/user，实际情况不确定，可以有很多写法，如/test/user, /new/user等等，为避免重复设置，可将前端请求路径统一以/mock开头，如/mock/api/user, /mock/test/user, /mock/new/user, 然后将/mock替换为空，server.js中去掉/mock</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// 创建Ajax对象</span></span><br><span class="line">xhr.open(<span class="string">'GET'</span>,<span class="string">'/api/user'</span>,<span class="literal">true</span>); <span class="comment">// 建立GET请求 指定方法，路径，是否异步  /mock/api/user, /mock/test/user</span></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xhr.response); <span class="comment">// 设置回调，处理结果</span></span><br><span class="line">&#125;</span><br><span class="line">xhr.send(); <span class="comment">// 发送Ajax请求</span></span><br><span class="line">结果：启动dev和server.js后，访问http:<span class="comment">//localhost:8081即可经代理实现server.js响应，8081是webpack-dev-server的服务</span></span><br><span class="line">但是不在一个端口，要配置代理proxy。</span><br></pre></td></tr></table></figure>

<p>2）方法二：当前端只想单纯模拟数据时，不需要写server.js，只模拟前端数据 在devServer中设置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.cofig.js</span></span><br><span class="line">devServer&#123;</span><br><span class="line">        before(app)&#123; <span class="comment">// 内部的提供方法，钩子</span></span><br><span class="line">            app.get(<span class="string">'/user'</span>,(req,res)=&gt;&#123; <span class="comment">// 路径与index.js请求路径一致即可</span></span><br><span class="line">                res.json(&#123;<span class="attr">name</span>:<span class="string">'Hanoso2020'</span>&#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// express</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// 创建Ajax对象</span></span><br><span class="line">xhr.open(<span class="string">'GET'</span>,<span class="string">'/api/user'</span>,<span class="literal">true</span>); <span class="comment">// 建立GET请求 /mock/api/user, /mock/test/user</span></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xhr.response); <span class="comment">// 设置回调</span></span><br><span class="line">&#125;</span><br><span class="line">xhr.send(); <span class="comment">// 发送Ajax请求</span></span><br></pre></td></tr></table></figure>

<p>3）方法三：有服务端，不用代理来处理，能不能在服务端启动webpack? webpack就是一个模块<br>采用中间件 就可以！ 仅在server.js中配置，先通过webpack拿到配置对象，产生编译对象 ，扔给中间件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"><span class="keyword">let</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="comment">// 中间件</span></span><br><span class="line"><span class="keyword">let</span> middle = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>);</span><br><span class="line"><span class="keyword">let</span> config = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>);<span class="comment">//拿到配置对象</span></span><br><span class="line"><span class="keyword">let</span> compailer = webpack(config); <span class="comment">// 启动server.js时启动webpack，由服务器端启动前端，处理配置文件，返回编译后的结果</span></span><br><span class="line"></span><br><span class="line">app.use(middle(compailer));<span class="comment">//加载中间件</span></span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/user'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.json(&#123;<span class="attr">name</span>:<span class="string">'Hanoso-middle'</span>&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);  <span class="comment">// 端口可按需配置</span></span><br><span class="line">通过访问localhost:<span class="number">300</span>/user打开网页，即可实现数据打印&#123;<span class="string">"name"</span>:<span class="string">"Hanoso-middle"</span>&#125;，即设置成功。</span><br></pre></td></tr></table></figure>

<h2 id="17-resolve解析第三方包"><a href="#17-resolve解析第三方包" class="headerlink" title="17. resolve解析第三方包"></a>17. resolve解析第三方包</h2><p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span>.modules&#123;</span><br><span class="line">    resolve:&#123; <span class="comment">// 解析第三方包</span></span><br><span class="line">        modules:[path.resolve(<span class="string">'node_modules'</span>)],</span><br><span class="line">        extensions:[<span class="string">'.js'</span>,<span class="string">'.css'</span>,<span class="string">'.json'</span>,<span class="string">'.vue'</span>], <span class="comment">// 限定扩展名，按序依次解析</span></span><br><span class="line">        mainFields:[<span class="string">'style'</span>,<span class="string">'main'</span>,<span class="string">'index'</span>], <span class="comment">// 入口文件的名字 index.js</span></span><br><span class="line">        alias:&#123; <span class="comment">// 设置别名，在index.js引入时可直接采用 import 'bootstrap'</span></span><br><span class="line">            bootstrap:<span class="string">'bootstrap/dist/css/bootstrap.css'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-配置环境变量"><a href="#18-配置环境变量" class="headerlink" title="18. 配置环境变量"></a>18. 配置环境变量</h2><p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">            DEV:<span class="built_in">JSON</span>.stringify(<span class="string">'dev'</span>), <span class="comment">// 字符串判断</span></span><br><span class="line">            FLAG:<span class="string">'true'</span>,  <span class="comment">// 此处也仅为演示，布尔判断</span></span><br><span class="line">            EXPRESSION:<span class="string">'1+1'</span>,</span><br><span class="line">            <span class="comment">// EXPRESSION:JSON.stringify('1+1'),  // 不加JSON.stringify，会打印出1+1.加上则打印2，此处仅作演示</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// 环境变量配置</span></span><br><span class="line"><span class="keyword">let</span> url=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">if</span>(DEV == <span class="string">'dev'</span>)&#123;</span><br><span class="line">    url = <span class="string">'http://localhost:8081'</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    url = <span class="string">'http://www.baidu.com'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(DEV);</span><br><span class="line"><span class="built_in">console</span>.log(EXPRESSION);</span><br><span class="line"><span class="built_in">console</span>.log(url);</span><br></pre></td></tr></table></figure>

<h2 id="19-区分不同环境变量（环境继承）"><a href="#19-区分不同环境变量（环境继承）" class="headerlink" title="19. 区分不同环境变量（环境继承）"></a>19. 区分不同环境变量（环境继承）</h2><p>需安装插件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">cnpm i --save-dev webpack-merge</span><br><span class="line"><span class="number">1</span>&gt; 创建基础配置文件webpack.base.js； <span class="number">2</span>&gt; 创建开发环境配置文件webpack.dev.js； <span class="number">3</span>&gt; 创建生产环境配置文件webpack.pro.js； 通过webpack-merge可以实现不同环境配置文件与基础配置文件的继承/覆盖。 示例代码如下：</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.base.js 配置基础信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.dev.js 配置开发环境信息</span></span><br><span class="line"><span class="keyword">let</span> &#123;smart&#125; = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">let</span> base = <span class="built_in">require</span>(<span class="string">'./webpack.base.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = smart(base,&#123;</span><br><span class="line">    mode: <span class="string">'development'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.pro.js 配置生产环境信息</span></span><br><span class="line"><span class="keyword">let</span> &#123;smart&#125; = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">let</span> base = <span class="built_in">require</span>(<span class="string">'./webpack.base.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = smart(base,&#123;</span><br><span class="line">    mode: <span class="string">'production'</span></span><br><span class="line">&#125;)</span><br><span class="line">如开启不同环境，可执行如下代码： npm run build -- --config webpack.pro.js 亦可设置package.json文件：</span><br><span class="line"></span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"webpack --config webpack.config.js"</span>,</span><br><span class="line">    <span class="string">"b-dev"</span>: <span class="string">"webpack --config webpack.dev.js"</span>,</span><br><span class="line">    <span class="string">"b-pro"</span>: <span class="string">"webpack --config webpack.pro.js"</span>,</span><br><span class="line">    <span class="string">"wds"</span>: <span class="string">"webpack-dev-server"</span>,</span><br><span class="line">    <span class="string">"server"</span>: <span class="string">"node server.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">通过以下命令启动相应环境：npm run b-dev 或 npm run b-pro。</span><br></pre></td></tr></table></figure>

<h2 id="20-优化项"><a href="#20-优化项" class="headerlink" title="20. 优化项"></a>20. 优化项</h2><p>noParse<br>功能：不去解析包（如jQuery）中的依赖库。 需配置config。</p>
<p>exclude或include<br>功能：排除或指定查找路径/文件夹，配置其一即可。 需配置config。</p>
<p>moment时间插件及IgnorePlugin<br>功能：格式化时间，时间计算等，可以设置语言。 安装：cnpm i –save-dev moment</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间插件moment</span></span><br><span class="line"><span class="keyword">import</span> moment <span class="keyword">from</span> <span class="string">'moment'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'moment/locale/zh-cn'</span>; <span class="comment">// 仅引入中文包</span></span><br><span class="line">moment.locale(<span class="string">'zh-cn'</span>); <span class="comment">// 设置语言</span></span><br><span class="line"><span class="keyword">let</span> r = moment().endOf(<span class="string">'day'</span>).fromNow();</span><br><span class="line"><span class="built_in">console</span>.log(r);</span><br><span class="line">需配置config。</span><br></pre></td></tr></table></figure>

<p>happypack多线程打包模块<br>安装：cnpm i –save-dev happypack，cnpm i –save-dev @babel/preset-react 多线程打包输出如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Happy[css]: Version: <span class="number">5.0</span><span class="number">.1</span>. Threads: <span class="number">3</span></span><br><span class="line">i ｢wds｣: Project is running at http:<span class="comment">//localhost:8081/</span></span><br><span class="line">i ｢wds｣: webpack output is served <span class="keyword">from</span> /</span><br><span class="line">i ｢wds｣: Content not <span class="keyword">from</span> webpack is served <span class="keyword">from</span> ./dist</span><br><span class="line">Happy[css]: All <span class="keyword">set</span>; signaling webpack to proceed.</span><br><span class="line">Happy[js]: Version: 5.0.1. Threads: 3</span><br><span class="line">Happy[js]: All <span class="keyword">set</span>; signaling webpack to proceed.</span><br><span class="line">i ｢wdm｣: Hash: 7b2804c8263a364b7bf0</span><br><span class="line">Version: webpack 4.41.4</span><br><span class="line">Time: 2572ms</span><br><span class="line">Built at: 2019-12-21 10:31:04 PM</span><br><span class="line">需配置config。</span><br></pre></td></tr></table></figure>

<p>webpack自带优化（tree-shaking + scope hosting）<br><strong>tree-shaking：采用import引入 生产环境下，把没用的到的代码 自动删除掉；</strong><br><strong>scope hosting：作用域提升，webpack打包时 自动简化 省略中间代码；</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js中</span></span><br><span class="line"><span class="comment">// webpack自带优化功能 测试</span></span><br><span class="line"><span class="keyword">import</span> calc <span class="keyword">from</span> <span class="string">'./test'</span></span><br><span class="line"><span class="built_in">console</span>.log(calc.sum(<span class="number">1</span>,<span class="number">2</span>));<span class="comment">//要换成calc.default.sum</span></span><br><span class="line"><span class="comment">// import 在生产环境下 可以自动去掉用不到的代码</span></span><br><span class="line"><span class="comment">// tree-shaking 把没用的到的代码 自动删除掉</span></span><br><span class="line"><span class="comment">// let calc = require('./test')</span></span><br><span class="line"><span class="comment">// console.log(calc.default.sum(1,2)); // 采用require方式，sum在default中</span></span><br><span class="line"><span class="comment">// ES6 模块会把结果放到default中</span></span><br><span class="line"><span class="comment">// require 不支持tree-shaking,引入不能像import一样在生产环境下去除多余代码，故推荐使用import引入</span></span><br><span class="line"><span class="comment">// scope hosting 作用域提升</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> d = a + b + c;</span><br><span class="line"><span class="built_in">console</span>.log(d, <span class="string">'--------------------'</span>) <span class="comment">// webpack打包时 自动简化 省略中间代码，返回最终结果</span></span><br><span class="line">抽离公共代码【导致其他问题】</span><br><span class="line">位置：optimization &#123; <span class="attr">splitChunks</span>:&#123;...&#125; &#125;</span><br><span class="line">问题：添加splitChunks配置后，会影响js/css等文件的打包，浏览器无效果。</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js中示例代码：</span></span><br><span class="line"><span class="comment">// 抽离公共代码 测试</span></span><br><span class="line"><span class="comment">// console.log('抽离公共代码 测试')//是为了缓存，提高加载速度，切换页面时缓存公共的页面部分样式。</span></span><br><span class="line"><span class="comment">// import './a.js'</span></span><br><span class="line"><span class="comment">// import './b.js'</span></span><br><span class="line"><span class="comment">// console.log('./index.js')</span></span><br><span class="line"><span class="comment">// import jquery from 'jquery';</span></span><br><span class="line"><span class="comment">// console.log(jquery)</span></span><br></pre></td></tr></table></figure>
<p>需配置config，跟单入口，单出口的文件相比，entry现在是一个对象了，output 的 filename 多了一个 [name].。<br>最后执行打包命令，可以看到 dist 目录下面生成了 index.bundle.js 和 signup.bundle.js 。<br>所以这里的 [name] 等同于 entry 定义的键名。<br>适合多页面应用，缓存公共部分代码<br>当遇到诸多子功能模块时，全部打包在一起的话会有好几MB，所以最佳方式是进行多入口打包。<br>以下来自他人的项目建议：<br>首先，项目打包策略遵循以下几点原则：<br><strong>选择合适的打包粒度，生成的单文件大小不要超过500KB<br>   充分利用浏览器的并发请求，同时保证并发数不超过6<br>   尽可能让浏览器命中304，频繁改动的业务代码不要与公共代码打包<br>   避免加载太多用不到的代码，层级较深的页面进行异步加载</strong></p>
<blockquote>
<p>第三方库如vue、jquery、bootstrap打包为一个文件<br> 公共组件如弹窗、菜单等打包为一个文件<br> 工具类、项目通用基类打包为一个文件<br> 各个功能模块打包出自己的入口文件<br>  各功能模块作用一个SPA，子页面进行异步加载</p>
</blockquote>
<p><img src="https://img-blog.csdn.net/20180620225415604?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1N1cGVyX0xE/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p>
<h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>场景：播放音乐，点按钮再加载资源播放。<br>介绍：在js代码回调函数中import其他js文件，并获取其中的数据。</p>
<p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// source.js中</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">'lazy-load'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js中</span></span><br><span class="line"><span class="comment">// 懒加载 测试</span></span><br><span class="line"><span class="keyword">let</span> button = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>);<span class="comment">//绑定监听事件</span></span><br><span class="line">button.innerHTML = <span class="string">'Hello'</span>;</span><br><span class="line">button.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">import</span>(<span class="string">'./source.js'</span>).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;  <span class="comment">// 回调函数中引入，路由懒加载的实现就是靠import语法</span></span><br><span class="line">    <span class="comment">//es6中的草案语法，jsonp实现动态加载文件</span></span><br><span class="line">        <span class="built_in">console</span>.log(data.default);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(button);</span><br></pre></td></tr></table></figure>

<h2 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h2><p>功能：局部更新修改的内容。每次更改页面只变一部分</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js中</span></span><br><span class="line"><span class="comment">// 热更新 测试</span></span><br><span class="line"><span class="keyword">import</span> str <span class="keyword">from</span> <span class="string">'./source'</span>;<span class="comment">//</span></span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">module</span>.hot)&#123; <span class="comment">// 如果devServer中hot为true，则启动热更新</span></span><br><span class="line">    <span class="built_in">module</span>.hot.accept(<span class="string">'./source'</span>,()=&gt;&#123;<span class="comment">//若支持热更新</span></span><br><span class="line">        <span class="keyword">let</span> str = <span class="built_in">require</span>(<span class="string">'./source'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(str)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">需配置config。</span><br></pre></td></tr></table></figure>

<p>以下为上述优化项在webpack.config.js中的配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Happypack = <span class="built_in">require</span>(<span class="string">"happypack"</span>); <span class="comment">// 4）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        hot:<span class="literal">true</span>, <span class="comment">// </span></span><br><span class="line">    &#125;,</span><br><span class="line">    optimization: &#123; <span class="comment">// 优化项</span></span><br><span class="line">        minimizer: [ ],</span><br><span class="line">        <span class="comment">// splitChunks:&#123; // 分割代码块 6)</span></span><br><span class="line">        <span class="comment">//     cacheGroups:&#123; // 缓存组</span></span><br><span class="line">        <span class="comment">//         common:&#123; // 抽离 公共的模块</span></span><br><span class="line">        <span class="comment">//             chunks:'initial',</span></span><br><span class="line">        <span class="comment">//             minSize:0, // 最小大小</span></span><br><span class="line">        <span class="comment">//             minChunks:2, // 最小出现次数</span></span><br><span class="line">        <span class="comment">//         &#125;,</span></span><br><span class="line">        <span class="comment">//         vendor:&#123; // 抽离 第三方模块</span></span><br><span class="line">        <span class="comment">//             priority:1, // 权重高，优先抽离第三方模块，再抽离其他</span></span><br><span class="line">        <span class="comment">//             test:/node_modules/, // 要抽离出的文件</span></span><br><span class="line">        <span class="comment">//             chunks: 'initial',</span></span><br><span class="line">        <span class="comment">//             minSize:0,</span></span><br><span class="line">        <span class="comment">//             minChunks:2</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        noParse:<span class="regexp">/jquery/</span>, <span class="comment">// 排出不需要解析的包（没有其他依赖项的包）； 1)</span></span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// 优化：多线程打包css文件</span></span><br><span class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: <span class="string">'Happypack/loader?id=css'</span> &#125;,  <span class="comment">// 4)</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            &#123;<span class="attr">test</span>: <span class="regexp">/\.js$/</span>, </span><br><span class="line">            <span class="comment">// exclude和include配置一个即可 2)</span></span><br><span class="line">            exclude:<span class="regexp">/node_modules/</span>,  <span class="comment">// 排除文件夹，不去该路径下查找</span></span><br><span class="line">            <span class="comment">// include:path.resolve('src'), // 指定文件夹，去该路径下查找</span></span><br><span class="line">            <span class="comment">// 使用happypack对js进行打包</span></span><br><span class="line">            use: <span class="string">'Happypack/loader?id=js'</span>  <span class="comment">// 4)</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.NamedModulesPlugin(), <span class="comment">// 打印更新的模块路径 8)</span></span><br><span class="line">        <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(), <span class="comment">// 热更新插件 8)</span></span><br><span class="line">        <span class="keyword">new</span> Happypack(&#123; <span class="comment">// 多线程方式打包css文件 4)</span></span><br><span class="line">            id: <span class="string">'css'</span>,</span><br><span class="line">            use:[<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>]</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> Happypack(&#123; <span class="comment">// 多线程方式打包js文件 4)</span></span><br><span class="line">            id: <span class="string">'js'</span>,</span><br><span class="line">            use:[&#123;</span><br><span class="line">                loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">                options:&#123;</span><br><span class="line">                    presets: [</span><br><span class="line">                        <span class="string">'@babel/preset-env'</span>,</span><br><span class="line">                        <span class="string">'@babel/preset-react'</span></span><br><span class="line">                    ],</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> webpack.IgnorePlugin(<span class="regexp">/\.\/locale/</span>, /moment/), <span class="comment">// 忽略moment插件中的locale模块 3)</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%AD%A6%E4%B9%A0/" rel="tag">工具类学习</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-“新基建”的智能化思考" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/12/25/%E2%80%9C%E6%96%B0%E5%9F%BA%E5%BB%BA%E2%80%9D%E7%9A%84%E6%99%BA%E8%83%BD%E5%8C%96%E6%80%9D%E8%80%83/"
    >“新基建”的智能化思考</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/12/25/%E2%80%9C%E6%96%B0%E5%9F%BA%E5%BB%BA%E2%80%9D%E7%9A%84%E6%99%BA%E8%83%BD%E5%8C%96%E6%80%9D%E8%80%83/" class="article-date">
  <time datetime="2019-12-24T16:00:00.000Z" itemprop="datePublished">2019-12-25</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%80%9D%E8%80%83/">人工智能的思考</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="多足鼎立，工业互联网加快建设"><a href="#多足鼎立，工业互联网加快建设" class="headerlink" title="多足鼎立，工业互联网加快建设"></a>多足鼎立，工业互联网加快建设</h2><p>   众所周知，目前，云办公、云教育、云医疗、云游戏等服务需求激增，同时也带动了企业对高质量云服务的的需求，包括要<strong>更快的网络速度，更优的存储成本，更强大的计算能力以及更流畅的直播</strong>等功能应用。<br>   百度推出EasyDL将阳春白雪的“深度学习”下放到中小型企业，为企业和开发者提供了从<strong>完善安全的数据服务、大规模分布式模型训练、丰富灵活的模型部署</strong>到预测的一站式服务。作业帮、国家中小学网络云平台等企业通过百度智能云实现快速扩容，“空中课堂”没有出现卡顿，实现“丝滑般”的用户体验。个人见解，百度揭开“高大上”的深度学习面纱，将科研界蓬勃发展的AI技术真正应用到企业平台中，帮助企业灵活部署训练完成的模型，比如<strong>针对零售场景专项算法调优</strong>，结合<strong>图像合成与增强技术</strong>提升模型泛化能力，提升了货架巡检业务场景的模型高可用性，通过零售商品的识别调整货架成列规则、优化自助结算服务；通过视频图像监控，为自动化驾驶保障出行安全；还有工业生产质检、良优品分类、医疗和农业中的物料细分等应用，为了优化企业体验，减少部署难度，百度提供了强大的API接口，智能化的整合了<strong>公有云API、设备端SDK、私有服务器部署</strong>、软硬一体化的方案，灵活地适配了各种使用场景。<strong>据报道</strong>，在<strong>城市智慧政务领域</strong>，百度推出的AI测温系统、智能外呼平台、电子出入证等一揽子解决方案，快速落地应用在交通枢纽，基层街道社区，工厂园区、商业写字楼等，让社区防护工作有堵有疏；<strong>智慧医疗领域</strong>，灵医智惠推出的智能咨询助手助力第三方机构为公众提供在线问诊服务，倍数级提升人工在线咨询效率；智能质检帮助制造企业安全生产。<strong>世界日新月异，删繁就简作为最朴素的真理其实是最适用的</strong>，从抖音的“短小精悍”、到拼多多的“物美价廉”、微信小程序的“用完即走”    快捷、经济、方便、“傻瓜式使用”已经成为火热产品的标签，好的产品，大道至简，这也应征了云服务的未来发展趋势：<strong>更快的网络速度，更优的存储成本，更强大的计算能力以及更流畅的直播应用。</strong>怀揣着AI产品梦的我，也要深入思考<strong>AI能力与应用场景的融合创新</strong>，怎样打通人工智能产业化应用落地的全部流程？怎么优化AI技术的标准化、自动化、模块化？怎样使得开发者、企业无需从头学习难度高、迭代快的前沿科技，就能低成本快速开发自己的应用产品？怎样让AI产品更加富有情怀和温度，打通人性深处最柔软的共鸣？一切都来自于细致观察，深入思考，勤做笔记，开阔视野！雷军说：创业要大成，一定要找到能让猪飞上天的台风口。勤奋、努力加坚持等等，这些只是成功的必要条件，最关键的是在对的时候做对的事情。看国家最新出台政策，云来云往，在互联网大潮中轻装上阵，删繁就简，快、准、狠地抓住需求和痛点，才能游刃有余，脱颖而出。<br>   <img src="https://img-blog.csdnimg.cn/20200312083250994.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>   如果说百度EasyDL的策略是删繁就简，简化企业应用流程，解决落地后顾之忧，那么腾讯AI加速器的策略就是更注重细分构建场景、在算法优化、硬件设施构建和AI算力上抢占先机了。放眼大观，本土科技企业、知名国际加速器纷纷通过<strong>新设业务或分部的方式入局AI加速器</strong>，既有腾讯这样的航母级企业走出去寻找项目，也有微软加速器这样的外来者扎根本土培育优质项目。<br>  把目光转移到腾讯：2019年8月16日，腾讯AI加速器三期名单出炉。TOP30项目从1500个报名者中脱颖而出，录取率仅2%，三期项目总估值超200亿。腾讯把项目目标聚焦于<strong>金融、教育、安全、工业、机器人、IoT、云计算、5G</strong>等。12月21日至12月22日，腾讯产业加速器之AI与SaaS第二次融合课程在深圳举行。腾讯云副总裁、大数据人工智能总经理王龙带来《现状和未来，协作与创新-人工智能行业落地探讨》的主题分享。报告内容高屋建瓴，眼光独到，让人醍醐灌顶，获益匪浅。王龙老师提到：<strong>AI进入落地考核期，“剩”者为王</strong>。老师提到，未来没有硬实力的公司会与泡沫一同消散，<strong>真正具有商业价值的公司才能存活</strong>，腾讯犀牛鸟云开发人才培养计划也完美印证了这一人才揽收策略。<br>  <img src="https://img-blog.csdnimg.cn/20200312092409250.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 腾讯侧重在玩法上进行“升级”，聚焦医疗、智慧零售、智慧楼宇等赛道，同时也广邀农业、工业、旅游、环保、内容等行业合作伙伴的加入。加速意味着<strong>更高要求的技术细节调控</strong>、云计算和硬件平台支持已经无法被“孵化”所满足，加速模式应运而生。换句话说，<strong>孵化器解决从0到1的问题，加速器解决从1到X的问题</strong>，是做乘法的过程，相对于泛滥的、低门槛的孵化器，存在的必要性和价值大大提升。在这之前的9个月，首期腾讯AI加速器29个项目整体估值从70亿增长到200多亿。<br>而稍早前的3月，百度AI加速器第一期项目结项时一场声势浩大的Demo Day显示出百度把AI加速器提到了重要的战略位置。<br>  虽然还没有入局，但马云曾说过投资1000亿的达摩院真正要做的是把技术进行普惠,看起来，相互争斗不止的BAT在AI加速器这里的会战也一定少不了，催热“AI加速器”、最近又动作频频的腾讯则暂时处在领先位置上。</p>
<h2 id="同质化竞争，谁主争锋？"><a href="#同质化竞争，谁主争锋？" class="headerlink" title="同质化竞争，谁主争锋？"></a>同质化竞争，谁主争锋？</h2><p>  <img src="https://img-blog.csdnimg.cn/20200312092736730.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>  仅从市场角度，这对“获客”显然十分不利，你也开放我也开放，你标榜技术强大我也说自己技术厉害，并没有太多差异化“卖点”。于是，加速项目就成了“开放”关键词外笼络更多用户的差异化手段。腾讯可能率先认识到了这一点，提前点燃了AI加速器。除了开放技术给用户，还扶持用户加速用户成长，这种方式显然更容易赢得市场。<br>  构建差异化卖点是茫茫大潮中出类拔萃的基本要素。AI加速器的意义在于能够提前甄选到优质用户并加以扶持，除了<strong>丰富平台用户量获得生态优势</strong>，更重要的是这种“<strong>一手扶持</strong>”下获取的用户很容易成为平台的核心用户并带来更为紧密的生态效应，例如腾讯AI开放平台上的慧川智能、Bello智能招聘、追一科技等归属度极强的用户都来自于AI加速器。最终，创造伙伴让它们与平台先天联结，<strong>高替代成本造就了高用户忠诚。</strong><br>  细研腾讯的案例。目前，腾讯对外宣称的AI的布局主要围绕以下三个层面展开：<br>1.以AI lab、优图、腾讯云等部门为主体，侧重方向是基础技术研究；<br>2.与腾讯社交、游戏、支付、云计算、零售等自有业务或生态圈业务相结合，<strong>在场景中把AI落地；</strong><br>3.在基础、业务层面上对外开放，连接腾讯内部和合作伙伴的资源与能力，打造生态。<br>显然，AI加速器正是第三层面的主要载体，而腾讯经常对外表达的<strong>构建AI创业生态、扶持AI创业、助力AI技术产业化</strong>等概念，其实在AI体系上打开了<strong>链接外部、与外部互动的口子</strong>，同时又把内外部的层次理清楚避免混乱，为腾讯开放平台运营的AI加速器<strong>提供了诸多管理上、流程上、技术上的便利。</strong><br>百度的AI架构也有类似特点，主打一站式服务，但很多时候，受限于本身业务单一，例如360AI、小米AI、科大讯飞AI等，在AI布局上把基础研发、业务、对外生态等不同内容混合到一起，仅从实操上来说并不一定利于对外延展出AI加速器。</p>
<h2 id="把控风口，依靠强资源-高匹配度-垂直化深耕"><a href="#把控风口，依靠强资源-高匹配度-垂直化深耕" class="headerlink" title="把控风口，依靠强资源+高匹配度+垂直化深耕"></a>把控风口，依靠强资源+高匹配度+垂直化深耕</h2><p>对普通孵化器来说，资金、人才、运营、技术等支持是通用的，而加速器所需要的资源带有浓烈的AI“个性”。从腾讯的案例来看，这种“个性”体现在：</p>
<p>（1）技术资源层面</p>
<p>仅仅IT技术、云计算等支撑是不够的。腾讯AI加速器提供的技术能力来自腾讯AI Lab、优图实验室、WeChat AI以及腾讯云，提供约60+项AI技术能力，以及10+AI技术课程。除此之外，加速器还为项目提供定制化的开发及辅导，一些时候甚至需要采用1V1的模式，帮助技术找到应用场景。</p>
<p>（2）创投资源层面</p>
<p>不是“给钱就行”，对资本与AI的契合度也有一定的要求。因此，腾讯AI加速器找到的资本合作伙伴包括腾讯投资、英诺天使、蓝驰创投、松禾远望、金沙江、北极光 、IDG 、创新工场等在AI领域投资比较活跃的投资方。</p>
<p>（3）导师资源层面</p>
<p>不只是那些能够对互联网“指点江山”的所谓大咖，AI加速器更需要对AI有深度认知的“导师”，它不是一种能够泛泛指导的技术门类。腾讯为此配备了产业、学术、工业、设计、投资界与AI相关的辅导人，提供数月的指导。</p>
<p>（4）渠道资源层</p>
<p> 从业务实现的角度，决定开发者选用哪个AI平台，首先是<strong>该平台能否实现自己想实现的功能</strong>，其次是使用某平台<strong>实现起来的难度有多大</strong>，最后是**效率有多高。AI加速器就是抓住了这些痛点和需求，腾讯借助得天独厚的互联网地位，聚焦多重开放平台、云、互联网+等渠道帮助项目触达行业大客户。</p>
<p>  问题来了，一旦所有的AI开放平台都开始做AI加速器时，差异化将再次消失。AI加速器越往后走，关于接口搭设、资源匹配及赋能等玩法就越变得普遍，毕竟，能够做得起AI开放平台的企业，做AI加速器并不会那么困难，只是时间长短和先后的问题。</p>
<p>对于先把AI加速器捂热，又暂时处在领先位置的腾讯来说，尽快在加速上再走出差异化步骤十分重要。而对那些追赶者而言，如果能够有所创新、改变雷同的玩法，也或将赢得后发优势。</p>
<p>这次腾讯AI加速器就发生了<strong>关键词的转变</strong>，按照腾讯开放平台副总经理、腾讯众创空间总经理王兰的说法，第二期要打造的是“<strong>面向垂直行业的AI解决方案</strong>”，引入腾讯觅影、传统零售商、腾讯众创等合作伙伴，具体实现包括<strong>医疗、智慧零售、智慧楼宇</strong>等解决方案。</p>
<p>AI加速器必须解决的一个重要问题是投入线性增长问题。在第一期AI加速器多行业出击的基础上，这次腾讯在重庆宣布将聚焦探索医疗、智慧零售、智慧楼宇三大垂直领域，此外也延展至农业、工业、旅游、环保、内容等垂直行业寻找合作伙伴的加入，料想腾讯是以<strong>3+N的模式逐步开展AI加速器的垂直化。</strong></p>
<p>而从成本投入角度，除了AI垂直领域的积淀，<strong>垂直化最有利于解决成本线性增长的问题</strong>。也即，如果持续深耕某些垂直领域，当“通用经验”积累到足够程度后，在类似的行业特性下总结出<strong>垂直领域统一的“加速范式”</strong>，既能够保证个性化加速效果，<strong>也能够实现较为明显的运营复制从而降低成本</strong>，<strong>垂直挖掘得越深，这种双重效应越明显。</strong></p>
<p>通过AI加速器获得用户优势，一定要先走垂直化深耕的道路。这意味着，腾讯“AI开放”层面正从去年面向广大开发者的AI技术能力开放<strong>转为面向政府、企业等行业伙伴的AI解决方案的开放</strong>，<strong>从“工具箱”开始向“方法库”升级，</strong>这可能是腾讯保持差异化优势的策略。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/AI%E8%83%BD%E5%8A%9B%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E7%9A%84%E8%9E%8D%E5%90%88%E5%88%9B%E6%96%B0%E6%80%9D%E8%80%83/" rel="tag">AI能力与应用场景的融合创新思考</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-详细剖析强缓存和协商缓存" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/11/14/%E8%AF%A6%E7%BB%86%E5%89%96%E6%9E%90%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/"
    >详细剖析强缓存和协商缓存</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/11/14/%E8%AF%A6%E7%BB%86%E5%89%96%E6%9E%90%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/" class="article-date">
  <time datetime="2019-11-13T16:00:00.000Z" itemprop="datePublished">2019-11-14</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="Cache-control"><a href="#Cache-control" class="headerlink" title="Cache-control"></a>Cache-control</h2><p>1.public：<strong>所有内容都将被缓存（客户端和代理服务器都可缓存）</strong>。具体来说响应可被任何中间节点缓存，如 Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server，中间的proxy可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给 Browser 而不再向proxy2要。</p>
<p>private：所有内容<strong>只有客户端可以缓存，Cache-Control的默认取值。</strong>具体来说，表示中间节点不允许缓存，对于Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server，proxy 会老老实实把Server 返回的数据发送给proxy1,自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据。</p>
<p>no-cache：客户端缓存内容<strong>，是否使用缓存则需要经过协商缓存来验证决定。表</strong>示不使用 Cache-Control的缓存控制方式做前置验证，<strong>而是使用 Etag 或者Last-Modified字段来控制缓存</strong>。需要注意的是，no-cache这个名字有一点误导。设置了no-cache之后，<strong>并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。</strong></p>
<p>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</p>
<p>max-age：max-age=xxx (xxx is numeric)表示缓存内容将在xxx秒后失效,优先级大于expires</p>
<p>s-maxage（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires header。</p>
<p>max-stale：能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）。</p>
<p>min-fresh：能够容忍的最小新鲜度。min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。<br>Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8zMTc0NzAxLThmZjk4MTYwM2NkZmRlZDA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<h2 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h2><ol>
<li>Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires<ol start="2">
<li>在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。</li>
</ol>
</li>
<li><strong>强缓存</strong>判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会<strong>导致加载文件不是服务器端最新的内容.</strong></li>
<li>如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到<strong>协商缓存策略。</strong></li>
</ol>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：<br>1.协商缓存生效，返回304和Not Modified<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8zMTc0NzAxLTY2MGZkMTYzMzI5ZDA4MGI?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>2. 协商缓存失效，返回200和请求结果<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8zMTc0NzAxLTI0OTUzMDc5Y2ZlYmYyYmY?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。</p>
<h2 id="Last-Modified和If-Modified-Since"><a href="#Last-Modified和If-Modified-Since" class="headerlink" title="Last-Modified和If-Modified-Since"></a>Last-Modified和If-Modified-Since</h2><p>浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header；<br>浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，<br><strong>如果没有变化，返回304和空的响应体，直接从缓存读取<br>  如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200</strong><br>但是 Last-Modified 存在一些弊端：<br>1.如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源<br>2.因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源<br>既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？<br><strong>所以在 HTTP / 1.1 出现了 ETag 和If-None-Match</strong></p>
<h2 id="ETag和If-None-Match"><a href="#ETag和If-None-Match" class="headerlink" title=".ETag和If-None-Match"></a>.ETag和If-None-Match</h2><p>1.Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，<strong>只要资源有变化，Etag就会重新生成。</strong><br>2.浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的I<strong>f-None-Match跟自己服务器上该资源的ETag是否一致，</strong>就能很好地判断资源相对客户端而言是否被修改过了。<br>3.如果服务器发现ETag匹配不上，那么直接以常规GET 200形式将新的资源（当然也包括了新的ETag）发给客户端。<br>4.如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可<strong>。</strong></p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>1.首先在精确度上，Etag要优于Last-Modified。<br>2.Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。<br>3.第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。<br>4.第三在优先级上，<strong>服务器校验优先考虑Etag</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>1.强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，<br> 2.若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，<br> 3.协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标   识，再存入浏览器缓存中；<br> 4.生效则返回304，继续使用缓存。</p>
</blockquote>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>1.对于频繁变动的资源，首先需要使用Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。<br>2.不常变化的场景：通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 max-age，这样浏览器之后请求相同的 URL 会命中强制缓存。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">前端性能优化</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-深入分析懒加载、预加载" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/11/14/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E6%87%92%E5%8A%A0%E8%BD%BD%E3%80%81%E9%A2%84%E5%8A%A0%E8%BD%BD/"
    >深入分析懒加载、预加载</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/11/14/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E6%87%92%E5%8A%A0%E8%BD%BD%E3%80%81%E9%A2%84%E5%8A%A0%E8%BD%BD/" class="article-date">
  <time datetime="2019-11-13T16:00:00.000Z" itemprop="datePublished">2019-11-14</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="懒加载的原理（延迟加载）"><a href="#懒加载的原理（延迟加载）" class="headerlink" title="懒加载的原理（延迟加载）"></a>懒加载的原理（延迟加载）</h2><p>1.图片进入<strong>可视区域之后</strong>再去请求图片资源，不要请求无效资源。<br>2.适用于电商等图片很多，页面很长的业务场景。<br>3.减少无效资源的加载。<br>4.并发加载的资源过多会阻塞JS的加载，影响网站的正常使用（浏览器有并发请求上限），图片在JS的上面。<br>5.SRC属性设置之后会请求SRC资源，后面的SRC先不设置，换成占位符。<br>6.监听滚轮事件，当进入相关图片的可视区域之后，才会去动态设置图片的src属性。<br>7.电商产品应用广泛。</p>
<h2 id="预加载原理（提前加载）"><a href="#预加载原理（提前加载）" class="headerlink" title="预加载原理（提前加载）"></a>预加载原理（提前加载）</h2><p>1.图片等静态资源在使用之前的<strong>提前请求。</strong><br>2.资源使用到时能从缓存中加载，不去网络请求，提升用户体验。<br>3.页面展示的依赖关系维护。比如当前页面会依赖音乐图片等，这样预加载之后页面渲染不会阻塞。<br>4.九宫格抽奖。频繁切换选中和非选中状态，要保障样式的展示。<br>5.动画展示。资源加载完了之后再去页面加载。</p>
<h2 id="懒加载的方法"><a href="#懒加载的方法" class="headerlink" title="懒加载的方法"></a>懒加载的方法</h2><blockquote>
<p>先将img标签中的src链接设为同一张图片(空白图片)，将其真正的图片地址存储再img标签的自定义属性中(比如data-img)。</p>
</blockquote>
<blockquote>
<p>当js监听到该图片元素进入可视窗口时，即将自定义属性中的地址存储到src属性中，达到懒加载的效果。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">"item"</span>&gt;</span><br><span class="line">    &lt;a href=<span class="string">"javascript:void(0)"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">data-img</span>=<span class="string">"$&#123;p.pic&#125;"</span> <span class="attr">src</span>=<span class="string">"img/blank.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/li&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装懒加载函数</span></span><br><span class="line"><span class="keyword">var</span> lazyLoad = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//匿名函数自调，避免全局污染</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $(<span class="built_in">window</span>).on(<span class="string">"scroll"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//监听窗口滚动事件</span></span><br><span class="line">            <span class="keyword">var</span> clock = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//启动定时器，加载图片</span></span><br><span class="line">                $(<span class="string">".item img"</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="comment">//遍历每张图片</span></span><br><span class="line">                    <span class="keyword">var</span> $cur = $(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">if</span>(checkShow($cur))</span><br><span class="line">                    <span class="comment">//调用检查函数，如果元素在可视范围内</span></span><br><span class="line">                        $cur.attr(<span class="string">'src'</span>, $cur.attr(<span class="string">'data-img'</span>));</span><br><span class="line">                        <span class="comment">//显示图片</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,<span class="number">300</span>);</span><br><span class="line">            <span class="keyword">if</span>(clock) clearTimeout(clock);</span><br><span class="line">            <span class="comment">//停止定时器</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查元素是否在可视范围内</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkShow</span>(<span class="params">$node</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> scrollH = $(<span class="built_in">window</span>).scrollTop(),</span><br><span class="line">        <span class="comment">//获取窗口滚动高度</span></span><br><span class="line">        winH = $(<span class="built_in">window</span>).height(),</span><br><span class="line">        <span class="comment">//获取窗口高度</span></span><br><span class="line">        top = $node.offset().top;</span><br><span class="line">        <span class="comment">//获取图片距离窗口顶部偏移高度</span></span><br><span class="line">        <span class="keyword">if</span>(top &lt; winH + scrollH)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回init函数</span></span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        load:init;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用懒加载函数,首屏要手动调动</span></span><br><span class="line">lazyLoad.load();</span><br></pre></td></tr></table></figure>
<p>Zepto就是jQuery的移动端版本, 可以看做是一个轻量级的jQuery<br>注意点:<br>Zepto的设计目的是提供 jQuery 的类似的API，但并不是100%覆盖 jQuery<br>jQuery的底层是通过DOM来实现效果的， zepto.js 是用css3 来实现的；<br>官网下载的zepto,就已经包含了官网所述的默认模块了<br>github上下载的zepto模块需要自己导入</p>
<p>与图片一样，视频同样可以延迟加载，来达到性能优化的目的。</p>
<p>正常情况下加载视频，都是使用<video>标签，那么对于一些需要用户自己播放的视频，最好指定<video>标签的preload属性为none，这样浏览器就不会预加载任何视频数据。<br>为了占用空间，我们用poster属性为其占位</video></video></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;video controls preload=<span class="string">"none"</span> poster=<span class="string">"占位图"</span>&gt;</span><br><span class="line">	&lt;source src=<span class="string">"视频资源同名.webm"</span> type=<span class="string">"video/webm"</span>&gt;</span><br><span class="line">	&lt;source src=<span class="string">"视频资源名.mp4"</span> type=<span class="string">"video/mp4"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/video&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="实现预加载的几种办法"><a href="#实现预加载的几种办法" class="headerlink" title="实现预加载的几种办法"></a>实现预加载的几种办法</h2><p>使用HTML标签<br><img src="http://pic26.nipic.com/20121213/6168183 0044449030002.jpg" style="display:none"><br>使用Image对象</p>
<script src="./myPreload.js"></script>
<p>使用XMLHttpRequest对象,<strong>虽然存在跨域问题，但会精细控制预加载过程</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttprequest=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"> xmlhttprequest.onreadystatechange=callback;</span><br><span class="line"> xmlhttprequest.onprogress=progressCallback;</span><br><span class="line"> xmlhttprequest.open(<span class="string">"GET"</span>,<span class="string">"http://image.baidu.com/mouse,jpg"</span>,<span class="literal">true</span>);</span><br><span class="line"> xmlhttprequest.send();</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(xmlhttprequest.readyState==<span class="number">4</span>&amp;&amp; xmlhttprequest.status==<span class="number">200</span>)&#123;</span><br><span class="line">     <span class="keyword">var</span> responseText=xmlhttprequest.responseText;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Request was unsuccessful:"</span>+xmlhttprequest.status);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">progressCallback</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line"> e=e || event;</span><br><span class="line"> <span class="keyword">if</span>(e.lengthComputable)&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"Received"</span>+e.loaded+<span class="string">"of"</span>+e.total+<span class="string">"bytes"</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>PreloadJS提供了一种预加载内容的一致方式，以便在HTML应用程序中使用。预加载可以使用HTML标签以及XHR来完成。默认情况下，PreloadJS会尝试使用XHR加载内容，因为它提供了对进度和完成事件的更好支持，但是由于跨域问题，使用基于标记的加载可能更好。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用preload.js</span></span><br><span class="line"><span class="keyword">var</span> queue=<span class="keyword">new</span> createjs.LoadQueue();<span class="comment">//默认是xhr对象，如果是new createjs.LoadQueue(false)是指使用HTML标签，可以跨域</span></span><br><span class="line">queue.on(<span class="string">"complete"</span>,handleComplete,<span class="keyword">this</span>);</span><br><span class="line">queue.loadManifest([</span><br><span class="line">&#123;<span class="attr">id</span>:<span class="string">"myImage"</span>,<span class="attr">src</span>:<span class="string">"http://pic26.nipic.com/20121213/6168183  0044449030002.jpg"</span>&#125;,</span><br><span class="line">&#123;id：<span class="string">"myImage2"</span>，src:<span class="string">"http://pic9.nipic.com/20100814/2839526  1931471581702.jpg"</span>&#125;</span><br><span class="line">]);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleComplete</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> image=queue.getResuLt(<span class="string">"myImage"</span>);<span class="comment">//队列存放资源</span></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两者都是提高页面性能有效的办法，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。<br>懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">前端性能优化</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-爬虫获取实时疫情数据并制作可视化表格" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/11/13/%E7%88%AC%E8%99%AB%E8%8E%B7%E5%8F%96%E5%AE%9E%E6%97%B6%E7%96%AB%E6%83%85%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%88%B6%E4%BD%9C%E5%8F%AF%E8%A7%86%E5%8C%96%E8%A1%A8%E6%A0%BC/"
    >接口防刷解决思路</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/11/13/%E7%88%AC%E8%99%AB%E8%8E%B7%E5%8F%96%E5%AE%9E%E6%97%B6%E7%96%AB%E6%83%85%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%88%B6%E4%BD%9C%E5%8F%AF%E8%A7%86%E5%8C%96%E8%A1%A8%E6%A0%BC/" class="article-date">
  <time datetime="2019-11-12T16:00:00.000Z" itemprop="datePublished">2019-11-13</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E6%A1%86%E6%9E%B6%E4%B8%8E%E6%9E%B6%E6%9E%84/">框架与架构</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!学校的服务器连不上了，实验跑不起来，回顾一下学习的知识，结合爬虫技术，制作一下疫情数据可视化表格，希望疫情快点好起来吧！我想早点做实验，马上要找实习了，时间太紧张啦！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> jsonData <span class="keyword">from</span> <span class="string">'./feiyan.json'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./06style.css'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(jsonData)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> provincesObj = &#123;</span><br><span class="line">    <span class="comment">//做一个数组列表，格式化得到的信息，每个省份是一个对象，设置里面的属性和值</span></span><br><span class="line">    <span class="comment">// "湖北省":&#123;</span></span><br><span class="line">    <span class="comment">//     confirm:0,</span></span><br><span class="line">    <span class="comment">//     suspect:0,</span></span><br><span class="line">    <span class="comment">//     heal:0,</span></span><br><span class="line">    <span class="comment">//     deal:0,</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;<span class="comment">//数组循环遍历，有索引值和元素，统计数据，拿province作为key,初始化为0，统计确诊，痊愈，死亡人数</span></span><br><span class="line"></span><br><span class="line">jsonData.data.list.forEach(<span class="function">(<span class="params">item,i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(provincesObj[item.province]==<span class="literal">undefined</span>)&#123;</span><br><span class="line">        provincesObj[item.province] = &#123;</span><br><span class="line">            confirm:<span class="number">0</span>,</span><br><span class="line">            heal:<span class="number">0</span>,</span><br><span class="line">            dead:<span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//初始化之后，加入数据，一开始是undefined,默认为0,判断这个省份是否存在</span></span><br><span class="line">     <span class="comment">//为null就设为0</span></span><br><span class="line">    item.confirm = item.confirm?item.confirm:<span class="number">0</span>;</span><br><span class="line">    item.heal = item.heal?item.heal:<span class="number">0</span>;</span><br><span class="line">    item.dead = item.dead?item.dead:<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    provincesObj[item.province] = &#123;</span><br><span class="line">        confirm:provincesObj[item.province].confirm+item.confirm,</span><br><span class="line">        heal:provincesObj[item.province].heal+item.heal,</span><br><span class="line">        dead:provincesObj[item.province].dead+item.dead</span><br><span class="line">    &#125;<span class="comment">//累加</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> provinceList = []<span class="comment">//加入数据，</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> provincesObj) &#123;</span><br><span class="line">    provincesObj[key].province = key;<span class="comment">//哪个省份</span></span><br><span class="line">    provinceList.push(provincesObj[key])<span class="comment">//具体人数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//放入数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(provincesObj)</span><br><span class="line"><span class="built_in">console</span>.log(provinceList)</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="keyword">let</span> provinceListSort = provinceList.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.confirm&lt;b.confirm)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="comment">//保证确证人数在最顶端，生成新的列表有顺序</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(provinceListSort)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bili</span>  <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="comment">//渲染模板</span></span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;中国病例&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">                &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;li&gt;</span></span><br><span class="line"><span class="regexp">                        &lt;span&gt;地区&lt;/</span>span&gt;</span><br><span class="line">                        &lt;span&gt;确诊&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">                        &lt;span&gt;死亡&lt;/</span>span&gt;</span><br><span class="line">                        &lt;span&gt;治愈&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;/</span>li&gt;</span><br><span class="line"></span><br><span class="line">                    &#123;<span class="comment">//传入数据，返回最终的表格</span></span><br><span class="line">                        <span class="keyword">this</span>.props.list.map(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> (</span><br><span class="line">                                &lt;li&gt;</span><br><span class="line">                                    &lt;span&gt;&#123;item.province&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">                                    &lt;span&gt;&#123;item.confirm&#125;&lt;/</span>span&gt;</span><br><span class="line">                                    &lt;span&gt;&#123;item.dead&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">                                    &lt;span&gt;&#123;item.heal&#125;&lt;/</span>span&gt;</span><br><span class="line">                                &lt;<span class="regexp">/li&gt; </span></span><br><span class="line"><span class="regexp">                            )</span></span><br><span class="line"><span class="regexp">                        &#125;)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">                    &#125;</span></span><br><span class="line"><span class="regexp">                &lt;/u</span>l&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;Bili list=&#123;provinceListSort&#125;&gt;&lt;/</span>Bili&gt;,</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'#root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>CSS部分</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ul,li&#123;</span><br><span class="line">    list-style: none;</span><br><span class="line">    margin: <span class="number">0</span>;</span><br><span class="line">    padding: <span class="number">5</span>px <span class="number">5</span>px;</span><br><span class="line">&#125;</span><br><span class="line">li&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    <span class="comment">/*设置flex布局*/</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">span&#123;</span><br><span class="line">    flex: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">li:nth-child(odd)&#123;<span class="comment">/*奇数选择器*/</span></span><br><span class="line">    background-color: #efefef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>爬虫部分</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>);<span class="comment">//后端用require!</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> httpUrl = <span class="string">'https://c.m.163.com/ug/api/wuhan/app/index/feiyan-data-list?t='</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> axios.get(httpUrl+<span class="keyword">new</span> <span class="built_in">Date</span>().getTime())<span class="comment">//加入时间戳，实时获取</span></span><br><span class="line">    <span class="built_in">console</span>.log(res.data)</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">//异步自执行函数,等待获取数据</span></span><br></pre></td></tr></table></figure>


      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E9%A1%B9%E7%9B%AE%E6%80%9D%E8%80%83/" rel="tag">项目思考</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" rel="tag">高并发</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-接口防刷解决思路" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/11/13/%E6%8E%A5%E5%8F%A3%E9%98%B2%E5%88%B7%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF/"
    >接口防刷解决思路</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/11/13/%E6%8E%A5%E5%8F%A3%E9%98%B2%E5%88%B7%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF/" class="article-date">
  <time datetime="2019-11-12T16:00:00.000Z" itemprop="datePublished">2019-11-13</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E6%A1%86%E6%9E%B6%E4%B8%8E%E6%9E%B6%E6%9E%84/">框架与架构</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="场景和原因："><a href="#场景和原因：" class="headerlink" title="场景和原因："></a>场景和原因：</h2><p>1.在项目中后台只需要提供一套API接口，就可以接入安卓、小程序、IOS、web等多个应用程序，这样可以节约开发成本。<br>但是一个后台接入这么多应用程序的http请求，必然导致后端的压力非常大。对于这些情况我们需要对用户的访问进行限流访问，我们可以依次对Nginx、tomcat、接口进行限流。<br>2.对于一些请求进行过滤和拦截是非常有必要的，能够有效地减轻后台的压力。<br>3.考虑线上环境 很多接口 如果不做缓存 可能导致有人拿到url  每秒几万次的访问后台程序,导致系统down机。<br>4.短时间接口被大量调用（攻击），出现系统崩溃和系统爬虫问题，怎么样提升服务的可用性？</p>
<h2 id="商讨解决方法"><a href="#商讨解决方法" class="headerlink" title="商讨解决方法"></a>商讨解决方法</h2><p>1.最简单有效的防护就是图片验证码，采用点触验证，验证滑动或者是第三方验证码服务，普通的图片验证码很容易被破解<br>2.频率，或者叫接口防刷，通过用户具有唯一性的ip验证用户的身份,模拟一个场景，每次用户调用接口，将此用户的ip进行记录，在有效的时间之内，用户每调用一次接口，给调用的次数+1,当超过（次数根据自己的时间情况进行定义）指定的次数时，将调用这个接口的用户ip加入黑名单中，锁定时间到了（锁定时间根据实际情况进行定义）之后移除在黑名单中的用户ip，进行解锁，但是每次用户在短时间内调用接口，实时记录的ip，次数，时间存到什么地方呢？<br>数据库，文件，memcache, redis？<br>最终的方案是redis！<br><strong>redis是一种基于内存的分布式缓存，数据存到数据库，因为redis支持的数据类型更多，支持永久存储，redis有部分数据是存储在了硬盘上</strong><br>3.网关控制流量洪峰，对在一个时间段内出现流量异常，可以拒绝请求。<br>4.源ip请求个数限制。对请求来源的ip请求个数做限制。<br>5.http请求头信息校验；（例如host，User-Agent，Referer）<br>6.对用户唯一身份uid进行限制和校验。例如基本的长度，组合方式，甚至有效性进行判断。或者uid具有一定的时效性<br>7.前后端协议采用二进制方式进行交互或者协议采用签名机制<br>8.人机验证，验证码，短信验证码，滑动图片形式，12306形式<br>9.签名，API接口启用签名策略，签名可以保障请求URL的完整安全，签名匹配再继续下一步操作，<br>10.token，对于重要的API接口，生成token值，做验证</p>
<h2 id="接口安全问题"><a href="#接口安全问题" class="headerlink" title="接口安全问题"></a>接口安全问题</h2><p>应对接口安全，我们可以对数据进行加密，不明文传输数据，可以选择对称加密（DES 2DES）或者是非对称加密（RSA），虽然说两者都是加密，但是又很大的区别，对称加密的速度快，但是相对非对称加密来说是不安全的，一旦一方泄露密钥，所有的数据将全部泄露，对于加密的长度来说非对称加密有长度限制，密钥的长度是1024，值能加密117个字符，如果长度过长，还需要分段加密，分段解密，效率更低，但是相对来说比较安全。</p>
<h2 id="怎样解决http频繁请求同一接口，但数据库来不及写入导致数据不一致的问题"><a href="#怎样解决http频繁请求同一接口，但数据库来不及写入导致数据不一致的问题" class="headerlink" title="怎样解决http频繁请求同一接口，但数据库来不及写入导致数据不一致的问题"></a>怎样解决http频繁请求同一接口，但数据库来不及写入导致数据不一致的问题</h2><p>1.这有点类似文件的情况，有一个test.dat文件，很多进程都要读写，为了避免冲突，会在操作文件时创建test.lck文件用于被其他进程发现，该文件已经处于被操作状态，这个过程中的互斥并没有改变目标文件的任何内容，而是通过外部数据加锁。<br>2.令牌算法限流<br>令牌桶算法最初来源于计算机网络。在网络传输数据时，为了防止网络拥塞，需限制流出网络的流量，使流量以比较均匀的速度向外发送。令牌桶算法就实现了这个功能，可控制发送到网络上数据的数目，并允许突发数据的发送。<br>3.限流的常用处理手段有：计数器、滑动窗口、漏桶、令牌。<br>4.总之一句话，让系统的流量，先到队列中排队、限流，不要让流量直接打到系统上。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E9%A1%B9%E7%9B%AE%E6%80%9D%E8%80%83/" rel="tag">项目思考</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" rel="tag">高并发</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-浏览器存储方式对比" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/11/13/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94/"
    >浏览器存储方式对比</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/11/13/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94/" class="article-date">
  <time datetime="2019-11-12T16:00:00.000Z" itemprop="datePublished">2019-11-13</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E8%B0%88%E8%B0%88%E7%BC%93%E5%AD%98/">谈谈缓存</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>1.因为HTTP请求无状态，所以需要Cookie去维持客户端状态。<br>2.浏览器客户端记录保存Cookie,服务端辨别用户的信息。<br>3.Cookie的生成方式：http response header 中的set-cookie，由服务端生成，客户端把Cookie存储和维护。<br>4.JS中可以通过document.cookie来读写cookie。<br>5..之后的请求都携带Cookie,就像健身房办卡，维护会员的信息。<br><strong>作用：<br>1.用于浏览器和服务器的交互。<br>2.客户端自身数据的存储。</strong><br>Cookie初衷是为了维护客户端的状态<br>存储的限制：大小4KB，需要设置过期时间。<br>Cookie的存储能力被localstorage代替<br>httponly为了保证安全，不支持JS读写，防止黑客攻击。<br>Cookie在相关域名下面会带来CDN的流量损耗，因为只要是这个域名下的信息都会携带cookie<br>对于静态资源来说，每次都在HTTP头部中携带Cookie信息，对大流量来说经济损失很大<br><strong>解决：CDN的域名和主站的域名要分开</strong></p>
<h2 id="Localstorage"><a href="#Localstorage" class="headerlink" title="Localstorage"></a>Localstorage</h2><p>1.接口封装好<br>2.浏览器的本地缓存方案<br>3.大小在5Mz左右<br>4.仅在客户端存在，不和服务端交互<br>5.场景：网速慢，本地缓存，在网不好的情况下，第一次请求来的信息我会保存，把首屏上的不变的信息存下来，不会有首屏的白屏情况，后期有接口返回的新数据，再重新渲染，提升首屏渲染速度。</p>
<h2 id="Sessionstorage"><a href="#Sessionstorage" class="headerlink" title="Sessionstorage"></a>Sessionstorage</h2><p>1.大小为5M左右<br>2.会话级别的浏览器存储<br>3.接口封装好<br>4.对于表单信息的维护，将表单信息存储，关闭之后是空的，下一步那种，可以存储。<br>5可以存储数组、数字、对象等可以被序列化为字符串的内容，不通信，仅存储</p>
<h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>1.在客户端存储大量结构化数据，使用索引来实现对数据库的高性能搜索。<br>2.为应用创建离线版本。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>sessionStorage操作的方法与localStroage是一样的，区别在于 sessionStorage 在关闭页面后即被清空，而 localStorage 则会一直保存。很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用sessionStorage就比较方便。</p>
<p>注意，刷新页面sessionStorage不会清除，但是打开同域新页面访问不到。</p>
<p>1.cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。<br>2. 存储大小限制不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。<br>3.数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；<br>localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；<br>cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。<br>4.作用域不同，sessionStorage不在不同的浏览器页面中共享，即使是同一个页面；<br>localStorage 在所有同源窗口中都是共享的；<br>cookie也是在所有同源窗口中都是共享的。<br>Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。<br>Web Storage 的 api 接口使用更方便，cookie的原生接口不友好，需要自己封装。<br>5. 安全性<br>需要注意的是，不是什么数据都适合放在 Cookie、localStorage 和 sessionStorage 中的，因为它们保存在本地容易被篡改，使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。所以千万不要用它们存储系统中的敏感数据。</p>
<h2 id="Service-Workers"><a href="#Service-Workers" class="headerlink" title="Service Workers"></a>Service Workers</h2><p><strong>1.JS是单线程的，JS与UI渲染是互斥的，优化就要调用SW<br>2.避免主线程的阻塞，3D模型很大<br>3.做离线化，与主页面通信</strong><br>SW是由事件驱动的,具有生命周期，可以拦截处理页面的所有网络请求(fetch)，可以访问cache和indexDB，支持推送，并且可以让开发者自己控制管理缓存的内容以及版本，为离线弱网环境下的 web 的运行提供了可能，让 web 在体验上更加贴近 native。<br>换句话说他可以把你应用里的<strong>所有静态动态资源根据不同策略缓存起来</strong>，在你下次打开时不再需要去服务器请求，这样一来就<strong>减少了网络耗时，使得web应用可以秒开</strong>，并且在离线环境下也变得可用。做到这一切你只需要增加一个sw文件，不会对原有的代码产生任何侵入，是不是很perfect？</p>
<h2 id="Service-Worker基本特征"><a href="#Service-Worker基本特征" class="headerlink" title="Service Worker基本特征"></a>Service Worker基本特征</h2><ul>
<li>无法操作DOM<pre><code>只能使用HTTPS以及localhost
可以拦截全站请求从而控制你的应用
与主线程独立不会被阻塞（不要再应用加载时注册sw）
完全异步，无法使用XHR和localStorage
一旦被 install，就永远存在，除非被 uninstall或者dev模式手动删除
独立上下文
响应推送
后台同步</code></pre></li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/" rel="tag">浏览器缓存</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-页面加载渲染的优化（一）" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/11/13/%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%B8%B2%E6%9F%93%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/"
    >页面加载渲染的优化（一）</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/11/13/%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%B8%B2%E6%9F%93%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/" class="article-date">
  <time datetime="2019-11-12T16:00:00.000Z" itemprop="datePublished">2019-11-13</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<p><img src="https://img-blog.csdnimg.cn/20200304125232265.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>1.HTML本身是通过网址请求回来的，由字节流转换成字符流，浏览器进行词法分析，分析成词法的token，从上到下，不同  &gt;的标签类型会解析成不同的对象，然后加载到DOM树上。<br>2.HTML中会通过link引入其他资源，这时会并发的请求静态资源，请求回来之后会和CSS资源进行结合，生成渲染树。<br>3.只有DOM树和CSS树都生成之后才会进行渲染，布局，绘制。<br>特点<br>1.顺序执行，并发加载（设3-4个CDN域名去最大化并发加载）<br>2.是否阻塞<br>3.依赖关系<br>4.引入方式</p>
</blockquote>
<p>场景：<br>1.页面出来了，样式没有出来，闪退等，是因为没有遵循好依赖关系，如果CSS放在header中去引入，那么页面就会等待CSS加载完毕生成CSS树之后再渲染，就不会出现闪动。<br>2.JS的执行顺序，通过JS 的async标签进行异步加载，梳理好依赖关系。<br>3.方式：JS通过script会有阻塞问题，可以通过defer,async标签更好。<br>3.是否动态引入？判断是不是在需要的时候再去加载。SPA单页应用应该在路由到某个页面的时候再去加载那个路由的内容，要异步动态的去引入内容。</p>
<h2 id="顺序执行，并发加载"><a href="#顺序执行，并发加载" class="headerlink" title="顺序执行，并发加载"></a>顺序执行，并发加载</h2><p>1.词法分析时，token的获取是从下到下顺序执行的<br>2.并发请求外部资源<br>3.并发上限：某个域名的限制</p>
<h2 id="CSS阻塞"><a href="#CSS阻塞" class="headerlink" title="CSS阻塞"></a>CSS阻塞</h2><p>1.CSS在head中会阻塞页面的渲染，页面需要link标签里面的样式内容才能去渲染，但为了避免闪动，还是要这样引入。<br>2.CSS阻塞JS的执行，JS去操作DOM，这时可能会有样式的修改，JS要依赖CSS之前加载完的样式效果。<br>3.CSS不阻塞外部脚本的加载，原因是webkit有HTML-preloader-scanner这样一个类，会预先扫描词法，通过预先加载器来请求后期加载所需要的资源。</p>
<h2 id="JS阻塞"><a href="#JS阻塞" class="headerlink" title="JS阻塞"></a>JS阻塞</h2><p>1.没有通过defer和async的，直接通过script标签的JS 会阻塞页面的渲染。<br>2.JS不会阻塞资源的加载。<strong>因为webkit有预先扫描器，有引用其他资源时，会并发去请求所需的资源，进行预先加载。</strong><br>3.JS顺序执行，阻塞后续JS逻辑的执行。JS有可能会调用document.write的方式，去修改DOM结构，那么由于动态修改了文档，JS会阻塞后面节点的创建。文档结构的分析和渲染会等到JS代码执行完成之后再去调用html.parse进行词法分析。<br>4.JS是顺序执行的，不管返回的情况如何，JS都会保存引入的依赖关系进行单线程加载。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">前端性能优化</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Node.js的三大特点" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/11/12/Node.js%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E7%82%B9/"
    >Node.js的三大特点</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/11/12/Node.js%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E7%82%B9/" class="article-date">
  <time datetime="2019-11-11T16:00:00.000Z" itemprop="datePublished">2019-11-12</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7Node/">打怪升级Node</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>Nodejs跟Nginx一样都是单线程为基础的，这里的单线程指主线程为单线程，所有的阻塞的全部放入一个线程池中，然后主线程通过队列的方式跟线程池来协作。线程池主要由一堆callback回调函数构成的，然后主线程在循环间隙中适当调用，并清空队列。<br>在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程。而每个线程需要耗费大约2MB内存。也就是说，理论上，一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。<br><strong>Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。</strong>当有用户连接了，就触发一个内部事件，<strong>通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。</strong>使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。</p>
<blockquote>
<p>另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。<br>坏处，就是一个用户造成了线程的崩溃，整个服务都崩溃了，其他人也崩溃了。</p>
</blockquote>
<p>话不多说，上图！<br><img src="https://img-blog.csdn.net/20180526131849738?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0wxMDYxMjU2MjY4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述">)<img src="https://img-blog.csdn.net/20180526131834846?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0wxMDYxMjU2MjY4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br>上图说明，单线程也能造成宏观上的“并发”。</p>
<h2 id="非堵塞I-O"><a href="#非堵塞I-O" class="headerlink" title="非堵塞I/O"></a>非堵塞I/O</h2><p>当用户在访问数据库取得数据的时候，需要一段请求时间。在传统的单线程处理机制中，在执行了访问数据库代码之后，整个线程都将暂停下来，等待数据库返回结果，才能执行后面的代码。也就是说，I/O阻塞了代码的执行，极大地降低了程序的执行效率。<br><strong>由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。</strong><br> <strong>当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。</strong><br>阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。Node.js中所有的I/O都是异步的，回调函数套回调函数。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命干活~</p>
<p>Node.js文件操作的函数基本都是异步的回调函数。</p>
<p>一个异步I/O的大致流程：</p>
<ol>
<li>发起I/O调用</li>
</ol>
<p>①用户通过js代码调用nodejs的核心模块，将回调函数和参数传入核心模块</p>
<p>②将回调函数和参数封装。</p>
<ol start="2">
<li>执行回调</li>
</ol>
<p>①操作完成后，将结果储存到请求对象的result属性上，并发出完成通知。</p>
<p>②循环事件，如果有未完成的，就进入请求对象的I/O观察者队列，之后当做异步事件来处理。</p>
<h2 id="异步事件驱动"><a href="#异步事件驱动" class="headerlink" title="异步事件驱动"></a>异步事件驱动</h2><p>在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件（比如，又有新用户连接了），然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。<br>Node.js底层是C++（V8也是C++写的）。<strong>底层代码中，近半数都用于事件队列、回调函数队列的构建。用事件驱动来完成服务器的任务调度。**</strong><br><img src="https://img-blog.csdn.net/20180526131824358?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0wxMDYxMjU2MjY4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p>
<blockquote>
<p>单线程的好处，减少了内存开销，操作系统的内存换页。</p>
</blockquote>
<blockquote>
<p>如果某一个事情，进入了，但是被I/O阻塞了，所以这个线程就阻塞了。</p>
</blockquote>
<blockquote>
<p>非阻塞I/O， 不会傻等I/O语句结束，而会执行后面的语句。</p>
</blockquote>
<blockquote>
<p>非阻塞就能解决问题了么？比如执行着用户A的业务，执行过程中，用户B的I/O回调完成了，此时怎么办？只能采用事件环的机制来等待调度，就是说不管是新用户的请求，还是老用户的I/O完成，都将以事件方式加入事件环，去等待调度。<br>看上图就是构成一个每分每秒都在调度运行的闭环，这个闭环上只有一个搬运工，但是，人家不用休息！</p>
</blockquote>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/Node/" rel="tag">Node</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="../../">上一页</a><a class="page-number" href="../../">1</a><span class="page-number current">2</span><a class="page-number" href="../3/">3</a><a class="page-number" href="../4/">4</a><a class="extend next" rel="next" href="../3/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2020
        Wangqiuxia
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    <aside class="sidebar">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="../../index.html"><img src="/images/ayer-side.svg" alt="爱产品，爱前端！"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../index.html">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../tags/%E6%8A%80%E6%9C%AF/">小程序</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../http:/shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../https:/v.xiumi.us/stage/v5/4IeLH/197507179">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="../../atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="../../images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="../../images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="../../js/jquery-2.0.3.min.js"></script>


<script src="../../js/jquery.justifiedGallery.min.js"></script>


<script src="../../js/lazyload.min.js"></script>


<script src="../../js/busuanzi-2.3.pure.min.js"></script>


<script src="../../js/share.js"></script>



<script src="../../fancybox/jquery.fancybox.min.js"></script>




<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['做一个有情怀懂产品的程序媛！','业精于勤荒于嬉！行成于思毁于随！','越努力越幸运'],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script>
  var ayerConfig = {
    mathjax: false
  }
</script>


<script src="../../js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=518895142&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>