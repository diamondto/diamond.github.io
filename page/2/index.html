<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     爱产品，爱前端！
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="../../css/style.css">

  
<script src="../../js/pace.min.js"></script>


  

  

<link rel="alternate" href="atom.xml" title="爱产品，爱前端！" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/diamondto.github.io"
        target="_blank"><img width="149" height="149" src="../../images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="../../index.html">爱产品，爱前端！</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-前端发展：一云多端、智能化、AI+" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2020/04/19/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%EF%BC%9A%E4%B8%80%E4%BA%91%E5%A4%9A%E7%AB%AF%E3%80%81%E6%99%BA%E8%83%BD%E5%8C%96%E3%80%81AI+/"
    >阿里面试总结（四）——小霞看前端——一云多端、智能化、AI+</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2020/04/19/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%EF%BC%9A%E4%B8%80%E4%BA%91%E5%A4%9A%E7%AB%AF%E3%80%81%E6%99%BA%E8%83%BD%E5%8C%96%E3%80%81AI+/" class="article-date">
  <time datetime="2020-04-18T16:00:00.000Z" itemprop="datePublished">2020-04-19</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">阿里面试总结</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="思考背景："><a href="#思考背景：" class="headerlink" title="思考背景："></a>思考背景：</h2><p>面试官哥哥(亲切、帅气、耐心倾听)延申的健康码、小程序、校园生活应用。</p>
<h2 id="面试总结："><a href="#面试总结：" class="headerlink" title="面试总结："></a>面试总结：</h2><p>1、技术的背后是人文，好的技术专注用户体验、性能优化、AI创新。</p>
<p>2、前端专家是综合性人才，高屋建瓴，兼顾商业背景、技术架构、产品体验</p>
<p>3、挖掘需求、解决痛点。</p>
<p>健康码：疫情下保障安全出行。（时代背景）</p>
<p>校园生活：打通支付闭环、热点引流、用户留存、丰富平台生态。</p>
<p>小程序：前端智能化、生活化、数字化。（移动时代碎片化、数字化）</p>
<p>4、企业理念是导向，用户体验是目标、技术框架是基石。缺一不可！~</p>
<p>6、反思：背了四年主持稿，英语演讲、辩论赛思维不适合面试场景</p>
<p>7、面试的语速要减慢、精简复杂流程、结构化表达、放轻松。</p>
<p>TIPS：企业和学校不同，工作之后汇报时要精炼、简洁</p>
<p>学校教育喜欢刨根问底追究细节，工作要注重高效率、高产出、浓缩精华。</p>
<p>8、解决问题的方法论、团队协作能力要从点线面的角度举例说明。</p>
<p>9、关注支付宝小程序，从商业环境、技术架构升级思考前端发展。</p>
<p>10、关注前沿技术、多比较JS、TS、Dart的异同，沉淀技术实力。</p>
<p>11、关注移动端发展曲线、想想怎么做好小程序，打造自己的差异化优势。</p>
<p>12、关于Node.js底层原理、Koa中间件、JS内存管理、V8引擎、性能优化、VUE、React设计思想我都有私下做过功课</p>
<p>以后把纸质笔记本的内容输出到公众号奈何公众号一天只能发一次</p>
<p>附上小霞22岁方法论：<br><img src="https://img-blog.csdnimg.cn/20200419132255688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>Apple法则：  取首英文字母串联起流程像乔布斯一样做前端</p>
<p>确定产品定位、项目目标、针对哪些场景优化到什么数量级？(Ambition）</p>
<p>收集用户需求、辨别真伪、确定优先级、做好项目排期（Accumulation)</p>
<p>预测方案A/B/C哪个性能更好？哪个框架更优？技术选型比较（Prediction)</p>
<p>确定方案后、团队合作、深耕细耘、一万小时的努力成就辉煌(Persistence)</p>
<p>前端科技日新月异、保持热情、终身学习、T型发展（Learn）</p>
<p>提高沟通表达效率、把自己打磨成一个接口，对接后台、UI、产品（Link）</p>
<p>及时复盘、定期总结、虚心求教、自我评估（Evaluation）</p>
<p>产品上线、数据分析、预测商业价值、盘活商业模式（Estimation）</p>
</blockquote>
<p>因为面试官哥哥提到了小程序的前端发展。所以有了下文~</p>
<h2 id="今日目标：调研资料、梳理逻辑、提炼总结"><a href="#今日目标：调研资料、梳理逻辑、提炼总结" class="headerlink" title="今日目标：调研资料、梳理逻辑、提炼总结"></a>今日目标：调研资料、梳理逻辑、提炼总结</h2><p>调研资源来自搜索引擎、阿里云，经过逻辑思考之后输出如下</p>
<p>以小程序为主题，从业务逻辑、技术架构、学习成果、前端思考上写个总结！</p>
<p>主要是帮助自己梳理业务逻辑，做好前端要和后台、运营、产品紧密对接</p>
<p>毕竟团队合作，众人拾柴才能提高企业发展的效率</p>
<p>小程序架构图先存储起来，后面好好梳理，阿里技术团队真的厉害</p>
<p>借助目前的知识沉淀能大概理解其中的原理，不过精细之处还要多多学习、细细研究</p>
<p>前端智能化发展一个很棒的例证！  链接如下：</p>
<p>商家应用 + AR : 助力虚拟试妆引擎落地手淘（2019/12/19)</p>
<p>最后附上研究生AI人体姿态估计成果</p>
<p>（流程复杂，面试难以讲好，不过面试官哥哥很耐心听我balabala）</p>
<p>（最后还鼓励了我，感动只要被肯定，就要坚持不懈）</p>
<p>总之，AI+前端让未来充满了希望和可能！</p>
<p>OK，吾日三省吾身，欲知细节，请看下文~</p>
<h2 id="一、业务逻辑"><a href="#一、业务逻辑" class="headerlink" title="一、业务逻辑:"></a>一、业务逻辑:</h2><p>718+X 模式打通线上线下场景 + 助力中小商家+  全球最佳B2B服务</p>
<p><img src="https://img-blog.csdnimg.cn/20200419132321364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200419132333400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p> 七大入口为小程序引流：</p>
<p>扫一扫、搜索、朋友tab主入口、支付成功页、小程序收藏、生活号、卡包</p>
<p>一个闭环构造商业生态：</p>
<p>构成服务、拉新、留存、促活的完整闭环。</p>
<p>八大API接口激活冷启动：</p>
<p>芝麻信用、资金管理、金融服务、高德定位、导航、路线规划、菜鸟和1688的配送、溯源、供应链。</p>
<p>X场景提升用户体验：</p>
<p>助力小程序一次开发，在阿里app中多端透出、多端运行。</p>
<p>企业核心：建立一套交易和信用机制    </p>
<p>小程序特点：高可用、性能优化、多端输出</p>
<p>阿里商业要素：信任+口碑+体验</p>
<p><img src="https://img-blog.csdnimg.cn/20200419132351900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>二、技术架构：</p>
<p>一云多端、借助AI、AR、VR、5G构建丰富场景</p>
<p>一云多端<br><img src="https://img-blog.csdnimg.cn/20200419132406969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>系统架构<br><img src="https://img-blog.csdnimg.cn/20200419132424100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>开发者：编程模型简洁、官方文档详细、学习门槛低、快速开发。</p>
<p>渲染引擎：</p>
<p>JavaScript+Webview 的方式</p>
<p>JavaScript+Native 的方式</p>
<p>研发支撑、运维支撑服务：提升开发者效率、上线管理等等。</p>
<p>运行架构<br><img src="https://img-blog.csdnimg.cn/20200419132442297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>浏览器内核<br><img src="https://img-blog.csdnimg.cn/20200419132449168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>离线缓存优化流程图<br><img src="https://img-blog.csdnimg.cn/20200419132459154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>虚拟DOM优化流程图<br><img src="https://img-blog.csdnimg.cn/20200419132513975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>技术架构部分的图片来自支付宝小程序首席架构师白招拒老师的分享</p>
<p>在次表示感谢，我会在后续日记中仔细梳理细节、输出自己的独立思考</p>
<p>今天先揭开小程序的面纱，后面再庖丁解牛、条分缕析</p>
<p>放上我的前端笔记：我取名叫四库全书、葵花宝典</p>
<p>涵盖了前端的汪洋知识星海，纯手写画图够真诚<br><img src="https://img-blog.csdnimg.cn/20200419132529800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>前端小程序怎么做？：</p>
<blockquote>
<p>现阶段我的理解：先记录五点，随着不断学习补充提升，请大家多多指教</p>
<p>1、业务流程场景化、优化渲染效果、打造极致体验（AR   VR   WebGL） </p>
<p>2、针对需求做好性能优化(技术框架、打包工具、CDN加速、5G、云端计算）</p>
<p>3、每一点都很不容易，扩大视野的同时要关注细节。</p>
<p>4、前端人要心有猛虎、细嗅蔷薇。</p>
<p>5、水能载舟、亦能覆舟。企业是舟、用户是水，打造企业品牌、追求极致体验</p>
<p>是前端人的目标和初心！</p>
</blockquote>
<p>三、学习成果   AI姿态估计（我的毕业设计方案）</p>
<p>研究生团队目前成果：<br><img src="https://img-blog.csdnimg.cn/20200419132557989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>（我们实验室的团队~第一排右2是小霞）</p>
<pre><code>华科女子军最多的团队</code></pre><p><img src="https://img-blog.csdnimg.cn/20200419132607972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>多人上肢关键点识别：<br><img src="https://img-blog.csdnimg.cn/20200419132616214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200419132628629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/2020041913264017.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们还能做什么？</p>
<p>人脸检测、手势识别、手势交互、目标追踪</p>
<p>四、前端行业未来思考 ：AI智能、图形学、云计算、蓬勃生态<br><img src="https://img-blog.csdnimg.cn/20200419132656608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>前端发展行情？</p>
<p>Webpack推陈出新Module Federation</p>
<p>Severless函数应用架构升级</p>
<p>基于FAAS实现NPM CDN同步</p>
<p>电商直播+AR技能应用升级</p>
<p>支付宝新春活动3D特效</p>
</blockquote>
<p>引领时代潮流、打造极致体验、开源助力分享、智能重构升级！</p>
<p>理科生眼中的前端情怀：</p>
<blockquote>
<p>舍我其谁、无惧挑战是每一个前端人的Map</p>
<p>心有猛虎、细嗅蔷薇是每一个前端人的Key</p>
<p>拥抱变化、精雕细琢是每一个前端人的Value</p>
<p>前端是一汪浩瀚星海，一片神奇星空！</p>
<p>一切皆有可能万物之上、希望至美 !</p>
</blockquote>
<p>我眼中的阿里内涵：</p>
<p><strong>左耳旁是太阳：原子碰撞、光芒万丈、阿里蒸蒸日上！（阿）</strong></p>
<p><strong>右部首是可能：创造时机、人才济济、阿里充满希冀 !（阿）</strong></p>
<p><strong>一横一竖、刚正坚挺、阿里用信任建设芊芊江山 !（里）</strong></p>
<p><strong>一田一土、返璞归真、阿里用赤诚打动亿万客户!（里）</strong></p>
<p>为了平仄相生、韵脚别致</p>
<p>本研究僧深度优先、广度优先搜了N遍残留的文学细胞</p>
<p><strong>亲爱的阿里</strong></p>
<p><strong>我愿赴汤蹈火、在所不辞</strong></p>
<p><strong>永葆热情、虚心求教</strong></p>
<p><strong>遇见前端，我想遇见更好的自己 !</strong></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E4%B8%AA%E4%BA%BA%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/" rel="tag">个人职业规划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E6%9C%AA%E6%9D%A5%E5%8D%81%E5%B9%B4/" rel="tag">未来十年</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-阿里面试总结" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2020/04/17/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"
    >阿里面试复盘总结（三）——动画方案+秒杀系统+项目难题</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2020/04/17/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2020-04-16T16:00:00.000Z" itemprop="datePublished">2020-04-17</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">阿里面试总结</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="一、动画方案"><a href="#一、动画方案" class="headerlink" title="一、动画方案"></a>一、动画方案</h2><p>如何设置一个节日动画，推陈出新，提升用户体验？<strong>（技术选型）</strong></p>
<p>1.requestAnimationFrame<br>本质：传入的回调函数执行异步任务、属于宏任务队列、由系统刷新率决定回调函数的时间间隔。</p>
<p><strong>优点：</strong></p>
<p>系统决定回调函数执行时机，动画更流畅，不掉帧。</p>
<p>窗口没激活时，动画将停止，节省计算资源。</p>
<p>存在兼容性问题，自己可以封装。</p>
<p>按帧对网页动画进行重绘，可以并发渲染。</p>
<p><strong>动画方案：</strong></p>
<p>1.大图动画性能消耗大，使用translate3D实现GPU加速。</p>
<p>2.动画结束、暂停时，切换回2D，取消加速。</p>
<p>3.按需加载，必要时卸载。</p>
<p>4.简化函数计算，减少回流、重绘。</p>
<p>5.采用Web  Workers 开启多线程，提供更好的动画效果。</p>
<p><strong>用户体验优化：</strong></p>
<p>1.首屏优先加载，所以图片loaded以后，再启动主动画资源加载。</p>
<p>2.图片优化：雪碧图、压缩、Base64。</p>
<p>3.存储DOM变量，减少DOM tree的查找。</p>
<p>4.限频。</p>
<p><strong>场景应用：</strong></p>
<p>1.Three.js+requestAnimationFrame实现3D动态效果。</p>
<p>2.WebGL+Webpack 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var globalID;</span><br><span class="line"><span class="function">function <span class="title">animate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Do whatever</span></span><br><span class="line">  globalID=requestAnimationFrame(animate);</span><br><span class="line">  <span class="comment">// Do something animate，返回一个ID</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//when ot start</span></span><br><span class="line">  globalID=requestAnimationFrame(animate);</span><br><span class="line"><span class="comment">//when to stop</span></span><br><span class="line">  cancelAnimationFrame(globalID);<span class="comment">//取消回调函数</span></span><br></pre></td></tr></table></figure>

<p>2.setTimeout</p>
<p>本质：异步任务、宏任务队列、有最小执行时间。</p>
<p><strong>缺点：</strong></p>
<p>1.H5标准规定：setTimeout()的第二个参数的最小值（）最短间隔不得低于4毫秒，当我们把延迟时间设置为0，实际上会4毫秒后才把事件推入任务队列。</p>
<p>2.时间不精准，误差与代码执行时间有关。</p>
<p>3.队列中所有的代码都要等到JS进程空闲后才能执行，不论它们是如何添加到队列的。</p>
<p>3.setInterval</p>
<p>本质：以指定周期调用函数，隔一段时间推入一个事件。异步循环任务。</p>
<p><strong>缺点：</strong></p>
<p>事件执行时间不一定准确，有可能当前事件还没有执行完毕，下一个事件来临。</p>
<p>某些间隔被跳过。</p>
<p>多个定时器的代码执行之间的间隔可能比预期小。</p>
<p><strong>解决方案：</strong>使用setTimeout构造轮询可以保证每次轮询的间隔。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function  fn()&#123;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"我被调用了"</span>);</span><br><span class="line">setTimeout(fn,<span class="number">100</span>);</span><br><span class="line">&#125;,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>这个模式链式调用了setTimeout()，每次函数执行的时候都会创建一个新的定时器。第二个setTimeout()调用当前执行的函数，并为其设置另外一个定时器。</p>
<p>这样做的好处是，在前一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。而且，它可以保证在下一次定时器代码执行前，至少要等待指定的间隔，避免了连续的运行。</p>
<p><strong>我的延申思考：</strong></p>
<p>requestIdleCallback()</p>
<p>1、MDN解释：该方法在浏览器的空闲阶段内调用函数排队。使开发者在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，比如动画和输入响应。</p>
<p>2、利用这个特性做性能优化：在每帧的空闲时间进行数据发送操作，或者低优先级的工作，不会影响动画的性能。</p>
<p>3、想到的应用：React  Fiber 架构思想：切割长任务，利用空闲时间执行，避免主线程长时间阻塞。</p>
<p>4、Fiber核心：树的深度遍历变成链表遍历+时间分片+任务调度。</p>
<p>其他实现方案：</p>
<p>GSAP:</p>
<p>优点：</p>
<p>1、运行速度快，多个动画可以同时执行。</p>
<p>2、轻量、模块化、按需使用、无需依赖。</p>
<p>3、零插件依赖。</p>
<p>4、灵活控制，代码量少，可以设置精确时间控制。</p>
<p>5、任何对象都可以实现动画。</p>
<p>6、实现重复：repeat设为-1就OK。</p>
<h2 id="二、Promise的理解"><a href="#二、Promise的理解" class="headerlink" title="二、Promise的理解"></a>二、Promise的理解</h2><p><strong>优点：</strong></p>
<p>1、对象状态不受外界影响。状态一旦改变，就不会再变。</p>
<p>2、解决了回调地狱。</p>
<p>3、提供统一接口，方便异步操作。</p>
<p><strong>缺点：</strong></p>
<p>1、无法中途取消。</p>
<p>2、处于pending无法知道进展到了哪一个阶段。（刚开始还是要完成）</p>
<p><strong>流程：观察者模式</strong></p>
<p>Promise的构造方法接收一个executor()，在new Promise()时就立刻执行这个executor回调</p>
<p>executor()内部的异步任务被放入宏/微任务队列，等待执行</p>
<p>then()被执行，收集成功/失败回调，放入成功/失败队列</p>
<p>executor()的异步任务被执行，触发resolve/reject，从成功/失败队列中取出回调依次执行</p>
<p>细节问题：</p>
<p>promise的then()放入了微任务队列。</p>
<p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获。</p>
<p>如果没有使用 catch 方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。</p>
<p>Node 有一个 unhandledRejection 事件，专门监听未捕获的 reject 错误。</p>
<p>Catch 方法返回的还是一个 Promise 对象，因此后面还可以接着调用 then 方法。</p>
<blockquote>
<p>then 方法</p>
</blockquote>
<ul>
<li><p>1、可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 resolved 时调用，第二个回调函数是<br>Promise 对象的状态变为 rejected 时调用。</p>
<p>2、第二个函数是可选的，不一定要提供。这两个函数都接受 Promise 对象传出的值作为参数。</p>
<p>3、采用链式的 then ，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个 Promise<br>对象（即有异步操作），这时后一个回调函数，就会等待该 Promise 对象的状态发生变化，才会被调用。</p>
<p>（异步变同步的思路）</p>
<p>4、then(）回调不是函数时要忽略，否则会导致链式调用中断。</p>
<p>5、一个Promise依赖于另外一个Promise，异步变同步。简化3的说法</p>
</li>
</ul>
<blockquote>
<p>异步加载图片：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">loadImageAsync</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> Promise(function(resolve, reject) &#123; </span><br><span class="line"> var image = <span class="keyword">new</span> Image();</span><br><span class="line">  image.onload = function() &#123;</span><br><span class="line">   resolve(image); </span><br><span class="line">   &#125;;</span><br><span class="line">   image.onerror = function() &#123; </span><br><span class="line">   reject(new Error('Could not load image at ' + url)); </span><br><span class="line">   &#125;;</span><br><span class="line">   image.src = url; </span><br><span class="line">   &#125;); </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>All方法</p>
</blockquote>
<p>1、接受的参数是数组（里面有多个Promise实例）或者具有iterable接口的对象，但必须使返回的成员是promise的实例。</p>
<p>2、数组中每一项都执行成功才会成功，有一个失败就失败。</p>
<p>3、可以用到前后端加载数据、解决乱序渲染的问题。</p>
<p>（数组下标迭代保证了顺序）</p>
<p>4、异步处理的好帮手，比如ajax请求多个数据，在此之前显示loading图标，使加载全部完成再显示页面，区分懒加载和预加载，看具体场景需求。</p>
<p>5、即使响应时间不同，也可以保证接受到的数据与原始数据顺序一致。</p>
<p>6、一个操作需要所有的Promise一起运行才能解决问题。</p>
<p>Race方法</p>
<p>1、不管结果成功还是失败，数组中哪一个结果最先执行完成就返回哪个结果。</p>
<p>2、具体场景还没有想到，业务里有这种需求吗？后续脑补。</p>
<p>我的延申思考：</p>
<p>1、Promise解决了异步编程的一些问题，但是链式调用不能取消执行，无法获取执行进度怎么办？</p>
<p>2、实际开发，我们如何做好状态管理，兼顾好同步和异步的切换？</p>
<p>3、上述解答可以从其他的框架中挖掘答案。</p>
<p>方案对比和思考：</p>
<p>Generator:</p>
<p>1、generator函数返回一个遍历器对象，是函数的内部指针。</p>
<p>2、每次调用遍历器对象的next方法，就会返回有value和done两个属性的对象。</p>
<p>3、value属性表示当前内部状态的值，等于yield语句后面的值。</p>
<p>4、done属性是布尔值，表示是否遍历结束。</p>
<p>优点：控制函数的暂停和继续，向外输出结果，下次继续执行可以传入参数。</p>
<p>缺点：不能自动执行，遇到yield暂停，要手动控制。</p>
<p>控制Generator函数流程的关键：</p>
<p>是接受传入的值，并且可以把执行的权力还给程序。</p>
<blockquote>
<p>yield*</p>
</blockquote>
<p>yield委托，让出迭代控制。</p>
<p>co:</p>
<p>返回一个Promise对象，让generator自动执行，类比执行器。</p>
<p>thunk函数</p>
<p>自动执行Generator函数。</p>
<blockquote>
<p>for  of :</p>
</blockquote>
<p>遍历Generator函数运行生成的Iterator对象。</p>
<p>不用调用next 方法，可以通过break return 暂停遍历。</p>
<p>实战应用：</p>
<p>1、购物车每订购一件商品就调用next()实现库存的减一，记录库存状态。</p>
<p>2、三次抽奖活动，点击按钮调用next()实现次数减一，转动转盘的时候，让按钮禁止点击，转盘结束之后再调用next()进行下一次的抽奖，然后打开按钮的开关，记录按钮状态。</p>
<p>3、支付场景：付款之后通过定时器询问接口，是否处理完成订单流程。</p>
<p>4、总结一下就是在中断某一个操作时，要保留当时的状态，下次执行时回到当初的状态，比如我们做饭中途取了一个快递，然后保持菜的状态不改变，取完快递回来，接着做饭。</p>
<p>由Generator引发的协程原理思考：</p>
<blockquote>
<p>协程：</p>
</blockquote>
<p>1、协程有自己的上下文和栈，当任务切换时，会将当前的上下文和栈保存到其他地方，再被切回来的时候，恢复之前保存的上下文和栈。</p>
<p>2、我的理解就是：保留上一次的状态，重新进入时恢复到上次离开的状态。</p>
<p>3、按需生成返回结果，而不是一次性的return所有的结果。</p>
<blockquote>
<p>场景应用：</p>
</blockquote>
<p>1、用户登录状态，切换某个页面之后，再次回来，保留上一次的状态。</p>
<p>2、按需读取大文件，一段段的读取，不用一次遍历整个列表。</p>
<p>3、类比流的思想，这里还要多学习一下stream的知识。</p>
<p>4、直接读取大文件容易造成内存溢出，Generator不会造成内存溢出。</p>
<p>5、使用中还可以向yield中传入值。</p>
<p>6、协程开销远小于线程，yield让协程暂停，和线程的阻塞有本质的区别。</p>
<p>7、协程的暂停由程序控制、线程的阻塞状态由操作系统的内核来进行切换。</p>
<blockquote>
<p>由Generator引发的Koa中的原理思考：</p>
</blockquote>
<p>1、首先执行一次 dispatch(0) 也就是默认返回第一个 app.use 传入的函数， 使用 Promise 函数封装返回。</p>
<p>2、其中第一个参数是 ctx，第二个参数就是 next 参数，next 每次执行之后都会等于下一个中间件函数，如果下一个中间件函数不为真则返回一个成功的 Promise。</p>
<p>3、Koa V1  基于Generator   Koa V2 利用async函数。</p>
<p>4、洋葱模型的执行顺序类似捕获和冒泡的过程。</p>
<p>5、由堆栈这种先进后出的模型可以类比Koa框架自外到内的Request和由里到外的Response的数据流。</p>
<p>6、context的保存和传递、中间件的管理、next的实现要深入理解。</p>
<p>7、源码中调用App.use（）把一个中间件push到一个列表中，每次执行use函数，就在函数数组中添加了一个函数，然后通过compose来遍历整个中间件，最终将context和dispatch(i+1)传给了middleware。</p>
<p>8、一个中间件不能调用两次next()，调用时类比async函数，此时并不是表示中间件函数执行完毕了，调用了next()之后主程序还可以执行其他代码，类似于让next函数异步处理。（我对源码是这样理解的，有错误请大家指教）</p>
<p>9、compose将多个中间件函数合并成一个大的中间件函数，然后依次调用单独的每一层。</p>
<p>10、由compose处理中间件想到了redux，redux是利用数组的reducer对数组参数进行迭代。</p>
<p>11、Koa的思想是不是继承了Emitter？为了在任意时间处理抛出的异常，订阅了error事件，Koa有一个app-onerror事件输出错误的日志。</p>
<p>12、error处理有两个层面：APP层面负责log，一次响应过程中的error处理负责排查每次响应的结果。</p>
<h2 id="三、秒杀活动设计的思考方案"><a href="#三、秒杀活动设计的思考方案" class="headerlink" title="三、秒杀活动设计的思考方案"></a>三、秒杀活动设计的思考方案</h2><blockquote>
<p>背景：疫情枪口罩</p>
</blockquote>
<p>前端设计：防抖、节流减少请求次数、降低服务器压力</p>
<p>后端设计：Node玩法高级，开启Master+Worker模式</p>
<p>优点：</p>
<p>Node本身的特性是单线程、事件驱动、异步非阻塞。</p>
<p>没有多线程的切换上下文、加锁、销毁等复杂操作，之前博客也接触学习过。</p>
<p>线程安全、数据读写一致性好。</p>
<p>缺点：</p>
<p>单线程无法利用多核CPU</p>
<p>当时面试想到的方案：</p>
<p>1、<strong>首先进程通信在本科学过有信号量、共享内存、消息队列、管道、套接字等，不过Node是基于管道实现的。</strong></p>
<p>2、Node可以跨平台，libuv会针对不同的平台，采用不同的方式实现进程的通信。</p>
<p>3、开启child_process模块，利用child_process模块直接创建子进程。</p>
<p>暂时取名叫单线程+多进程模式吧</p>
<p>（这和H5提出的Web  Worker有异曲同工之妙，相当于另辟蹊径，解决了JS主线程和UI渲染共用一个线程所引发的相互阻塞问题）。</p>
<p>4、fork线程的开销还是比较大的，是为了利用CPU的资源。</p>
<p>5、口罩请求打到主进程上面，主进程进行代理，转发到不同端口的子进程上。</p>
<p>下来思考复盘之后可能出现的问题：</p>
<p>代理请求转发不友好</p>
<p>1、操作系统的文件描述符是有限的，维护需要成本。</p>
<p>2、比如：当客户端连接到主进程的时候，用完了一个操作符，当主进程连接到子进程时，又用掉了一个，从数量上看，代理方案不节省资源。</p>
<p>解决办法：（办法是查阅Node.js  9.2.3得出的）</p>
<blockquote>
<p>句柄传递-去除代理</p>
</blockquote>
<p>句柄传递可以代替代理的方案，原理是主进程收到客户端的请求之后，将这个请求直接发送到工作进程，而不是重新与子进程之间建立新的连接来转发数据。（又好像发布订阅模式）<br><img src="https://img-blog.csdnimg.cn/20200419125338865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200419125357754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>问题来了</p>
<p>为何通过发送句柄之后，多个进程可以监听到相同的端口而不引起异常？</p>
<p>官方解答：</p>
<p>1、因为独立启动的进程中，TCP服务器端socket套接字的文件描述符并不相同，导致监听到相同的端口时会抛出异常。</p>
<p>2、Node底层对每个端口监听设置了SO_REUSEADDR选项，不同进程可以对相同的网卡和端口进行监听，服务器套接字可以被不同的进程复用。</p>
<p>3、对于send(）发送的句柄还原出来的服务而言，文件描述符是相同的，所以监听相同的端口不会引起异常。</p>
<p>4、网络请求向服务器发送时，只有一个幸运的进程可以抢到连接，本质上一个请求的进程对应服务是抢占式的。</p>
<p>好了，这个问题终于解决啦</p>
<p>还有可能出现的问题：（简单给出思路和方案，日后再深入分析~）</p>
<p>1、数据共享？</p>
<p>答：Node本身不支持数据共享，所以我们要引入第三方Redis缓存，写一个定时脚本，在秒杀还没有开始之前，把口罩的库存数量写到Redis，从Redis拿数据处理。</p>
<p>2、多人抢一只口罩，库存来不及更新？</p>
<p>答：使用check-and-set实现乐观锁操作。（这个下去再仔细研究一下）</p>
<h2 id="四、项目梳理：每个项目选了一个点来切入"><a href="#四、项目梳理：每个项目选了一个点来切入" class="headerlink" title="四、项目梳理：每个项目选了一个点来切入"></a>四、项目梳理：每个项目选了一个点来切入</h2><h2 id="项目一"><a href="#项目一" class="headerlink" title="项目一"></a>项目一</h2><p>问题：给学校水果商店做的小程序，计算金额的时候，浮点数的精度问题。</p>
<p>举例子： 源自浮点数误差</p>
<p>0.1+0.2   //0.30000000000000004<br>1-0.9     //0.09999999999999998<br>9007199254740993-9007199254740992  //0<br>Math.pow(2,1023) //8.98846567431158e+307<br>//但是<br>Math.pow(2,1024)  //Infinity<br>0.1 &gt;&gt; 0.0001 1001 1001 1001…（1001无限循环）<br>0.2 &gt;&gt; 0.0011 0011 0011 0011…（0011无限循环）<br>原因分析：</p>
<p>JavaScript 里的数字是采用 IEEE 754 标准的 64 位双精度浮点数。</p>
<p>这个规范定义了浮点数的格式，对于64位的浮点数在内存中的表示：</p>
<p>最高的1位是符号位，接着的11位是指数，剩下的52位为有效数字。</p>
<p>第0位：符号位， s 表示 ，0表示正数，1表示负数；</p>
<p>第1位到第11位：储存指数部分， e 表示 ；</p>
<p>第12位到第63位：储存小数部分（即有效数字），f 表示；</p>
<p>根本原因：计算机底层只能二进制存储，所有的语言都存在这个问题。</p>
<blockquote>
<p>解决办法：</p>
</blockquote>
<p>1、引入两个库</p>
<p>Math.js<br> 适用于JavaScript 和 Node.js </p>
<p>具有灵活的表达式解析器，支持符号计算。</p>
<p>配有大量内置函数和常量</p>
<p>支持大数字(超出安全数的数字)，复数，分数，单位和矩阵的运算。</p>
<p>decimal.js<br>可以方便 JavaScript 进行十进制类型的任意精度数值计算。</p>
<p>2调用误差检查函数number.epsilon（）  兼容方法：math.abs(2，-52)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">withinErrorMargin</span> <span class="params">(left, right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.<span class="built_in">abs</span>(left - right) &lt; Number.EPSILON</span><br><span class="line">&#125;</span><br><span class="line">withinErrorMargin(<span class="number">0.1</span>+<span class="number">0.2</span>, <span class="number">0.3</span>)</span><br></pre></td></tr></table></figure>

<p>3、自己封装</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 核心方法，实现加减乘除运算，确保不丢失精度</span></span><br><span class="line"><span class="comment">     * 思路：把小数放大为整数（乘），进行算术运算，再缩小为小数（除）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param a &#123;number&#125; 运算数1</span></span><br><span class="line"><span class="comment">     * @param b &#123;number&#125; 运算数2</span></span><br><span class="line"><span class="comment">     * @param op &#123;string&#125; 运算类型，有加减乘除（add/subtract/multiply/divide）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">function <span class="title">operation</span><span class="params">(a, b, op)</span> </span>&#123;</span><br><span class="line">        var o1 = toInteger(a);</span><br><span class="line">        var o2 = toInteger(b);</span><br><span class="line">        var n1 = o1.num;</span><br><span class="line">        var n2 = o2.num;</span><br><span class="line">        var t1 = o1.times;</span><br><span class="line">        var t2 = o2.times;</span><br><span class="line">        var max = t1 &gt; t2 ? t1 : t2;</span><br><span class="line">        var result = null;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            case 'add':</span><br><span class="line">                <span class="keyword">if</span> (t1 === t2) &#123; <span class="comment">// 两个小数位数相同</span></span><br><span class="line">                    result = n1 + n2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t1 &gt; t2) &#123; <span class="comment">// o1 小数位 大于 o2</span></span><br><span class="line">                    result = n1 + n2 * (t1 / t2);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// o1 小数位 小于 o2</span></span><br><span class="line">                    result = n1 * (t2 / t1) + n2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result / max</span><br><span class="line">            case 'subtract':</span><br><span class="line">                <span class="keyword">if</span> (t1 === t2) &#123;</span><br><span class="line">                    result = n1 - n2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t1 &gt; t2) &#123;</span><br><span class="line">                    result = n1 - n2 * (t1 / t2);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = n1 * (t2 / t1) - n2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result / max;</span><br><span class="line">            case 'multiply':</span><br><span class="line">                result = (n1 * n2) / (t1 * t2);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            case 'divide':</span><br><span class="line">                result = (n1 / n2) * (t2 / t1);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加减乘除的四个接口</span></span><br><span class="line">    <span class="function">function <span class="title">add</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">        return operation(a, b, 'add');</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">function <span class="title">subtract</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">        return operation(a, b, 'subtract');</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">function <span class="title">multiply</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">        return operation(a, b, 'multiply');</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">function <span class="title">divide</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">        return operation(a, b, 'divide');</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exports</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        add: add, <span class="comment">// 加</span></span><br><span class="line">        subtract: subtract, <span class="comment">// 减</span></span><br><span class="line">        multiply: multiply, <span class="comment">// 乘</span></span><br><span class="line">        divide: divide <span class="comment">// 除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p>学习反思：</p>
<p>1、下去学习了千位分隔符（用正则可以解决）的解决办法。</p>
<p>2、学习了大数相加的办法：转换成字符串进行操作，按位遍历，执行加减乘除，使用变量来保存进位。</p>
<p>3、了解了底层数据的存储方式。</p>
<p>4、涉及到金额要格外细心铭感。</p>
<h2 id="项目二："><a href="#项目二：" class="headerlink" title="项目二："></a>项目二：</h2><p>学习了VUE的框架原理，通过项目有了一些框架体会和思考。</p>
<p>问题：坑挺多，一般查阅MDN和stackoverflow和社区可以解决bug。</p>
<p>收获：VUE-Router的源码学习。</p>
<p>导航守卫的执行过程。</p>
<p>URL变化逻辑切换不同页面的原理。（出栈入栈）</p>
<blockquote>
<p>原理概括分析：</p>
</blockquote>
<p>1当点击router-link时，最终会执行router.push(this.history.push）入栈。</p>
<p>2通过transitionTo做路劲切换，成功的回调会执行pushHash(roote.fullPath</p>
<p>方法，后面根据路劲变化去做入栈出栈操作，完成pop,place,replace功能。</p>
<p>3在 history 的初始化中，会设置一个监听器，监听历史栈的变化。</p>
<p>4当点击浏览器返回按钮的时候，如果已经有 url 被压入历史栈，则会触发 popstate 事件，然后拿到当前要跳转的 hash，执行 transtionTo 方法做一次路径转换。</p>
<blockquote>
<p>阅读源码笔记：</p>
</blockquote>
<p>1、导航守卫就是发生在路由路径切换时，执行的一系列钩子函数。</p>
<p>2、这些钩子函数执行的逻辑：首先构造一个队列 queue，这个队列实际上是一个数组。</p>
<p>3、然后再定义一个迭代器函数 iterator；最后再执行 runQueue 方法执行这个队列。</p>
<p>4、一个非常经典的异步函数队列化执行的模式，queue 是一个NavigationGuard 类型的数组，源码定义了 step 函数，每次根据 index 从 queue 中取一个 guard，然后执行 fn 函数，并且把 guard 作为参数传入，第二个参数是一个函数，当这个函数执行的时候再递归执行 step 函数，前进到下一个，其实这里的 fn 就是非常经典的 iterator 函数</p>
<p>5、iterator 函数逻辑就是去执行每一个导航守卫 hook，并传入 route、current 和匿名函数，这些参数对应源码中的 to、from、next。</p>
<p>6、当执行了匿名函数，会根据一些条件执行 abort 或 next，只有执行 next 的时候，才会前进到下一个导航守卫钩子函数中，这也就是为什么官方文档会说只有执行 next 方法才 resolve 这个钩子函数。</p>
<p>下面举例一个比较经典的，其他就不上图啦</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 经典的同步执行异步函数</span></span><br><span class="line">  runQueue(<span class="built_in">queue</span>, iterator, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> postEnterCbs = []</span><br><span class="line">    <span class="keyword">const</span> isValid = () =&gt; <span class="keyword">this</span>.current === route</span><br><span class="line">    <span class="comment">// 当所有异步组件加载完成后，会执行这里的回调，也就是 runQueue 中的 cb()</span></span><br><span class="line">    <span class="comment">// 接下来执行 需要渲染组件的导航守卫钩子</span></span><br><span class="line">    <span class="keyword">const</span> enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">queue</span> = enterGuards.concat(<span class="keyword">this</span>.router.resolveHooks)</span><br><span class="line">    runQueue(<span class="built_in">queue</span>, iterator, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 跳转完成</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.pending !== route) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abort</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.pending = null</span><br><span class="line">      onComplete(route)</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.router.app) &#123;</span><br><span class="line">        <span class="keyword">this</span>.router.app.$nextTick(() =&gt; &#123;</span><br><span class="line">          postEnterCbs.forEach(cb =&gt; &#123;</span><br><span class="line">            cb()</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">export</span> function <span class="title">runQueue</span> <span class="params">(<span class="built_in">queue</span>: Array&lt;?NavigationGuard&gt;, fn: Function, cb: Function)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> step = index =&gt; &#123;</span><br><span class="line">  <span class="comment">// 队列中的函数都执行完毕，就执行回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="built_in">queue</span>.length) &#123;</span><br><span class="line">      cb()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">queue</span>[index]) &#123;</span><br><span class="line">      <span class="comment">// 执行迭代器，用户在钩子函数中执行 next() 回调</span></span><br><span class="line">      <span class="comment">// 回调中判断传参，没有问题就执行 next()，也就是 fn 函数中的第二个参数</span></span><br><span class="line">        fn(<span class="built_in">queue</span>[index], () =&gt; &#123;</span><br><span class="line">          step(index + <span class="number">1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        step(index + <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取出队列中第一个钩子函数</span></span><br></pre></td></tr></table></figure>

<h2 id="项目三：还在完善中"><a href="#项目三：还在完善中" class="headerlink" title="项目三：还在完善中"></a>项目三：还在完善中</h2><blockquote>
<p>优化一：封装函数</p>
</blockquote>
<p>/*<br>封装的能发ajax请求的函数, 向外暴露的本质是axios</p>
<ol>
<li>解决post请求携带参数的问题: 默认是json, 需要转换成urlencode格式</li>
<li>让请求成功的结果不再是response, 而是response.data的值</li>
<li>统一处理所有请求的异常错误</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">*/</span><br><span class="line">import axios from 'axios'</span><br><span class="line">import qs from 'qs'</span><br><span class="line">import &#123;message&#125; from 'antd'</span><br><span class="line"><span class="comment">// 添加请求拦截器: 让post请求的请求体格式为urlencoded格式 a=1&amp;b2</span></span><br><span class="line"><span class="comment">// 在真正发请求前执行</span></span><br><span class="line">axios.interceptors.request.use(function (config) &#123;</span><br><span class="line">  <span class="comment">// 得到请求方式和请求体数据</span></span><br><span class="line">  <span class="keyword">const</span> &#123;method, data&#125; = config</span><br><span class="line">  <span class="comment">// 处理post请求, 将data对象转换成query参数格式字符串</span></span><br><span class="line">  if (method.toLowerCase() === 'post' &amp;&amp; typeof data==='object') &#123;</span><br><span class="line">    config.data = qs.stringify(data) <span class="comment">// username=admin&amp;password=admin</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">  <span class="comment">// 功能1: 让请求成功的结果不再是response, 而是response.data的值</span></span><br><span class="line">  <span class="comment">// 功能2: 统一处理所有请求的异常错误</span></span><br><span class="line"><span class="comment">// 在请求返回之后且在我们指定的请求响应回调函数之前</span></span><br><span class="line">axios.interceptors.response.use(function (response) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response.data <span class="comment">// 返回的结果就会交给我们指定的请求响应的回调</span></span><br><span class="line">  <span class="comment">// return response // 返回的结果就会交给我们指定的请求响应的回调</span></span><br><span class="line">&#125;, function (error) &#123; <span class="comment">// 统一处理所有请求的异常错误</span></span><br><span class="line">  message.error('请求出错 ' + error.message)</span><br><span class="line">  <span class="comment">// return Promise.reject(error);</span></span><br><span class="line">  <span class="comment">// 返回一个pending状态的promise, 中断promise链</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(() =&gt; &#123;&#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> axios</span><br></pre></td></tr></table></figure>

<blockquote>
<p>优化二：减少Render次数</p>
</blockquote>
<p>Component与PureComponent</p>
<p> 原因分析：Component存在的问题?</p>
<p> 父组件重新render(), 子组件也会重新执行render(), 即使没有任何变化</p>
<p> 解决Component存在的问题</p>
<p> 原因: 组件的shouldComponentUpdate()默认返回true, 即使数据没有变化render()都会重新执行</p>
<p> 办法1: 重写shouldComponentUpdate(), 判断如果数据有变化返回true, 否则返回false</p>
<p> 办法2: 使用PureComponent代替Component</p>
<p> 办法3：使用React.memo()高阶函数</p>
<p>PureComponent的基本原理：</p>
<p>（1）重写实现shouldComponentUpdate()</p>
<p>（2）对组件的新/旧state和props中的数据进行浅比较, 如果都没有变化, 返回false, 否则返回true</p>
<p>（3）一旦ShouldComponentUpdate()返回false，就不再执行用于更新的render()</p>
<blockquote>
<p>优化三：缓存HTTP请求和数据</p>
</blockquote>
<p>原因：</p>
<p>当用户再次请求相同的搜索内容时，可以不必发送网络请求，从缓存中取。</p>
<p>思路：</p>
<p>创建一个资源对象来缓存结果，当每次向网络发出新请求时，检查缓存中有没有上次的相同查询结果，存在就直接返回，不存在再发送网络请求，并将最新的请求数据保存到缓存中。</p>
<blockquote>
<p>优化四：用好Key</p>
</blockquote>
<p>虚拟DOM的key的地位:</p>
<p>1、其实key就是一个是虚拟DOM对象的标识, Key把页面上的DOM和虚拟DOM做了一层关联映射。</p>
<p>2、虚拟DOM是真实DOM在内存中的一个表示。在更新显示时key是一个唯一的标签，就像我们现实生活中的身份证，在生命周期中如果变化了，React会销毁原来的真实DOM，创建新的真实DOM。</p>
<p>3、当列表数组中的数据发生变化生成新的虚拟DOM后, React会逐层做Diff算法，分为TreeDiff  Component Diff  Element Diff </p>
<p>（1）key没有变</p>
<pre><code>item数据没变, 直接使用原来的真实DOM。

item数据变了, 对原来的真实DOM进行数据更新。</code></pre><p>（2）key变了：</p>
<p>销毁原来的真实DOM, 根据item数据创建新的真实DOM显示。</p>
<p>(即使item数据没有变)</p>
<p>4、key为index存在的问题</p>
<p>（1）添加/删除/排序 =&gt; 产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低</p>
<p>（2）如果item界面还有输入框 =&gt; 产生错误的真实DOM更新 ==&gt; 界面有问题</p>
<p>5、使用总结：问题的关键就是一定要用唯一属性作为Key</p>
<p>（1）如果不存在添加/删除/排序/过滤操作, 用index作为keys是可以的。</p>
<p>（2）列表不可以变动时，可以用index作为key。</p>
<p>（3）列表添加删除时，可能导致某一部分的商品下标（key）改变被销毁，导致数据错乱或者不必要的重复渲染。</p>
<p>（4）用唯一属性作为key，比如商品的出厂号码等，在生命周期中唯一不变</p>
<blockquote>
<p>优化小细节总结五：</p>
</blockquote>
<p>1、JS事件中节流。</p>
<p>比如即时搜索功能，节流到输入字段结束之后再去请求数据。</p>
<p>2、避免在map 方法中使用index作为组件的Key。</p>
<p>3、采用记忆化的React组件：存储复杂函数的计算结果，比如优化三中的缓存组件。</p>
<p>4、使用Web  Workers扩展任务。</p>
<p>5、根据需要采用服务端渲染。</p>
<p>6、在服务器启动Gzip压缩，在Node端安装Compression并调用。</p>
<blockquote>
<p>目前计划和挑战：</p>
</blockquote>
<p>1、学习移动消息推送中一键免密登录、第三方登录的原理，尝试实现这个功能。</p>
<p>2、深化前端模块化、工程化的理念和实践，关注智能化的新方向。</p>
<p>3、学习Flutter技术，做好研究生的深度学习毕设。</p>
<p>4、关注前端领域、做好T型学习模式，视野要广，对于某方向的技术要好好沉淀，多思考，多锻炼，坚持不懈，做到精益求精。</p>
<p>5、保持热情和动力、科技改变美丽人生、打造极致体验</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E4%B8%AA%E4%BA%BA%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/" rel="tag">个人职业规划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E6%80%9D%E8%80%83%E5%A4%8D%E7%9B%98/" rel="tag">思考复盘</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-认真剖析Promise" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2020/04/14/%E8%AE%A4%E7%9C%9F%E5%89%96%E6%9E%90Promise/"
    >阿里面试总结（二）——认真剖析Promise</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2020/04/14/%E8%AE%A4%E7%9C%9F%E5%89%96%E6%9E%90Promise/" class="article-date">
  <time datetime="2020-04-13T16:00:00.000Z" itemprop="datePublished">2020-04-14</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">阿里面试总结</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>今天面试官小姐姐问了一个很好的问题，Promise怎么异步转同步？<br>当时有点紧张想复杂了，下来好好梳理一下，小姐姐人很好，激发了小霞打下坚实基础，投身大前端的激情和动力，hhh，话不多说，<strong>追根溯源，脚踏实地，勤恳思辨就是学习最好的方法</strong>，路漫漫，加油干！</p>
<h2 id="一、同步异步场景需求剖析："><a href="#一、同步异步场景需求剖析：" class="headerlink" title="一、同步异步场景需求剖析："></a>一、同步异步场景需求剖析：</h2><p>1、RunAsync.add(new Task())//task1<br>    .add(new Task())//task2<br>    .add(new Task())//task3<br>    .start();<br>我们希望task1完成之后task2再启动，task2完成后task3再启动，也即异步串联。<br>2、把异步变成同步。<br>3、页面倒计时，10、9、8、7、6依次输出。<br>首先拆解一下题意，不能曲解了嘿嘿嘿，我当时就是紧张了，想到了Promise.all和Promise.race去解决多个并行任务，设计逻辑，判断返回函数的顺序的场景。其实我们要解决的是异步串联问题，也就是把异步变成同步，注意这里不要曲解字面意思哦。<br>让我娓娓道来！后来我又想了一个方法，除了.then异步串联，好像还可以用自动迭代去next()。目前想到这两种解决方案。<br>首先，什么是同步？什么是异步？</p>
<blockquote>
<p>字面误区：1、js单线程，同步操作任务，并非一起操作之意，而是你执行完了我再去执行；2、js异步操作任务，也并非是指在不同线程里做不同的事情。</p>
</blockquote>
<p><strong>本质理解：</strong>首页js的语言执行环境是单线程的，也就是一次只能完成一个任务，多个任务就必须按照时间先后排队，前面完成后才能完成后一个任务。这个是js的常规模式，也就也是同步操作任务。</p>
<p><strong>弊端：</strong>同步操作任务带来的问题是，只要一个任务执行时间过程，后面的任务都会排队等待，拖延整个程序的执行。<br>如：常见的浏览器假死很可能就是js任务执行时间太长导致。</p>
<p>为了解决同步操作带来的弊端，js语言增加了异步任务的操作模式：<br>1、当前任务可以携带回一个回调函数（当前任务执行时间过长，把需要提前执行的任务放在回掉中）。<br>2、可以利用setTimeout构建异步任务，让主逻辑优先执行，对于耗时间长的任务可以放在setTimeout中异步执行。<br>3、所以异步操作任务主要是改变了程序的正常执行操作顺序。<br>举个栗子吧！<br>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"1"</span>)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"2"</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"3"</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"4"</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"5"</span>)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>执行结果为：</p>
<p>1<br>5<br>2<br>3<br>4</p>
<p>那么大致的运行机制如下：<br>（1）在js主程序（单线程）上的同步任务形成了一个主任务执行栈。<br>（2）主线程之外还存在一个任务队列，这个队列存在一些按时间顺序存放的事件，<strong>如鼠标点击、计时触发等，主线程中每出现一个异步任务，任务队列就会增加一个异步任务的事件。</strong><br>（3）一般执行栈中的同步任务执行完毕，系统就会读取任务队列，看看哪些事件是可以执行的，一旦可以执行将进入执行栈开始执行，后面分析Generator再区别微任务和宏任务。<br>（4）不断重复以上动作。<br>严肃剖析一下：</p>
<p><strong>同步</strong>：百度的名词解释是： 同步指两个或两个以上随时间变化的量在变化过程中保持一定的相对关系。<br> 例如：你去饭店去吃饭。当你叫服务员点餐时，服务员正在别的桌服务，这时你要等待服务员，把别人的事情处理完成以后，才可以到你这服务。不能同时进行，是要有排队顺序的，所以会阻塞进程，简单的说，只有一条主任务工作。<br>总结：就是一个任务完成之后，才能执行下一个任务。我们可以将同步看成是单线的执行，即要么执行成功，要么执行失败，反正就是要返回一个结果，在没有得到这个结果之前什么都不干，就傻傻的等着。任务提交后不向系统交出控制权，持续等待。<br><strong>异步</strong>：执行一个任务的同时，中间去执行其它的事件，最终在回来执行这个任务，不连续，node最大的特点就是支持异步，例如：node虽然是单线程，但是CPU利用率非常高，它就是一个日夜不息的接单员，一直在流水线工作。其实这样好处也很多，不用处理开辟线程、销毁线程的任务，而且不用设计资源抢占、读写锁的问题，对I/O密集友好。<br>总结：异步则是当你的任务提交了之后，不用管任务的结果是什么，可以继续执行别的任务，任务提交后将控制权交予系统，系统可以进行其他任务的执行。<br>两者比较<br>1、同步的执行效率会比较低，耗费时间，但有利于我们对流程进行控制，避免很多不可掌控的意外情况。<br>2、异步的执行效率高，节省时间，但是会占用更多的资源，也不利于我们对进程进行控制。<br><strong>优缺点及使用场景</strong><br>异步优点<br>1、异步流程可以立即给调用方返回初步的结果。</p>
<p>2、异步流程可以延迟给调用方最终的结果数据，在此期间可以做更多额外的工作，例如结果记录等等。</p>
<p>3、异步流程在执行的过程中，可以释放占用的线程等资源，避免阻塞，等到结果产生再重新获取线程处理。</p>
<p>4、异步流程可以等多次调用的结果出来后，再统一返回一次结果集合，提高响应效率。</p>
<p><strong>异步使用场景：</strong></p>
<p>1、不涉及共享资源，或对共享资源只读，即非互斥操作。</p>
<p>2、没有时序上的严格关系。</p>
<p>3、不需要原子操作，或可以通过其他方式控制原子性。</p>
<p>4、常用于IO操作等耗时操作，因为比较影响客户体验和使用性能。</p>
<p>5、不影响主线程逻辑。</p>
<p><strong>同步优点：</strong></p>
<p>1、同步流程对结果处理通常更为简单，可以就近处理。</p>
<p>2、同步流程对结果的处理始终和前文保持在一个上下文内。同步是一步一步来操作，等待请求返回的数据，再执行下一步，那么一定会有一些情况，只有这一步执行完，拿到数据，通过获取到这一步的数据来执行下一步的操作。</p>
<p>3、同步流程可以很容易捕获、处理异常。</p>
<p>4、同步流程是最天然的控制过程顺序执行的方式。</p>
<h2 id="二、异步串联"><a href="#二、异步串联" class="headerlink" title="二、异步串联"></a>二、异步串联</h2><p>其实面试官小姐姐的答案就是：.then()来异步串联。<br>下面是我的思考和解答：<br>首先是一个简单版的手撸Promise:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">Promise</span><span class="params">(executor)</span></span>&#123; <span class="comment">//executor执行器</span></span><br><span class="line">    let self = <span class="keyword">this</span>;</span><br><span class="line">    self.status = 'pending'; //等待态</span><br><span class="line">    self.value  = undefined; <span class="comment">// 表示当前成功的值</span></span><br><span class="line">    self.reason = undefined; <span class="comment">// 表示是失败的值</span></span><br><span class="line">    <span class="function">function <span class="title">resolve</span><span class="params">(value)</span></span>&#123; <span class="comment">// 成功的方法</span></span><br><span class="line">        if(self.status === 'pending')&#123;</span><br><span class="line">            self.status = 'resolved';</span><br><span class="line">            self.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">function <span class="title">reject</span><span class="params">(reason)</span></span>&#123; <span class="comment">//失败的方法</span></span><br><span class="line">        if(self.status === 'pending')&#123;</span><br><span class="line">            self.status = 'rejected';</span><br><span class="line">            self.reason = reason;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    executor(resolve,reject);</span><br><span class="line">&#125;</span><br><span class="line">Promise.prototype.then = function(onFufiled,onRejected)&#123;</span><br><span class="line">    let self = <span class="keyword">this</span>;</span><br><span class="line">    if(self.status === 'resolved')&#123;</span><br><span class="line">        onFufiled(self.value);</span><br><span class="line">    &#125;</span><br><span class="line">    if(self.status === 'rejected')&#123;</span><br><span class="line">        onRejected(self.reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">module</span>.exports = Promise;</span><br></pre></td></tr></table></figure>
<p>使用方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let Promise = require('./m2.Promise');</span><br><span class="line">let p = <span class="keyword">new</span> Promise((resolve, reject) =&gt;&#123;</span><br><span class="line">          setTimeout(()=&#123;</span><br><span class="line">    resolve('zfpx')</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.then(function(data)&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"data"</span>,data)</span><br><span class="line">&#125;,function(err)&#123;</span><br><span class="line">  console.log('err',err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200413232504760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200413232526253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>观察这个例子，我来分析 一下Promise 的调用流程：</p>
<ul>
<li>Promise的构造方法接收一个executor()，在new Promise()时就立刻执行这个 executor 回调   </li>
<li>executor()内部的异步任务被放入宏/微任务队列，等待执行 then()被执行，收集成功/失败回调，放入成功/失败队列   </li>
<li>executor()的异步任务被执行，触发resolve/reject，从成功/失败队列中取出回调依次执行</li>
</ul>
<p>我理解这是个观察者模式，是一种收集依赖=》触发通知 =》取出依赖执行 的方式。<br>new Promise时（）会立即执行executor，并传入resolve和reject，由于他们是在executor内部被调用，所以要使用箭头函数去固定this指向，否则会找不到成功resolve之后的this.resolveQueue。<br>在 Promise 里，执行顺序是then收集依赖 ，异步触发resolve ， resolve执行依赖。then方法的回调里取到异步操作的返回值，then返回一个新的promise，分别对应状态改变的时候触发的回调，到了时间我们就返回Promise的结果，类似于依赖执行完毕。then方法可以被同一个promise调用多次，要实现这个功能，我们可以用一个队列来存储回调。<br>依此，我们可以勾勒出 Promise 的大致形状：其实就是一个单向变更的状态机，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">Promise</span><span class="params">(executor)</span> </span>&#123; <span class="comment">// executor是一个执行函数</span></span><br><span class="line">    let self = <span class="keyword">this</span>;</span><br><span class="line">    self.status = 'pending';</span><br><span class="line">    self.value = undefined; <span class="comment">// 默认成功的值</span></span><br><span class="line">    self.reason = undefined; <span class="comment">// 默认失败的原因</span></span><br><span class="line">    self.onResolvedCallbacks = []; <span class="comment">// 存放then成功的回调</span></span><br><span class="line">    self.onRejectedCallbacks = []; <span class="comment">// 存放then失败的回调</span></span><br><span class="line">    <span class="function">function <span class="title">resolve</span><span class="params">(value)</span> </span>&#123; <span class="comment">// 成功状态</span></span><br><span class="line">        if (self.status === 'pending') &#123;</span><br><span class="line">            self.status = 'resolved';</span><br><span class="line">            self.value = value;</span><br><span class="line">            self.onResolvedCallbacks.forEach(function (fn) &#123;</span><br><span class="line">                fn();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">function <span class="title">reject</span><span class="params">(reason)</span> </span>&#123; <span class="comment">// 失败状态</span></span><br><span class="line">        if (self.status === 'pending') &#123;</span><br><span class="line">            self.status = 'rejected';</span><br><span class="line">            self.reason = reason;</span><br><span class="line">            self.onRejectedCallbacks.forEach(function (fn) &#123;</span><br><span class="line">                fn();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executor(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123; <span class="comment">// 捕获的时候发生异常,就直接失败了</span></span><br><span class="line">        reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">resolvePromise</span><span class="params">(promise2, x, resolve, reject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有可能这里返回的x是别人的promise</span></span><br><span class="line">    <span class="comment">// 尽可能允许其他乱写</span></span><br><span class="line">    <span class="keyword">if</span> (promise2 === x) &#123; <span class="comment">//这里应该报一个类型错误，有问题</span></span><br><span class="line">        return reject(new TypeError('循环引用了'))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 看x是不是一个promise,promise应该是一个对象</span></span><br><span class="line">    let called; <span class="comment">// 表示是否调用过成功或者失败</span></span><br><span class="line">    if (x !== null &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123;</span><br><span class="line">        <span class="comment">// 可能是promise &#123;&#125;,看这个对象中是否有then方法，如果有then我就认为他是promise了</span></span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">// &#123;then:1&#125;</span></span><br><span class="line">            let then = x.then;</span><br><span class="line">            if (typeof then === 'function') &#123;</span><br><span class="line">                <span class="comment">// 成功</span></span><br><span class="line">                then.call(x, function (y) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">                    called = <span class="literal">true</span></span><br><span class="line">                    <span class="comment">// y可能还是一个promise，在去解析直到返回的是一个普通值</span></span><br><span class="line">                    resolvePromise(promise2, y, resolve, reject)</span><br><span class="line">                &#125;, function (err) &#123; <span class="comment">//失败</span></span><br><span class="line">                    <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">                    called = <span class="literal">true</span></span><br><span class="line">                    reject(err);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(x)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 说明是一个普通值1</span></span><br><span class="line">        resolve(x); <span class="comment">// 表示成功了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Promise.prototype.then = function (onFulfilled, onRjected) &#123;</span><br><span class="line">    <span class="comment">//成功和失败默认不传一个函数</span></span><br><span class="line">    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : function (value) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    onRjected = typeof onRjected === 'function' ? onRjected : function (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    let self = <span class="keyword">this</span>;</span><br><span class="line">    let promise2; <span class="comment">//返回的promise</span></span><br><span class="line">    if (self.status === 'resolved') &#123;</span><br><span class="line">        promise2 = <span class="keyword">new</span> Promise(function (resolve, reject) &#123;</span><br><span class="line">            <span class="comment">// 当成功或者失败执行时有异常那么返回的promise应该处于失败状态</span></span><br><span class="line">            <span class="comment">// x可能是一个promise 也有可能是一个普通的值</span></span><br><span class="line">            setTimeout(function () &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    let x = onFulfilled(self.value);</span><br><span class="line">                    <span class="comment">// x可能是别人promise，写一个方法统一处理</span></span><br><span class="line">                    resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.status === 'rejected') &#123;</span><br><span class="line">        promise2 = <span class="keyword">new</span> Promise(function (resolve, reject) &#123;</span><br><span class="line">            setTimeout(function () &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    let x = onRjected(self.reason);</span><br><span class="line">                    resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"> </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当调用then时可能没成功 也没失败</span></span><br><span class="line">    if (self.status === 'pending') &#123;</span><br><span class="line">        promise2 = <span class="keyword">new</span> Promise(function (resolve, reject) &#123;</span><br><span class="line">            <span class="comment">// 此时没有resolve 也没有reject</span></span><br><span class="line">            self.onResolvedCallbacks.push(function () &#123;</span><br><span class="line">                setTimeout(function () &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        let x = onFulfilled(self.value);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">            self.onRejectedCallbacks.push(function () &#123;</span><br><span class="line">                setTimeout(function () &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        let x = onRjected(self.reason);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 捕获错误的方法</span></span><br><span class="line">Promise.prototype.<span class="keyword">catch</span> = function (callback) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(null, callback)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解析全部方法</span></span><br><span class="line"><span class="comment">// let arr = [];</span></span><br><span class="line"><span class="comment">// arr[1] = 100;</span></span><br><span class="line"><span class="comment">// console.log(arr.length)</span></span><br><span class="line">Promise.all = function (promises) &#123;</span><br><span class="line">    <span class="comment">//promises是一个promise的数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise(function (resolve, reject) &#123;</span><br><span class="line">        let arr = []; <span class="comment">//arr是最终返回值的结果</span></span><br><span class="line">        let i = <span class="number">0</span>; <span class="comment">// 表示成功了多少次</span></span><br><span class="line">        function processData(index, y) &#123;</span><br><span class="line">            arr[index] = y;</span><br><span class="line">            <span class="keyword">if</span> (++i === promises.length) &#123;</span><br><span class="line">                resolve(arr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">            promises[i].then(function (y) &#123;</span><br><span class="line">                processData(i, y)</span><br><span class="line">            &#125;, reject)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只要有一个promise成功了 就算成功。如果第一个失败了就失败了</span></span><br><span class="line">Promise.race = function (promises) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise(function (resolve, reject) &#123;</span><br><span class="line">        <span class="keyword">for</span> (var i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">            promises[i].then(resolve,reject)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成一个成功的promise</span></span><br><span class="line">Promise.resolve = function(value)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise(function(resolve,reject)&#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成一个失败的promise</span></span><br><span class="line">Promise.reject = function(reason)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise(function(resolve,reject)&#123;</span><br><span class="line">        reject(reason);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">Promise.defer = Promise.deferred = function () &#123;</span><br><span class="line">    let dfd = &#123;&#125;;</span><br><span class="line">    dfd.promise = <span class="keyword">new</span> Promise(function (resolve, reject) &#123;</span><br><span class="line">        dfd.resolve = resolve;</span><br><span class="line">        dfd.reject = reject;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> dfd</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mjs</span></span><br><span class="line"><span class="keyword">module</span>.exports = Promise;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>显然.then()需要返回一个 Promise，这样才能找到 then 方法链式调用，所以我们会把 then 方法的返回值包装成<br>Promise。 .then()的回调需要顺序执行，我们要等待当前 Promise 状态变更后，再执行下一个 then 收集的回调，这就要求我们对 then 的返回值分类讨论。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Promise/A+规范的三种状态</span></span><br><span class="line">const PENDING = 'pending'</span><br><span class="line">const FULFILLED = 'fulfilled'</span><br><span class="line">const REJECTED = 'rejected'</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> &#123;</span></span><br><span class="line">  <span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">  constructor(executor) &#123;<span class="comment">//executor是异步任务，才可以先then收集回调，再返回resolve  reject的结果</span></span><br><span class="line">    <span class="keyword">this</span>._status = PENDING     <span class="comment">// Promise状态</span></span><br><span class="line">    <span class="keyword">this</span>._resolveQueue = []    <span class="comment">// 成功队列, resolve时触发</span></span><br><span class="line">    <span class="keyword">this</span>._rejectQueue = []     <span class="comment">// 失败队列, reject时触发</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span></span><br><span class="line">    let _resolve = (val) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span>   <span class="comment">// 对应规范中的"状态只能由pending到fulfilled或rejected"</span></span><br><span class="line">      <span class="keyword">this</span>._status = FULFILLED              <span class="comment">// 变更状态</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这里之所以使用一个队列来储存回调,是为了实现规范要求的 "then 方法可以被同一个 promise 调用多次"</span></span><br><span class="line">      <span class="comment">// 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">this</span>._resolveQueue.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> callback = <span class="keyword">this</span>._resolveQueue.shift()</span><br><span class="line">        callback(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现同resolve</span></span><br><span class="line">    let _reject = (val) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span>   <span class="comment">// 对应规范中的"状态只能由pending到fulfilled或rejected"</span></span><br><span class="line">      <span class="keyword">this</span>._status = REJECTED               <span class="comment">// 变更状态</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">this</span>._rejectQueue.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> callback = <span class="keyword">this</span>._rejectQueue.shift()</span><br><span class="line">        callback(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// new Promise()时立即执行executor,并传入resolve和reject</span></span><br><span class="line">    executor(_resolve, _reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">  then(resolveFn, rejectFn) &#123;</span><br><span class="line">    <span class="keyword">this</span>._resolveQueue.push(resolveFn)</span><br><span class="line">    <span class="keyword">this</span>._rejectQueue.push(rejectFn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面实现了then方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then方法</span></span><br><span class="line">then(resolveFn, rejectFn) &#123;</span><br><span class="line">  <span class="comment">//return一个新的promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">    <span class="comment">//把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span></span><br><span class="line">    <span class="keyword">const</span> fulfilledFn = value =&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">        let x = resolveFn(value)</span><br><span class="line">        <span class="comment">//分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">        x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把后续then收集的依赖都push进当前Promise的成功回调队列中(_rejectQueue), 这是为了保证顺序调用</span></span><br><span class="line">    <span class="keyword">this</span>._resolveQueue.push(fulfilledFn)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//reject同理</span></span><br><span class="line">    <span class="keyword">const</span> rejectedFn  = error =&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        let x = rejectFn(error)</span><br><span class="line">        x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._rejectQueue.push(rejectedFn)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试可以满足面试官姐姐提出的需求场景。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(res)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(res)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(res)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 1 2 3</span></span><br></pre></td></tr></table></figure>

<h2 id="三、-then方法的几点注意"><a href="#三、-then方法的几点注意" class="headerlink" title="三、 then方法的几点注意"></a>三、 then方法的几点注意</h2><p>1、jquery能实现链式调用靠的就是返回this，promise不能返回this，promise实现链式调用靠的是返回一个新的promise。调用then时要返回一个新的promise。<br>2、Promise 是用来执行异步操作的。但有时一个异步操作需要等其他的异步操作完成，这时候就可以使用then来做。<br>3、使用 promise.then + 递归的方法异步转同步，我一直理解then().then()是一个chain，每一个then会返回一个promise，然后往后面传。但是我今天跑了一段代码，没有按照这个顺序执行，可能和异常错误处理有关。<br>4、then是会返回一个promise对象，但是这个promise对象的this是你前一个promise的，如果你return 一个新的promise，this则是这个promise，所以后面的then需要依据第二个promise是否resolve，才决定是否执行相应的then。<br>5、<strong>then，catch都是同步方法</strong>，假设执行b=new Promise(func)后里面的异步操作，已经开始但可能未处理完，同步执行下去是运行b.then(a)，b.then(aa)，b.then(aaa)…，假设运行到b.then(aa)方法时异步操作仍未处理完，那么then函数就会把aa push到b里面的一个callbacks数组中，假设运行b.then(aaa)前异步操作完成，首先将异步结果赋值给b里的result变量，然后循环调用callbacks数组里存好的方法：a(result),aa(result)，执行完毕后再运行b.then(aaa)，此时判断异步已执行完毕，不用将aaa push到callbacks数组里，而是直接运行aaa(result)，真正原因是res()内部设置了一个延时执行回调，延时setTimeout的最小值，<strong>也就是说res才是异步的，</strong>由于这点异步时间，导致最后一例中a.then(a)将a函数存放到callbacks里了，导致顺序发生错误，可以试着将a.then(a)延时执行，这就和浏览器时间频率有关系了，想一想怎么在秒杀系统处理呢？<br>6、在new promise(fn)中，<strong>new出来的函数是同步的，但是 fn的res() 函数是异步的，会挂起线程</strong>，执行到then的时候，顺利执行then的代码块，只是把成功的回调函数放到了resovledCallbacks中，但是就算state修改完毕为solved的时候，5中提到的执行then（aaa）的时候也是会异步操作，也不是立即执行aaa， 因为then的内部实现方式根据promiseA规范中也是有一个settimeout 在延时器内部执行aaa的。<br>再举个具体栗子！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">loadImageAsync</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Promise(function(resolve, reject) &#123;</span><br><span class="line">           var image = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">           image.onload = function() &#123;</span><br><span class="line">               console.<span class="built_in">log</span>(<span class="string">"load"</span>);</span><br><span class="line">               resolve(image);</span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line">           image.onerror = function() &#123;</span><br><span class="line">               reject(new Error('Could not load image at ' + url));</span><br><span class="line">           &#125;;</span><br><span class="line">           console.<span class="built_in">log</span>(<span class="string">"change src"</span>);</span><br><span class="line">           <span class="function">function <span class="title">init_img</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               image.src = url;</span><br><span class="line">           &#125;</span><br><span class="line">           setTimeout(init_img,<span class="number">5000</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>loadImageAsync 用来异步加载图片. setTimeout 人为地延迟5秒加载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">loadImageAsync2</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Promise(function(resolve, reject) &#123;</span><br><span class="line">            var image = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">            image.onload = function() &#123;</span><br><span class="line">                console.<span class="built_in">log</span>(<span class="string">"2load"</span>);</span><br><span class="line">                resolve(image);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            image.onerror = function() &#123;</span><br><span class="line">                reject(new Error('Could not load image at ' + url));</span><br><span class="line">            &#125;;</span><br><span class="line">            console.<span class="built_in">log</span>(<span class="string">"2change src"</span>);</span><br><span class="line">            <span class="function">function <span class="title">init_img</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                image.src = url;</span><br><span class="line">            &#125;</span><br><span class="line">            setTimeout(init_img,<span class="number">1000</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>loadImageAsync2 也是用来加载图片，人为地延迟1秒。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var p = loadImageAsync('http://img02.tooopen.com/images/20141231/sy_78327074576.jpg');</span><br><span class="line">    p.then(function (img) &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">"1:"</span>+img.src);</span><br><span class="line">    &#125;);</span><br><span class="line">    var h = loadImageAsync2('http://img02.tooopen.com/images/20141225/sy_77944235469.jpg');</span><br><span class="line">    h.then(function (img) &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">"2:"</span>+img.src);</span><br><span class="line">    &#125;);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"wqx"</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到 图片2先加载， 然后加载图片1 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s = loadImageAsync('http://img02.tooopen.com/images/20141231/sy_78327074576.jpg');</span><br><span class="line">  s.then(function (img) &#123;</span><br><span class="line">      console.<span class="built_in">log</span>(<span class="string">"1:"</span>+img.src);</span><br><span class="line">      return loadImageAsync2('http://img02.tooopen.com/images/20141225/sy_77944235469.jpg');</span><br><span class="line">  &#125;).then(function (img) &#123;</span><br><span class="line">      console.<span class="built_in">log</span>(<span class="string">"2:"</span>+img.src);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>创建新的promise 对象 s，我在s 的then 成功回调函数中 去调用 loadImageAsync2 函数。</p>
<p>这样就保证了 加载图片2 之前先加载图片1。</p>
<p>这里注意的是第二个then 其实是loadImageAsync2 返回的promise 实例调用的。这样就保证了加载完毕图片再去打印图片的解释说明。</p>
<p><strong>还要注意的两点：</strong><br>1、值穿透：根据规范，如果 then() 接收的参数不是 function，那么我们应该忽略它。如果没有忽略，当 then()回调不为 function 时将会抛出异常，导致链式调用中断。<br>2、处理状态为 resolve/reject 的情况：其实我们上边 then() 的写法是对应状态为padding的情况，但是有些时候resolve/reject 在 then() 之前就被执行（比如Promise.resolve().then()），如果这个时候还把 then()回调 push 进 resolve/reject 的执行队列里，那么回调将不会被执行，因此对于状态已经变为fulfilled或rejected的情况，我们直接执行 then 回调。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">  then(resolveFn, rejectFn) &#123;</span><br><span class="line">    <span class="comment">// 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span></span><br><span class="line">    typeof resolveFn !== 'function' ? resolveFn = value =&gt; value : null</span><br><span class="line">    typeof rejectFn !== 'function' ? rejectFn = reason =&gt; &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(reason instanceof Error? reason.message:reason);</span><br><span class="line">    &#125; : null</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return一个新的promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span></span><br><span class="line">      <span class="keyword">const</span> fulfilledFn = value =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">          let x = resolveFn(value)</span><br><span class="line">          <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// reject同理</span></span><br><span class="line">      <span class="keyword">const</span> rejectedFn  = error =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          let x = rejectFn(error)</span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">this</span>._status) &#123;</span><br><span class="line">        <span class="comment">// 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行</span></span><br><span class="line">        <span class="keyword">case</span> PENDING:</span><br><span class="line">          <span class="keyword">this</span>._resolveQueue.push(fulfilledFn)</span><br><span class="line">          <span class="keyword">this</span>._rejectQueue.push(rejectedFn)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 当状态已经变为resolve/reject时,直接执行then回调</span></span><br><span class="line">        <span class="keyword">case</span> FULFILLED:</span><br><span class="line">          fulfilledFn(<span class="keyword">this</span>._value)    <span class="comment">// this._value是上一个then回调return的值(见完整版代码)</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REJECTED:</span><br><span class="line">          rejectedFn(<span class="keyword">this</span>._value)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、catch、all、race、finally方法"><a href="#四、catch、all、race、finally方法" class="headerlink" title="四、catch、all、race、finally方法"></a>四、catch、all、race、finally方法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.<span class="keyword">catch</span>()</span><br><span class="line"><span class="keyword">catch</span>()方法返回一个 Promise，并且处理拒绝的情况。它的行为与调用 Promise.prototype.then(undefined, onRejected) 相同。</span><br><span class="line"><span class="comment">//catch方法其实就是执行一下then的第二个回调</span></span><br><span class="line"><span class="keyword">catch</span>(rejectFn) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(undefined, rejectFn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise.prototype.finally() finally()方法返回一个 Promise。在 promise 结束时，无论结果是 fulfilled 或者是 rejected，都会执行指定的回调函数。在 finally 之后，还可以继续then。并且会将值原封不动的传递给后面的 then。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//finally方法</span></span><br><span class="line">finally(callback) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    value =&gt; MyPromise.resolve(callback()).then(() =&gt; value),   <span class="comment">// MyPromise.resolve执行回调,并在then中return结果传递给后面的Promise</span></span><br><span class="line">    reason =&gt; MyPromise.resolve(callback()).then(() =&gt; &#123; <span class="keyword">throw</span> reason &#125;)  <span class="comment">// reject同理</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise.resolve() Promise.resolve(value)方法返回一个以给定值解析后的 Promise 对象。如果该值为 promise，返回这个 promise；如果这个值是 thenable（即带有”then” 方法)），返回的 promise 会“跟随”这个 thenable 的对象，采用它的最终状态；否则返回的 promise 将以此值完成。此函数将promise 对象的多层嵌套展平。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态的resolve方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">resolve</span><span class="params">(value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(value instanceof MyPromise) <span class="keyword">return</span> value <span class="comment">// 根据规范, 如果参数是Promise实例, 直接return这个实例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(resolve =&gt; resolve(value))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise.reject() Promise.reject()方法返回一个带有拒绝原因的 Promise 对象。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态的reject方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">reject</span><span class="params">(reason)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; reject(reason))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise.all() Promise.all(iterable)方法返回一个 Promise 实例，此实例在 iterable参数内所有的 promise 都“完成（resolved）”】或参数中不包含 promise 时回调完成（resolve）；<br>如果参数中promise 有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败 promise 的结果。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态的all方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">all</span><span class="params">(promiseArr)</span> </span>&#123;</span><br><span class="line">  let index = <span class="number">0</span></span><br><span class="line">  let result = []<span class="comment">//放在数组中</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">    promiseArr.forEach((p, i) =&gt; &#123;</span><br><span class="line">      <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">      MyPromise.resolve(p).then(</span><br><span class="line">        val =&gt; &#123;</span><br><span class="line">          index++</span><br><span class="line">          result[i] = val<span class="comment">//保证顺序到达</span></span><br><span class="line">          <span class="comment">//所有then执行后, resolve结果</span></span><br><span class="line">          <span class="keyword">if</span>(index === promiseArr.length) &#123;</span><br><span class="line">            resolve(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        err =&gt; &#123;</span><br><span class="line">          <span class="comment">//有一个Promise被reject时，MyPromise的状态变为reject</span></span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise.race() Promise.race(iterable)方法返回一个 promise，一旦迭代器中的某个 promise解决或拒绝，返回的 promise 就会解决或拒绝，找到最先完成的那个任务，数组中有一个完成就返回，没有顺序之分，看完成的速度。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">race</span><span class="params">(promiseArr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">    <span class="comment">//同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span></span><br><span class="line">    <span class="keyword">for</span> (let p of promiseArr) &#123;</span><br><span class="line">      MyPromise.resolve(p).then(  <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">        value =&gt; &#123;</span><br><span class="line">          resolve(value)        <span class="comment">//注意这个resolve是上边new MyPromise的</span></span><br><span class="line">        &#125;,</span><br><span class="line">        err =&gt; &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、Generator的秘密"><a href="#五、Generator的秘密" class="headerlink" title="五、Generator的秘密"></a>五、Generator的秘密</h2><p>下面这个代码可能就是面试官姐姐的问题初衷吧。我之前想到了用next方法，没有表达清楚，面完突然好像懂了吼吼吼。<br>所以终极方案就是：Promise+Generator<br>Generator的这种特性对于异步来说，意味着什么呢？<br>意味着，我们终于获得了一种在不阻塞主线程的前提下实现“同步等待”的方法！<br>为便于说明，先上一段直接使用回调的代码：<br>看下面这个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function* <span class="title">myGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  yield Promise.resolve(<span class="number">1</span>);</span><br><span class="line">  yield Promise.resolve(<span class="number">2</span>);</span><br><span class="line">  yield Promise.resolve(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = myGenerator()</span><br><span class="line">gen.next().value.then(val =&gt; &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(val)</span><br><span class="line">  gen.next().value.then(val =&gt; &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(val)</span><br><span class="line">    gen.next().value.then(val =&gt; &#123;</span><br><span class="line">      console.<span class="built_in">log</span>(val)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出1 2 3</span></span><br><span class="line"></span><br><span class="line">这就是面试官姐姐的问题，这是我的思路，下文深究一下这个问题的根源。</span><br><span class="line">```cpp</span><br><span class="line">function  gen1() &#123; </span><br><span class="line">let count = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123; </span><br><span class="line">let msg = yield ++count; </span><br><span class="line">console.<span class="built_in">log</span>(msg); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let iter = gen1(); <span class="comment">//获得迭代器</span></span><br><span class="line">console.<span class="built_in">log</span>(iter.next().value); </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line">console.<span class="built_in">log</span>(iter.next(‘magic’).value); </span><br><span class="line"><span class="comment">// ‘magic’ </span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">let it = gen1(); <span class="comment">// 获得迭代器</span></span><br><span class="line"><span class="function">function <span class="title">request</span><span class="params">()</span> </span>&#123; </span><br><span class="line">ajax(&#123; </span><br><span class="line">url: ‘www.someurl.com’, </span><br><span class="line">onSuccess(res)&#123; </span><br><span class="line">it.next(res); <span class="comment">// 恢复Generator运行，同时向其中塞入异步返回的结果 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">gen2</span><span class="params">()</span> </span>&#123; </span><br><span class="line">let response = yield request(); </span><br><span class="line">console.<span class="built_in">log</span>(response.text); </span><br><span class="line">&#125;</span><br><span class="line">it.next(); <span class="comment">// 启动Generator</span></span><br><span class="line">```cpp</span><br><span class="line">let it = gen2(); </span><br><span class="line">let p = it.next().value; <span class="comment">// p是yield返回的Promise </span></span><br><span class="line">p.then(res =&gt; it.next(res), </span><br><span class="line">err =&gt; it.<span class="keyword">throw</span>(err) <span class="comment">// 发生错误时，将错误抛入生成器 </span></span><br><span class="line">);</span><br><span class="line">```cpp</span><br><span class="line"><span class="function">function <span class="title">request</span><span class="params">()</span> </span>&#123; <span class="comment">// 此处的request返回的是一个Promise </span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve, reject) =&gt; &#123; </span><br><span class="line">ajax(&#123; </span><br><span class="line">url: ‘www.someurl.com’, </span><br><span class="line">onSuccess(res) &#123; </span><br><span class="line">resolve(res); </span><br><span class="line">&#125;, </span><br><span class="line">onFail(err) &#123; </span><br><span class="line">reject(err); </span><br><span class="line">&#125; </span><br><span class="line">&#125;); </span><br><span class="line">&#125;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">function* <span class="title">gen2</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">let response = yield request(); </span><br><span class="line">console.<span class="built_in">log</span>(response.text); </span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123; </span><br><span class="line">console.<span class="built_in">log</span>(“出错了”, error.message); <span class="comment">// 可以捕获Promise抛进来的错误！ </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>思考：gen是个function，执行它时却不执行里面的代码，而是返回一个Iterator对象，代码执行到yield处可以暂停，暂停以后，可以恢复继续执行，另外，暂停/恢复执行时，还可以传出/传入数据！<br>其实Generator并没有改变JS运行的基本规则。<br>思考let response = yield request()这行代码，我来仔细分析下这段代码是如何运行的。如有错误，欢迎大家指教。<br>1、首先，最后一行it.next()使得Generator内部的代码从头开始执行，执行到yield语句时，暂停，此时可以把yield想象成return，Generator的栈帧需要被弹出，会先计算yield右边的表达式，即执行request函数调用，以获得用于返回给上一级栈帧的值。<br>2、但是现在request函数没有返回值，但它发送了一个异步ajax请求，并注册了一个onSuccess回调，表示在请求返回结果时，恢复Generator的栈帧并继续运行代码，并把结果作为参数塞给Generator，准确地说是塞到yield所在的地方。<br>3、这response变量就获得了ajax的返回值。 可以看出，这里yield的功能设计得非常巧妙，好像它可以“赋值”给response。<br>4、更妙的是，迭代器不但可以.next，还可以.throw，即把错误也抛入Generator，让后者来处理。也就是说，在Generator里使用try-catch语句捕获异步错误。</p>
<blockquote>
<p>是不是只有.then方法这样的形式才能完成自动执行的功能呢？ 我去查阅了一些资料发现，yield 后边除了接 Promise，还可以接thunk函数， thunk 函数，就是单参的只接受回调的函数，详细介绍可以看阮一峰 Thunk。<br>函数的含义和用法，无论是 Promise 还是 thunk 函数，其核心都是通过传入回调的方式来实现 Generator 的自动执行。<br>总结一下：Generator 实现的核心在于上下文的保存，函数并没有真的被挂起，每一次 yield，其实都执行了一遍传入的生成器函数。<br>只是在这个过程中间用了一个 context 对象储存上下文，使得每次执行生成器函数的时候，都可以从上一个执行结果开始执行，看起来就像函数被挂起了一样。</p>
</blockquote>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">下面尝试封装一下自动迭代：</span><br><span class="line">这个run 方法里，可以把执行下一步的操作封装成 step()，每次 Promise.<span class="keyword">then</span>()的时候都去执行 step()，实现自动迭代的效果。在迭代的过程中，我们还把 resolve 的值传入gen.next()，使得 <span class="keyword">yield</span> 得以返回 Promise 的 resolve 的值。</span><br><span class="line">```<span class="javascript">cpp</span></span><br><span class="line"><span class="javascript"> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> g = gen()    <span class="comment">//由于每次gen()获取到的都是最新的迭代器,因此获取迭代器操作要放在step()之前,否则会进入死循环</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">val</span>) </span>&#123;              <span class="comment">//封装一个方法, 递归执行next()</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> res = g.next(val)           <span class="comment">//获取迭代器对象，并返回resolve的值</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>(res.done) <span class="keyword">return</span> res.value   <span class="comment">//递归终止条件</span></span></span><br><span class="line"><span class="javascript">    res.value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;         <span class="comment">//Promise的then方法是实现自动迭代的前提</span></span></span><br><span class="line"><span class="javascript">      step(val)                     <span class="comment">//等待Promise完成就自动执行下一个next，并传入resolve的值</span></span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">  step()  <span class="comment">//第一次执行</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br></pre></td></tr></table></figure>

<p>理解Generator的关键点在于理解函数执行时，内存里发生了什么。<br>一个JS程序的内存分为代码区、栈区、堆区和队列区，从MDN借图一张以说明（图中没有画出代码区）：<br><img src="https://img-blog.csdnimg.cn/20200414013448793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>1、队列（Queue）就是事件循环队列，分为了宏任务和微任务。<br>2、代码区保存着全部JS源代码被引擎编译成的机器码（以V8为例）。<br>3、栈（stack）保存着每个函数执行所需的上下文，一个栈元素被称为一个栈帧，一个栈帧对应一个函数。<br>4、对于引用类型的数据，在栈帧里只保存引用，而真正的数据存放在堆（Heap）里。<br>5、堆与栈不同的是，栈内存由JS引擎自动管理，入栈时分配空间，出栈时回收，非常清楚明了。<br>6、堆是程序员通过new操作符手动向操作系统申请的内存空间（当然，用字面量语法创建对象也算），何时该回收没那么明晰，所以需要一套垃圾收集（GC）算法来专门做这件事。<br>以上是预备知识，现在 回到Generator的正题：<br>1、普通函数在被调用时，JS引擎会创建一个栈帧，在里面准备好局部变量、函数参数、临时值、代码执行的位置（也就是说这个函数的第一行对应到代码区里的第几行机器码），在当前栈帧里设置好返回位置，然后将新帧压入栈顶。<br>2、待函数执行结束后，这个栈帧将被弹出栈然后销毁，返回值会被传给上一个栈帧。<br>3、当执行到yield语句时，Generator的栈帧同样会被弹出栈外，但Generator在这里耍了个花招——它在堆里保存了栈帧的引用（或拷贝）！<br>4、这样当iter.next方法被调用时，JS引擎便不会重新创建一个栈帧，而是把堆里的栈帧直接入栈。因为栈帧里保存了函数执行所需的全部上下文以及当前执行的位置，所以当任务调度来临时，就好像程序从原本暂停的地方继续向前执行了。 因为每次yield和iter.next都对应一次出栈和入栈，所以可以直接利用已有的栈机制，实现值的传出和传入。<br>终于揭开了Generator背后的神秘！</p>
<p>上述写法完美结合了Promise和Generator的优点，写法套路非常固定，当Promise对象一多时，就需要写许多类似p.then(res =&gt; …., err =&gt; …)这样的重复语句，所以就把这种套路给提炼成了一个更加精简的语法，那就是传说中的async/await，六中梳理一下hhh。</p>
<h2 id="六、async，await是解决异步操作的终极方案"><a href="#六、async，await是解决异步操作的终极方案" class="headerlink" title="六、async，await是解决异步操作的终极方案"></a>六、async，await是解决异步操作的终极方案</h2><p>场景：在多个回调依赖的场景中，尽管 Promise 通过链式调用取代了回调嵌套，但过多的链式调用可读性仍然不佳，流程控制也不方便，ES7 提出的 async 函数，终于让 JS 对于异步操作有了终极解决方案，简洁优美地解决了以上两个问题。</p>
<blockquote>
<p>设想一个这样的场景，异步任务 a-&gt;b-&gt;c 之间存在依赖关系，如果我们通过 then链式调用来处理这些关系，可读性并不是很好，如果我们想控制其中某个过程，比如在某些条件下，b 不往下执行到 c，那么也不是很方便控制。比如读取完了文件再去写，等待一段时间后再去执行，类似于我们会中断流程，然后再接着原来的任务去做。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> a = await Promise.resolve(a);</span><br><span class="line">  <span class="keyword">const</span> b = await Promise.resolve(b);</span><br><span class="line">  <span class="keyword">const</span> c = await Promise.resolve(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">async funtion <span class="title">fetch</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">let response = await request(); <span class="comment">// request定义同上一端段示例代码 </span></span><br><span class="line">console.<span class="built_in">log</span>(response.text); </span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123; </span><br><span class="line">console.<span class="built_in">log</span>(“wqx”, error.message); </span><br><span class="line">&#125; ;</span><br><span class="line">fetch();</span><br></pre></td></tr></table></figure>
<p>下面做一下总结：<br>1、MDN上说，async/await 实际上是对 Generator（生成器）的封装，是一个语法糖。<br>2、ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，通过 next()方法可以切换到下一个状态，为改变执行流程提供了可能，从而为异步编程提供解决方案。<br>3、Generator 函数也可以通过给next()传参, 让 yield 具有返回值。<br>4、async/await自带执行器，不需要手动调用 next()就能自动执行下一步。<br>5、async函数返回值是 Promise 对象，而 Generator 返回的是生成器对象。<br>6、await能够返回 Promise 的 resolve/reject 的值。<br>7、在代码中也可以通过给gen.next()传值的方式，让 yield 能返回 resolve 的值。<br>8、async解决了生成器函数能自动往下执行，且 yield 能返回 resolve 的值这两个问题。<br>就靠拢同步风格的程度而言，感觉async/await已经到了炉火纯青的地步，以后在项目中要积极思考，合理应用到不同的场景！</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF%E5%92%8C%E6%80%BB%E7%BB%93/" rel="tag">个人成长和总结</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E8%AE%A4%E7%9C%9F%E5%89%96%E6%9E%90Promise/" rel="tag">认真剖析Promise</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-思考用户登录的加密解密" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2020/04/13/%E6%80%9D%E8%80%83%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E7%9A%84%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"
    >思考用户登录的加密解密</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2020/04/13/%E6%80%9D%E8%80%83%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E7%9A%84%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/" class="article-date">
  <time datetime="2020-04-12T16:00:00.000Z" itemprop="datePublished">2020-04-13</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%8C%96/">网络安全与工程化</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<p>最近做项目用到了Axios中的CancelToken，对加密解密等用户鉴权场景比较好奇，一番学习实践后，总结如下哈：</p>
<h2 id="1、数据库存储上的加密解密："><a href="#1、数据库存储上的加密解密：" class="headerlink" title="1、数据库存储上的加密解密："></a>1、数据库存储上的加密解密：</h2><blockquote>
<p><strong>1. 单向hash（MD5）</strong></p>
</blockquote>
<p>1、单向的hash加密，以MD5和SHA算法为代表，这类做法比明文直接存储看起来要安全，但是如果在DB被攻破的时候，以目前计算机的算力加之黑客的各种技术手段，其实跟明文是差别不大的。<br>2、本科学习时，了解到密码学里面破解密码最笨的一种方法是暴力破解，随着目前计算机硬件的发展，带来计算能力的提升，每秒钟上亿次的hash计算已经不是问题，直接暴力破解几乎是分秒的事情。<br>3、另外与之相近的有一种字典表/彩虹表破解的手段，原理很简单，黑客们会把常见密码以及各种hash算法加密后的字符串整理到一个表中，因为只要是<strong>同一明文密码同一hash算法</strong>得出的值就是一样的，也就是说黑客不断完善整理的彩虹表可以用来任何MD5加密系统的破解，带着破解的DB用户MD5密码那一列信息，<strong>直接循环去select 明文 from 字典表/彩虹表 where 密文 = 密码</strong>，基本可以破解目前多数人设置的普通密码。</p>
<blockquote>
<p><strong>2. hash+盐</strong></p>
</blockquote>
<p> 1、早期为了改进单向hash的缺陷，为了让彩虹表失效，引入了盐，盐是随机生成的一个唯一字符串，连在明文密码后增强密码的随机性，然后再做hash得到的加密密文存储在DB中，这样一个是相同的密码存在db中的值就不同了，另一个是彩虹表也不会再起作用了。<br> 2、但是同样以目前计算机的算力，暴力破解也是分分钟的事情，因为为了校验密码的原因，我们一般会把这种方法生成的密码和盐一块存在DB中，明文+盐 hash= 密码。<br> 3、黑客在拿到盐和加密密码后，只需要用计算机不断去生成明文，然后计算就可以很快破解。这种方法是避免了彩虹表，但是暴力破解还是避免不了。<br>4、 这种情况类似于目前比特币挖矿，以目前矿机的算力挖矿，<strong>加之比特币不断增加hash碰撞难度</strong>，暴力破解确实越来越困难，比特币越来越稀有，但是随着量子高性能计算机的发展，未来可能比特币这种hash碰撞的难度也是分秒钟的事。</p>
<blockquote>
<p><strong>3. PBKDF2, BCrypt 或 SCrypt 算法</strong></p>
</blockquote>
<p>1、这类算法有一个特点，<strong>算法中都有个因子，用于指明计算密码摘要所需要的资源和时间，也就是计算强度</strong>。<br>2、计算强度越大，攻击者建立rainbow table越困难，以至于不可继续。这类算法也可以保证即使计算能力不断提高，只要调整算法中的强度因子，密码仍然不可能被轻易的攻破。 后台密码存储的安全，可使用BCrypt或SCrypt进行保证，将计算迭代次数调高，增加计算时间，从而防止彩虹表与字典攻击。</p>
<blockquote>
<p><strong>4、第三方密码存储服务商</strong></p>
</blockquote>
<p>1、如果一个系统对于密码存储的要求实在很高，比如说如果用户密码泄露会造成大量现金流失，损失是毁灭性不可逆的，那么可以考虑第三方密码存储服务商。<br>2、在欧美金融界以及电商界，许多早期的大型银行，信用卡，金融机构的线上密码存储，就使用了比较靠谱的第三方存储服务。<br>3、原因有两个：一方面是自身去开发维护一套复杂的密码存储系统成本可能比整个线上系统还要高，另一方面为了风险规避。</p>
<h2 id="2、实战总结："><a href="#2、实战总结：" class="headerlink" title="2、实战总结："></a>2、实战总结：</h2><p>1、密码最好是以不可还原明文的方式来保存。否则攻击数据库很容易造成巨大危害，尤其是在金融行业和电商行业。<br>2、通常利用哈希算法的单向性来保证明文以不可还原的有损方式进行存储。<br>3、这类方法的各个具体操作方式按安全性由低到高依次为：</p>
<p>A：使用自己独创的哈希算法对密码进行哈希，存储哈希过的值。</p>
<p>B：使用 MD5 或 SHA-1 哈希算法：MD5 和 SHA-1 已破解。虽不能还原明文，但很容易找到能生成相同哈希值的替代明文。而且这两个算法速度较快，暴力破解相对省时，建议不要使用它们。</p>
<p>C ：使用更安全的 SHA-256 等成熟算法，更加复杂的算法增加了暴力破解的难度。但如果遇到简单密码，用彩虹字典的暴力破解法，很快就能得到密码原文。</p>
<p>D：加入随机 salt 的哈希算法。</p>
<p>密码原文（或经过 hash 后的值）和随机生成的 salt 字符串混淆，然后再进行 hash，最后把 hash 值和 salt 值一起存储。<br>验证密码的时候只要用 salt 再与密码原文做一次相同步骤的运算，比较结果与存储的 hash 值就可以了。这样一来哪怕是简单的密码，在进过 salt 混淆后产生的也是很不常见的字符串，根本不会出现在彩虹字典中。salt 越长暴力破解的难度越大。</p>
<p>E：具体的 hash 过程也可以进行若干次叠代，虽然 hash 叠代会增加碰撞率，但也增加暴力破解的资源消耗。<br>就算真被破解了，黑客掌握的也只是这个随机 salt 混淆过的密码，用户原始密码依然安全，不用担心其它使用相同密码的应用。</p>
<p>上面这几种方法都不可能得到密码的明文，就算是系统管理员也没办法。对于那些真的忘了密码的用户，网站只能提供重置密码的功能了。</p>
<p>下面的 python 程序演示了如何使用 salt 加 hash 来单向转换密码明文</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`cpp</span></span><br><span class="line"><span class="string">import os</span></span><br><span class="line"><span class="string">from hashlib import sha256</span></span><br><span class="line"><span class="string">from hmac import HMAC</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def encrypt_password(password, salt=None):</span></span><br><span class="line"><span class="string">    """Hash password on the fly."""</span></span><br><span class="line"><span class="string">    if salt is None:</span></span><br><span class="line"><span class="string">        salt = os.urandom(8) # 64 bits.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    assert 8 == len(salt)</span></span><br><span class="line"><span class="string">    assert isinstance(salt, str)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if isinstance(password, unicode):</span></span><br><span class="line"><span class="string">        password = password.encode('UTF-8')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    assert isinstance(password, str)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    result = password</span></span><br><span class="line"><span class="string">    for i in xrange(10):</span></span><br><span class="line"><span class="string">        result = HMAC(result, salt, sha256).digest()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return salt + result</span></span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">这里先随机生成 <span class="number">64</span> bits 的 salt，再选择 SHA-<span class="number">256</span> 算法使用 HMAC 对密码和 salt 进行 <span class="number">10</span> 次叠代混淆，最后将 salt 和 hash 结果一起返回。</span><br><span class="line"></span><br><span class="line">使用的方法很简单：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">hashed = encrypt<span class="constructor">_password('<span class="params">secret</span> <span class="params">password</span>')</span></span><br><span class="line">下面是验证函数，它直接使用 encrypt_password 来对密码进行相同的单向转换并比较</span><br><span class="line"></span><br><span class="line">def validate<span class="constructor">_password(<span class="params">hashed</span>, <span class="params">input_password</span>)</span>:</span><br><span class="line">    return hashed<span class="operator"> == </span>encrypt<span class="constructor">_password(<span class="params">input_password</span>, <span class="params">salt</span>=<span class="params">hashed</span>[:8])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> validate<span class="constructor">_password(<span class="params">hashed</span>, '<span class="params">secret</span> <span class="params">password</span>')</span></span><br><span class="line">虽然只有简短几行，但借助 python 标准库帮助，这已经是一个可用于生产环境的高安全密码加密验证算法了。</span><br></pre></td></tr></table></figure>

<h2 id="3、-密码传输问题"><a href="#3、-密码传输问题" class="headerlink" title="3、 密码传输问题"></a>3、 密码传输问题</h2><p>学习总结了密码的存储问题，接下来再记录一下密码的传输问题，好好消化，为以后工作打下坚实基础，感谢一面小姐姐，我会继续深入思考！</p>
<p>对于在线系统，密码的传输要经过下面几个步骤：</p>
<blockquote>
<p>用户在浏览器中输入原始密码：键盘 ——&gt; 操作系统 ——&gt; 浏览器内存<br>程序对原始密码进行转换：内存中的原始密码 ——&gt;内存中的转换后的密码<br> 转换后的密码在线上传输：内存中转换后的密码 ——&gt; 网络 ——&gt; 系统<br>这其中每一步都可能泄露原始密码，当然也有相应的保护措施。</p>
</blockquote>
<p>千里之行始于足下，接下来让我一步步剖析！:</p>
<blockquote>
<p><strong>用户输入密码</strong></p>
</blockquote>
<p>常用的攻击方法包括：</p>
<p>1、偷看输入的密码</p>
<p>在公共场合输入密码很容易被偷看，例如使用 ATM 机取款的时候。输入密码时密码明文用 星号代替就是为了防止偷窥。<br>但这样正常用户也不能直接用眼睛确认输入密码是否正确，通常在设置新密码时就要输入两遍来确保输入无误。<br>iPhone 在这点做了改进，每输入一个密码字符先显示半秒钟的明文再转成 * 显示，鉴于使用 iPhone 虚拟键盘输入时，按错键的概率还是比较高的，这个折中也是在可用性和安全性上做了妥协。<br>还有些系统为了最大限度的防偷窥，在输入密码时屏幕没有任何输出，比如 Unix/Linux 的命令行登录界面。这样就连输入的密码长度都看不出来。</p>
<p>2、用木马程序记录键盘输入</p>
<p>现在比较流行的 QQ 或网络游戏的盗号就常用这种方式进行。安装杀毒软件来防盗号自不必说，还可以用屏幕软键盘输入密码，这样木马就记录不到键盘事件，只能通过分析鼠标点击和当时屏幕图象来破解密码。如果再进一步，软键盘的字符布局每次都随计产生，那就更加重了分析破解的难度。</p>
<p>3、感染应用程序或使用钓鱼手法，直接得到内存中的密码值</p>
<p>不管如何防范输入的过程，一旦密码到程序里，就会以明文的形式呈现在内存中，只要恶意软件模仿安全程序（或模仿网站的外观）直接套取密码就轻而易举。<br>现在出现的假 ATM 机诈骗也是这种手法的衍生。<br>还有一种，不是替换或模仿程序，而是用病毒感染原程序将内存中的值读到。<br>要防范这种攻击，必须要对原程序的完整性和合法性进行验证，只有在验证通过后，才能进行正常的登录交互操作。<br>这个验证可以用数字签名来实现。比如 Windows 10中所有微软的可执行文件都带有微软的数字签名。<br>在网站上则是 HTTPS 的验证。当然，这个验证过程还牵扯到人的判断，在社会工程学上，软件要配合一些强制的措施，才能保证人不会麻痹大意中招。<br>比如浏览器在访问非信任机构签发的数字签名的 HTTPS 站点时，会警告并且阻止用户进行访问。Windows 10 现在所有的驱动程序也都必须要有微软的数字签名才能运行。</p>
<blockquote>
<p><strong>密码转换</strong></p>
<p>原始密码会经过一些转换，才能在线上传输。这跟密码的存储类似。<br>直接传输密码明文是最不安全的。而用简单的可逆变换，或者固定密钥加密也只是增加了破解难度。<br>最好是每次服务器随机产生一个密钥，送给客户端进行加密。</p>
</blockquote>
<p>1、如果使用 HTTPS，那所有通过 SSL 通道的信息都经过了随机密钥加密。<br>2、HTTPS 虽然安全，可它最大的问题是性能。连接初始时密钥的协商是通过非对称加密的体系进行的，这会造成连接较慢（密钥协商好后的数据加密是纯耗 CPU 的工作，在现在的硬件条件下，并不是瓶颈）。<br>金融在线系统一般都使用 HTTPS ，但大部分在线应用出于性能的考虑，会选择使用 HTTP 交换随机密码的方式。<br>3、随机密钥由服务器生成并发送给客户端。客户端用此密钥将密码加密，送给服务器。这里不要求加密方法是可逆的。一个较安全的做法是客户端使用 MD5 或 SHA-1 算法对密码进行不可逆转换，再用密钥加密送到 Server。现在已经有很多 Javascript 的加密库可以在浏览器端进行这样的转换工作。</p>
<blockquote>
<p><strong>密码在线传输</strong></p>
</blockquote>
<p>1、使用 HTTPS 加密传输，HTTPS 对服务器性能要求高，也影响登录速度。一般用在高安全性的登录上面。Google 和微软的登录都强制使用 HTTPS 确保安全第一。使用随机密钥对密码进行变换后再传输，相对安全。密码明文很安全，但仍可能发生重放攻击。这种方式是性能和安全性的折中。一般的服务使用足亦。<br>2、不做任何修饰，直接将密码通过 HTTP 传输。这种方式实现起来非常简单，但却可能是对用户隐私和数据的不负责任。<br><strong>常用服务分析</strong><br>这里用抓包方式分析一下常用的网络服务的密码传输，看看它们在安全性方面做的如何：</p>
<p>网站    密码传输方式    安全性<br>bitbucket.org    HTTPS 加密传输    高<br>微软 live.com    HTTPS 加密传输    高<br>google.com    HTTPS 加密传输    高<br>csdn.net    HTTP Javascript 加密传输    中<br>javaeye.com    HTTP 明文传输    低</p>
<p>思考：登录网站时，输入登录名、密码，用抓包工具抓一下包就知道密码是否进行加密。<br>网站用的是https，为什么抓包用户名密码还是明文传输？<br>为什么站点使用了https加密之后，还是能够用firebug之类的软件查看到提交到的信息，密码显示的还是明文的?<br>学习之后找到答案：<br>这是因为:<br>1、https(ssl)加密是发生在应用层与传输层之间，所以在传输层看到的数据才是经过加密的，而我们捕捉到的http post，是应用层的数据，此时还没有经过加密。这些明文信息，其实就是你的本地数据。<br>2、加密数据只有客户端和服务器端才能得到明文，客户端到服务端的通信过程是安全的。<br>深挖：这样的话密码不是会被本地恶意软件截获么?<br>解决：银行电商等安全防护程度较高的网站，除了https加密外，还有安全控件加密，用户必须下载安全控件后才能输入密码。</p>
<blockquote>
<p><strong>加盐哈希</strong></p>
</blockquote>
<p> 这个方案也是大多数公司目前使用的方案，一般流程是将用户随机盐发送给客户端，客户端再使用SHA256(SALT+PASSWORD)计算之后将结果传送给服务器，服务器直接与数据库中的匹配。<br> <strong>至于哈希算法的话，普遍都采用MD5、SHA1、SHA256等算法。</strong><br> 加盐的方式也各不相同，<strong>比如在密码尾部、在密码中间、在密码头部增加随机盐，有的甚至会使用多次HASH。</strong><br>不仅如此，甚至可以每次用户设置密码的时候，都为每一个用户生成随机盐，并将随机盐与用户信息一并存储（有时为了混淆，最好将随机盐与密码分表存储，也不要起SALT之类的列名）如此相信即使攻破的数据库，想要破解用户密码也是相当困难的。<br>后续如果收到用户登陆请求，取出用户随机盐并通过相同的算法进行计算，将结果和数据库中密码相对比就可以判断用户密码是否输入正确。 <strong>由于摘要算法的不可逆性，其实一定程度上就限制了登陆过程中用户密码的传输方式。</strong></p>
<p><strong>解决方案：</strong></p>
<blockquote>
<p>使用复杂些的HASH算法，例如MD5(SALT + MD5(C-SALT +PASSWORD))，C-SALT可理解为服务器固定的盐，此处仅仅是为了使破解者的字典更难构造一些。<br>如此客户端只需要将MD5(C-SALT+PASSWORD)的值发送到服务器，服务器再将随机盐取出，进行MD5即可。<br>更高级别的安全需要建议可使用SHA256来替代。 </p>
</blockquote>
<p>方法一<br>1、服务器端存储密码为Hash(Random-Salt + Hash(Constant-SALT + Pasword))<br>2、客户端传输密码为Hash(Constant-SALT + Password)<br>3、Random-Salt为用户的随机盐，每个用户均不同，服务器端收到客户端的hash密码后，在将其与用户随机盐一起Hash运算，从而将结果与数据库存储值相比较。<br><strong>优点</strong>：数据库存储的密码经过两层哈希，且其中包含了固定盐和用户随机盐，安全性较高。<br><strong>缺点</strong>：客户端传输的密码虽然经过了一层哈希，但是使用固定盐值，因此相同密码生成的结果均一致，容易收到重放攻击。<br>方法二<br>1、服务器端存储密码为Hash(Constant-SALT + Pasword)<br>2、客户端传输密码为Hash(Random-Salt + Hash(Constant-SALT + Password))<br><strong>Random-Salt为每次进入登陆页面时生成的随机盐，此处主要是为了防止重放攻击。<br>服务器收到客户端上传的hash之后的密码，根据用户ID取出服务器存储的密码，并通过与之前返回客户端的Random-Salt（可存储于Session中）进行Hash运算，从而与客户端上传的密码进行比较。</strong><br><strong>优点</strong>：客户端有效的防止了重放攻击<br><strong>缺点</strong>：在前端代码中，固定盐值暴露，一旦后台数据库被攻破，用户密码信息将有危险。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/" rel="tag">前端安全</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E9%89%B4%E6%9D%83/" rel="tag">用户登录鉴权</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-阿里面试总结（一）——深入浅析浏览器动画" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2020/04/13/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E6%B5%85%E6%9E%90%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A8%E7%94%BB/"
    >阿里面试总结（一）——深入浅析浏览器动画</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2020/04/13/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E6%B5%85%E6%9E%90%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A8%E7%94%BB/" class="article-date">
  <time datetime="2020-04-12T16:00:00.000Z" itemprop="datePublished">2020-04-13</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">阿里面试总结</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>一面思考+延申</p>
<h2 id="需求思考：让动画流畅无阻，提升用户体验"><a href="#需求思考：让动画流畅无阻，提升用户体验" class="headerlink" title="需求思考：让动画流畅无阻，提升用户体验"></a>需求思考：让动画流畅无阻，提升用户体验</h2><p>在Web应用中，实现动画效果的方法比较多。<br>Javascript 中可以通过定时器 setTimeout 来实现，css3 可以使用 transition 和 animation 来实现，html5 中的 canvas 也可以实现。<br>除此之外，html5 还提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是请求动画帧。 </p>
<p><strong>如果有一个需求，要设置动画不停播放移动，怎么做最好呢？</strong><br>我们经常面临一个抉择：到底使用哪种动画方式？怎么符合业务场景？下面做一下对比。</p>
<h2 id="1、JS动画与CSS3动画的区别和使用场景"><a href="#1、JS动画与CSS3动画的区别和使用场景" class="headerlink" title="1、JS动画与CSS3动画的区别和使用场景"></a>1、JS动画与CSS3动画的区别和使用场景</h2><p><strong>JS动画</strong><br>缺点：<br>(1)JavaScript在浏览器的主线程中运行，而主线程中还有其它需要运行的JavaScript脚本、样式计算、布局、绘制任务等,对其干扰导致线程可能出现阻塞，从而造成丢帧的情况。<br>(2)代码的复杂度高于CSS动画。</p>
<p>优点：<br>(1)JavaScript动画控制能力很强, 可以在动画播放过程中对动画进行控制：开始、暂停、回放、终止、取消都是可以做到的。<br>(2)动画效果比css3动画丰富,有些动画效果，比如曲线运动,冲击闪烁,视差滚动效果，只有JavaScript动画才能完成<br>(3)CSS3有兼容性问题，而JS大多时候没有兼容性问题。</p>
<p><strong>CSS动画</strong><br>缺点：<br> (1)运行过程控制较弱,无法附加事件绑定回调函数。<br> (2)CSS动画只能暂停,不能在动画中寻找一个特定的时间点，不能在半路反转动画，不能变换时间尺度，不能在特定的位置添加回调函数或是绑定回放事件,无进度报告。<br> (3)CSS比较简单，性能调优方向固定，对于帧速表现不好的低版本浏览器，CSS3可以做到自然降级，而JS则需要撰写额外代码。<br>优点：<br>(1)浏览器可以对动画进行优化。<br>(2)浏览器使用与 requestAnimationFrame 类似的机制。<br>(3)css3后来添加了transform动画函数。</p>
<p><strong>CSS动画流畅的原因</strong><br><strong>渲染线程分为main thread(主线程)和compositor thread(合成器线程)。</strong><br>如果CSS动画只是改变transform和opacity，这时整个CSS动画得以在compositor thread完成<br>（而JS动画则会在main thread执行，然后触发compositor进行下一步操作）<br>在JS执行一些昂贵的任务时，main thread繁忙，CSS动画由于使用了compositor thread可以保持流畅，在主线程中，维护了一棵Layer树（LayerTreeHost），管理了TiledLayer，在compositor thread，维护了同样一颗LayerTreeHostImpl，管理了LayerImpl，这两棵树的内容是拷贝关系。因此可以彼此不干扰，当Javascript在main thread操作LayerTreeHost的同时，compositor thread可以用LayerTreeHostImpl做渲染。当Javascript繁忙导致主线程卡住时，合成到屏幕的过程也是流畅的。<br>为了实现防假死，鼠标键盘消息会被首先分发到compositor thread，然后再到main thread。这样，当main thread繁忙时，compositor thread还是能够响应一部分消息。<br>例如，鼠标滚动时，加入main thread繁忙，compositor thread也会处理滚动消息，滚动已经被提交的页面部分（未被提交的部分将被刷白）。</p>
<p><strong>CSS动画比JS流畅的前提：</strong><br>1、JS在执行一些昂贵的任务。<br>2、同时CSS动画不触发layout或paint。<br>3、在CSS动画或JS动画触发了paint或layout时，需要main thread进行Layer树的重计算，这时CSS动画或JS动画都会阻塞后续操作。<br>4、只有如下属性的修改才符合“仅触发Composite，不触发layout或paint：<br>backface-visibility<br>opacity<br>perspective<br>perspective-origin<br>transfrom<br>所以只有用上了3D加速或修改opacity时，css3动画的优势才会体现出来。</p>
<p><strong>总结：</strong><br> 1、如果动画只是简单的状态切换，不需要中间过程控制，在这种情况下，css动画是优选方案。它可以让你将动画逻辑放在样式文件里面，而不会让你的页面充斥 Javascript 库。<br> 2、如果要设计很复杂的富客户端界面或者在开发一个有着复杂UI状态的 APP，应该使用js动画，这样动画可以保持高效，并且工作流也更可控。<br> 3、综上，在实现一些小的交互动效的时候，就多考虑考虑CSS动画。对于一些复杂控制的动画，使用javascript比较可靠。</p>
<h2 id="2、RequestAnimationFrame有哪些好处和优化？"><a href="#2、RequestAnimationFrame有哪些好处和优化？" class="headerlink" title="2、RequestAnimationFrame有哪些好处和优化？"></a>2、RequestAnimationFrame有哪些好处和优化？</h2><p>为了深入理解 requestAnimationFrame 背后的原理，我们首先需要了解一下与之相关的几个概念：<br>1、屏幕刷新频率<br>即图像在屏幕上更新的速度，也即屏幕上的图像每秒钟出现的次数，它的单位是赫兹(Hz)。 对于一般笔记本电脑，这个频率大概是60Hz， 可以在桌面上右键-&gt;屏幕分辨率-&gt;高级设置-&gt;监视器 中查看和设置。这个值的设定受屏幕分辨率、屏幕尺寸和显卡的影响，原则上设置成让眼睛看着舒适的值都行。</p>
<p>市面上常见的显示器有两种，即CRT和LCD， CRT就是传统显示器，LCD就是我们常说的液晶显示器。</p>
<p>CRT是一种使用阴极射线管的显示器，屏幕上的图形图像是由一个个因电子束击打而发光的荧光点组成，由于显像管内荧光粉受到电子束击打后发光的时间很短，所以电子束必须不断击打荧光粉使其持续发光。电子束每秒击打荧光粉的次数就是屏幕刷新频率。</p>
<p>而对于LCD来说，则不存在刷新频率的问题，它根本就不需要刷新。因为LCD中每个像素都在持续不断地发光，直到不发光的电压改变并被送到控制器中，所以LCD不会有电子束击打荧光粉而引起的闪烁现象。</p>
<p>因此，当你对着电脑屏幕什么也不做的情况下，显示器也会以每秒60次的频率正在不断的更新屏幕上的图像。为什么你感觉不到这个变化？ 那是因为人的眼睛有视觉停留效应，即前一副画面留在大脑的印象还没消失，紧接着后一副画面就跟上来了，这中间只间隔了16.7ms(1000/60≈16.7)， 所以会让你误以为屏幕上的图像是静止不动的。而屏幕给你的这种感觉是对的，试想一下，如果刷新频率变成1次/秒，屏幕上的图像就会出现严重的闪烁，这样就很容易引起眼睛疲劳、酸痛和头晕目眩等症状。</p>
<p>2、动画原理<br>根据上面的原理我们知道，你眼前所看到图像正在以每秒60次的频率刷新，由于刷新频率很高，因此你感觉不到它在刷新。而动画本质就是要让人眼看到图像被刷新而引起变化的视觉效果，这个变化要以连贯的、平滑的方式进行过渡。 那怎么样才能做到这种效果呢？</p>
<p>刷新频率为60Hz的屏幕每16.7ms刷新一次，我们在屏幕每次刷新前，将图像的位置向左移动一个像素，即1px。这样一来，屏幕每次刷出来的图像位置都比前一个要差1px，因此你会看到图像在移动；由于我们人眼的视觉停留效应，当前位置的图像停留在大脑的印象还没消失，紧接着图像又被移到了下一个位置，因此你才会看到图像在流畅的移动，这就是视觉效果上形成的动画。</p>
<p>3、setTimeout<br>理解了上面的概念以后，我们不难发现，setTimeout 其实就是通过设置一个间隔时间来不断的改变图像的位置，从而达到动画效果的。但我们会发现，利用setTimeout实现的动画在某些低端机上会出现卡顿、抖动的现象。<br>这里是MDN的阐述：<br><img src="https://img-blog.csdnimg.cn/20200413185804863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/20200413190019842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 这种现象的产生有两个原因：</p>
<p>setTimeout的执行时间并不是确定的。在Javascript中，</p>
<blockquote>
<p>1、 <strong>setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，因此<br>setTimeout 的实际执行时间一般要比其设定的时间晚一些。</strong><br>2、<strong>刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的屏幕刷新频率可能会不同，而setTimeout只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。</strong></p>
</blockquote>
<p>以上两种情况都会导致setTimeout的执行步调和屏幕的刷新步调不一致，从而引起丢帧现象。 那为什么步调不一致就会引起丢帧呢？</p>
<p>首先要明白，setTimeout的执行只是在内存中对图像属性进行改变，这个变化必须要等到屏幕下次刷新时才会被更新到屏幕上。如果两者的步调不一致，就可能会导致中间某一帧的操作被跨越过去，而直接更新下一帧的图像。假设屏幕每隔16.7ms刷新一次，而setTimeout每隔10ms设置图像向左移动1px， 就会出现如下绘制过程：</p>
<p>第0ms: 屏幕未刷新，等待中，setTimeout也未执行，等待中；</p>
<p>第10ms: 屏幕未刷新，等待中，setTimeout开始执行并设置图像属性left=1px；</p>
<p>第16.7ms: 屏幕开始刷新，屏幕上的图像向左移动了1px， setTimeout 未执行，继续等待中；</p>
<p>第20ms: 屏幕未刷新，等待中，setTimeout开始执行并设置left=2px;</p>
<p>第30ms: 屏幕未刷新，等待中，setTimeout开始执行并设置left=3px;</p>
<p>第33.4ms:屏幕开始刷新，屏幕上的图像向左移动了3px， setTimeout未执行，继续等待中；</p>
<p>…<br>从上面的绘制过程中可以看出，屏幕没有更新left=2px的那一帧画面，图像直接从1px的位置跳到了3px的的位置，这就是丢帧现象，这种现象就会引起动画卡顿。</p>
<p>4、requestAnimationFrame</p>
<blockquote>
<p>与setTimeout相比，<strong>requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机</strong>。<br>具体一点讲<strong>，如果屏幕刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms</strong>，换句话说就是，requestAnimationFrame的步伐跟着系统的刷新步伐走。<br><strong>它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。</strong></p>
</blockquote>
<p><strong>总结一下，requestAnimationFrame有以下优势：</strong></p>
<p>1、CPU节能：使用setTimeout实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，<strong>完全是浪费CPU资源。而requestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统步伐走的requestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。</strong></p>
<p>2、函数节流：在高频率事件(resize,scroll等)中，为了防止在一个刷新间隔内发生多次函数执行，使用<strong>requestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。一个刷新间隔内函数执行多次时没有意义的，因为显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。</strong></p>
<p>3、兼容性：requestAnimationFrame 是专门为实现高性能的帧动画而设计的一个API，目前已在多个浏览器得到了支持，包括IE10+，Firefox，Chrome，Safari，Opera等，在移动设备上，ios6以上版本以及IE mobile 10以上也支持requestAnimationFrame，唯一比较遗憾的是目前安卓上的原生浏览器并不支持requestAnimationFrame，不过对requestAnimationFrame的支持应该是大势所趋了，安卓版本的chrome 16+也是支持requestAnimationFrame的。</p>
<p>4、<strong>requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。</strong></p>
<p>5、<strong>在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，会暂停渲染，保证我们设计的动画函数的每一次调用都对应着一次屏幕重绘，这当然就意味着更少的的cpu，gpu和内存使用量。</strong></p>
<p>像setTimeout、setInterval一样，requestAnimationFrame是一个全局函数<strong>。调用requestAnimationFrame后，它会要求浏览器根据自己的频率进行一次重绘，它接收一个回调函数作为参数，在即将开始的浏览器重绘时，会调用这个函数，并会给这个函数传入调用回调函数时的时间作为参数。</strong>由于requestAnimationFrame的功效只是一次性的，所以若想达到动画效果，则必须连续不断的调用requestAnimationFrame，就像我们使用setTimeout来实现动画所做的那样。<strong>requestAnimationFrame函数会返回一个资源标识符，可以把它作为参数传入cancelAnimationFrame函数来取消requestAnimationFrame的回调。</strong>怎么样，是不是也跟setTimeout的clearTimeout很相似啊。</p>
<p>所以，可以这么说，requestAnimationFrame就是一个性能优化版、专为动画量身打造的setTimeout，不同的是requestAnimationFrame不是自己指定回调函数运行的时间，而是跟着浏览器内建的刷新频率来执行回调，这当然就能达到浏览器所能实现动画的最佳效果了。</p>
<p>目前，各个支持requestAnimationFrame的浏览器有些还是自己的私有实现，所以必须加前缀，对于不支持requestAnimationFrame的浏览器，我们只能使用setTimeout，因为两者的使用方式几近相同，所以这两者的兼容并不难。对于支持requestAnimationFrame的浏览器，我们使用requestAnimationFrame，而不支持的我们优雅降级使用传统的setTimeout。<strong>下面我把它们封装一下，就能得到一个统一兼容各大浏览器的API了hhh</strong></p>
<h2 id="3、RequestAnimationFrame使用语法："><a href="#3、RequestAnimationFrame使用语法：" class="headerlink" title="3、RequestAnimationFrame使用语法："></a>3、RequestAnimationFrame使用语法：</h2><p>以下来自MDN：<br>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。<br>注意：若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调window.requestAnimationFrame()<br>当你准备更新动画时你应该调用此方法。这将使浏览器在下一次重绘之前调用你传入给该方法的动画函数(即你的回调函数)。回调函数执行次数通常是每秒60次，但在大多数遵循W3C建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。回调函数会被传入DOMHighResTimeStamp参数，DOMHighResTimeStamp指示当前被 requestAnimationFrame() 排序的回调函数被触发的时间。在同一个帧中的多个回调函数，它们每一个都会接受到一个相同的时间戳，即使在计算上一个回调函数的工作负载期间已经消耗了一些时间。该时间戳是一个十进制数，单位毫秒，最小精度为1ms(1000μs)。</p>
<blockquote>
<p>使用语法是window.requestAnimationFrame(callback);<br>callback参数表示下一次重绘之前更新动画帧所调用的函数(即上面所说的回调函数)。该回调函数会被传入DOMHighResTimeStamp参数，该参数与performance.now()的返回值相同。<br>它表示requestAnimationFrame() 开始去执行回调函数的时刻。<br> callback的返回值是一个 long整数，表示一个请求 ID ，是回调列表中唯一的标识（是个非零值），我们可以传这个值给window.cancelAnimationFrame()以取消回调函数。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">范例</span><br><span class="line"><span class="keyword">var</span> start = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'SomeElementYouWantToAnimate'</span>);</span><br><span class="line">element.style.position = <span class="string">'absolute'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!start) start = timestamp;</span><br><span class="line">  <span class="keyword">var</span> progress = timestamp - start;</span><br><span class="line">  element.style.left = <span class="built_in">Math</span>.min(progress / <span class="number">10</span>, <span class="number">200</span>) + <span class="string">'px'</span>;</span><br><span class="line">  <span class="keyword">if</span> (progress &lt; <span class="number">2000</span>) &#123;</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(step);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.requestAnimationFrame(step);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">这个API的调用很简单，如下所示：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">var progress = 0;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//回调函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function render() &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    progress += 1; //修改图像的位置</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (progress &lt; 100) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           //在动画没有结束前，递归渲染</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           window.requestAnimationFrame(render);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">//第一帧渲染</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">window.requestAnimationFrame(render);</span></span><br></pre></td></tr></table></figure>
<p>下面是一个小Demo:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        #box&#123;</span></span><br><span class="line"><span class="regexp">            background-color: rebeccapurple;</span></span><br><span class="line"><span class="regexp">            width: 100px;</span></span><br><span class="line"><span class="regexp">            height: 100px;    </span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>style&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div id="box"&gt;&lt;/</span>div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> duration = <span class="number">4000.0</span>;</span><br><span class="line">        <span class="keyword">var</span> startTime = <span class="number">-1.0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">currentTime</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> h1 = <span class="built_in">document</span>.getElementById(<span class="string">"box"</span>);</span><br><span class="line">            <span class="keyword">var</span> opacity = currentTime/duration;</span><br><span class="line">            h1.style.opacity = opacity;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">eachFrame</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> timeElapse = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()-startTime;</span><br><span class="line">            <span class="keyword">if</span>(startTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                startTime = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">                render(<span class="number">0.0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(timeElapse &lt; duration) &#123;</span><br><span class="line">                render(timeElapse);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="built_in">window</span>.requestAnimationFrame(eachFrame);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame(eachFrame);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="4、实战动画和处理兼容性的封装"><a href="#4、实战动画和处理兼容性的封装" class="headerlink" title="4、实战动画和处理兼容性的封装"></a>4、实战动画和处理兼容性的封装</h2><p>下面是对动画函数的封装，可以处理浏览器的兼容问题哈：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> lastTime = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">var</span> vendors = [<span class="string">'webkit'</span>, <span class="string">'moz'</span>, <span class="string">'ms'</span>, <span class="string">'o'</span>];</span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">var</span> x=<span class="number">0</span> ; x&lt;vendors.length ; ++x)&#123;</span><br><span class="line">		<span class="keyword">if</span> ( <span class="built_in">window</span>.requestAnimationFrame &amp;&amp; <span class="built_in">window</span>.cancelAnimationFrame ) &#123;</span><br><span class="line">   			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">window</span>.requestAnimationFrame = <span class="built_in">window</span>[vendors[x]+<span class="string">'RequestAnimationFrame'</span>];</span><br><span class="line">		<span class="built_in">window</span>.cancelAnimationFrame = <span class="built_in">window</span>[vendors[x]+<span class="string">'CancelAnimationFrame'</span>] || <span class="built_in">window</span>[vendors[x]+<span class="string">'CancelRequestAnimationFrame'</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">window</span>.requestAnimationFrame)&#123; </span><br><span class="line">		<span class="built_in">window</span>.requestAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">callback, element</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">var</span> currTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">			<span class="keyword">var</span> timeToCall = <span class="built_in">Math</span>.max(<span class="number">0</span>, <span class="number">16</span> - (currTime - lastTime));</span><br><span class="line">			<span class="keyword">var</span> id = <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">				callback(currTime + timeToCall);</span><br><span class="line">			&#125;, timeToCall);</span><br><span class="line">			lastTime = currTime + timeToCall;</span><br><span class="line">			<span class="keyword">return</span> id;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">window</span>.cancelAnimationFrame)&#123;</span><br><span class="line">		<span class="built_in">window</span>.cancelAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line"> 			clearTimeout(id); </span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>下面举个简单的例子来说明怎么运用requestAnimationFrame进行动画，下面的代码会将id为demo的div以动画的形式向右移动到300px，上手实践一下，为日后更复杂的动画打基础！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;div id=<span class="string">"demo"</span> style=<span class="string">"position:absolute; width:100px; height:100px; background:#ccc; left:0; top:0;"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">	var demo = document.getElementById('demo');</span></span><br><span class="line"><span class="regexp">	function rander()&#123;</span></span><br><span class="line"><span class="regexp">		demo.style.left = parseInt(demo.style.left) + 1 + 'px'; /</span><span class="regexp">/每一帧向右移动1px</span></span><br><span class="line"><span class="regexp">	&#125;</span></span><br><span class="line"><span class="regexp">	requestAnimationFrame(function()&#123;</span></span><br><span class="line"><span class="regexp">		rander();</span></span><br><span class="line"><span class="regexp">		/</span><span class="regexp">/当超过300px后才停止</span></span><br><span class="line"><span class="regexp">		if(parseInt(demo.style.left)&lt;=300)&#123;			</span></span><br><span class="line"><span class="regexp">			requestAnimationFrame(arguments.callee);</span></span><br><span class="line"><span class="regexp">		&#125;</span></span><br><span class="line"><span class="regexp">	&#125;);</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>




      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/" rel="tag">个人成长</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E5%8A%A8%E7%94%BB-%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/" rel="tag">动画+秒杀系统</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-短视频流量大战的四大法宝——精准产品定位、打磨垂直内容、完善监管激励、优化创新服务" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2020/04/03/%E7%9F%AD%E8%A7%86%E9%A2%91%E6%B5%81%E9%87%8F%E5%A4%A7%E6%88%98%E7%9A%84%E5%9B%9B%E5%A4%A7%E6%B3%95%E5%AE%9D%E2%80%94%E2%80%94%E7%B2%BE%E5%87%86%E4%BA%A7%E5%93%81%E5%AE%9A%E4%BD%8D%E3%80%81%E6%89%93%E7%A3%A8%E5%9E%82%E7%9B%B4%E5%86%85%E5%AE%B9%E3%80%81%E5%AE%8C%E5%96%84%E7%9B%91%E7%AE%A1%E6%BF%80%E5%8A%B1%E3%80%81%E4%BC%98%E5%8C%96%E5%88%9B%E6%96%B0%E6%9C%8D%E5%8A%A1/"
    >短视频流量大战的四大法宝——精准产品定位、打磨垂直内容、完善监管激励、优化创新服务</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2020/04/03/%E7%9F%AD%E8%A7%86%E9%A2%91%E6%B5%81%E9%87%8F%E5%A4%A7%E6%88%98%E7%9A%84%E5%9B%9B%E5%A4%A7%E6%B3%95%E5%AE%9D%E2%80%94%E2%80%94%E7%B2%BE%E5%87%86%E4%BA%A7%E5%93%81%E5%AE%9A%E4%BD%8D%E3%80%81%E6%89%93%E7%A3%A8%E5%9E%82%E7%9B%B4%E5%86%85%E5%AE%B9%E3%80%81%E5%AE%8C%E5%96%84%E7%9B%91%E7%AE%A1%E6%BF%80%E5%8A%B1%E3%80%81%E4%BC%98%E5%8C%96%E5%88%9B%E6%96%B0%E6%9C%8D%E5%8A%A1/" class="article-date">
  <time datetime="2020-04-02T16:00:00.000Z" itemprop="datePublished">2020-04-03</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<blockquote>
<p>行业竞争激烈、人口红利见顶，在这场短视频流量大战中，如何打出漂亮一战？</p>
</blockquote>
<h2 id="行业背景调查"><a href="#行业背景调查" class="headerlink" title="行业背景调查"></a>行业背景调查</h2><p>1、TikTok（抖音海外版）在海外取得极大成功，对于其它视频应用产生了强烈冲击。此举招致了不少制裁，但也从一个侧面反映出TikTok在海外的影响力。据外媒报道，为了应对TikTok强势崛起，谷歌旗下视频网站YouTube将作出应对，并计划在今年年末推出名为Shorts的短视频功能，参与到TikTok的直接竞争中来。不过，与TikTok独立的APP模式相比，Shorts将成为YouTube主应用中的一部分，这或许会使Shorts的竞争力受到影响。</p>
<p>2、疫情当前，各大电影院都纷纷关门。流媒体似乎迎来了百年难得一遇的暖春，尤其是Netflix，凭借最为丰富的剧集资源库，在流媒体中称王，甚至将自己多部作品提前上线，吸取流量。下个月，又有一家全新平台入局流媒体——Quibi。Quibi ，Quickbites 的缩写，译为“速食”，这是一家还未上线便已获得十亿美元融资的短视频平台。 仅服务于手机端用户，内容专注于时下最热的短视频。Quibi的野心是成为「短视频界的Netflix」。在内容播放上，Quibi的每部剧集的总时长控制在2小时左右。</p>
<p>每集大约7-10分钟，每部约10-16集。至于更新频率——采用日更，每部剧每日更新一集。每隔一周就会有26个原创项目上线。这意味着每个礼拜都会有100来集短视频播出。当然，Quibi创办人杰弗里·卡森伯格也说了，“这不是短视频，而是一个个短视频章节组成的长视频。”他们想做的是“Quick bites. Big stories”，用一个零食时间，讲述大故事。</p>
<p>3、中新经纬客户端 4 月 2 日发布新闻，” 爱奇艺随刻版 “App 正式上线。爱奇艺对外宣称，” 爱奇艺随刻版 “App 是爱奇艺全新推出的海量精彩、多元化的综合视频社区产品，并要打造中国版的YouTube。随着 5G 和 AI 商用的发展，爱奇艺加入短视频赛道或许将给视频行业带来新的格局变化。爱奇艺创始人、CEO 龚宇认为，” 迄今为止，由于多种复杂因素的综合影响，YouTube 模式尚未在中国发展成规模，随着 5G 和 AI 技术的部署不断加强，类似 App 的市场潜力将在未来 2-3 年显著增长。为了抓住机遇，爱奇艺已开始做出初步的努力并投资建立规模化的业务模式。”</p>
<p>4、最近一段时间，正在内测的微信视频号引起了全行业的关注，诸多内容创作者纷纷开始研究微信视频号。一时间，微信视频号究竟会不会成为下一个风口，微信视频号能不能顺利突围，也成为大家热议的话题。视频号定位于“人人皆可创作的平台”，与朋友圈并驾齐驱，可见地位的重要性。它是微信的破圈——长短互补，强弱交织，蝴蝶效应，生态闭环——避免微信不被新生的短视频文化需求边缘化。猜想未来，视频号可能是所有市场中，唯一可以实现去中心化的、并且借助微信熟人社交链来打造电商基因 、金融科技、 闭环支付的短内容平台。毕竟，微信得天独厚的强大关系链牵动着十亿中国人的社交网络，这是其他APP望尘莫及的独特优势。</p>
<p>龙头齐聚，纷纷引发头脑风暴，打出自家品牌，如何才能脱颖而出呢？</p>
<p>笔者认为，以史为镜，可以知兴替，想要勇敢破圈、打出漂亮一战，</p>
<p>从产品定位的宏观策略上需要做好以下几点。</p>
<h2 id="精准产品定位"><a href="#精准产品定位" class="headerlink" title="精准产品定位"></a>精准产品定位</h2><p><strong>1、一切从用户出发，从用户中来，到用户中去。</strong></p>
<p>“水能载舟、异能覆舟”。水是用户，古往今来，得民心者得天下！比如汉武帝的成功、共产党的胜利、流芳百世的产品一定是为了满足用户的根本需求，在服务和体验上全身心为用户着想的产品。</p>
<p>抖音让你欲罢不能，为什么呢？全屏沉浸、精准分发、高清流畅、时髦新颖。（短视频）</p>
<p>微信不可替代，为什么呢？简单快捷、轻便舒适、不推销广告、自主订阅、功能齐全。（社交）</p>
<p>支付宝每天必开，为什么呢？花呗消费、余额盈利、风险投资、线下服务，一应俱全。（支付)</p>
<p>所有的成功，都来自合适的场景下，合适的满足了用户的迫切需求，并做到了这个领域的最佳应用体验。所以，流量不是目标，只是用户信任的附属品，赢得用户最根本、持续性的信任，才是高明之策！</p>
<p>互联网时代，从不缺人口和流量。我们缺啥？注意力和信任。注意力是招揽用户的法宝，信任是扩大生态的根本。</p>
<p><strong>2、深挖人性需求、细分使用场景。</strong></p>
<p>很多人说，微视没有打赢抖音，我们仔细去体验一下，真的是内容不好，设计不潮吗？</p>
<p>我想说，其实不是的，微视有自己的特色，主张探索和发现，提供自拍模板，其实也是腾讯的良心之作了。它是家庭影院，需要我们搬好小凳，拿好遥控器、和家人朋友互动，发掘自己的创造力，主打“创造、互动”。</p>
<p>抖音，凭借新潮的音乐和酷炫的节拍、场景，全身心为用户打造极致观看体验，不用用户思考，解放双手，它是3D影院，黑色环境下，你坐好就完事了，啥也不用管，我放啥你看啥，只要推荐算法精准，你肯定不想走，主打“沉浸、消费”。</p>
<p>从人性角度讲，用户是懒惰、贪婪的，所以，他们在巨大的工作、学习压力下想逃避现实的繁琐，选择了抖音，傻瓜式享受，人性所趋。</p>
<p><strong>总结一下，互联网时代，获取用户的两种方法：</strong></p>
<p>1、逃避现实，提供愉悦。打造虚拟世界快感，满足用户虚荣心、在虚拟世界找到更美更有钱更有权利的自己。</p>
<p>比如美拍、抖音、快手、全民K歌、王者荣耀、各大等级游戏。</p>
<p>2、直面现实、抵御恐惧、激励用户成长，跳出舒适圈、看清变化的世界、防止被世界抛弃。</p>
<p>通过线上打卡好友支持，坚持线上flag，目的是改变现实生活的自己，实现现实生活中在学习、工作上的实用价值，关注的是个人现实生活成长体验。</p>
<p>比如得到、微信读书、喜马拉雅、KEEP、薄荷健康、有道云笔记、英语流利说等各大教育机构APP。</p>
<p>下图是马斯洛的需求分级：<img src="https://img-blog.csdnimg.cn/20200403135554265.jpeg#pic_center" alt="在这里插入图片描述"></p>
<p>行业情况告诉我们，以上两种方式，各有玩法，就看怎么制定高级策略了，我认为区别有两点。</p>
<p><strong>提供快感、愉悦，快餐文化消费（最低层次的需求）</strong></p>
<p>1、提供快感（最低层次的需求）根源是逃避现实，是短期消费，利用碎片化时代用户的孤独和无聊情绪，最容易成功吸引，变现容易，但产品生命周期短，如果没有特点，只能昙花一现。</p>
<p>2、入门门槛低，但是不长久，比如，我身边玩抖音的人少了，因为新鲜感没有了。确实是这样，人是矛盾的，需求是动态的，上瘾是一时新鲜，如果没有现实生活的成长，很难长久。</p>
<p>2、一般靠群体实现，基于群体认同感，出发点是人关心虚拟世界中自己在群体中的地位。</p>
<p><strong>直面现实、抵御恐惧、长期习惯消费（自我实现的需求）</strong></p>
<p>1、根源是自我认同感。个人认同追求优越感，我们想要标新立异、想要出类拔萃，打卡、改变、去实现自我价值。</p>
<p>2、成功是上瘾的，当人通过努力获得了现实世界的超脱和破圈后，得到荣誉和赞赏，他会对成功上瘾。人性所趋，古往今来，不曾改变。</p>
<p>3、产品周期长，养成习惯难，但一旦过了缓冲期，产生数字资产的沉淀，用户就不会轻易放弃，用户黏度高。</p>
<p>比如，你写了很久的日记本，你不会轻易丢掉（文字积淀）；你谈了很久的男朋友，你舍不得忘不掉（情感积淀）；你的微信，不可能卸载（那里有您的社交关系链沉淀）。</p>
<p><strong>3、认清行业形势，把握合适时机。</strong></p>
<p>古语云：先下手为强。微视在很早就开始规划了，起了大早，却赶了晚集，可见市场、运营对产品的重要性。</p>
<p>产品从0到1 ，运营从1到100，好的产品是苗子，需要运营来及时呵护、养育，否则，很难茁壮成长。字节跳动的宣传和运营抢占了市场的先机，抖音先入为主，抢占了一部分用户的产品认知。</p>
<p>产品认知是很可怕的，甚至可以扭曲现实，一旦品牌深入人心之后，用户很难再去接受新的认知，尤其是相似性的同质化的产品。</p>
<p>所以，第一印象非常重要，这也是微信步步谨慎、每次改版都要深思熟虑的原理。</p>
<p>反思一下微博出品的绿洲，火不起来是因为没有达到精良设计时就横空出世，好牌也打乱了，很可惜。</p>
<p>所以最好的时机是合适，不是抢占更不是拖延。</p>
<p>因为，第一印象、决定了你在我心中的定位。比如，初次约会~</p>
<p>客观分析，这是市场决策的重要一环。以微视为例子：</p>
<p>2018年春节，腾讯微视通过QQ 走运红包合作发放微视礼包，新增数百万用户。黄子韬、刘昊然、张天爱、迪玛西等数十位明星助阵拜年并入驻微视。 [3]<br>2018年4月2日，腾讯微视发布2018年首次重大更新，推出三大首创功能，视频跟拍、歌词字幕、一键美型， [4]  并打通QQ音乐千万正版曲库，进行全面的品牌及产品升级。增加歌词字幕玩法，用户在选择背景音乐之后，录制视频时可选择显示歌词字幕，实现轻松跟唱。 [5]<br>2019年1月，微视在春节期间推出视频红包的创新玩法，从2月4日（除夕）00:00至2月6日（大年初一）24:00，共有7809万个视频红包在微信、QQ和微视里被领取。 [6-7]<br>2019年2月，微视上线测试个人视频红包玩法，用户可以通过微视制作视频红包，并且分享到微信和QQ，邀请好友领取。[8]<br>2019年4月，微视上线新版本，推出 “创造营助力”、“解锁技能”等全新模板。用户可通过微视的模板制作互动视频，并通过微信、QQ等社交平台分享给好友；好友可直接在微信、QQ里浏览该互动视频，并进行互动操作 [9]<br>2019年6月，微视开启了 30 秒朋友圈视频能力内测。用户在微视发布界面勾选“同步到朋友圈（最长可发布30秒）”按钮，即可将最长30秒的视频同步到朋友圈。<br>从上面的推广流程上看，腾讯也是大力扶持，花费了很多心思，可是还是晚了一点。<br>争夺大战中，规则有三点。<br>1、内容为王，多元全面，但垂直领域又足够精准优质。<br>2、创新为源，玩法新、巧、稀缺、有特色。<br>3、天时、地利、人和。</p>
<h2 id="打磨垂直内容"><a href="#打磨垂直内容" class="headerlink" title="打磨垂直内容"></a>打磨垂直内容</h2><p>现在各大视频主打娱乐、搞笑、影视、资讯，内容同质化严重。</p>
<p>很多内容型产品没有品牌意识，仍处于早期的用户和内容原始积累阶段，因此被克隆后并没有反抗能力。</p>
<p>产品是躯干、内容是血肉，需要产品本身的调性和机制去调节。总的来说、突出明确定位、品牌特色、</p>
<p>突出差异性和稀缺性，就是让用户只能来我们这看，别的地方没有，仅此一家！</p>
<p>其他APP比较泛滥，拿视频号说说我的看法。我认为主攻一下几点。</p>
<p><strong>视频号的垂直化领域区分：</strong><br>1.<strong>基于哲学</strong>：一个基于特定文化或者主题来交流、互动并持续产生内容的空间，简称“同好互动空间”。<br>弱关系社区中，关键是你对和你建立联系的事物，是否产生了感应。比如点赞、评论、分享等互动操作。<br>类比视频版的知乎，缩略般的B站、去中心化版的微博。<br>意义：<br>一部基于物的生活知识的百科全书（好物推荐、种草合集、生活小常识）、一部基于人的经验分享和情感解惑（关乎学习、职场、恋爱）。<br>2.<strong>基于个人</strong>：记录自己，记录世界，记录自己与世界的联系。重要的是减小朋友圈发文的人设压力，在陌生人关系中大胆释放自己。<br>意义：<br>记下生活的灵感和感动，类比个人精炼的成长日记，关乎生活的辛酸苦辣，关乎个人成长历程、心路轨迹。<br>（游戏规则是带有个人简介，我们要清晰自己的定位，也是帮助我们找到自己的差异化优势和稀缺性特质）<br>3.<strong>基于品牌</strong>：记录中小型企业生产品牌的流程，全程拍摄品牌打造、精雕细琢的细节，传达企业的真诚和品牌的优质，让用户亲眼可见、增强对企业的关注度、对品牌的认知度。比如现有的内测的钻石、服装、无人机产业。<br>意义：<br>对于品牌，打通公众号宣传、小程序直播、实现商业化变现的通道。<br>对于用户，真实、快速、立体、全面感知产品的差异化优势，丰富知识面，扩展视野格局，更方便更快速买到更放心的优质产品。<br>4.<strong>基于媒体</strong>：记录时事热点、媒体资讯、关乎天下大事、家国情怀。<br>意义：<br>为社会热点留白，等待时机造势，当媒体活动宣发时，这是很好的流量入口 。<br>（说不定下一个微信红包的热点降临、健康码、出行公交码的热潮会借助视频号来引爆支付产业瓜分半壁江山)。</p>
<h2 id="完善监管激励"><a href="#完善监管激励" class="headerlink" title="完善监管激励"></a>完善监管激励</h2><p>社区监管和激励体系是为了引导内容生产者不去产出同质化内容。</p>
<p>1、<strong>激励是赏</strong>、对创作者的原创内容进行精神鼓励和物质奖励，精神鼓励来自朋友和陌生人的关注、点赞、评论，人都有攀比心和虚荣心，精神奖励甚至超乎了物质奖励。</p>
<p>2、物质奖励来自更多特权和升级，助力创作者升级，当粉丝达到一定数量赋予特权、平台给予更多推送机会、曝光率、传播量、扩大个人影响力。</p>
<p>3、对创作者本人来说，以上措施激发更多创造。对同行业的人来说鼓励原创、激发新鲜点子，类似学校里面的年级排名、职场中的评级等等，都是为了激励同行业的人去打开自己的创造源泉，拿出自己的绝活，拉开和同行人的差距，这样就发挥了每一个个体的创造力和想象力，我们平台方，只需要做好舞台背景、打好灯光，让人们去尽情表演吧，相信大众的创造力和想象力，这是一套完整的闭环法则。</p>
<p>4、<strong>监管是控</strong>，禁止同质内容、加大剽窃账号的惩罚力度，打击平台内侵犯版权的行为，对疑似剽窃的账号封禁、减少曝光机会、降低推送频率、降低等级。</p>
<p>5、禁止使用虚假的信息创建帐号、故意误导他人、干扰真实的平台数据以及其他弄虚作假的行为，保障平台每一个用户的核心利益。</p>
<p>6、<strong>鼓励原创</strong>，提倡分享优质的内容信息，向广大自媒体作者普及版权意识，要求内容不能是旧文、或者全网已有的传播的同质内容。</p>
<p>7、<strong>净化环境。</strong>不允许传播对他人有害、令人极度不适、不利于青少年身心健康等不良信息。禁止传播侵扰用户安宁、造成用户使用体验减损或者影响软件正常使用和运行的内容。</p>
<p>如频繁发送骚扰信息、垃圾信息、广告信息，过度营销或商业推广。</p>
<h2 id="优化创新服务"><a href="#优化创新服务" class="headerlink" title="优化创新服务"></a>优化创新服务</h2><p>用户体验包含了内容和形式。</p>
<p>例子：知乎主打问答模式、简书注重创作形式、爱奇艺推出5G  VR  360度旋转体验。</p>
<p>从内容和形式这两个维度入手，打造更有特色的体验才能塑造好产品的风格、调性、差异性，优化品牌意识。</p>
<p>具体可以从结构层的信息架构、框架层的信息设计、表现层的视觉设计入手。</p>
<p>以下是我的三点想法：</p>
<p>1、<strong>载体上</strong>：找到合适的形式。比如文字、图片、语言、视频，各种形式可以主打或者组合。</p>
<p>比如“得到”推荐音频、B站长视频、视频号一分钟短视频、知乎文字、朋友圈图文。</p>
<p>2、<strong>分发上：</strong>确定算法推荐、热点搜索、个性化推荐还是主动订阅。这个比较复杂，以后专门谈。</p>
<p>3、<strong>互动形式上</strong>：深挖用户场景和习惯，不一样的互动形式会打造不同使用体验。</p>
<p>比如：快手双击666，新浪微博站内转载、视频号折叠评论等等。</p>
<p>4、<strong>播放形式上</strong>：瀑布流怎么布局，全屏还是小屏、评论是否隐藏、5G  VR怎么利用。</p>
<p>比如：</p>
<p>快手双列信息流，因为算法推荐更关注了长尾小号，所以怕用户不喜欢，分发不精准，采用双列让用户多了选择，减小平台的分发误判率。</p>
<p>抖音全屏体验，因为算法精准，平台分发定位准确，误判率小，所以不用担心用户不喜欢当前视频，主打观看体验。</p>
<p>视频号：中间区域播放，不支持暂停，分割视频区域和评论区域，既可以评论互动又可以专注看视频。</p>
<p><strong>为什么不能暂停播放？</strong></p>
<p>1、<strong>从产品调性思考</strong>：因为内容短、精致、所以一分一秒都有干货，提醒用户节奏慢下来细细品味，提倡慢文化，与倍速对比，打造不同观看体验，也算是一个差异化特色。</p>
<p>2、<strong>从用户角度思考</strong>：若用户可以看完，说明他是感兴趣的，下次可以继续关注此类视频的动态，基于主动订阅的，用户有兴趣，所以不会影响体验，不会反感内容。假如不喜欢此类视频，可以取消关注，下次不再推送，所以更加精准了，很巧妙的办法。</p>
<p>3、<strong>从创作者思考</strong>：每一分每一秒都要高品质，否则用户取消关注，自己粉丝骤减，得不偿失。</p>
<p>4、<strong>从平台思考</strong>：无为而治，“看不见的手”，非常高明，让双方相互监管激励，可以说设计思维很缜密，很精心。</p>
<p>5、能不能结合VR打造立体观看体验呢？</p>
<p>6、横屏竖屏怎么设计？</p>
<p>7、基于中国人的生活规律和习惯，能否不同时间推荐不同视频？</p>
<p>“同城”和“附近的人”都是从空间角度思考，我们是不是可以从时间角度入手？</p>
<p>比如早上音乐类、中午美食类、晚上新闻资讯、职场干货类 。</p>
<p>以上是个人深入思考的想法，绞尽脑汁了，很喜欢头脑风暴，若有不足或疑虑，请大家多多交流指教。</p>
<p>视频号，<strong>未来可期，万物之上，希望至美！</strong></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E7%9F%AD%E8%A7%86%E9%A2%91%E6%80%8E%E4%B9%88%E5%81%9A/" rel="tag">短视频怎么做?</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E8%A7%86%E9%A2%91%E5%8F%B7%E6%80%9D%E8%80%83/" rel="tag">视频号思考</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-视频号—— 一部2020下凡人间的动态史记" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2020/04/02/%E8%A7%86%E9%A2%91%E5%8F%B7%E2%80%94%E2%80%94%20%E4%B8%80%E9%83%A82020%E4%B8%8B%E5%87%A1%E4%BA%BA%E9%97%B4%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%B2%E8%AE%B0/"
    >视频号——一部2020下凡人间的动态史记</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2020/04/02/%E8%A7%86%E9%A2%91%E5%8F%B7%E2%80%94%E2%80%94%20%E4%B8%80%E9%83%A82020%E4%B8%8B%E5%87%A1%E4%BA%BA%E9%97%B4%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%B2%E8%AE%B0/" class="article-date">
  <time datetime="2020-04-01T16:00:00.000Z" itemprop="datePublished">2020-04-02</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E8%A7%86%E9%A2%91%E5%8F%B7/">我眼中的视频号</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<blockquote>
<p>我一直由衷地崇拜张小龙老师，他是一片星辰大海，神圣而神秘。<br>这位华科电信系的“学长前辈”把善良、真理想到了极致，把简单、纯粹做到了极致。<br>他是上帝派落到凡间的天使，剖析犀利的视角，出谋划策、牵动宇宙。<br>他是时光洪流的掌舵人，引领标新立异的潮流，深挖特立独行的思考。<br>他是纷繁世态的独行侠，心怀普惠众生的悲悯，救济着每一个孤独的灵魂。<br>张小龙，传承中国龙人的基因、一颦一簇、一举一动、推动着时代的奇迹。</p>
</blockquote>
<h2 id="一、关于微信的个人思考"><a href="#一、关于微信的个人思考" class="headerlink" title="一、关于微信的个人思考"></a>一、关于微信的个人思考</h2><p>高山仰止,景行行止,虽不能至,心向往之。我知道，张小龙老师一直在路上思考，他的高度，我们无法抵达。<br>这篇文章构思了很久，其中可能有不太成熟的想法，但都是我深入思考的结晶。<br>这些文字就当做管窥蠡测一下我眼中的微信和视频号吧，我坚信微信的力量，坚信视频号的能量。<br>我始终认为，微信是一个艺术品。微信基于普惠理念发展出了工具、简单自然等产品哲学。<br>产品最深入人心的部分是认知，认知甚至可以扭曲现实，微信从真正意义上讲，改变了一个时代人的生活方式。<br>微信最初是为了提高通讯效率的一个工具，切入口足够垂直细分，从而很好的保护了自己，这为日后发展壮大，强大的地基和丰富的生态做足了铺垫。<br>白色象征干净、纯粹、人的出生就是一张白纸，白色泡泡象征每一个富有个性的人（因为每个人的DNA是不同的，人是基因、环境、角色的产物。）<br>绿色泡泡象征大自然的生态，它和谐、环保、包容、真实、承载着每一条人与人、人与物、物与物的连接。绿色泡泡的体积是更大的，因为人类征服不了自然，人类应该是大自然的敬畏者，白云飘飘，绿水青山，简单的意境，清新的格调，微信传达的是遥远山谷的一缕回音。<br>这轻轻的一声，敲响了十亿人沉沉的关系链。<br>微信的开屏首页，是苍茫星球中个体对万物的思考。时间不可逆，所有人类命运体最终都会走向必然，都将流向同一条河流。命运宿命论虽然悲哀却很真实。地心引力带着神秘的磁场运转着渺小的独立个体，构成庞大的社交网络。<br>熟人关系的朋友圈是一轮五彩斑斓的小圆圈，亲密无间的每分每秒循环播放，构成一个个闭环的圆圈广场。<br>陌生人关系的视频号，像极了蝶舞联翩的大蝴蝶，带着强IP属性的点点滴滴，散部在茫茫的星辰大海。<br>一强一弱，横纵交织，并驾齐驱，对立统一，这是多么和谐美好的设计。<br>微信，从盘古开天地的蛮荒时代降临，经历夸父逐日的兴衰荣辱，无数个十年后，它将直通浩瀚星海的宇宙。<br>个人设计的slogan提议：<br>微信视频号：拒绝蹉跎度日，记录朝花夕拾，人间贵在真实，你我载入历史。<br>微信支付：如影随形，安全经营，绿色贴心，福利降临。<br>微信读书：生活不止粗茶淡饭的琐碎，还有云淡风轻的诗和远方。<br>小程序：便捷生活的万花筒，疑难杂症的万金油。<br>搜一搜：世界日新月异，评论针尖利弊，掌舵风云资讯，天地与你同行。<br>附近的人：经纬交错，田园脉络，不用陌陌，桃花朵朵。<br>我眼中的产品：<br>你若盛开，清风自来；桃李不言，下自成蹊。<br>清风细雨，润物无声；上善若水，干净纯粹。<br>己所不欲，勿施于人；删繁就简，大智若愚。<br>从婴儿的视角观察，用哲人的大脑思考。<br>虚心求教，Stay  hungry，Stay  young。<br>从实践中总结的方法论：乔布斯Apple法则：<br>ambition–accumulation–persistence–prediction–learn–link–estimation–evaluation</p>
<h2 id="二、初识宇宙新物种——视频号大驾光临"><a href="#二、初识宇宙新物种——视频号大驾光临" class="headerlink" title="二、初识宇宙新物种——视频号大驾光临"></a>二、初识宇宙新物种——视频号大驾光临</h2><p><strong>产品定位：</strong><br>1、视频号定位于“<strong>人人皆可创作的平台</strong>”<br>2、微信作为一个基础的信息传递的工具或者说平台，任何一个不经意的动作，可能会引起信息洪流流向的变化。<br>3、微信的价值观是“再小的个体，也有自己的品牌”。<br>4、视频号是为了弥补当年短内容的失误。<br>5、微信是一个开放的平台，致力于提供给用户有价值的服务，来搭建一个动态的生态系统，从而消除中介、消除地理限制。<br>6、我们希望建造一个森林，而不是一座宫殿，而所有这一切实现的前提就是用户价值第一。<br><strong>表层现象</strong><br>1.仔细想想，我们是不是习惯了在朋友圈虚构好自己的人设？我们P图，精修，记录点滴美好，它是熟人社交中一张光鲜亮丽的名片，代表着我们的身份、地位和人设。<br>2.我们不敢轻易点赞，点在看，因为我们幻想着别人对我们的看法，“好看”文章的属性似乎反应了我们朋友圈人设的认知观，于是，我们变得小心翼翼了，害怕亲密的朋友发现了我们细腻的小心思，害怕隐私被揭开，害怕人设坍塌，形象受损，这一切的根源都是隐私风险和信任背书。不过，要知道任何表层需求上的驱动，剖析到底还是人性底层的驱动。<br><strong>深层需求分析：</strong><br>1.人作为一个社交动物，生而社交，但面对着如今充斥着焦虑和压力的社会，每个人都在极力逃避着那一颗社交压力的尘埃。<br>2.相对于社交产品或者IM工具的社交压力来说，陌生人社区产品逐渐成为了现代人缓解压力、寻找同好并获得兴趣满足的窗口。<br>3.根本渊源就是：马斯洛常说的，人性最底层的社交、尊重和自我实现的需求。<br><strong>人性角度：</strong><br>人性是两面的，一方面，我们贪婪，懒惰，迷恋舒适和稳定，基础物质的快乐来自规避风险，逃离现实。<br>另一方面，我们又渴望他人的赞赏和认可，为了荣誉和奖赏，我们诚惶诚恐，殚精竭虑，迫切打破舒适圈，刷新认知，走向新的台阶展现自己。<br><strong>精神层面：</strong><br>世界日新月异，如果不分年龄、性别、角色、人类最本质的需求是什么？<br>我认为，是恐惧。<br>世界太快了，它加速旋转，日夜不息，我们忙碌地从一座围城跳到另一座围城。<br>年轻时我们没有家室之累，无所畏惧，因为一无所有，所以能慷慨地舍弃一切。但我们恐惧被新鲜事物抛弃。到了中年，我们肩负老小，为谋生繁衍，奔波忙碌，劳耕累耘。我们恐惧贫穷、家庭破裂、事业风险。终于奋斗了很久，我们老了，然后被迫恐惧疾病和孤独。<br>总之，我们害怕自我更新的速度小于社会发展的速度，害怕被时代抛弃，害怕失去核心竞争力，于是我们产生了焦虑和恐惧 ，进而衍生了深层次的需求。它凌驾于安全、生理、社交、渴望被尊重、直接蹭升到自我实现的需求。<br><strong>现实层面：</strong><br>罗曼罗兰说：世界上只有一种英雄主义，那就是看清了生活的真相，但依然热爱它。<br>鲁迅说：真正的勇士敢于直面惨淡的人生，敢于正视淋漓的鲜血。<br>没错，人生本质上是不美好的，苦难是生命的常态，但我们依然可以在这个星球上猩猩相惜，肆意生长。<br>真正让我们快乐的，是克服重重险阻之后的喜悦，是破圈带给我们的蜕变。<br>基于上述人性角度的分析，人最珍贵的是清楚的认识自己，坦诚的记录自己，接受生活的真相和真实的自己，认清形势、珍惜当下。<br>所以，成长的酸甜苦辣，破圈的兴衰荣辱，都需要这样一个没有创作压力的平台。<br>以铜为镜，可以正衣冠；以史为镜，可以知兴替；以人为镜，可以知得失。<br>简单说，它就是一面干净的镜子，一把简单的工具，记录自己，记录世界，记录自己和世界的联系。它真实、便捷、随时可拍、触手可及。<br>对于每一个人来说，它好像我们的移动日记本，随时随地用视频记录自己的灵感和思考。从上帝视角观察，视频号就是一个个鲜活人物在茫茫星辰大海中一生的足迹呀，历史风云变幻，时代沧桑变迁，时代的巨轮承载了一代代人平凡又伟大的冒险，一代代鲜活的生命在这里上演人间的茶米油盐、爱恨情仇、辛酸苦辣、兴衰荣辱、这是一件多么美好、多少真实、多少有意义的流动数字资产啊！<br>我承认，这世上有数不完的艰辛、苦楚、失败与遗憾；总有平凡的人儿们喝着醍醐灌顶的烈酒，唱着声嘶力竭的热歌；偌大的星球上，形形色色，各行各业的人们穿梭在不同的轨道，企盼着平衡、探索着真理、追寻着真爱、万有引力很强大，生存法则很残酷，奋然前行，需要每一个平凡个体的勇气和信心！<br>肉体或精神的折磨，或许才是成熟的淬炼、成长的真相。<br>即使我们都是无名之辈，那又怎么样呢？世界很大，苦痛很大，但我们依然企盼着希望，带着茕茕孑立的孤独和猩猩相惜的点赞。<br>即使我们渺小如蝼蚁，那又如何呢？庞大的社交网络上，我们点头触碰，为千千万万平凡真实的VLOG热泪盈眶，为时空交错下心怀一致的赤诚与朝圣而欢呼雀跃！<br>多少年之后，我们的子孙后代，依然可以翻阅到我们的点点滴滴，它可能是简单平凡的日常琐事，也可能是阳春白雪的鸿篇巨著，但他们，都是我们曾经一分钟的感动啊，春夏秋冬，我们都曾真实记录过，年岁轮回，我们都曾认真体验过。<br>很多年之后，它们像罗马时代的墓碑一样，隐秘而神圣，这个大大的平台，跨越了岁月的交替和时空的变迁，多么伟大，多么难得。</p>
<p><strong>视频号的诞生原因：</strong><br><strong>行业背景：</strong><br>1.短视频产品在用户量和用户使用时长上的飞速增长。<br>2.弥补腾讯系在短视频领域的缺失，借助私域流量+公域流量弥补微视的遗憾。<br>虽然公众号本身，已是一个完整的内容生态，但其也存在明显的缺陷，它的属性，会带来一连串的诺米骨牌效应：<br><strong>强订阅关系—&gt;被动获取能力的缺失—&gt;低创作门槛的缺失—&gt;移动化创作方式的缺失—&gt;长尾内容的缺失—&gt;非人人可以创作的平台。</strong><br>因此，要依靠更大陌生人社交圈子的短视频，导流到公众号。<br>鼓励<strong>长尾作者</strong>去发挥创造力，提供视频号引流带来粉丝积淀和回馈变现，让有价值的服务普惠众生。<br>3、微信的理念其实是普惠，它重视的是人人都可用，而不是某个特定的群体。短视频降低了创作门槛，鼓励人人可创造有价值的内容。<br><strong>一句话定位视频号对微信生态的巨大意义：</strong><br>1.微信的破圈——长短互补，强弱交织，蝴蝶效应，生态闭环——避免微信不被新生的短视频文化需求边缘化。<br>2.唯一可以实现去中心化的、并且借助微信熟人社交链来打造电商基因 、金融科技、 闭环支付的短内容平台。<br><img src="https://img-blog.csdnimg.cn/20200402045437941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>视频号的分解单元</strong><br>基于特定文化或者主题来交流互动并持续产生内容的小标签话题<br><strong>视频号的整体框架：</strong><br>横向内容优质多元、百花齐放，兼顾高质量和正能量，垂直化领域足够深入，IP定位属性精准的陌生人社交网络<br><strong>与朋友圈相比，视频号的特点：</strong><br>1.位置于二级入口朋友圈下层，并驾齐驱，可见地址很重要！<br>2.打破熟人关系链，将交流的平台扩大到陌生人的领域。<br>3.实现强关系社交的转换，打开弱关系社交的大圈。<br>4.将微信的私域流量扩大到公域流量，完成微信生态的扩容。<br>5.降低创造长内容公众号的门槛，实现便捷、迅速记录当下生活点滴的机会。<br>6.打破过于隐秘的私人社交小圈，搭建社区大圈，增加模块的主题性、内容性、互动性。<br><strong>视频号的垂直化领域区分：</strong><br>1.<strong>基于哲学</strong>：一个基于特定文化或者主题来交流、互动并持续产生内容的空间，简称“同好互动空间”。<br>弱关系社区中，关键是你对和你建立联系的事物，是否产生了感应。比如点赞、评论、分享等互动操作。<br>类比视频版的知乎，缩略般的B站、去中心化版的微博。<br>意义：<br>一部基于物的生活知识的百科全书（好物推荐、种草合集、生活小常识）、一部基于人的经验分享和情感解惑（关乎学习、职场、恋爱）。<br>2.<strong>基于个人</strong>：记录自己，记录世界，记录自己与世界的联系。重要的是减小朋友圈发文的人设压力，在陌生人关系中大胆释放自己。<br>意义：<br>记下生活的灵感和感动，类比个人精炼的成长日记，关乎生活的辛酸苦辣，关乎个人成长历程、心路轨迹。<br>（游戏规则是带有个人简介，我们要清晰自己的定位，也是帮助我们找到自己的差异化优势和稀缺性特质）<br>3.<strong>基于品牌</strong>：记录中小型企业生产品牌的流程，全程拍摄品牌打造、精雕细琢的细节，传达企业的真诚和品牌的优质，让用户亲眼可见、增强对企业的关注度、对品牌的认知度。比如现有的内测的钻石、服装、无人机产业。<br>意义：<br>对于品牌，打通公众号宣传、小程序直播、实现商业化变现的通道。<br>对于用户，真实、快速、立体、全面感知产品的差异化优势，丰富知识面，扩展视野格局，更方便更快速买到更放心的优质产品。<br>4.<strong>基于媒体</strong>：记录时事热点、媒体资讯、关乎天下大事、家国情怀。<br>意义：<br>为社会热点留白，等待时机造势，当媒体活动宣发时，这是很好的流量入口 。<br>（说不定下一个微信红包的热点降临、健康码、出行公交码的热潮会借助视频号来引爆支付产业瓜分半壁江山)。</p>
<h2 id="三、对视频号的多维创新思考"><a href="#三、对视频号的多维创新思考" class="headerlink" title="三、对视频号的多维创新思考"></a>三、对视频号的多维创新思考</h2><p><strong>1、宣传视频号的小创意</strong><br>slogan: 拒绝蹉跎度日，记录朝花夕拾，人间贵在真实，你我载入历史。<br>1.还在抖音刷视频虚度光阴吗？临渊羡鱼，不如退而结网，来视频号提升自己吧！人生还有更独特的诗意和远方！<br>2.还在快手看直播吗？你想要的，视频号都有！精挑细选，有你好看~<br>3.还在知乎海淘干货、面经吗？视频版的浓缩精华，视频号等你来分享~<br>4.还在B站倍速播放卡槽点吗？慢一点，让我们享受一分钟的干货精华。<br>5.还在微博海量信息中大海捞针吗？这里有专属优质小圈，用料考究，视听盛宴等你来哦~<br>6.这是一部修身、齐家、治国、平天下的短视频版《资治通鉴》！<br>7.我们终将老去，来视频号沉淀您的即刻视频！。<br>8.沉淀前世今生的数字资产！<br>9.时光一去不复返，视频号里转一转。<br>10.人要怎么度过这一生？<br>当他回首往事的时候，他不会因为虚度年华刷抖音而悔恨，也不会因为碌碌无为逛淘宝而羞耻；<br>这样，在临死的时候，他就能够说：“我的整个生命和全部回忆都已经献给世界上最壮丽的事业———在视频号和陌生的你相遇。<br><strong>2、用户获取分析</strong><br>在国内内容类产品的发展史中，有两个产品在用户获取方面是异常彪悍的。<br>1、移动互联网初始萌芽的今日头条，在早期还享有移动互联网用户红利的时候，用性价比超高的大规模推广手段（手机厂商预装应用等）获取了大量用户，为整个头条系的产品积累了丰富的用户启动资源。<br>2、只用了27个月就成功上市的趣头条，主要针对的是下沉市场人群，通过金币激励体系疯狂地获取用户，硬生生地在巨头林立的内容资讯类产品中占据了一席之地。<br>事实上，绝大多数内容类产品在获取用户方面都是一个非常大的难题，毕竟现在获取一个用户的流量成本非常之高，从早期的1.5-2元／个，变成了现在20-50元／个。<br>如果一个产品本身的变现能力不行的话，它其实是没有办法大规模、可持续地去获取用户的。<br>但对视频号而言，用户获取却是相对而言简单许多的事情，毕竟这是一款坐拥10亿日活的产品，开了二级菜单给视频号导流，怕也是绝大多数互联网产品望尘莫及的一个数量级。<br>目前微信的策略：<br>1、将视频号的位置放置在「发现」中，紧随「朋友圈」之后，可以借助熟人朋友圈实现破圈。<br>2、内测阶段，微信的每一步都要稳扎稳打。上线方案，一起头脑风暴，集思广益。<br><strong>3、内容生态构建——差异性、稀缺性——与长内容公众号互补引流</strong><br>对于平台：<br>（1）微信是一个巨大的生态系统，我们只要提供一个平台，最基本的道具和框架，就是最好的方式，不要局限大家的认知、眼界、格局。<br>（2）把舞台留出来，灯光打上，让观众们激发无限创意和想象，交给观众去创造吧，我们要相信十亿中国人的发明创造。<br>（3）内容监管审核：关键在于保真、优质、定位精准、独特、新鲜、激发情感共鸣。<br>（4）社区建设注重具体场景，基于弱关系链、推荐生活VLOG、新闻热点资讯、科普知识、个人经验干货。<br>（5）减少娱乐、搞笑、剧情、走高端路线，打造温情故事、家国情怀、中国文化。<br><strong>（6）关注00后、10后Z世代文化和老年人喜闻乐见的生活视频，这是目前比较稀缺的两块内容区域。</strong><br>（个人建议，有待数据分析考量，出于重点打造差异化、空白区域切入的思路）</p>
<p><strong>4、内容生产模式</strong><br>（1）UGC用户群体庞大、真实记录生活VLOG、个人号定位精准简介、帮助用户更好认识自己、记录自我、世界、自我与世界的情感联系。UGC里有我们承受生活的苦难后获得的生长，有看清生活的本质但依然热爱生活的勇气，有不加滤镜、真实鲜活的自我。<br>（2）PGC里有专业精致的干货，有利用有限时间创造无限价值的方法，内容足够垂直化，优质化，涵盖了正能量明星背后的奋斗故事、优质行业博主光环背后的辛酸、自媒体创作者对于人生的深刻思考、中小企业品牌创造的精致打磨。这类视频用户粘性高，变现能力也最强。<br>（3）PUGC：优势互补、取其精华、去其糟粕。</p>
<p><strong>5、内容分发——筛选优质精准内容、提升用户体验</strong><br>内容类产品／平台的一个共同特点：<br>（1）首先平台本身必须是一个好的工具型产品，可低门槛地提供体验良好的工具供普通用户创作内容使用。<br>（2）平台要有一个<strong>良好的机制</strong>可以从海量的内容中筛选出优质的内容供用户消费。（真的很想来实习，自己主动研究了推荐算法，不过张小龙老师说不太推荐，主攻社交推荐，可能两者结合？应该要数据分析来解答）<br>（3）用户要有好的成长体验，能真正帮助用户在这里察看人生百态，获取有用资讯，实现自我价值转化和成长。<br>目前主流的内容分发模式有三个：算法推荐、社交推荐、用户订阅。<br><strong>张小龙老师的经典看法：</strong><br>几年前，我说过一句话，“推送改变世界，因为用户更懒了”。包括微信，也是基于推送的。<br>你收到的每一条消息，都被你把优先级排得比你要真正获取的信息的优先级更高一些。<br>那么，推送什么信息，决定了用户会看什么信息，决定了他在一个什么样的世界里。<br>这是一个我们要经常思考的问题，也是我们在努力的方向。所以，我很少说分发这个词，我觉得推荐可能更尊重一些。<br>“我们并不认为一个规则百分百确定的系统就好，相反，一个动态的、自我完善规则能够让系统获得动态稳定，整个系统可能是我们和第三方一起定义出来的。<br><strong>头条：算法推荐：协调过滤、召回排序</strong><br>优点:  全屏体验、精准分发。<br>缺点：马太效应、头部集中、中心化严重、社交关系难沉淀。<br>快手：均分算法推荐和社交推荐，基于同城构建社交。<br>优点：部分去中心化，关注下沉市场，从用户细分打造差异化。<br>缺点：内容上有质量风险，导致品牌调性下降。<br>微信：未知，我猜想通过<strong>用户自主关注、社交推荐、个性化推荐</strong>等多种方式，展示更丰富优质、用户更感兴趣的内容。<br>张小龙老师主张推荐，他主张技术的背后是人，更注重朋友之间的信任背书（比如微信读书）<br>优点：强社交属性、特有私域流量<br>我的一点小思考：<strong>快手有同城推荐，是基于地域的，我们可不可以基于时间域呢？给内容打标签，让算法在时间域上加一些权重分配？</strong><br>原理：中国人喜欢晚上看新闻、中午看娱乐缓解工作压力、英国人下午4点甜点喝茶、妈妈辈喜欢晚上广场舞、职场人喜欢晚上看看书<br><strong>从用户角度思考：</strong><br>1、视频号真好玩，不同时间知道我想做不同的事情，难道会读心术？<br>2、哎呀，六点了，视频号有没有我想看的新闻？<br>3、中午打开视频号，看看种草推荐吧，嘻嘻，视频号懂我。<br>4、晚上结束了一天的工作，来点鸡汤激励一下自己吧，我想看看视频号有没有牛人干货技巧分享。<br>5、我的好朋友最近在朋友圈分享了很多优质视频，我去看看吧，不然下次聚会就OUT啦。<br><strong>6、商业变现</strong><br>方式：广告、电商、直播、游戏、会员等等。<br>方式选择：是否贴合产品的使用和服务场景，平台自身的产品定位、用户属性。<br>优势：<br>1、公众号和短视频互相倒流。<br>2、发送到朋友圈或者朋友，通过分享来传播。<br>3、下一步可能打开小程序？<br>想象一下，视频号+公众号+小程序+微信群+朋友圈可能带来微信生态的大繁荣 。<br>张老师语录：<br>1、如果不慢慢来，只会使得第一波进来的人作为一个红利滥用它的流量。<br>2、作为流量红利来用的人并没有创造价值，对用户没有好处，还对平台造成损伤。<br><strong>自我思考：</strong><br>1、视频号目前打通小程序做商业化可能是不太好的，<strong>流量是用户信任的附属品</strong>，当我们初次将产品传给用户认知时，应该本着一切从用户出发的角度，视频号首先是一个真实记录生活的平台，产品的初次认知和定位很重要 。<br>2、商业化不让用户反感的前提是用户金钱付出的成本足够承担带给用户的价值，如果我们目前还做不到，那就慢慢打磨。<br>3、互联网时代争取的不应该是流量，而应该是信任，信任是互联网的稀缺资源。<br>4、注意力也是互联网的稀缺资源，当我们拥有了差异性和稀缺性，我们就拥有了良好稳健的生态和护城河。</p>
<h2 id="四、关于社区文化的思考：社区三基石（文化、角色、内容）"><a href="#四、关于社区文化的思考：社区三基石（文化、角色、内容）" class="headerlink" title="四、关于社区文化的思考：社区三基石（文化、角色、内容）"></a>四、关于社区文化的思考：社区三基石（文化、角色、内容）</h2><p>社区从社会学的角度来谈，本质上是一个社会群体组织单位。当个人进入群体之后，理性、独立、客观等个人意识会逐步地被弱化，藏在群体之中，无意识的情况之下，群体意识会逐渐占据着心智上的主导地位，这种群体意识即社区意识。<br>群体意识可以给社区带来更强的凝聚力、更强的归属感等积极意义，也可能使社区陷入混论、盲目和无序，因此需要通过社区文化来引导和管理社区意识。<br>由此可见，文化对于社区来说十分重要。所以要想打造一个好的社区，必须先要有一个好的且强有力的文化作支撑。<br><strong>底层闭环逻辑：</strong><br>1、社区的定位决定了社区的文化，而社区的文化影响着社区角色的行为以及它们所生产和消费的内容。<br>2、内容作为文化的载体吸引着认同社区文化的用户进入社区。<br>3、用户使用这个产品，愿意留在这个社区的前提是认同社区的文化和价值。<br><strong>收益（社交红利）=信息×关系链×互动</strong><br><strong>•信息像肉</strong><br><strong>•关系链似骨</strong><br><strong>•互动则像血液一样造成流动</strong><br>自我思考：<br>1、用户的社交帐号中，都有或多或少的好友，这就是对关系链的简单理解。<br>2、用户们的好友对于企业而言是弱关系，但对于用户自身则是强关系。<br>3、强弱之间的影响力截然不同，只有用户主动分享和推荐，信任依附在流动的信息之上，关系链的力量才会充分爆发。<br>4、“互动”（评论和转发）的发生本身取决于“信息”文案质量，以及用户好友数量多寡和紧密程度。<br>5、互动也是最简单、最直接的激励，推动有价值的信息在人群中口口相传流动开来，形成口碑效应和病毒式的传播。<br>6、这个公式也可以凝练成一句话：“让信息在关系链中流动”，或者“让人们讨论你”。<br>7、对于实操中的企业而言，谋求建立一套持续、稳定、有效的分享体系/文化，则是在这个理解上可以采取的策略。<br>换句话说，是从基础、从每个细节、环节、流程开始的优化，牢牢地和社交网络结合起来。<br>不管是“信息”“关系链”“互动”，都是构建这套体系的最基础构件。<br>在日常工作中，企业对“信息”“关系链”“互动”三个环节的不同分解与侧重，衍生出不同风格。<br>8、强调信息的企业与创业团队，以策划和活动见长；强调大号的价值，微博营销多云集于此。<br>实际上，这些着力点，都是致力于构建一套有别于社交平台之外的第三方付费分享体系。<br>9、朴素的情感（炫耀、爱心、利己利他等）是引发作用差别的根本因素。<br>热点事件因此而起，人们围观、参与令自己开心或愤怒的事情，也由此产生了许多无聊的“自娱现象”。<br>10、当信息纵横流动开来，会将一个个原本分割独立的社交网络连成整体，论坛与微博、微信、QQ空间，在某种意义上成为同一事物的不同映射。<br><strong>1、让团队来建立强有力的社区明文化</strong><br> 从字面意思很好理解，明文化这就是摆在台面上的，社区所倡导的文化和氛围。<br>通常大家都认为明文化是由社区运营人员通过白纸黑字的形式来制定一套符合社区文化的行为规范而建立起来的，例如什么社区公告、圈子规范等。其实并不是这么简单，包括UI风格、活动专题、推荐机制等等都是在想用户传递社区的文化、价值和底线，明文化是由团队的每个人一同打造的。<br>明文化就如同社区里的法律一般，所有社区成员的言行举止都要受到明文化的约束，不遵守甚至使违规就会收到惩罚，它确保了社区机制的正常运行。<br><strong>2、让用户来养成社区的暗文化</strong><br> 如果说明文化是社区的法律，那么暗文化就是社区的道德。它是没有强制约束的，是社区群体意识下自主形成的产物，同时它也是一个社区是否充满活力的象征，也正是它的存在将社区成员和网络路人彻底隔绝开来。<br>互联网上古时期D吧的屌丝文化、或者是最近几年兴起的B站的弹幕文化等等这些都是暗文化的代表，当然暗文化最直白最浅显最具体的表现就是社区黑话，比如一星护体、刚下飞机、下次一定之类的，懂得就是社区人，不懂就是社会人。<br>所以成功的社区，光有明文化是不够的，还需要重视暗文化的养成。但是暗文化不像是明文化那样可以在一朝一夕建立起来的，而是需要运营小伙伴持续地经营，通过头部用户去示范去引导去带动，在潜移默化中慢慢建立起来。<br><strong>2、角色</strong><br>角色的内核实际上就是社区的用户，是社区组织下最小的有机单位。<br>在群体意识和社区文化的作用下，用户会无意识地陷入角色化，而社区角色化最重要的意义就是让用户之间自主地产生协同分工，来维持社区的正常运作和活力。<br>一个成熟的社区里不可能只有一种角色，角色越多恰恰是证明社区分工越为成熟。<br>为生产者提供工具，为消费者提供内容<br>内容生产者和内容消费者其实是一个社区众多角色中抽象出来最简单的两个角色。<br>顾名思义，内容生产者就是在社区里生产内容的用户，他们通过生产内容进行自我展示，得到其他用户的反馈，获得尊重和自我价值的实现，甚至可以获得实质的收益；<br>而内容消费者则是大多数普通用户，通过消费社区里的内容，来满足自己的需求，获取价值。当然两者之间可不是一分为二的绝对划分，会有一定的重合，正是两者之间的互动，使得社区焕发出活力。<br>对于内容生产者，要要尽可能降低他们内容生产的门槛，提供便利的内容创作的工具，让他们可以更加快捷地进行内容创作；<br>对于内容消费者，首先通过算法推荐或者社交推荐，将感兴趣的内容展示给他们，其次是通过内容的整合和分发，保证他们内容消费的连贯性，最后就是要注重他们内容消费的体验。<br><strong>注重KOL，更要注重KOC</strong><br>决定一个社区能够走多快的是它的KOL，但决定一个社区能走多远的是它的KOC。<br>对于任何社区来说，KOL的重要性都不言而喻，尤其是在社区的启动阶段，KOL可以在短期内为社区带来一大批忠实的流量，即便是社区的成熟期，KOL也可以稳定住社区流量的基本盘。<br>但是太过于依赖KOL，很容易造成社区被KOL所裹挟的局面，包括我自己负责的产品里也有前车之鉴。社区与KOL的两方博弈最终受伤的还是社区，而KOC这些腰部用户却是一股第三力量，有助于打破这种“零和博弈”的局面。KOC对于社区来说，首先它的基数大，其次它的潜力大，最关键的是在于社区的博弈中，KOC属于一种弱势，欠搭把手的状态，社区会有更多的话语权。<br>社区加上KOC自然要大于KOL。所以一个健康且成功的社区里，服务好KOL大佬的同时，需要把更多的帮助给予到KOC的成长之路中去。<br><strong>打造角色等级体系的上升通道</strong><br>上瘾模型中说，用户对于一款产品上瘾基本分为“触发-行动-赏酬-投入”四个步骤。从中可以看出，如果想让用户对社区进行脑力和体力的投入之前，需要让他们获得多变的赏酬，而角色等级体系或者特权体系就是一种最常见的精神赏酬方式。</p>
<p>不论是内容生产者还是内容消费者，只要是做出符合社区价值的行为，就可以获得对应的虚拟收益，虚拟收益可以累计成对应等级，让角色之间自然而然的出现等级差异，这样促使他们相互进行攀比、炫耀，去持续创造符合社区价值的内容，这对于社区的发展是非常有必要的。</p>
<p><strong>3、内容</strong><br>内容毫无疑问的是社区最重要的资产。有句话说“花钱是门学问”，同样的花好内容资产对于任何一个社区都是一门学问。<br><strong>没有时效性的内容最珍贵</strong><br>热点内容在短期内会对社区带来巨大的瞬时流量，但是具有时效性的命门，也让他的价值会随着时间推移很快就流失掉。<br>经常混迹不同社区的话，你会发现很多让你感慨“‘大清亡了”的内容，仍然对于比你年纪小的用户群体们充满着吸引力，有着不错的阅读量和互动量。<br>对于没有时效性要求的、非资讯类的社区而言，没有时效性的内容经得起沉淀，也更显珍贵。<br><strong>做好内容分层，明确内容主体</strong><br>对于任何一个内容而言，它都是有层次的，我们不能一概而论。举个例子，我发了一个动态，这就是这个动态的一级内容，那么有人评论了我，这就属于二级内容了，接着又有人回复了这条评论，这就属于这条动态的三级内容了。就这么简单地划分了三级内容，但要说明的一点就是不是每个社区都有三级内容，也不是每个社区只有这三级内容。<br>最关键的是不同的社区对于内容侧重的层级也可能是不一样的，这就产生了他们的内容特点，例如最右注重的是二级内容也就是常说的神论，而小红书的核心内容是它的一级内容。<br>所以在积累社区内容之前，我们必须要明确我们社区内容的主体在哪。<br><strong>内容生产需要看不见的手</strong><br>如果说内容生产者（侧重用户部分）是内容生产看得见的手，那么平台侧的内容生产就是那只看不见的手，特别是社区发展的初期，这只看不见的手尤为重要。<br>发挥平台的力量，主要有三种方式：</p>
<p>①内容搬运</p>
<p>社区从0到1，真的不是缺人，而是缺内容。社区的逻辑就是内容为王，只要有了内容，就一定可以找到消费你内容的用户，然后再分化出再创作内容的用户。</p>
<p>但是没有内容呢？那就得靠平台通过爬虫也好，人工也罢，去从外站搬运符合社区文化的内容过来完成内容资本的原始积累。像是最右，70%以上的内容都是官方或者用户进行搬运的。</p>
<p>②官方生产</p>
<p>官方生产的内容就其数量而言，相比于搬运的内容一定是少之又少的，主要是对于搬运内容的一个有效补充，但是就其内容价值而言，那就可能远高于搬运内容。</p>
<p>要注意的是，官方生产的内容不一定是要用官方账号去发表，更多地通过普通用户账号去发表，具有真实性、原创性、优质性，打造社区核心内容。</p>
<p>③活动引导</p>
<p>平台通过活动来引导、征集用户原创内容，这也是一个比较常见的社区内容生产方式。</p>
<p><strong>内容筛选“取精华弃糟粕”</strong><br>好了，基础的内容有了，那我们面对“河量”或者海量的内容，就要进行到下一步筛选内容了。<br>筛选的过程大致分为三个步骤：<br>首先可以通过机器过滤，把一些涉及到违法、色情、有害的内容过滤掉；<br>接着就是需要把不符合我们社区文化和价值的内容刨除掉；<br>最后就是要在剩余的内容里，通过智能算法或者人工筛选，把优质内容和普通内容区分开来分发，因此它们将会得到不同的流量灌溉。</p>
<p><strong>找到适合的节点去综合分发内容</strong><br>社区的内容分发要结合自身的特点，找到并设置合理的节点进行有效的内容分发，常见的节点有用户节点、关系节点、话题节点等等。<br>比如说你在外卖平台经常点炸鸡，就会给你推很多炸鸡的店铺，这就是基于用户行为的内容分发。再比如你关注了A，A点赞了某个内容，就将这个内容也推给你，这就是基于用户关系的分发。这里由于篇幅的关系也不展开来讲了。<br>除了分发的节点外，按照分发机制来划分的话，市面上最常见的就是算法分发和社交分发这两种。算法分发的好处不必多说，可能比你自己更了解自己，但坏处就是很容易形成信息茧房，而社交推荐因为基于社交关系，你和你的朋友之间的偏好有一定的差异，所以会让你看到很多新的差异化的内容，但弊端就是让你觉得推荐的不精准。<br>所以综合之下，算法分发与社交分发相结合，找到适合社区信息架构的节点去进行有效的内容分发是关键。</p>
<p><strong>根据内容价值进行合理排序</strong><br>内容排序的前提是内容价值的判断，通过价值来进行展示上的排序，就跟产品需求排优先级一样，价值越高越靠前。而社区内容的价值判断往往是基于用户的互动行为，比如说微博的转评赞，B站的一键三连，这都是基于用户行为对内容的价值和热度进行评判。<br>但是也不能只把价值高的放在前面，这样容易导致社区内容的马太效应严重，打击中小内容生产者的积极性，所以一般的内容排序规则是多个维度穿插在一起的，以此来降低单一维度的权重，实现一种合理排序。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E8%A7%86%E9%A2%91%E5%8F%B7/" rel="tag">视频号</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-做好视频号的三点建议" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2020/04/02/%E5%81%9A%E5%A5%BD%E8%A7%86%E9%A2%91%E5%8F%B7%E7%9A%84%E4%B8%89%E7%82%B9%E5%BB%BA%E8%AE%AE/"
    >做好视频号的三点建议</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2020/04/02/%E5%81%9A%E5%A5%BD%E8%A7%86%E9%A2%91%E5%8F%B7%E7%9A%84%E4%B8%89%E7%82%B9%E5%BB%BA%E8%AE%AE/" class="article-date">
  <time datetime="2020-04-01T16:00:00.000Z" itemprop="datePublished">2020-04-02</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="一、推荐算法上主攻空白区——增加时间维度"><a href="#一、推荐算法上主攻空白区——增加时间维度" class="headerlink" title="一、推荐算法上主攻空白区——增加时间维度"></a>一、推荐算法上主攻空白区——增加时间维度</h2><p>原因：快手中有一个同城模块，是利用了基于地域的空间差异性。<br>分析：现有的短视频推荐算法可以按照发布时间排序推荐，这是从发布者的角度出发。<br>反思：能不能从<strong>用户者的角度出发？</strong><br>1、因为视频号足够短，信息浓缩度高，只要可以精准分发，<strong>就能戳中痛点快速帮助用户解析眼前问题。</strong><br>2、用户会把着当作碎片化时代的心理咨询师、贴心小帮手、<strong>微信本质是工具。</strong><br>3、用户心理：视频号真懂我，每时每刻和我同行，<strong>它是我的魔法师，懂猜心术，</strong>不让我沉迷娱乐浪费时间，它是在<strong>帮我随时随地解决需求、让我过好正能量的每一天，</strong>有了它，我生活更加方便、舒心了，<strong>抖音看再多，都是别人的狂欢，还是要回到现实生活调整好自己的节奏、用心打理自己的生活。</strong><br><strong>场景：用户在一天的不同时间场景下需求是不同的，我们只要一分钟，用高效优质内容帮您快速解决紧急需求！</strong><br>1、比如早上想听比较<strong>欢快的音乐、搞笑的闹钟铃声</strong>开启一天新生活。<br>2、从视频中选择优质、用户好友喜欢、或者用户曾经点赞的<strong>温情励志鸡汤类</strong>的一分钟短视频，激发用户开启努力工作的每一天。<br>3、我们还可以选取关于<strong>早餐美食、早茶文化、日出、闹钟、出门穿搭、化妆干货经验</strong>的优质短视频。助力美美出门！<br>4、到了十点左右，学生用户推荐<strong>学习加油站、学生广播体操、课间文化、智力游戏、学习标兵PK</strong>视频。点燃学习激情。<br>5、十点职场达人：外卖最新单品种草分享帮助您优化午餐选择、工作日程管理干货祝您解决业务难题、只要一分钟，可能给您带来意想不到的优质体验。<br>6、午饭时间：农民伯伯种田视频、舌尖上的中国、美食点评、优质吃播（为了传播中国饮食文化而不是空洞的表演）。<br>7、下午四点：英国人喜欢下午茶，可以推荐一些缓解压力的风景短片、主要为了调节工作气氛，帮助用户更好的复盘一天的工作。<br>8、晚饭时间：家人其乐融融的场景短片，万家灯火的车水马龙，给用户一种要回家的归属感。<br>9、7点：中国人的标配：准时新闻联播，通过短视频一分钟提炼，可以快速获取最新资讯和点评。<br>10、睡眠：轻音乐、书评、助力生活解惑，关注内心成长，因为人们喜欢在安静的夜晚深入思考，白天过于喧嚣。<br><strong>预想结果：<br>   消费者层面：</strong><br>1、视频号真懂我，每时每刻和我同行，<strong>它是我的魔法师，懂猜心术，</strong>不让我沉迷娱乐浪费时间，它是在<strong>帮我随时随地解决需求、让我过好正能量的每一天。<br>2、</strong>有了它，我生活更加方便、舒心了，<strong>抖音看再多，都是别人的狂欢，还是要回到现实生活调整好自己的节奏、用心打理自己的生活。</strong><br><strong>生产者层面：</strong><br>1、我的粉丝<strong>每时每刻都需要我</strong>，<strong>因为他们在和我相同的时间维度上</strong> ，明天我的粉丝在讨论什么新鲜话题呢？我主打中国饮食，要时常更新才能让粉丝<strong>每一天都可以在固定的时间和我见面呀</strong>，虽然我们是粉丝弱关系，但是我每天都要和朋友们约会，作为饮食达人，我要努力打磨自己的视频号。<br>2、时间是不可逆的，珍惜时间，努力做出好产品。<br><strong>平台层面的战术考量：</strong><br>1、我们的初心是为了提升用户体验，和其他短视频拉开差距的，虽然其他短视频每天都是推送用户感兴趣的话题，但是它们只是内容上切分，没有从时间维度考虑，但是，<strong>短视频的体验效果和时间场景是有很大联系的！</strong><br>2、用户来看这个视频，其他平台是无聊打发时间，图个乐子，一天之内啥时候看都行，每天看不看无所谓，看心情咯，今天工作忙就不娱乐了。<br>3、用户来视频号，不仅仅是为了娱乐，更是为了多和陌生人互动，我为什么要天天来看呢？<br>  <strong>因为它很短，但是很有料<br>  能根据每天的不同时间点给我推荐不同类型的我感兴趣的话题<br>  很能帮助我快速解决不同时间和场景下的视频需求。<br>  视频号不是消磨我的时间，它是我的猜心小帮手，了解我现在想看啥，真有趣，还能根据早中晚区别我的想法，真智能。<br>  视频号不仅仅是别人的世界，这里也有我的生活思考和点滴记录<br>  打开视频号，看这热络鲜活的世界，最新鲜最懂我。</strong></p>
<p> <strong>差异化优势：</strong><br> 1、用户众多，相比抖音一二线，快手三四线、B站二次元、视频号是一个全中国人都在用的记录平台。<br> 2、<strong>每天定点推送我想要的视频 ：</strong>它就像个小闹钟，聪明精确的了解我每时每刻的需求和偏好，更智能更高效。抖音消磨我的时间，每时每刻都是同类型的视频，我想在不同时间尝鲜，晚上适合思考，白天适合娱乐，我是地道中国人！<br> 3、我的朋友、我的粉丝、我的偶像都在这里，<strong>真实简单，这是更接地气的社区平台</strong>，不仅可以和陌生人社交，还可以和同圈子的人交流，<strong>真是一呼百应，就像小蝴蝶，说不定一不小心，我闪动了小小的蝴蝶效应，改变了世界的认知呢</strong>，我要好好打磨作品，给世界留下点我的思考印记，<strong>这个平台传作简单、气氛又好，每时每刻都很热闹，我就粘在这里啦</strong>。<br> <strong>推荐方式机制</strong><br>1、按照内容发布时间倒序为主、点赞量、评论量、转发量和收藏量为辅的排序方式。<br>发布时间倒序：按照内容发布时间新旧排序，新发布的内容用户先看到；<br>点赞量、评论量、转发量和收藏量为辅：如果存在发布时间相同的内容，先按照用户点赞量递减排序；点赞量相同，按照评论量递减；评论量相同按照转发量递减；转发量相同按照收藏量递减。如果收藏量相同则按照后台获取的优先顺序排序。<br>2、做好内容池排序标签后，推送上按照一天24小时，分四段时间区域切分，在不同时间块，根据行为习惯，加入基于用户角度的时间权重。<br>3、其余权重采用人以类聚，物以群分的规则，划分关键词，提取特征向量，做双向维度匹配。<br>4、迭代用户历史记录行为和内容标签，优化算法方案。<br>5、列举上述4条的优先级排序，设置不同权重，然后按照由强及弱进行推荐。<br>6、做此类推荐首先需要有内容数据支撑和用户行为支撑作为冷启动。<br><strong>数据分析迭代：</strong><br>观察类型：<br>1、不同类型间的内容播放数据（平均浏览量环比前日增长）<br>可能原因分析：<br>有的类型是正增长，而较多类型处于负增长主要原因有两个：<br>A: 用户基数较小，探究的样本空间就相对较小，所以分化比较严重；<br>B:这段时间为内容创作适应阶段，需要长期对标用户，调整创作方案和创作类型。<br>2、用户次日留存，平均看视频时长、视频号板块使用时间。</p>
<h2 id="二、内容筛选上主攻垂直化——正向激励（知识性）、Z时代文化（趣味性）、新闻资讯（时效性）、中国文化（时空交错性"><a href="#二、内容筛选上主攻垂直化——正向激励（知识性）、Z时代文化（趣味性）、新闻资讯（时效性）、中国文化（时空交错性" class="headerlink" title="二、内容筛选上主攻垂直化——正向激励（知识性）、Z时代文化（趣味性）、新闻资讯（时效性）、中国文化（时空交错性)"></a>二、内容筛选上主攻垂直化——正向激励（知识性）、Z时代文化（趣味性）、新闻资讯（时效性）、中国文化（时空交错性)</h2><p>   创作者要清晰定位、优质输出。优秀，是会传染的，做好闭环激励，一切皆有可能。<br>   创作者需要根据的用户反馈，快速调整创作方案，再迅速投到产品中等待再次反馈最新的内容。<br>   强关系社区，更强调娱乐性、生活化分享以及存在区域性特征。<br>   弱关系社区，则更强调信息的价值、快捷，媒体属性更强。<br>   弱关系平台可能是我们展示自己的一个公平的舞台，你可以把才华在这里无障碍的表现出来。<br>   弱关系平台获得自己人生中的很多以前不会有的机会和认同。<br>   我个人认为，新浪微博这样的东西，更多的是要做自己的个人品牌。<br>   而对于强关系的社区来说，则要注意保护自己的隐私和形象，以免成为别人的谈资和笑柄，影响你在圈子内的形象。</p>
<p> <strong>1、基于哲学：</strong>一个基于特定文化或者主题来交流、互动并持续产生内容的空间，简称“同好互动空间”。<br>弱关系社区中，关键是你对和你建立联系的事物，是否产生了感应。比如点赞、评论、分享等互动操作。<br>类比视频版的知乎，缩略般的B站、去中心化版的微博。<br>意义：<br>一部基于物的生活知识的百科全书（好物推荐、种草合集、生活小常识）、一部基于人的经验分享和情感解惑（关乎学习、职场、恋爱）。<br>  2.<strong>基于个人</strong>：记录自己，记录世界，记录自己与世界的联系。重要的是减小朋友圈发文的人设压力，在陌生人关系中大胆释放自己。<br>意义：<br>我们只有不断地与各类人员进行交往和信息沟通，才能不断地丰富自己、发展自己、扩充自己。<br>记下生活的灵感和感动，类比个人精炼的成长日记，关乎生活的辛酸苦辣，关乎个人成长历程、心路轨迹。<br>（游戏规则是带有个人简介，我们要清晰自己的定位，也是帮助我们找到自己的差异化优势和稀缺性特质）<br>  3.<strong>基于品牌</strong>：记录中小型企业生产品牌的流程，全程拍摄品牌打造、精雕细琢的细节，传达企业的真诚和品牌的优质，让用户亲眼可见、增强对企业的关注度、对品牌的认知度。比如现有的内测的钻石、服装、无人机产业。<br>意义：<br>对于品牌，打通公众号宣传、小程序直播、实现商业化变现的通道。<br>对于用户，真实、快速、立体、全面感知产品的差异化优势，丰富知识面，扩展视野格局，更方便更快速买到更放心的优质产品。<br>  4.<strong>基于媒体</strong>：记录时事热点、媒体资讯、关乎天下大事、家国情怀。<br>意义：<br>为社会热点留白，等待时机造势，当媒体活动宣发时，这是很好的流量入口 。<br>（说不定下一个微信红包的热点降临、健康码、出行公交码的热潮会借助视频号来引爆支付产业瓜分半壁江山)。<br><strong>平台内容过滤机制：</strong><br>通过平台用户对内容打分，过滤出优质内容和劣质内容，将优质内容推送给其他更多用户，劣质内容则淘汰不在推送。<br>初步设想实现方式如下：<br>1、制定随机种子：内容随机推送给100个用户（数量根据平台用户规模和库内内容存量定），然后通过100个用户对内容的行为操作统计分数。<br>2、优劣判断：设定优劣分数判定标准，150分以上为优质。（每个平台不一样，根据用户规模、内容情况和历史数据判定）。<br>3、优质推送规则：100个随机用户完成打分后，将优质内容按照分数高低推送给其他用户，同时优质内容每天也会再次进行重计分和重排序。<br>4、打分规则：内容得分=是否分享<em>分数+是否关注</em>分数+是否评论<em>分数+是否点赞</em>分数+是否收藏<em>分数。<br>分数：指的是每个行为占比，这里，设定所有行为总分=10，其余各项分别=1；<br>这里没有考虑完播率：*</em>目前视频号不支持跳播，提倡慢文化，细细品味优质内容，个人认为设计很棒，有差异性。带来不一样的用户体验，要培养快餐文化下的细品习惯。**<br>功能上线后，保证优质内容持续产生；研究用户平均使用时长；研究用户留存情况；优化运营推广的方案。</p>
<h2 id="三、宣传产品的策略"><a href="#三、宣传产品的策略" class="headerlink" title="三、宣传产品的策略"></a>三、宣传产品的策略</h2><p>1、好的产品会说话，定位要精准、犀利、用户对产品的第一认知非常重要，产品最深入人心的是认知，认知可扭曲现实。<br>2、针对不同用户画像，深挖痛点、精准投放。<br>3、好的宣传，是真诚大于套路，但本质还是套路。<br>4、把精准的人设，通过合适的渠道，合适的时间，投放到合适的人群，参考直播策略 人、货、场的饥饿营销模式。</p>
<p><strong>1、宣传视频号的小创意</strong><br><strong>slogan: 拒绝蹉跎度日，记录朝花夕拾，人间贵在真实，你我载入历史。</strong><br>以上四句话对应区别抖音、鼓舞用户创造、产品定位、时代意义。<br>快抖是可乐，快感中少了营养，<strong>微信是青山悠悠，蝴蝶翩翩，带你飞向未知的诗和远方。</strong><br>哲学版：<br>1、我们要追求那真实的功业，要追求对宇宙人生更深远的了解；要追求永远超过狭小生活圈子之外的更有用的东西。<br>2、让整个一生都在追求中度过吧。那么在这一生中必定会有许许多多美好的时刻。<br>3、看清这个世界，然后爱它。<br>4、人类经常把一个生涯发生的事，撰写成历史，在从那里看人生。其实，那不过是隐，人生是内在的。<br>5、与其花许多时间和精力去凿许多浅井，不如花同样的时间和精力去凿一口深井。<br>6、一个人的痛苦，无非来自两个方面，一是没有个性，另一个是个性太强。<br>7、累累的创伤，就是生命给你的最好东西，因为在每个创伤上面都标志着前进的一步。<br>8、什么是生命？它并不是象冷酷的理智和我们的肉眼所见到的那个模样，而是我们幻想中的那个模样。生命的节奏是爱。<br>9、给时间以岁月，给岁月以文明。<br>10、有趣是个开放的空间，一直伸往未知的领域。<br>11、有趣和生活与年龄无关，你选择什么样的生活由你决定，从何时开始改变由你做主。<br>12、世界是美好与未知的，世界也是无趣与必然的。在这个认识的过程中去创造美，去获取快乐。<br>13、当信息足够公开，话语权足够平等，并且时间足够长，最终的结果一定是最好的。<br>14、区块链，更是一个美好的技术理念，但它所建构的基础，却诚然是我们“肮脏”的物理世界，“腐朽”的人性社会。<br>15、产品是技术和艺术的结合。<br>16、微信一直坚守君子之交淡若水的社交原则，从未改变。<br><strong>喜闻乐见版：</strong><br>1.还在抖音刷视频虚度光阴吗？临渊羡鱼，不如退而结网，来视频号提升自己吧！人生还有更独特的诗意和远方！<br>2.还在快手看直播吗？你想要的，视频号都有！精挑细选，有你好看~<br>3.还在知乎海淘干货、面经吗？视频版的浓缩精华，视频号等你来分享~<br>4.还在B站倍速播放卡槽点吗？慢一点，让我们享受一分钟的干货精华。<br>5.还在微博海量信息中大海捞针吗？这里有专属优质小圈，用料考究，视听盛宴等你来哦~<br>6.这是一部修身、齐家、治国、平天下的短视频版《资治通鉴》！<br>7.我们终将老去，来视频号沉淀您的即刻视频！。<br>8.沉淀前世今生的数字资产！<br>9.时光一去不复返，视频号里转一转。<br>10.人要怎么度过这一生？<br>当他回首往事的时候，他不会因为虚度年华刷抖音而悔恨，也不会因为碌碌无为逛淘宝而羞耻；<br>这样，在临死的时候，他就能够说：“我的整个生命和全部回忆都已经献给世界上最壮丽的事业———在视频号和陌生的你相遇。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E8%A7%86%E9%A2%91%E5%8F%B7%E6%80%9D%E8%80%83/" rel="tag">视频号思考</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E8%A7%86%E9%A2%91%E5%8F%B7%E6%98%AF%E4%BC%9F%E5%A4%A7%E7%9A%84/" rel="tag">视频号是伟大的</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-React项目需求分析" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2020/03/17/React%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"
    >React项目需求分析</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2020/03/17/React%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2020-03-16T16:00:00.000Z" itemprop="datePublished">2020-03-17</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/React%E5%AE%9E%E6%88%98%E5%B0%8F%E7%BB%93/">React实战小结</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="1-项目开发准备"><a href="#1-项目开发准备" class="headerlink" title="1. 项目开发准备"></a>1. 项目开发准备</h2><pre><code>1). 描述项目
2). 技术选型 
3). API接口/接口文档/测试接口</code></pre><h2 id="2-启动项目开发"><a href="#2-启动项目开发" class="headerlink" title="2. 启动项目开发"></a>2. 启动项目开发</h2><pre><code>1). 使用react脚手架创建项目
2). 开发环境运行: npm start
3). 生产环境打包运行: npm run build   serve build</code></pre><h2 id="3-git管理项目"><a href="#3-git管理项目" class="headerlink" title="3. git管理项目"></a>3. git管理项目</h2><pre><code>1). 创建远程仓库
2). 创建本地仓库
    配置.gitignore
    git init
    git add .
    git commit -m &quot;init&quot;
3). 将本地仓库推送到远程仓库
    git remote add origin url
    git push origin master
4). 在本地创建dev分支, 并推送到远程
    git checkout -b dev
    git push origin dev
5). 如果本地有修改
    git add .
    git commit -m &quot;xxx&quot;
    git push origin dev
6). 新的同事: 克隆仓库
    git clone url
    git checkout -b dev origin/dev
    git pull origin dev
7). 如果远程修改了
    git pull origin dev
8). 如何得到后面新增的远程分支
    git pull
    git checkout -b dev origin/xxx</code></pre><h2 id="4-创建项目的基本结构"><a href="#4-创建项目的基本结构" class="headerlink" title="4. 创建项目的基本结构"></a>4. 创建项目的基本结构</h2><pre><code>api: ajax请求的模块
components: 非路由组件
pages: 路由组件
App.js: 应用的根组件
index.js: 入口js</code></pre><h2 id="5-引入antd"><a href="#5-引入antd" class="headerlink" title="5 引入antd"></a>5 引入antd</h2><pre><code>下载antd的包
按需打包: 只打包import引入组件的js/css
    下载工具包
    config-overrides.js
    package.json
自定义主题
    下载工具包
    config-overrides.js
使用antd的组件
    根据antd的文档编写</code></pre><h2 id="6-引入路由"><a href="#6-引入路由" class="headerlink" title="6. 引入路由"></a>6. 引入路由</h2><pre><code>下载包: react-router-dom
拆分应用路由:
  Login: 登陆
  Admin: 后台管理界面
注册路由:
  &lt;BrowserRouter&gt; / &lt;HashRouter&gt;
  &lt;Switch&gt;
  &lt;Route path=&apos;&apos; component={}/&gt;</code></pre><h2 id="7-Login的静态组件"><a href="#7-Login的静态组件" class="headerlink" title="7. Login的静态组件"></a>7. Login的静态组件</h2><pre><code>1). 自定义了一部分样式布局
2). 使用antd的组件实现登陆表单界面
  Form  / Form.Item
  Input
  Icon
  Button</code></pre><h2 id="8-相关知识点"><a href="#8-相关知识点" class="headerlink" title="8. 相关知识点"></a>8. 相关知识点</h2><pre><code>1). 区别开发环境运行和生产环境打包运行
2). 路由的理解</code></pre><h2 id="1-收集表单数据和表单的前台验证"><a href="#1-收集表单数据和表单的前台验证" class="headerlink" title="1. 收集表单数据和表单的前台验证"></a>1. 收集表单数据和表单的前台验证</h2><pre><code>1). form对象
    如何让包含&lt;Form&gt;的组件得到form对象?  WrapLoginForm = Form.create()(LoginForm)
    WrapLoginForm是LoginForm的父组件, 它给LoginForm传入form属性
    用到了高阶函数和高阶组件的技术

2). 操作表单数据
    form.getFieldDecorator(&apos;标识名称&apos;, {initialValue: 初始值, rules: []})(&lt;Input/&gt;)包装表单项标签
    form.getFieldsValue(): 得到包含所有输入数据的对象
    form.getFieldValue(id): 根据标识得到对应字段输入的数据

3). 前台表单验证
    a. 声明式实时表单验证:
        form.getFieldDecorator(&apos;标识名称&apos;, {rules: [{min: 4, message: &apos;错误提示信息&apos;}]})(&lt;Input/&gt;)
    b. 自定义表单验证
        form.getFieldDecorator(&apos;标识名称&apos;, {rules: [{validator: this.validatePwd}]})(&lt;Input/&gt;)
        validatePwd = (rule, value, callback) =&gt; {
          if(有问题) callback(&apos;错误提示信息&apos;) else callack()
        } 
    c. 点击登陆时统一验证
        form.validateFields((error, values) =&gt; {
          if(!error) {通过了验证, 发送ajax请求}
        })</code></pre><h2 id="2-高阶函数与高阶组件"><a href="#2-高阶函数与高阶组件" class="headerlink" title="2. 高阶函数与高阶组件"></a>2. 高阶函数与高阶组件</h2><pre><code>1). 高阶函数
    定义: 接收的参数是函数或者返回值是函数
    常见的: 数组遍历相关的方法 / 定时器 / Promise / 高阶组件 / fn.bind(obj)()
    作用: 实现一个更加强大, 动态的功能

2). 高阶组件: 
    本质是一个函数
    函数接收一个组件, 返回一个新的组件
    Form.create()返回的就是一个高阶组件   

3). 高阶组件与高阶函数的关系
    高阶组件是特别的高阶函数
    接收一个组件函数, 返回是一个新的组件函数</code></pre><h2 id="3-后台应用"><a href="#3-后台应用" class="headerlink" title="3. 后台应用"></a>3. 后台应用</h2><pre><code>启动后台应用: mongodb服务必须启动
使用postman测试接口(根据接口文档):
    访问测试: post请求的参数在body中设置
    保存测试接口
    导出/导入所有测试接口</code></pre><h2 id="4-编写ajax代码"><a href="#4-编写ajax代码" class="headerlink" title="4. 编写ajax代码"></a>4. 编写ajax代码</h2><pre><code>1). ajax请求函数模块: api/ajax.js
    封装axios: interceptor + promise
    a. 解决post请求参数后台不能读取问题: axios默认以json形参传递请求体参数, 在请求拦截器中转换成urlencode形式
    b. 请求成功的结果不再是response, 而是reponse.data: 使用响应拦截器成功的回调返回response.data
    c. 内部统一处理请求异常: 在响应拦截失败的回调中返回pending状态的promise, 中断promise链

2). 接口请求函数模块: api/index.js
    根据接口文档编写(一定要具备这个能力)
    接口请求函数: 调用ajax模块发请求, 返回值promise对象

3). 解决ajax跨域请求问题(开发时)
    办法: 配置代理  ==&gt; 开发的配置不能用于生产环境
    编码: package.json: proxy: &quot;http://localhost:5000&quot;

4). 对代理的理解
    a. 是什么?
        具有特定功能的程序: webpack-dev-server ==&gt; http-proxy-middleware
    b. 运行在哪?
        前台应用端, 不在后台应用端
        只能在开发时使用
    c. 作用?
        解决开发时的ajax请求跨域问题
        a. 监视并拦截请求(3000)
        b. 转发请求(4000)
    d. 配置代理
        告诉代理服务器一些信息: 比如转发的目标地址
        开发环境: 前端工程师
        生产环境: 后端工程师
5). async和await的理解和使用
    a. 作用?
       简化promise对象的使用: 不用再使用then()来指定成功/失败的回调函数
       以同步编码(没有回调函数了)方式实现异步流程
    b. 哪里写await?
        在返回promise的表达式左侧写await: 不想要promise, 想要promise异步执行的成功的value数据
    c. 哪里写async?
        await所在函数(最近的)定义的左侧写async</code></pre><h2 id="5-实现登陆-包含自动登陆"><a href="#5-实现登陆-包含自动登陆" class="headerlink" title="5. 实现登陆(包含自动登陆)"></a>5. 实现登陆(包含自动登陆)</h2><pre><code>login.jsx
    1). 调用登陆的接口请求
    2). 如果失败, 显示错误提示信息
    3). 如果成功了:
        保存user到local/内存中
        跳转到admin
    4). 如果内存中的user有值, 自动跳转到admin
admin.jsx
    判断如果内存中没有user(_id没有值), 自动跳转到login
storageUtils.js
    包含使用localStorage来保存user相关操作的工具模块
    使用第三库store
        简化编码
        兼容不同的浏览器
memoryUtils.js
    用来在内存中保存数据(user)的工具类, user的初始值从local中读取</code></pre><h2 id="1-LeftNav组件"><a href="#1-LeftNav组件" class="headerlink" title="1. LeftNav组件"></a>1. LeftNav组件</h2><pre><code>1). 使用antd的组件
    Menu / Menu.Item / Menu.SubMenu

2). 使用react-router
    withRouter(): 包装非路由组件, 给其传入history/location/match属性
    history: push()/replace()/goBack()
    location: pathname属性
    match: params属性

3). componentWillMount与componentDidMount的比较
    componentWillMount: 在第一次render()前调用一次, 为第一次render()准备数据(同步)
    componentDidMount: 在第一次render()之后调用一次, 启动异步任务, 后面异步更新状态重新render

4). 根据配置数据动态生成Item和SubMenu的数组
    map() + 递归: 多级菜单列表
    reduce() + 递归: 多级菜单列表

5). 2个问题?
    刷新时如何选中对应的菜单项?
        selectedKey是当前请求的path
    刷新子菜单路径时, 自动打开子菜单列表?
        openKey是 一级列表项的某个子菜单项是当前对应的菜单项</code></pre><h2 id="2-Header组件"><a href="#2-Header组件" class="headerlink" title="2. Header组件"></a>2. Header组件</h2><pre><code>1). 界面静态布局
    三角形效果
2). 获取登陆用户的名称显示
    MemoryUtils
3). 当前时间
    循环定时器, 每隔1s更新当前时间状态
    格式化指定时间: dateUtils
4). 天气预报
    使用jsonp库发jsonp请求百度天气预报接口
    对jsonp请求的理解
5). 当前导航项的标题
    得到当前请求的路由path: withRouter()包装非路由组件
    根据path在menuList中遍历查找对应的item的title
6). 退出登陆
    Modal组件显示提示
    清除保存的user
    跳转到login
7). 抽取通用的类链接按钮组件
    通过...透传所有接收的属性: &lt;Button {...props} /&gt;    &lt;LinkButton&gt;xxxx&lt;/LinkButton&gt;
    组件标签的所有子节点都会成为组件的children属性</code></pre><h2 id="3-jsonp解决ajax跨域的原理"><a href="#3-jsonp解决ajax跨域的原理" class="headerlink" title="3. jsonp解决ajax跨域的原理"></a>3. jsonp解决ajax跨域的原理</h2><pre><code>1). jsonp只能解决GET类型的ajax请求跨域问题
2). jsonp请求不是ajax请求, 而是一般的get请求
3). 基本原理
    浏览器端:
        动态生成&lt;script&gt;来请求后台接口(src就是接口的url)
        定义好用于接收响应数据的函数(fn), 并将函数名通过请求参数提交给后台(如: callback=fn)
    服务器端:
        接收到请求处理产生结果数据后, 返回一个函数调用的js代码, 并将结果数据作为实参传入函数调用
    浏览器端:
        收到响应自动执行函数调用的js代码, 也就执行了提前定义好的回调函数, 并得到了需要的结果数据</code></pre><h2 id="1-Category组件使用antd组件构建分类列表界面"><a href="#1-Category组件使用antd组件构建分类列表界面" class="headerlink" title="1. Category组件使用antd组件构建分类列表界面"></a>1. Category组件使用antd组件构建分类列表界面</h2><pre><code>Card
Table
Button
Icon</code></pre><h2 id="2-相关接口请求函数"><a href="#2-相关接口请求函数" class="headerlink" title="2. 相关接口请求函数"></a>2. 相关接口请求函数</h2><pre><code>获取分类列表
添加分类
更新分类</code></pre><h2 id="3-异步显示分类列表"><a href="#3-异步显示分类列表" class="headerlink" title="3. 异步显示分类列表"></a>3. 异步显示分类列表</h2><pre><code>设计分类列表的状态: categorys
异步获取分类列表: componentDidMount(){}
更新状态显示</code></pre><h2 id="4-添加分类"><a href="#4-添加分类" class="headerlink" title="4. 添加分类"></a>4. 添加分类</h2><pre><code>1). 界面
    antd组件: Modal, Form, Select, Input
    显示/隐藏: showStatus状态为1/0

2). 功能
    父组(Category)件得到子组件(CategoryForm)的数据(form)
    调用添加分类的接口
    重新获取分类列表</code></pre><h2 id="5-更新分类"><a href="#5-更新分类" class="headerlink" title="5. 更新分类"></a>5. 更新分类</h2><pre><code>1). 界面
    antd组件: Modal, Form, Input
    显示/隐藏: showStatus状态为2/0

2). 功能
    父组(Category)件得到子组件(CategoryForm)的数据(form)
    调用更新分类的接口
    重新获取分类列表
3). 重要问题
    描述: &lt;Input&gt;指定initialValue后, 如果输入改变了, 再指定新的initialValue, 默认显示输入的值
    解决: 在关闭Modal时, 进行表单项重置: form.resetFields()</code></pre><h2 id="6-Product整体路由"><a href="#6-Product整体路由" class="headerlink" title="6. Product整体路由"></a>6. Product整体路由</h2><pre><code>1). 配置子路由: 
    ProductHome / ProductDetail / ProductAddUpdate
    &lt;Route&gt; / &lt;Switch&gt; / &lt;Redirect&gt;

2). 匹配路由的逻辑:
    默认: 逐层路由不完全匹配   &lt;Route path=&apos;/product&apos; component={ProductHome}/&gt;
    exact属性: 完全匹配</code></pre><h2 id="7-分页实现技术-2种"><a href="#7-分页实现技术-2种" class="headerlink" title="7. 分页实现技术(2种)"></a>7. 分页实现技术(2种)</h2><pre><code>1). 前台分页
    请求获取数据: 一次获取所有数据, 翻页时不需要再发请求
    请求接口: 
        不需要指定请求参数: 页码(pageNum)和每页数量(pageSize)
        响应数据: 所有数据的数组

2). 基于后台的分页
    请求获取数据: 每次只获取当前页的数据, 翻页时要发请求
    请求接口: 
        需要指定请求参数: 页码(pageNum)和每页数量(pageSize)
        响应数据: 当前页数据的数组 + 总记录数(total)

3). 如何选择?
    基本根据数据多少来选择</code></pre><h2 id="8-ProductHome组件"><a href="#8-ProductHome组件" class="headerlink" title="8. ProductHome组件"></a>8. ProductHome组件</h2><pre><code>1). 分页显示
   界面: &lt;Card&gt; / &lt;Table&gt; / Select / Icon / Input / Button
   状态: products / total
   接口请求函数需要的数据: pageNum, pageSize
   异步获取第一页数据显示
       调用分页的接口请求函数, 获取到当前页的products和总记录数total
       更新状态: products / total
   翻页:
       绑定翻页的监听, 监听回调需要得到pageNum
       异步获取指定页码的数据显示  </code></pre><h2 id="9-Array的声明式方法的实现"><a href="#9-Array的声明式方法的实现" class="headerlink" title="9. Array的声明式方法的实现"></a>9. Array的声明式方法的实现</h2><pre><code>1). map()
2). reduce()
3). filter()
4). find()/findIndex()
5). every()/some()</code></pre><h2 id="1-ProductHome组件"><a href="#1-ProductHome组件" class="headerlink" title="1. ProductHome组件"></a>1. ProductHome组件</h2><pre><code>2). 搜索分页
   接口请求函数需要的数据: 
       pageSize: 每页的条目数
       pageNum: 当前请求第几页 (从1开始)
       productDesc / productName: searchName 根据商品描述/名称搜索
   状态:  searchType / searchName  / 在用户操作时实时收集数据
   异步搜索显示分页列表
       如果searchName有值, 调用搜索的接口请求函数获取数据并更新状态

3). 更新商品的状态
   初始显示: 根据product的status属性来显示  status = 1/2
   点击切换:
       绑定点击监听
       异步请求更新状态

4). 进入详情界面
    memoryUtils.product = product
    history.push(&apos;/product/detail&apos;)
5). 进入添加界面
    memoryUtils.product = null
    history.push(&apos;/product/addupdate&apos;)
6). 进入修改界面
    memoryUtils.product = product
    history.push(&apos;/product/addupdate&apos;)</code></pre><h2 id="2-ProductDetail组件"><a href="#2-ProductDetail组件" class="headerlink" title="2. ProductDetail组件"></a>2. ProductDetail组件</h2><pre><code>1). 读取商品数据: memoryUtils.product
2). 显示商品信息: &lt;Card&gt; / List 
3). 异步显示商品所属分类的名称</code></pre><h2 id="3-ProductAddUpdate"><a href="#3-ProductAddUpdate" class="headerlink" title="3. ProductAddUpdate"></a>3. ProductAddUpdate</h2><pre><code>1). 基本界面
    Card / Form / Input / TextArea / Button
    FormItem的label标题和layout
2). 分类下拉列表的异步显示
3). 表单数据收集与表单验证</code></pre><h2 id="4-PicturesWall"><a href="#4-PicturesWall" class="headerlink" title="4. PicturesWall"></a>4. PicturesWall</h2><pre><code>1). antd组件
    Upload / Modal / Icon
    根据示例DEMO改造编写
2). 上传图片
    在&lt;Upload &gt;上配置接口的path和请求参数名
    监视文件状态的改变: 上传中 / 上传完成/ 删除
    在上传成功时, 保存好相关信息: name / url
    为父组件提供获取已上传图片文件名数组的方法
3). 删除图片
    当文件状态变为删除时, 调用删除图片的接口删除上传到后台的图片
4). 父组件调用子组件对象的方法: 使用ref技术
    a. 创建ref容器: thi.pw = React.createRef()
    b. 将ref容器交给需要获取的标签元素: &lt;PicturesWall ref={this.pw} /&gt;  // 自动将将标签对象添加为pw对象的current属性
    c. 通过ref容器读取标签元素: this.pw.current</code></pre><h2 id="1-RichTextEditor"><a href="#1-RichTextEditor" class="headerlink" title="1. RichTextEditor"></a>1. RichTextEditor</h2><pre><code>1). 使用基于react的富文本编程器插件库: react-draft-wysiwyg
2). 参考库的DEMO和API文档编写
3). 如果还有不确定的, 百度搜索, 指定相对准确的关键字</code></pre><h2 id="2-完成商品添加与修改功能"><a href="#2-完成商品添加与修改功能" class="headerlink" title="2. 完成商品添加与修改功能"></a>2. 完成商品添加与修改功能</h2><pre><code>1). 收集输入数据
    通过form收集: name/desc/price/pCategoryId/categoryId
    通过ref收集: imgs/detail
    如果是更新收集: _id
    将收集数据封装成product对象
2). 更新商品
    定义添加和更新的接口请求函数
    调用接口请求函数, 如果成功并返回商品列表界面</code></pre><h2 id="3-角色管理"><a href="#3-角色管理" class="headerlink" title="3. 角色管理"></a>3. 角色管理</h2><pre><code>1). 角色前台分页显示
2). 添加角色
3). 给指定角色授权
    界面: Tree
    状态: checkedKeys, 根据传入的role的menus进行初始化
    勾选某个Node时, 更新checkedKeys
    点击OK时: 通过ref读取到子组件中的checkedKeys作为要更新product新的menus
            发请求更新product
    解决默认勾选不正常的bug: 利用组件的componentWillReceiveProps()</code></pre><h2 id="4-用户管理"><a href="#4-用户管理" class="headerlink" title="4. 用户管理"></a>4. 用户管理</h2><pre><code>1). 显示用户分页列表
2). 添加用户
3). 修改用户
4). 删除用户</code></pre><h2 id="5-导航菜单权限控制"><a href="#5-导航菜单权限控制" class="headerlink" title="5. 导航菜单权限控制"></a>5. 导航菜单权限控制</h2><pre><code>1). 基本思路(依赖于后台): 
    角色: 包含所拥有权限的所有菜单项key的数组: menus=[key1, key2, key3]
    用户: 包含所属角色的ID: role_id
    当前登陆用户: user中已经包含了所属role对象
    遍历显示菜单项时: 判断只有当有对应的权限才显示
2). 判断是否有权限的条件?
    a. 如果当前用户是admin
    b. 如果当前item是公开的
    c. 当前用户有此item的权限: key有没有menus中
    d. 如果当前用户有此item的某个子item的权限</code></pre><h2 id="1-redux理解"><a href="#1-redux理解" class="headerlink" title="1. redux理解"></a>1. redux理解</h2><pre><code>什么?: redux是专门做状态管理的独立第3方库, 不是react插件, 但一般都用在react项目中
作用?: 对应用中状态进行集中式的管理(写/读)
开发: 与react-redux, redux-thunk等插件配合使用</code></pre><h2 id="2-redux相关API"><a href="#2-redux相关API" class="headerlink" title="2. redux相关API"></a>2. redux相关API</h2><pre><code>redux中包含: 
    createStore(), 
    applyMiddleware(), 
    combineReducers()
store对象: 
    getState(), 
    dispatch(), 
    subscribe()
react-redux: 
    &lt;Provider store={store}&gt;: 向所有的容器组件提供store
    connect(
        state =&gt; ({xxx: state.xxx}),
        {actionCreator1, actionCreator2}
    )(UI组件): 
        产生的就是容器组件, 负责向UI组件传递标签属性, 
        一般属性值从state中获取, 函数属性内部会执行dispatch分发action
redux-thunk
    createStore(reducer, applyMiddleware(thunk))
    dispatch(函数) ==&gt; 函数体内执行异步操作 ==&gt; 完成后dispatch同步action</code></pre><h2 id="3-redux核心概念-3个"><a href="#3-redux核心概念-3个" class="headerlink" title="3. redux核心概念(3个)"></a>3. redux核心概念(3个)</h2><pre><code>action: 
    默认是对象(同步action), {type: &apos;xxx&apos;, data: value}, 需要通过对应的actionCreator产生, 
    它的值也可以是函数(异步action), 需要引入redux-thunk才可以
reducer
    根据老的state和指定的action, 返回一个新的state
    不能修改老的state
store
    redux最核心的管理对象
    内部管理着: state和reducer
    提供方法: getState(), dispatch(action), subscribe(listener)</code></pre><h2 id="4-redux工作流程"><a href="#4-redux工作流程" class="headerlink" title="4. redux工作流程"></a>4. redux工作流程</h2><p><img src="file:///C:/Users/Fei/Documents/My%20Knowledge/temp/ed830b94-aa5c-4058-aa8b-db17d9f00154/128/index_files/bf81947f9a3a71970c687a87ea1369b0.JPG" alt></p>
<h2 id="5-项目中引入redux"><a href="#5-项目中引入redux" class="headerlink" title="5. 项目中引入redux"></a>5. 项目中引入redux</h2><pre><code>1). 下载相关的库
    redux
    react-redux
    redux-thunk
    redux-devtools-extension(这个只在开发时需要)
2). 创建redux文件夹
    action-types.js
    actions.js
    reducers.js
    store.js
3). store.js
    默认暴露创建的store对象
    指定好reducer
    应用上thunk异步中间件
    应用上redux调试插件

4). reducer.js
    为头部标题定义reducer函数: headerTitle
    为登陆的用户定义reducer函数: user
    通过combineReducers()来整合多个子reducer, 生成一个总的reducer函数
    总的state的结构: {headerTitle: &apos;xxx&apos;, user: {}}

5). action-types.js
    同步action对象的type名称常量

6). actions.js
    定义与type对应的同步action creator函数: 返回action对象
    定义异步action creator函数: 返回action函数

7). 在需要与redux通信的组件中
    引入connect函数
    引入action creator函数
    通过connect包装UI组件生成容器组件, 并暴露
        export default connect(
            state =&gt; ({}),
            {}
        )(UI组件)</code></pre><h2 id="1-setState-的使用"><a href="#1-setState-的使用" class="headerlink" title="1. setState()的使用"></a>1. setState()的使用</h2><pre><code>1). setState(updater, [callback]),
    updater为返回stateChange对象的函数: (state, props) =&gt; stateChange
    接收的state和props被保证为最新的
2). setState(stateChange, [callback])
    stateChange为对象,
    callback是可选的回调函数, 在状态更新且界面更新后才执行
3). 总结:
    对象方式是函数方式的简写方式
        如果新状态不依赖于原状态 ===&gt; 使用对象方式
        如果新状态依赖于原状态 ===&gt; 使用函数方式
    如果需要在setState()后获取最新的状态数据, 在第二个callback函数中读取</code></pre><h2 id="2-setState-的异步与同步"><a href="#2-setState-的异步与同步" class="headerlink" title="2. setState()的异步与同步"></a>2. setState()的异步与同步</h2><pre><code>1). setState()更新状态是异步还是同步的?
    a. 执行setState()的位置?
        在react控制的回调函数中: 生命周期勾子 / react事件监听回调
        非react控制的异步回调函数中: 定时器回调 / 原生事件监听回调 / promise回调 /...
    b. 异步 OR 同步?
        react相关回调中: 异步
        其它异步回调中: 同步

2). 关于异步的setState()
    a. 多次调用, 如何处理?
        setState({}): 合并更新一次状态, 只调用一次render()更新界面 ---状态更新和界面更新都合并了
        setState(fn): 更新多次状态, 但只调用一次render()更新界面  ---状态更新没有合并, 但界面更新合并了
    b. 如何得到异步更新后的状态数据?
        在setState()的callback回调函数中</code></pre><h2 id="3-Component与PureComponent"><a href="#3-Component与PureComponent" class="headerlink" title="3. Component与PureComponent"></a>3. Component与PureComponent</h2><pre><code>1). Component存在的问题?
    a. 父组件重新render(), 当前组件也会重新执行render(), 即使没有任何变化
    b. 当前组件setState(), 重新执行render(), 即使state没有任何变化

2). 解决Component存在的问题
    a. 原因: 组件的shouldcomponentUpdate()默认返回true, 即使数据没有变化render()都会重新执行
    b. 办法1: 重写shouldComponentUpdate(), 判断如果数据有变化返回true, 否则返回false
    c. 办法2: 使用PureComponent代替Component
    d. 说明: 一般都使用PureComponent来优化组件性能

3). PureComponent的基本原理
    a. 重写实现shouldComponentUpdate()
    b. 对组件的新/旧state和props中的数据进行浅比较, 如果都没有变化, 返回false, 否则返回true
    c. 一旦componentShouldUpdate()返回false不再执行用于更新的render()</code></pre>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/React/" rel="tag">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E4%B8%8E%E6%A2%B3%E7%90%86/" rel="tag">项目总结与梳理</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-JS异步解决方案的发展历程以及优缺点" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2020/03/11/JS%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9/"
    >JS异步解决方案的发展历程以及优缺点</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2020/03/11/JS%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9/" class="article-date">
  <time datetime="2020-03-11T15:59:00.342Z" itemprop="datePublished">2020-03-11</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>JS 异步已经告一段落了，这里来一波小总结~</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 回调函数（callback）</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// callback 函数体</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>缺点：回调地狱，不能用 try catch 捕获错误，不能 return<br>回调地狱的根本问题在于：<br>缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符<br>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（控制反转）<br>嵌套函数过多的多话，很难处理错误</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">'XXX1'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// callback 函数体</span></span><br><span class="line">    ajax(<span class="string">'XXX2'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// callback 函数体</span></span><br><span class="line">        ajax(<span class="string">'XXX3'</span>, () =&gt; &#123;</span><br><span class="line">            <span class="comment">// callback 函数体</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）</p>
<ol start="2">
<li>Promise<br>Promise就是为了解决callback的问题而产生的。<br>Promise 实现了链式调用，也就是说每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装<br>优点：解决了回调地狱的问题</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">'XXX1'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 操作逻辑</span></span><br><span class="line">      <span class="keyword">return</span> ajax(<span class="string">'XXX2'</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 操作逻辑</span></span><br><span class="line">      <span class="keyword">return</span> ajax(<span class="string">'XXX3'</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 操作逻辑</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>缺点：无法取消 Promise ，错误需要通过回调函数来捕获</p>
<ol start="3">
<li>Generator<br>特点：可以控制函数的执行，可以配合 co 函数库使用</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">fetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> ajax(<span class="string">'XXX1'</span>, () =&gt; &#123;&#125;)</span><br><span class="line">    <span class="keyword">yield</span> ajax(<span class="string">'XXX2'</span>, () =&gt; &#123;&#125;)</span><br><span class="line">    <span class="keyword">yield</span> ajax(<span class="string">'XXX3'</span>, () =&gt; &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = fetch()</span><br><span class="line"><span class="keyword">let</span> result1 = it.next()</span><br><span class="line"><span class="keyword">let</span> result2 = it.next()</span><br><span class="line"><span class="keyword">let</span> result3 = it.next()</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>Async/await<br>async、await 是异步的终极解决方案</li>
</ol>
<p>优点是：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题<br>缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式</span></span><br><span class="line">  <span class="comment">// 如果有依赖性的话，其实就是解决回调地狱的例子了</span></span><br><span class="line">  <span class="keyword">await</span> fetch(<span class="string">'XXX1'</span>)</span><br><span class="line">  <span class="keyword">await</span> fetch(<span class="string">'XXX2'</span>)</span><br><span class="line">  <span class="keyword">await</span> fetch(<span class="string">'XXX3'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来看一个使用 await 的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  a = a + <span class="keyword">await</span> <span class="number">10</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>, a) <span class="comment">// -&gt; '2' 10</span></span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line">a++</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>, a) <span class="comment">// -&gt; '1' 1</span></span><br></pre></td></tr></table></figure>
<p>对于以上代码你可能会有疑惑，让我来解释下原因</p>
<p>首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为 await 内部实现了 generator ，generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来<br>因为 await 是异步操作，后来的表达式不返回 Promise 的话，就会包装成 Promise.reslove(返回值)，然后会去执行函数外的同步代码<br>同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 0 + 10<br>上述解释中提到了 await 内部实现了 generator，其实 await 就是 generator 加上 Promise的语法糖，且内部实现了自动执行 generator。<br>在最新的ES7（ES2017）中提出的前端异步特性：async、await。</p>
<p>什么是async、await？<br>async顾名思义是“异步”的意思，async用于声明一个函数是异步的。而await从字面意思上是“等待”的意思，就是用于等待异步完成。并且await只能在async函数中使用</p>
<p>通常async、await都是跟随Promise一起使用的。为什么这么说呢？因为async返回的都是一个Promise对象同时async适用于任何类型的函数上。这样await得到的就是一个Promise对象(如果不是Promise对象的话那async返回的是什么 就是什么)；</p>
<p>await得到Promise对象之后就等待Promise接下来的resolve或者reject。</p>
<p>来看一段简单的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testSync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">         setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">             resolve(<span class="string">"async await test..."</span>);</span><br><span class="line">          &#125;, <span class="number">1000</span>);</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;</span><br><span class="line">testSync();<span class="comment">//async await test...</span></span><br></pre></td></tr></table></figure>

<p>就这样一个简单的async、await异步就完成了。使用async、await完成异步操作代码可读与写法上更像是同步的，也更容易让人理解。相对于es6的generator函数，更直观理解。</p>
<p><strong>async、await串行并行处理<br>串行：等待前面一个await执行后接着执行下一个await，以此类推</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncAwaitFn</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(str)</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> serialFn = <span class="keyword">async</span> () =&gt; &#123; <span class="comment">//串行执行</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">'serialFn'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> asyncAwaitFn(<span class="string">'string 1'</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> asyncAwaitFn(<span class="string">'string 2'</span>));</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'serialFn'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>serialFn();<br><strong>并行：将多个promise直接发起请求（先执行async所在函数），然后再进行await操作。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncAwaitFn</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(str)</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> parallel = <span class="keyword">async</span> () =&gt; &#123; <span class="comment">//并行执行</span></span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">'parallel'</span>)</span><br><span class="line">    <span class="keyword">const</span> parallelOne = asyncAwaitFn(<span class="string">'string 1'</span>);</span><br><span class="line">    <span class="keyword">const</span> parallelTwo = asyncAwaitFn(<span class="string">'string 2'</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//直接打印</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> parallelOne)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> parallelTwo)</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'parallel'</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">parallel()</span><br></pre></td></tr></table></figure>

<p>async、await错误处理<br>JavaScript异步请求肯定会有请求失败的情况，上面也说到了async返回的是一个Promise对象。既然是返回一个Promise对象的话那处理当异步请求发生错误的时候我们就要处理reject的状态了。<br>在Promise中当请求reject的时候我们可以使用catch。为了保持代码的健壮性使用async、await的时候我们使用try catch来处理错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">catchErr</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> errRes = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    reject(<span class="string">"http error..."</span>);</span><br><span class="line">                 &#125;, <span class="number">1000</span>);</span><br><span class="line">           );</span><br><span class="line">                <span class="comment">//平常我们也可以在await请求成功后通过判断当前status是不是200来判断请求是否成功</span></span><br><span class="line">                <span class="comment">// console.log(errRes.status, errRes.statusText);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">             <span class="built_in">console</span>.log(err);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">catchErr(); <span class="comment">//http error...</span></span><br></pre></td></tr></table></figure>
<p>以上就是async、await使用try catch 处理错误的方式。<br>async/await的使用使得 Promise操作更加方便了！</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="../../">上一页</a><a class="page-number" href="../../">1</a><span class="page-number current">2</span><a class="page-number" href="../3/">3</a><a class="page-number" href="../4/">4</a><span class="space">&hellip;</span><a class="page-number" href="../6/">6</a><a class="extend next" rel="next" href="../3/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2020
        Wangqiuxia
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    <aside class="sidebar">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="../../index.html"><img src="/images/ayer-side.svg" alt="爱产品，爱前端！"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../index.html">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../tags/%E6%8A%80%E6%9C%AF/">小程序</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../http:/shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../https:/v.xiumi.us/stage/v5/4IeLH/197507179">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="../../atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="../../images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="../../images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="../../js/jquery-2.0.3.min.js"></script>


<script src="../../js/jquery.justifiedGallery.min.js"></script>


<script src="../../js/lazyload.min.js"></script>


<script src="../../js/busuanzi-2.3.pure.min.js"></script>


<script src="../../js/share.js"></script>



<script src="../../fancybox/jquery.fancybox.min.js"></script>




<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['做一个有情怀懂产品的程序媛！','业精于勤荒于嬉！行成于思毁于随！','越努力越幸运'],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script>
  var ayerConfig = {
    mathjax: false
  }
</script>


<script src="../../js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=1436709403&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>