<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     爱产品，爱前端！
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="../../css/style.css">

  
<script src="../../js/pace.min.js"></script>


  

  

<link rel="alternate" href="atom.xml" title="爱产品，爱前端！" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/diamondto.github.io"
        target="_blank"><img width="149" height="149" src="../../images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="../../index.html">爱产品，爱前端！</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-云计算服务竞品分析" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/10/15/%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9C%8D%E5%8A%A1%E7%AB%9E%E5%93%81%E5%88%86%E6%9E%90/"
    >云计算服务竞品分析</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/10/15/%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9C%8D%E5%8A%A1%E7%AB%9E%E5%93%81%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2019-10-14T16:00:00.000Z" itemprop="datePublished">2019-10-15</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE/">人工智能与大数据</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="1-政策背景："><a href="#1-政策背景：" class="headerlink" title="1.政策背景："></a>1.政策背景：</h2><p>   2018年7月23日，为推动企业利用云计算加快数字化、网络化、智能化转型，推进互联网、大数据、人工智能与实体经济深度融合，工业和信息化部印发《推动企业上云实施指南(2018-2020年)》，对云计算应用的方方面面做出详细指导和支持，可谓是手把手教企业上云。随着“互联网+”行动的积极推进，我国云计算应用正从互联网行业向政务、金融、工业、轨道交通等传统行业加速渗透，云计算应用效果开始显现。<br><img src="https://img-blog.csdnimg.cn/20200310201628342.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>近几年，国内云计算产业发展、行业推广、市场监管等重要环节的<strong>宏观政策环境已经日趋完善。</strong><br>2015年，国务院先后出台三项与云计算密切相关的政策文件，为云计算发展奠定了重要政策基础;中央网信办发布了关于党政部门云计算安全管理的文件，在政务云领域发挥重要影响;新版《电信业务分类目录》针对云计算业务形态，明确了互联网资源协作服务业务的概念，相关市场管理政策相继配套出台;工信部于2017年发布《云计算发展三年行动计划(2017-2019年)》，提出了我国云计算发展的指导思想、基本原则、发展目标、重点任务和保障措施。<br>“十二五”末期，我国云计算产业规模已达1500亿元，产业发展势头迅猛、创新能力显著增强、服务能力大幅提升、应用范畴不断拓展，已成为提升信息化发展水平、打造数字经济新动能的重要支撑。但也存在市场需求尚未完全释放、产业供给能力有待加强、低水平重复建设现象凸现、产业支撑条件有待完善等问题。<br>为促进<strong>云计算快速健康发展</strong>，2017年3月30日，工业和信息化部印发《云计算发展三年行动计划(2017-2019年)》，明确了云计算发展的五项重点任务。<br><img src="https://img-blog.csdnimg.cn/20200310202324904.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="2-行业现状"><a href="#2-行业现状" class="headerlink" title="2.行业现状:"></a>2.行业现状:</h2><p>  从中国云计算市场产业链来看，互联网公司提供基于云的网络平台、在线存储等云端服务在云计算领域承担越来越重要的作用，将不断推动云计算产业链逐渐成熟和规范。 国内云计算公司众多，有提供IaaS+PaaS+SaaS全部服务的(比如腾讯云)，也有专做细分市场的(比如网宿、环信)。按背景可以将主流的服务商分为以下五类：<br><img src="https://img-blog.csdnimg.cn/20200310195719693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="3-竞品分类"><a href="#3-竞品分类" class="headerlink" title="3.竞品分类"></a>3.竞品分类</h2><p><img src="https://img-blog.csdnimg.cn/20200310203318750.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>  在能源电力和制造业等传统行业，天翼云和华为云等非互联网公司有着天然的优势。<br>  阿里云创立于2009年，是目前中国最大的云计算平台。<strong>阿里云致力于提供安全、可靠的计算和数据处理能力</strong>。用户通过阿里云，用互联网的方式即可远程获取海量计算、存储资源和大数据处理能力。阿里云已建成的超大规模数据中心包括华东、华北、华南、欧洲、美国、香港、日本、新加坡、欧洲、中东、澳大利亚，阿里云已经在全球主要互联网市场形成云计算基础设施覆盖，将为中国出海企业以及当地企业提供云计算服务。<br>   腾讯云创立于2010年，是腾讯公司打造的面向广大企业和个人的公有云平台。腾讯云有着深厚的基础架构，并且有多年对海量互联网服务的经验，<strong>不管是社交、游戏还是其他领域，都有多年成熟的产品</strong>。腾讯云在金融，电子商务和游戏领域有绝对优势，其中在手游云服务的市场份额已经达到46%。腾讯在云端完成重要部署，<strong>为开发者及企业提供云服务、云数据、云运营等整体一站式服务方案</strong>。作为目前中国互联网综合服务提供商和中国服务用户最多的互联网企业，腾讯正在积极通过云计算、云技术，推进互联网与各行业的融合创新。</p>
<h2 id="4-产品结构与功能分析"><a href="#4-产品结构与功能分析" class="headerlink" title="4.产品结构与功能分析"></a>4.产品结构与功能分析</h2><p>   阿里云产品体系包括云计算基础服务、大数据、安全(云盾)以及域名与网站(万网)四大部分。其中，大数据(数加)提供数据应用、数据分析展现、大数据基础服务以及人工智能四大类服务；安全(云盾)提供防御以及检测两大类服务；域名与网站(万网)提供域名注册、域名交易与转入、域名解析、云虚拟主机、网站建设以及阿里邮箱六大类服务。<br>   在行业解决方案方面，阿里云推出了通用解决方案、行业解决方案、专项解决方案以及大数据解决方案。其中，通用解决方案包括网站解决方案、移动APP解决方案、专有云解决方案和混合云解决方案；行业解决方案覆盖电商、音视频、金融、游戏、医疗、政务、渲染等行业；专项解决方案包括安全、 云存储、容灾、企业互联网架构等；大数据解决方案包括个性化推荐、大数据仓库、云上数据集成方案、 路况预测等。<br>     <img src="https://img-blog.csdnimg.cn/20200310204615296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="阿里云产品体系结构和行业解决方案  "><br>    腾讯云产品体系包括基础产品、域名服务以及大数据与AI三大部分。其中，域名服务模块提供域名注册、域名安全、解析与备案四个功能。除此之外，大数据模块提供大数据处理套件、云搜、文智自然语言处理、机智机器学习、用户洞察分析与云推荐引擎功能，AI提供万象优图、智能语音服务与微金小云客服功能。<br>    腾讯云已经拥有完整的产品体系，为合作伙伴提供多样化、高性能的云服务。腾讯云同时提供通用解决方案、行业解决方案以及技术解决方案。其中，通用解决方案包括视频、位置服务、网站、微信生态、运维等服务；行业解决方案覆盖了游戏、O2O、金融、广告、医疗、在线教育、电商、智能硬件、 旅游、政务行业；技术解决方案提供安全、数据迁移与直播安全服务。<br>    <img src="https://img-blog.csdnimg.cn/20200310204834888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="腾讯云产品体系结构和行业解决方案"></p>
<h2 id="5-行业解决方案对比"><a href="#5-行业解决方案对比" class="headerlink" title="5.行业解决方案对比"></a>5.行业解决方案对比</h2><p>1.阿里云凭着资源量和创新能力，目前在中国的公有云市场占据着绝对优势。<br>2.而腾讯云作为后起之秀，并没有急于占据所有行业云市场，而是把战略重点放在了与原有业务相关的金融，电子商务和游戏领域，使得其迅速在游戏云占据了市场第一的位置。</p>
<h2 id="总结与建议"><a href="#总结与建议" class="headerlink" title="总结与建议"></a>总结与建议</h2><p>总结<br>就产品和服务种类而言，阿里云在国内处于遥遥领先的地位，腾讯云的产品比阿里云略少，但其在游戏、社交、视频、移动等方面有着非常丰富的经验和实力。另外，腾讯云的用户界面设计也略优于阿里云。</p>
<p>建议<br>阿里云：巩固现有龙头地位，积极拓展其他业务，加大在视频直播、游戏研发、移动服务研发的投入，在这些领域追赶腾讯云。</p>
<p>腾讯云：保持现有优势，步步为营，增加业务范畴，条件允许的情况下通过更优惠的价格吸引更多的用户。</p>
<p>随着云计算应用的不断深入，以及对大数据处理需求的不断扩大，云计算市场会进一步扩大，无论是阿里云还是腾讯云都应抓住时机，做好现有产品，推出更多新型产品，才能在未来的云计算服务市场抢占更多的位置。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E4%BA%91%E8%AE%A1%E7%AE%97/" rel="tag">云计算</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-React中绑定this并传参的几种方式" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/10/10/React%E4%B8%AD%E7%BB%91%E5%AE%9Athis%E5%B9%B6%E4%BC%A0%E5%8F%82%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"
    >React中绑定this并传参的几种方式</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/10/10/React%E4%B8%AD%E7%BB%91%E5%AE%9Athis%E5%B9%B6%E4%BC%A0%E5%8F%82%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/" class="article-date">
  <time datetime="2019-10-09T16:00:00.000Z" itemprop="datePublished">2019-10-10</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7React/">打怪升级React</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<blockquote>
<p>在事件处理函数中，直接使用 bind 绑定 this 并传参<br>在构造函数中绑定并传参<br>利用箭头函数的this指向解决<br>bind的作用：为前面的函数，修改函数内部的 this 指向，让函数内部的this，指向 bind 参数列表中的 第一个参数 </p>
</blockquote>
<p>bind 和 call/apply 之间的区别： call/apply 修改完this指向后，会立即调用前面的函数，但是 bind 只是修改this指向，并不会l立即调用，bind会重新返回一个新函数。</p>
<p>注意： bind 中的第一个参数，是用来修改 this 指向的，第一个参数后面的所有参数，都会当作将来调用 前面函数 时候的参数传递进去</p>
<p>接下来具体看代码：<br>第一种方式的代码： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">BindThis</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state=&#123;</span><br><span class="line">      msg:<span class="string">'这是默认的msg'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">      &#123;/* 方式1：在 事件处理函数中，直接使用 bind 绑定 this 并传参 */&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">'绑定This并传参的方式'</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeMsg1.bind(this,</span> '🐷', '🍕')&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;this.state.msg&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>




<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> changeMsg1(arg1, arg2)&#123;</span><br><span class="line">    <span class="comment">//注意：这里的方式，是一个普通的方法，因此，在触发的时候，这里的this是undefined</span></span><br><span class="line">    <span class="comment">// console.log(this);</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      msg:<span class="string">'绑定This并传参的方式'</span>+ arg1 + arg2</span><br><span class="line">    &#125;) </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">第二种方式的代码：</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">BindThis</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state=&#123;</span><br><span class="line">      msg:<span class="string">'这是默认的msg'</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 绑定 this 并传参的方式2: 在构造函数中绑定并传参</span></span><br><span class="line">    <span class="comment">// 注意，当一个函数，调用 bind 改变了this指向后，bind 函数调用的结果，有一个返回值，这个值，就是被改变this指向后的函数的引用</span></span><br><span class="line">    <span class="comment">// 注意： bind 不会修改 原函数的 this 指向</span></span><br><span class="line">    <span class="keyword">this</span>.changeMsg2 = <span class="keyword">this</span>.changeMsg2.bind(<span class="keyword">this</span>, <span class="string">'🚗'</span>, <span class="string">'👫'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"绑定this并传参的方式2"</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeMsg2&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;this.state.msg&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  changeMsg2(arg1,arg2)&#123;</span><br><span class="line">    <span class="comment">//console.log(this)</span></span><br><span class="line">    <span class="comment">// 注意：这里的方式，是一个普通方法，因此，在触发的时候，这里的 this 是 undefined</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      msg: <span class="string">'绑定this并传参的方式2'</span> + arg1 + arg2</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>第二种方式需要注意： 当一个函数，调用 bind 改变了this指向后，bind 函数调用的结果，有一个返回值，这个值，就是被改变this指向后的函数的引用；<br>            bind 不会修改 原函数的 this 指向</p>
</blockquote>
<p> 第三种方式代码： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">BindThis</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state=&#123;</span><br><span class="line">      msg:<span class="string">'这是默认的msg'</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>     </span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"绑定this并传参的方式3"</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123; this.changeMsg3('😊', '😘') &#125;&#125; /&gt;</span></span><br><span class="line"><span class="xml">     </span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;this.state.msg&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  changeMsg3 = <span class="function">(<span class="params">arg1,arg2</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      msg:<span class="string">'绑定this并传参的方式3'</span> + arg1 + arg2</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"绑定this并传参的方式3"</span> onClick=&#123;<span class="keyword">this</span>.changeMsg3(<span class="string">'😊'</span>, <span class="string">'😘'</span>) &#125;/&gt;</span><br></pre></td></tr></table></figure>

<p>注意： 根据第三种方式得上面这一小段代码出现bug！<br>由于传参，通过this.changeMsg3（arg1,arg2）直接调用了这个函数，就是在没有点击时已经调用了，本身onclick事件里面放的是函数，而不是函数的调用的结果，如果这样写，在页面就会直接显示结果。</p>
<blockquote>
<p>解决方式： 就是在onclick事件中放一个箭头函数，在箭头函数内部调用。<br>三种方式都能达到同样的效果，但是性能上还是有很大的差别的。</p>
</blockquote>
<p>总结：</p>
<blockquote>
<p>每次在render的时候都要去绑定this，是性能最差的！</p>
<p>使用构造函数的方式：在每一个实例化之后的this 都会定义该方法，但是该方式其实是定义在prototype 上的，各个实例对象共享该方法。<br>定义在原型链上的方法，在实际调用该方法的时候，其查找的过程是这样的：<br>首先检查this 上是否有该方法的定义，如果没有的话，则去prototype 上查找是否有该方法，所以在方法调用的过程中，会经历一次跨原型链的查找，带来额外的消耗。</p>
</blockquote>
<blockquote>
<p>箭头函数的方式，在实际调用的时候，访问的是外层作用缓存的_this， 所以在作用域查找上有一层消耗。</p>
</blockquote>
<p>问题延申：React组件的this在不同场景下分别是什么？<br>背景：因为JavaScript函数中的this不是在函数声明的时候定义的，而是在函数调用（即运行）的时候定义的（不包括箭头函数）同样，React组件也遵循JavaScript的这种特性，所以组件方法的‘调用者’不同会导致this的不同（这里的 “调用者” 指的是函数执行时的当前对象。<br>ES6中新增了箭头函数这种语法,箭头函数以其简洁性和方便获取this的特性。<br>下面来总结一下他们之间的区别：</p>
<blockquote>
<p>普通函数下的this:<br>在普通函数中的this总是代表它的直接调用者，在默认情况下，this指的是window，<br>在严格模式下,没有直接调用者的函数中的this是 undefined使用<br>call,apply,bind(ES5新增)绑定的,this指的是 绑定的对象<br>箭头函数中的this:<br>箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象),<br>而不是执行时的对象, 定义它的时候,可能环境是window,也有可能是其他的。</p>
</blockquote>
<p>阅读深入浅出React之后的总结：</p>
<blockquote>
<p>React组件生命周期函数中的this指向组件实例；<br>自定义组件方法的this会因调用者不同而不同；<br>为了在组件的自定义方法中获取组件实例，需要手动绑定this到组件实例。</p>
</blockquote>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/React/" rel="tag">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/" rel="tag">事件绑定</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-数组技巧总结 (1)" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/09/12/%E6%95%B0%E7%BB%84%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%20(1)/"
    >数组技巧总结</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/09/12/%E6%95%B0%E7%BB%84%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%20(1)/" class="article-date">
  <time datetime="2019-09-11T16:00:00.000Z" itemprop="datePublished">2019-09-12</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7JS/">打怪升级JS</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="map与for-each"><a href="#map与for-each" class="headerlink" title="map与for each"></a>map与for each</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">			<span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">			<span class="comment">//for each 对数组直接进行循环，相当于直接for循环,没有返回值</span></span><br><span class="line">			<span class="comment">//三个参数是item  index arr不是必须的</span></span><br><span class="line">			<span class="comment">// let result = arr.forEach((item,index,arr)=&gt;&#123;</span></span><br><span class="line">			<span class="comment">// 	console.log(item)</span></span><br><span class="line">			<span class="comment">// 	console.log(index)</span></span><br><span class="line">			<span class="comment">// 	console.log(arr)</span></span><br><span class="line">			<span class="comment">// 	return item</span></span><br><span class="line">			<span class="comment">// &#125;)</span></span><br><span class="line">			<span class="comment">//console.log(result)</span></span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">let</span> arr2 = [<span class="string">'香蕉'</span>,<span class="string">"苹果"</span>,<span class="string">"雪梨"</span>]</span><br><span class="line">			<span class="comment">//map,对数组每一项进行加工，加工完成之后返回1个新的数组！</span></span><br><span class="line">			<span class="comment">// let result2 = arr2.map((item,index,arr)=&gt;&#123;</span></span><br><span class="line">			<span class="comment">// 	let str = index + item + index</span></span><br><span class="line">			<span class="comment">// 	return str</span></span><br><span class="line">			<span class="comment">// &#125;)</span></span><br><span class="line">			<span class="comment">// console.log(result2)</span></span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">let</span> arr3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line">			<span class="comment">//filter过滤，就是将想要的内容进行筛选，不要内容去除，最终返回想要的内容的数组。</span></span><br><span class="line">			<span class="comment">// let result3 = arr3.filter((item,index)=&gt;&#123;</span></span><br><span class="line">			<span class="comment">// 	if(item%2==0)&#123;</span></span><br><span class="line">			<span class="comment">// 		//通过返回true还是false进行选择，true就是想要，false就是去除。</span></span><br><span class="line">			<span class="comment">// 		return true;</span></span><br><span class="line">			<span class="comment">// 	&#125;else&#123;</span></span><br><span class="line">			<span class="comment">// 		return false;</span></span><br><span class="line">			<span class="comment">// 	&#125;</span></span><br><span class="line">			<span class="comment">// &#125;)</span></span><br><span class="line">			<span class="comment">// console.log(result3)</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">//reduce,是对整个数组进行整合，比如要将数组里所有的数字进行相加</span></span><br><span class="line">			<span class="comment">//将数组每一项内容整合后，返回1个内容</span></span><br><span class="line">			<span class="keyword">let</span> arr4 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line">			<span class="keyword">let</span> result4 =arr4.reduce(<span class="function">(<span class="params">pre,next,index</span>)=&gt;</span>&#123;</span><br><span class="line">				<span class="built_in">console</span>.log(pre);</span><br><span class="line">				<span class="built_in">console</span>.log(next);</span><br><span class="line">				<span class="built_in">console</span>.log(index)</span><br><span class="line">				<span class="keyword">return</span> pre+next</span><br><span class="line">			&#125;,<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">console</span>.log(result4)</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//for...in...主要用于遍历对象的，不适用于遍历数组,for(key in obj),里面的每项是key</span></span><br><span class="line">			<span class="comment">//for...of...可以用来遍历数组，类数组的对象，字符串，set/map,generator。</span></span><br><span class="line">			<span class="comment">//for(item of arr),里面的是每一项</span></span><br><span class="line">			<span class="comment">//map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</span></span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">let</span> obj = &#123;</span><br><span class="line">				name:<span class="string">"老陈"</span>,</span><br><span class="line">				type:<span class="string">"帅"</span>,</span><br><span class="line">				content:<span class="string">"前端"</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span>(key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">				<span class="built_in">console</span>.log(<span class="string">"key："</span>+key+<span class="string">";value:"</span>+obj[key])</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">let</span> arr5 = [<span class="string">"范冰冰"</span>,<span class="string">"李晨"</span>,<span class="string">"鹿晗"</span>]</span><br><span class="line">			<span class="comment">//for of循环的是每一项的内容</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr5)&#123;</span><br><span class="line">				<span class="built_in">console</span>.log(item)</span><br><span class="line">			&#125;</span><br><span class="line">		&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p>这是一个非常流行的关于Javascript数组的采访问题，数组去重。这里有一个快速简单的解决方案，可以使用一个新的Set()。我想向您展示两种可能的方法，一种是使用.from()方法，另一种是使用spread操作符(…)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"banana"</span>, <span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"watermelon"</span>, <span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"grape"</span>, <span class="string">"apple"</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// First method</span></span><br><span class="line"><span class="keyword">var</span> uniqueFruits = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(fruits));</span><br><span class="line"><span class="built_in">console</span>.log(uniqueFruits); </span><br><span class="line"><span class="comment">// returns ["banana", "apple", "orange", "watermelon", "grape"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Second method</span></span><br><span class="line"><span class="keyword">var</span> uniqueFruits2 = […<span class="keyword">new</span> <span class="built_in">Set</span>(fruits)];</span><br><span class="line"><span class="built_in">console</span>.log(uniqueFruits2); </span><br><span class="line"><span class="comment">// returns ["banana", "apple", "orange", "watermelon", "grape"]</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>替换数组中的特定值<br>有时在创建代码时需要替换数组中的特定值，有一种很好的简单的方法可以做到这一点，我们可以使用.splice(start、valueToRemove、valueToAdd)，并将所有三个参数传递给它，这些参数可以指定我们希望从哪里开始修改、希望修改多少值和新值。</li>
</ol>
<p>var fruits = [“banana”, “apple”, “orange”, “watermelon”, “apple”, “orange”, “grape”, “apple”];<br>fruits.splice(0, 2, “potato”, “tomato”);<br>console.log(fruits);<br>// returns [“potato”, “tomato”, “orange”, “watermelon”, “apple”, “orange”, “grape”, “apple”]<br>3. 没有map()的映射数组<br>也许每个人都知道数组的map()方法，但是有一个不同的解决方案，它可以用来获得类似的效果和非常干净的代码。我们可以使用.from()方法。</p>
<p>var friends = [<br>    { name: “John”, age: 22 },<br>    { name: “Peter”, age: 23 },<br>    { name: “Mark”, age: 24 },<br>    { name: “Maria”, age: 22 },<br>    { name: “Monica”, age: 21 },<br>    { name: “Martha”, age: 19 },<br>]</p>
<p>var friendsNames = Array.from(friends, ({name}) =&gt; name);<br>console.log(friendsNames);<br>// returns [“John”, “Peter”, “Mark”, “Maria”, “Monica”, “Martha”]<br>4. 空数组<br>您是否有一个满是元素的数组，但是您需要出于任何目的对其进行清理，并且您不想逐个删除项? 很容易就可以在一行代码中完成。要清空一个数组，您需要将数组的长度设置为0，就是这样!</p>
<p>var fruits = [“banana”, “apple”, “orange”, “watermelon”, “apple”, “orange”, “grape”, “apple”];</p>
<p>fruits.length = 0;<br>console.log(fruits);<br> // returns []</p>
<h2 id="将数组转换为对象"><a href="#将数组转换为对象" class="headerlink" title="将数组转换为对象"></a>将数组转换为对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spread运算符(…)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"banana"</span>, <span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"watermelon"</span>];</span><br><span class="line"><span class="keyword">var</span> fruitsObj = &#123; …fruits &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(fruitsObj);</span><br><span class="line"><span class="comment">// returns &#123;0: "banana", 1: "apple", 2: "orange", 3: "watermelon", 4: "apple", 5: "orange", 6: "grape", 7: "apple"&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="用数据填充数组"><a href="#用数据填充数组" class="headerlink" title="用数据填充数组"></a>用数据填充数组</h2><p>在某些情况下，当创建一个数组时，希望用一些数据来填充它，或者需要一个具有相同值的数组，在这种情况下使用fill()方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>).fill(<span class="string">"1"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newArray); </span><br><span class="line"><span class="comment">// returns ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1"]</span></span><br></pre></td></tr></table></figure>

<h2 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h2><p>.concat()方法或spread操作符(…)在处理数组时非常有用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>];</span><br><span class="line"><span class="keyword">var</span> meat = [<span class="string">"poultry"</span>, <span class="string">"beef"</span>, <span class="string">"fish"</span>];</span><br><span class="line"><span class="keyword">var</span> vegetables = [<span class="string">"potato"</span>, <span class="string">"tomato"</span>, <span class="string">"cucumber"</span>];</span><br><span class="line"><span class="keyword">var</span> food = […fruits, …meat, …vegetables];</span><br><span class="line"><span class="built_in">console</span>.log(food); </span><br><span class="line"><span class="comment">// ["apple", "banana", "orange", "poultry", "beef", "fish", "potato", "tomato", "cucumber"]</span></span><br></pre></td></tr></table></figure>

<h2 id="求两个数组的交集"><a href="#求两个数组的交集" class="headerlink" title="求两个数组的交集"></a>求两个数组的交集</h2><blockquote>
<p>为了找到两个数组的交集，以确保数组中的值不重复，使用.filter方法和.include方法。最后，将得到两个数组的交集。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numOne = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> numTwo = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> duplicatedValues = […<span class="keyword">new</span> <span class="built_in">Set</span>(numOne)].filter(<span class="function"><span class="params">item</span> =&gt;</span> numTwo.includes(item));</span><br><span class="line"><span class="built_in">console</span>.log(duplicatedValues); </span><br><span class="line"><span class="comment">// returns [2, 4, 6]</span></span><br></pre></td></tr></table></figure>

<h2 id="从数组中删除假值"><a href="#从数组中删除假值" class="headerlink" title="从数组中删除假值"></a>从数组中删除假值</h2><blockquote>
<p>在Javascript中，假值是false, 0， “ “， null, NaN, undefined  使用.filter()方法。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mixedArr = [<span class="number">0</span>, <span class="string">"blue"</span>, <span class="string">""</span>, <span class="literal">NaN</span>, <span class="number">9</span>, <span class="literal">true</span>, <span class="literal">undefined</span>, <span class="string">"white"</span>, <span class="literal">false</span>];</span><br><span class="line"><span class="keyword">var</span> trueArr = mixedArr.filter(<span class="built_in">Boolean</span>);</span><br><span class="line"><span class="built_in">console</span>.log(trueArr); </span><br><span class="line"><span class="comment">// returns ["blue", 9, true, "white"]</span></span><br></pre></td></tr></table></figure>

<h2 id="从数组中获取随机值"><a href="#从数组中获取随机值" class="headerlink" title="从数组中获取随机值"></a>从数组中获取随机值</h2><blockquote>
<p>有时需要从数组中随机选择一个值。要以一种简单、快速、简短的方式创建它，并保持代码整洁，可以根据数组长度获得一个随机索引号。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"blue"</span>, <span class="string">"white"</span>, <span class="string">"green"</span>, <span class="string">"navy"</span>, <span class="string">"pink"</span>, <span class="string">"purple"</span>, <span class="string">"orange"</span>, <span class="string">"yellow"</span>, <span class="string">"black"</span>, <span class="string">"brown"</span>];</span><br><span class="line"><span class="keyword">var</span> randomColor = colors[(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (colors.length + <span class="number">1</span>)))]</span><br></pre></td></tr></table></figure>

<h2 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a>数组反转</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"blue"</span>, <span class="string">"white"</span>, <span class="string">"green"</span>, <span class="string">"navy"</span>, <span class="string">"pink"</span>, <span class="string">"purple"</span>, <span class="string">"orange"</span>, <span class="string">"yellow"</span>, <span class="string">"black"</span>, <span class="string">"brown"</span>];</span><br><span class="line"><span class="keyword">var</span> reversedColors = colors.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(reversedColors); </span><br><span class="line"><span class="comment">// returns ["brown", "black", "yellow", "orange", "purple", "pink", "navy", "green", "white", "blue"]</span></span><br></pre></td></tr></table></figure>

<h2 id="lastIndexOf-方法"><a href="#lastIndexOf-方法" class="headerlink" title="lastIndexOf()方法"></a>lastIndexOf()方法</h2><blockquote>
<p>允许查找给定元素的最后一次出现的索引。例如，数组有重复的值，可以找到它最后一次出现的位置。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">var</span> lastIndex = nums.lastIndexOf(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(lastIndex); </span><br><span class="line"><span class="comment">// returns 9</span></span><br></pre></td></tr></table></figure>

<h2 id="将数组中的所有值相加"><a href="#将数组中的所有值相加" class="headerlink" title="将数组中的所有值相加"></a>将数组中的所有值相加</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> sum = nums.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y);</span><br><span class="line"><span class="built_in">console</span>.log(sum); </span><br><span class="line"><span class="comment">// returns 14</span></span><br></pre></td></tr></table></figure>

<h2 id="易混辨析"><a href="#易混辨析" class="headerlink" title="易混辨析"></a>易混辨析</h2><p>比如有一个数组a=[1,2,3,4]，还有一个对象a={0:1,1:2,2:3,3:4}，然后运行alert(a[1])，两种情况下的运行结果是相同的！这就是说，数据集合既可以用数组表示，也可以用对象表示，那么我到底该用哪一种呢？<br><strong>数组表示有序数据的集合，而对象表示无序数据的集合。如果数据的顺序很重要，就用数组，否则就用对象。</strong><br>当然，数组和对象的另一个区别是，数组的数据没有”名称”（name），对象的数据有”名称”（name）。<br>但是问题是，很多编程语言中，都有一种叫做”关联数组”（associative array）的东西。这种数组中的数据是有名称的。<br>但是在《javascript DOM》中，不推荐我们使用 关联数组！</p>
<blockquote>
<p><strong>判断一个对象是不是数组类型最可靠的方法是这两种:<br>Object. prototype.toString.call(obj)===[ object Array]和Array. isArray(obj)。</strong></p>
</blockquote>
<p>原因：typeof 检查基本数据类型是可以的，但不准确。<br>Array.isArray() 用于确定传递的值是否是一个 Array。如果对象是 Array，则为true; 否则为false.这个是可以的！<br> <strong>所有 函数的原型对象默认是OBJECT的实例，但OBJECT除外。Function 函数是new自己产生的。</strong><br>但是！bug问题就是研究不深入啊啊啊啊啊啊，作为程序媛，我有点难~<br>A  instance of   B不准确！因为原型链可以改变，只要B构造函数的显示原型对象protptype在左边A的原型链上可以找到就返回TRUE。只要在A 的原型链上找到了B的prototype,，就可以,任何一个就可以说明A是B的一个实例。<br>这种方法有一个问题，就是验证不够严格。 如果对象创建时不是使用数组创建的，但是只要原型链上有数组类型，也认为是数组，如下面一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Test.prototype = <span class="built_in">Array</span>.prototype;</span><br><span class="line"><span class="keyword">let</span> test = <span class="keyword">new</span> Test();</span><br><span class="line">test <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Object. prototype.toString.call(obj)===[ object Array]原理是根据对象的class属性(类属性)，跨原型链调用toString()方法。<br><code>Object.prototype.toString.call(new Date());   //&quot;[object Date]&quot;
Object.prototype.toString.call(Window);       //&quot;[object window]&quot;
Object.prototype.toString.call(/./);          //&quot;[object RegExp]&quot;</code></p>
</blockquote>
<p>解释一下，在js中一个对象一旦被创建，在内部会携带创建对象的类型名，一旦创建就不能被修改了。那么怎么获取这个对象的类型名呢？所谓”纯粹的对象”，就是说该对象是通过”{}“或”new Object”创建的。<br>js中提供了调用对象原型中的toString方法， Object.prototype.toString.call(obj)。因为很多对象继承的toString（）方法被重写了，为了能够调用正确的toString（）版本，也就是最原始的版本。可以使用Function.call()的方法。<br>其中call可以这么理解，相当于obj去借用这个 Object.prototype.toString()<br><strong>举个栗子~</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;,</span><br><span class="line">arr = [];</span><br><span class="line"></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>	<span class="comment">//false</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>	<span class="comment">//true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>	<span class="comment">//true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Object</span>	<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span></span><br><span class="line">var obj = &#123;&#125;,</span><br><span class="line">arr = [];</span><br><span class="line"></span><br><span class="line">obj.constructor === <span class="built_in">Object</span>	<span class="comment">//true</span></span><br><span class="line">arr.constructor === <span class="built_in">Object</span>	<span class="comment">//false</span></span><br><span class="line">obj.constructor === <span class="built_in">Array</span>	<span class="comment">//true！</span></span><br><span class="line">arr.constructor === <span class="built_in">Array</span>	<span class="comment">//false</span></span><br></pre></td></tr></table></figure>



      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/Javascript/" rel="tag">Javascript</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-React" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/08/23/React/"
    >React生命周期（一）</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/08/23/React/" class="article-date">
  <time datetime="2019-08-22T16:00:00.000Z" itemprop="datePublished">2019-08-23</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7React/">打怪升级React</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="Initialization-初始化阶段。"><a href="#Initialization-初始化阶段。" class="headerlink" title="Initialization:初始化阶段。"></a>Initialization:初始化阶段。</h1><h1 id="Mounting-挂载阶段。"><a href="#Mounting-挂载阶段。" class="headerlink" title="Mounting: 挂载阶段。"></a>Mounting: 挂载阶段。</h1><h1 id="Updation-更新阶段。"><a href="#Updation-更新阶段。" class="headerlink" title="Updation: 更新阶段。"></a>Updation: 更新阶段。</h1><h1 id="Unmounting-销毁阶段"><a href="#Unmounting-销毁阶段" class="headerlink" title="Unmounting: 销毁阶段"></a>Unmounting: 销毁阶段</h1><p>什么是生命周期函数？<br>如果非要用一句话把生命周期函数说明白，我觉的可以用这句话来说明：</p>
<p>生命周期函数指在某一个时刻组件会自动调用执行的函数</p>
<p>举例：render()函数，就是一个生命周期函数，它在state发生改变时自动执行。这就是一个标准的自动执行函数。</p>
<p>constructor不算生命周期函数。<br>constructor叫构造函数，它是ES6的基本语法。虽然它和生命周期函数的性质一样，但不能认为是生命周期函数。</p>
<p>我个人把它看成React的Initialization阶段，定义属性（props）和状态(state)。</p>
<p><img src="https://img-blog.csdnimg.cn/20200302110716424.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Mounting阶段<br>Mounting阶段叫挂载阶段，伴随着整个虚拟DOM的生成，它里边有三个小的生命周期函数，分别是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">componentWillMount : 在组件即将被挂载到页面的时刻执行。</span><br><span class="line">render : 页面state或props发生变化时执行。</span><br><span class="line">componentDidMount : 组件挂载完成时被执行。</span><br><span class="line">componentWillMount代码</span><br><span class="line"></span><br><span class="line">componentWillMount()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillMount----组件将要挂载到页面的时刻'</span>)</span><br><span class="line">&#125;</span><br><span class="line">componentDidMount代码</span><br><span class="line"></span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidMount----组件挂载完成的时刻执行'</span>)</span><br><span class="line">&#125;</span><br><span class="line">render代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">render()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render---组件挂载中.......'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看一下控制台，会打出如下提示：</p>
<p>componentWillMount—-组件将要挂载到页面的时刻执行<br>render—-开始挂载渲染<br>componentDidMount—-组件挂载完成的时刻执行<br>这也是生命周期的顺序。有小伙伴会问我，这个函数书写有顺序吗?哪个在前？哪个在后？其实是没有顺序的，你可以随便改动他们的顺序。</p>
<p>注意的问题：</p>
<p>componentWillMount和componentDidMount这两个生命周期函数，只在页面刷新时执行一次，而render函数是只要有state和props变化就会执行，这个一定要注意。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/React/" rel="tag">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/jsx/" rel="tag">jsx</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-推荐算法笔记（二）" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/07/12/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"
    >推荐算法笔记（二）</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/07/12/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/" class="article-date">
  <time datetime="2019-07-11T16:00:00.000Z" itemprop="datePublished">2019-07-12</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/">实习项目复盘</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="推荐算法背景"><a href="#推荐算法背景" class="headerlink" title="推荐算法背景"></a>推荐算法背景</h2><p>在商品短缺，信息缺失和广告缺乏的时代，人类社会面临着无可奈何的选择不足困境；而在商品过剩，信息过度和广告过多的社会中，人类社会又面临着史无前例的选择过多困境甚至于因为选择过多而产生无从选择的尴尬情景。</p>
<p>在这两种截然不同的社会经济环境中，个体所采取或者说所应对的策略，前一种侧重于自觉地主动搜寻个体需求之物，后一种侧重于不自觉地被动接受社会提供之物。</p>
<p>体现在现实的经济社会中，就是我们现在不仅通过搜索引擎主动地查询搜索购买商品，查询收集浏览新闻信息和广告资讯；而且我们更是被动地接受了由机器深度学习进行系统自动化推荐算法所计算出来的，为个体量身定做而提供的各种推荐商品，信息和广告等个性化服务。</p>
<p>当然，也正如同古希腊大哲学家苏格拉底所说的那样，人最难认识的是自己，有时用户很难用恰当的关键词语来描述自己的需求和想法，又或是无法对自己未知而又可能感兴趣的信息做出描述而显得无所适从或者说无可选择。因此，通过机器算法的推荐系统能得到进一步的发展和应用就成为顺理成章的事情了。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLndvc2hpcG0uY29tL3dwLWZpbGVzLzIwMTgvMDIvdGFKTkpXMmJlZTFLSEN1UlZzaWwucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>虽然这种基于机器各种算法而产生的商品、信息和广告推荐成为各大互联网服务平台的标配，尤其是通过主打算法的个性化推荐类新闻app在近一两年的崛起和称霸，更是成为中国互联网界有目共睹的辉煌成就。</p>
<p>但隐藏在这些热闹表象身后所体现出来的实质上更多地是社会科学技术发展到一定程度所必然出现的结果，即AI技术中有关深度学习技术手段在历史上几次起起落落后应用于推荐系统中的重新崛起和发展。因此，近几年推荐系统的风生水起，与其说是互联网界的成就，不如说是中国科技界，尤其是AI技术的进步。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLndvc2hpcG0uY29tL3dwLWZpbGVzLzIwMTgvMDIvOERUWlZSTkFGZEdqTWM3WjNxelgucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>很明显，深度学习是AI体系中技术层面上的一种运算方法和手段，而推荐系统则是深度学习在具体细分领域的一种技术层面应用，它的重新崛起是社会发展到一定阶段后，人类所形成新的需求矛盾与科技进步发展所形成新的生产力相互结合的必然结果。</p>
<p>它与各种互联网服务平台结合而成的实际应用就是我们现在的个性化推荐商品（电商），新闻（资讯分发），广告以及其他各种个性化服务平台，如下图。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLndvc2hpcG0uY29tL3dwLWZpbGVzLzIwMTgvMDIvWk1WWkdLRDRPYlVzRFBXREpCa08ucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>推荐算法历史与种类<br>实际上，推荐这二个字对我们来说并不陌生，遍布于生活、工作、学习等各个方面，如学习中的三好生推荐，高考中的保送生推荐；工作中的优秀员工推荐，选举时的候选人推荐；生活中的超市购物店长推荐，畅品推荐等等。</p>
<p>而从其纵向的发展历史来看，我们也经历了从毛遂自荐，口碑相传的个体推荐形式，逐步过渡到1/2或者2/3简单多数规则的群体推荐形式，以及进一步转化到涉及各种权重、混合、360度全方位等复杂规则的群体推荐形式。</p>
<p>然而，不管是个体自荐和推荐，还是群体推荐；抑或不论是简单多数规则，还是复杂规则；本质上都属于一种人为推荐形式。而人为推荐则必然不同程度地存在着诸多如暗箱操作、感情用事、趋利避害、标准不一的主观性意见缺陷，导致难以得到客观化的满意结果。</p>
<p>为使推荐的结果更加合乎实际和更加客观化，通过计算机采取一定技术方法的算法推荐系统就应运产生了。与人为推荐系统的发展历程一样，早期计算机推荐系统中的算法和技术也是十分简单和粗糙的，如打分预测，即通过用户（User）对物品（Item）的打分（Rating）进行评分预测推荐；或相似评估，即通过对用户和物品一些较为粗糙简单的明显属性进行分析评判推荐。</p>
<p>只是在进入互联网时代后，随着云计算和大数据分析等技术的发展，在运算和存储能力跃入新的层级之后，推荐算法不仅在数量的广度上，而且在技术的深度上都达到了前所未有的一个水平。</p>
<p>目前各种具体推荐算法很多，而且分类标准也不尽相同，但万变不离其宗，由于推荐系统本质是向用户推荐合适物品的个性化服务，主要涉及到用户和物品二个对象。因此，从大的方向来看，可以划分为基于用户的“人以群分”推荐算法和基于物品的“物以类聚 ”推荐算法，简述如下：</p>
<p>1、以人为中心的“人以群分”推荐算法<br>这种推荐系统的内在原理有一个假设前提，即相同群体中的成员拥有共同的兴趣爱好，因此同类人喜欢什么就推荐什么。很明显在这种推荐系统中，关键点是如何全面准确地划定人“群”的属性，即“群”的相似度和近似度对个体的影响力权重程度。一般地，最常见的是基于人口统计学中个体自然的基本属性而推荐。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLndvc2hpcG0uY29tL3dwLWZpbGVzLzIwMTgvMDIvN3RiMFpCNG9xUVMwOXNmeXN4OVYucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>因此，根据个体的基本属性在理论上就会出现很多推荐子系统，如基于性别的，基于年龄的，基于学历的，基于地域的等等推荐系统，这里的关于人的推荐系统是平行关系的，与下面的物品推荐系统层级关系有所不同。当然在实际经济中，并不是所有的推荐系统都是有用或者说有效的，因此就必须根据个体和物品进行有目的的筛选淘汰了。</p>
<p>栗子：基于年龄的推荐系统</p>
<p>这里的“群”就是年龄，而且假设年龄对物品和用户的影响力权重占第一位。推荐原理如下：</p>
<p>第一步：机器通过大数据以“年龄”为关键属性搜寻找到各个用户之间的相似度和邻近度。<br>第二步：对不同用户A,B,C的相似度进行排序。<br>第三步：选出与当前用户A最相近的用户C。<br>第四步：将用户A喜欢的物品a推荐给没有接触过的用户C。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLndvc2hpcG0uY29tL3dwLWZpbGVzLzIwMTgvMDIveE1Jc2lpdlZBcEdGVDgxZ3JKQzUucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>这是较为通俗易懂的基于用户简单推荐方式，当然在实际经济生活中，“群”属性确定，推荐方式和具体运算过程则要复杂得多，但基本原理相似。</p>
<p>2、以物为中心的“物以类聚”推荐算法<br>与“人以群分”的推荐方式相类似，它是以物品的相似度代替了用户的相似度。这种推荐系统也有一个假设前提，即同一用户对相同类型的物品具有共同的兴趣爱好或者说吸引力，因此用户喜欢什么就推荐相同类型的物品。一样的道理，在这种推荐系统中，关键点是如何全面准确地划定物品的“类”的属性，即物品的“类”属性相似度和近似度对个体的影响力权重程度。</p>
<p>与“人以群分”推荐算法中“群”的各个属性划分是基于横向平行关系不同，在“物以类聚”推荐算法中物品的“类”是基于纵向层级关系而划定。而且由于大千世界各种物品成千上万，因此首先必须确定一个物品分门别类的划分标准，或者说确定一个比较合适的划分标准就显得十分重要。</p>
<p>物品具有自然属性和商品属性，因此可以按生物标准进行自然属性分类，也可以按经济属性进行商品属性分类；但由于我们都处于经济社会中，因此一般地，我们将物品的类别划分确定为以商品经济属性为主，兼顾生物自然属性进行划分。第一层先划分为有形产品和无形服务；第二层再根据惯例按国民经济行业有关第一产业、第二产业、第三产业进行行业分类。然后每一层按照从大到小，结合物品的品类、品种等自然生物属性和功能、用途、产地等商品属性逐层进行细分，直至分解到最后的最底层每一个单品sku。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLndvc2hpcG0uY29tL3dwLWZpbGVzLzIwMTgvMDIvMTBORm03TjFTWkhDbHZjcU4ybmYucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>相应地，根据物品类别在理论上也存在着很多推荐系统，对于有形产品来说，有基于价格的，基于用途的，基于产地的；对于无形服务来说，有基于年代的，基于等级的，基于提供者的等等细分推荐系统。当然也要根据需要进行筛选。</p>
<p>栗子：基于产地的物品推荐系统</p>
<p>这里的“类”就是产地，而且假设产地对用户的影响力权重占第一位。推荐原理如下：</p>
<p>第一步：机器通过大数据以“产地”为关键属性搜寻找到各个物品之间的相似度和邻近度。<br>第二步：对不同物品a,b,c的相似度进行排序。<br>第三步：选出与当前物品a最相近的物品c。<br>第四步：将物品c推荐给没有接触过的用户A。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLndvc2hpcG0uY29tL3dwLWZpbGVzLzIwMTgvMDIvRHZ2R0VGeDh3VWhFWHJRU0ZROFMucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>以上介绍的二种方法是推荐领域最基本的，也是最简单的的方法。但在实际的经济生活中和现实的真实案例推荐中，往往不是那么简单，需要面临着许多复杂多变的情景和任务，因此，在这二种基本推荐基础上的各种混合推荐系统就应运而生了。主要有</p>
<p>3、基于协同过滤推荐系统：这又分为基于用户协同过滤和基于物品协同过滤二种推荐方法<br>基于用户的协同过滤推荐方法原理与基于以人为中心的“人以群分”推荐算法相同，都是通过计算用户的相似度，利用相似，邻近和邻居进行计算推荐；它们的区别是如何计算用户的相似度，基 于以人为中心的“人以群分”推荐算法只考虑个体用户本身的基本特征，而基于用户的协同过滤机制则是在用户的历史偏好数据上计算用户的相似，即考虑用户的历史行为特征。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLndvc2hpcG0uY29tL3dwLWZpbGVzLzIwMTgvMDIvcGxKUVBXT1BUT0NPUlk4MWhMQUwucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>同样，基于物品的协同过滤方法与基于以物为中心的“物以类聚”推荐算法工作原理相似，都是基于物品相似度预测推荐；它们的区别也是物品相似度计算的方法不一样，前者是从用户历史的偏好推断，即物品有关的购买，收藏，评论，点赞等信息，而后者是基于物品本身的基本属性信息。</p>
<p>4、基于关联规则的推荐：就是找不同商品之间的相关性，假设用户喜欢A，A和B有紧密联系，就推荐B。主要指一些互补关系的产品，如香烟与打火机，复印机和色粉盒，也指一些在用途、渠道、购买者等方面相同的一些产品，如奶粉与尿不湿购买者可能为同一人，买了面包的人可能会买牛奶，零食与饮料可互补，海边的五金小店售卖啤酒等等。</p>
<p>5、基于背景的推荐：即找寻发现物品的行业特征以及物品在购买场景、展示场景和使用场景时的一些规律进行合适的推荐，如展示场景推荐系统就是表示如何将推荐产品合理地展示在电商页面的各个部分，以及明确各个部分的大小，顺序，色彩，主次等属性，从而达到重点区域突出，个性化推荐加强，进而提高销量的结果。</p>
<p>还有一些推荐算法，如标签的流行度推荐算法，基于效用的推荐，基于知识的推荐，组合推荐，加权推荐系统，模型推荐等；现归纳如图。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLndvc2hpcG0uY29tL3dwLWZpbGVzLzIwMTgvMDIvNDI3Y01rUjRlQVVmelZ0M0pSZ0oucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>推荐算法应用：精打细算才是出路<br>理论的最终目的是为了应用，是为了更好地指导我们的实践。因此，各种推荐算法在实际经济生活中的运用才是我们所需要考虑的核心问题。算法无好坏，适合是王道。</p>
<p>由于每个推荐算法都不是完美的，都有着不同程度的各自优缺点；因此理想的状态是使用所有推荐算法，取长补短，通过给不同算法的结果加权，从而达到完美的结果。但在实际应用中，基于企业的技术能力，成本压力和时间约束等因素，较为实际的步骤是：</p>
<p>根据所处行业，企业主要产品和主流用户的属性，确定以一个推荐算法为主计算结果，其他1-2个算法为辅论证和调整结果的混合推荐算法系统。<br>具体计算时，兼顾技术上的可能性，经济上的可行性和时间上的可控性三原则，实现推荐算法在技术、经济和效率的有机结合。<br>时空因素的影响：包括时间上有明显淡旺季区别的企业，有某些特定大事影响原有业务和产品运作方式的，如图原先体育栏目中，按项目、国别、球队、球员等维度逐层进行计算，然而在奥运会或者世界杯时期，可能在体育栏目中，就要变成奥运会、国家、运动员这几个维度进行计算了；空间上如交通企业，地域性明显的o2o、风景区和旅行社等。<br>4.不断迭代调整，提高计算准确率，实现更切合实际和满意的结果。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLndvc2hpcG0uY29tL3dwLWZpbGVzLzIwMTgvMDIvdlk4YlVaNUtXeGZKc2hJaDZKalAucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>那么，在电商行业、资讯信息广告行业和各种交互服务行业应用时，如何实现推荐算法的精打细算呢？具体的做法是：</p>
<p>电商行业：按大众化和小众化商品划分</p>
<p>对于那些大众化，老小皆宜的消费品，尤其是快消品，宜采用基于用户为中心的“人以群分”的User  RS 推荐算法，强调用户存在的买点和痛点，兼顾企业的优点和竞争点，也适合于那些选购性的耐用物品。</p>
<p>对于小众化，专业性强，特定品，以及工业品等物品，则应采用基于物品为中心的“物以类聚”的Item RS 推荐算法，强调物品自身的新奇特优等卖点，兼顾企业的优点和竞争点；从而进行精准化推荐，也适合于一些长尾物品以及没有用户画像的新产品冷启动情景。</p>
<p>资讯信息广告行业：按社会化和专业化划分</p>
<p>对于以娱乐消遣休闲为目的社会化新闻和一些常识谈资分享类信息，侧重于User  RS推荐算法。</p>
<p>以科技类，冷知识等专业知识，提高生活、学习和工作水平和能力为目的，侧重于Item RS推荐算法。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E5%A4%8D%E7%9B%98%E6%80%BB%E7%BB%93/" rel="tag">复盘总结</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/" rel="tag">推荐算法</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-推荐算法笔复盘整理" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/07/02/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E7%AC%94%E5%A4%8D%E7%9B%98%E6%95%B4%E7%90%86/"
    >推荐算法笔记复盘整理</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/07/02/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E7%AC%94%E5%A4%8D%E7%9B%98%E6%95%B4%E7%90%86/" class="article-date">
  <time datetime="2019-07-01T16:00:00.000Z" itemprop="datePublished">2019-07-02</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">实习项目总结</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="1-引入"><a href="#1-引入" class="headerlink" title="1.引入"></a>1.引入</h2><p>   目前推荐系统研究的主要趋势是从单一的、独立的推荐系统算法逐渐向组合多种推荐算法形成混合式的综合推荐算法方向发展，越来越多的结合用户标签数据、社交网络数据、上下文信息、地理位置信息。<br>   群体推荐也成为一个目前非常热门的主题。并且有些也用到了推荐系统领域之外的算法，如模糊集概念、人工智能领域的遗传算法，贝叶斯网络等。<br>   当然也有一些研究还在不断深入挖掘传统、经典的如基于内容过滤、协同过滤等算法可能的改进算法。<br>   注意：互联网上的很多数据分布都属于长尾分布，即大部分数据的使用频率很低，只有少部分的数据被广泛使用，这小部分数据其实就是热门数据，但如果把热门数据和冷门数据的使用量作对比，会发现冷门数据的使用量远远大于热门数据的使用量，这也许和人们想象中相反，但这是经过长时间的统计分析得出的结论。<br>   用户的行为数据其实也符合这一规律，无论从物品角度的物品流行度，还是用户角度的用户流行度都符合长尾分布。</p>
<h2 id="2-推荐系统算法概述"><a href="#2-推荐系统算法概述" class="headerlink" title="2.推荐系统算法概述"></a>2.推荐系统算法概述</h2><p>   推荐系统的研究大致可以分为三个阶段。<br>   第一阶段是基于传统的服务，第二阶段是基于目前的社交网络的服务，第三阶段是即将到来的物联网。<br>   这其中产生了很多基础和重要的算法，例如协同过滤（包括基于用户的和基于物品的）、基于内容的推荐算法、混合式的推荐算法、基于统计理论的推荐算法、基于社交网络信息（关注、被关注、信任、知名度、信誉度等）的过滤推荐算法、群体推荐算法、基于位置的推荐算法。<br>   其中基于邻域的协同过滤推荐算法是推荐系统中最基础、最核心、最重要的算法，该算法不仅在学术界得到较为深入的研究，而且在业界也得到非常广泛的应用。<br>   基于邻域的算法主要分为两大类，一类是基于用户的协同过滤算法，另一类是基于物品的协同过滤算法。<br>   除此之外，基于物品的推荐算法应用也非常广泛，所以下面我将对这三种基础算法进行系统学习之后的比较总结。</p>
<h2 id="3-基于用户的协同过滤算法"><a href="#3-基于用户的协同过滤算法" class="headerlink" title="3.基于用户的协同过滤算法"></a>3.基于用户的协同过滤算法</h2><p>   基于用户的协同过滤算法其简单应用情景是：当用户需要个性化推荐时，可以先找到与他相似其他用户（通过兴趣、爱好或行为习惯等，然后把那些用户喜欢的并且自己不知道的物品推荐给用户。</p>
<p>注：两个用户对流行物品的有相似兴趣，丝毫不能说明他们有相似的兴趣，此时要增加惩罚力度。</p>
<h2 id="4-基于物品的协同过滤算法"><a href="#4-基于物品的协同过滤算法" class="headerlink" title="4.基于物品的协同过滤算法"></a>4.基于物品的协同过滤算法</h2><p>   基于物品的协同过滤算法其简单应用情景是：当一个用户需要个性化推荐时，例如由于他之前购买过金庸的《射雕英雄传》这本书，所以会给他推荐《神雕侠侶》，因为其他用户很多都同时购买了这两本书。</p>
<p>注：1、如果是热门物品，很多人都喜欢，就会接近1，就会造成很多物品都和热门物品相似，此时要增加惩罚力度。</p>
<pre><code>2、活跃用户对物品相似度的贡献小于不活跃的用户。</code></pre><h2 id="5-基于内容的推荐算法"><a href="#5-基于内容的推荐算法" class="headerlink" title="5.基于内容的推荐算法"></a>5.基于内容的推荐算法</h2><p>   虽然协同过滤是目前较为流行的推荐算法，在学术界和工业界都有广泛的研究和使用，但同样作为推荐系统领域的基础算法一一基于内容的推荐也是很重要的，其他它还是最早出现的推荐算法。<br>   其基本原理是根据用户之前对物品的历史行为（如用户购买过什么物品、对什么物品收藏过、评分过等等，然后再根据计算与这些物品相似的物品，并把它们推荐给用户。例如用户之前购买过金庸的武侠小说，这可以说明用户可能是一个金庸迷或武侠迷，这时就可以给用户推荐一些金庸的其他武侠小说。<br>   基于内容的推荐算法之前也成为基于内容的过滤（搜索）算法，早期主要应用在信息检索</p>
<p>   基于内容的推荐算法一般包括以下三步：</p>
<p>1、为每个物品抽取一些特征用来表示这个物品。</p>
<p>2、使用用户的历史行为数据分析物品的这些特征，从而学习出用户的喜好特征或者说兴趣。</p>
<p>3、通过比较上一步得到的用户兴趣和待推荐物品的特征，确定一组相关性最大的物品作为推荐列表。</p>
<h2 id="6-推荐系统基础算法对比"><a href="#6-推荐系统基础算法对比" class="headerlink" title="6. 推荐系统基础算法对比"></a>6. 推荐系统基础算法对比</h2><p>  协同过滤是目前应用最广泛的推荐算法，它仅仅通过了解用户与物品之间的关系进行推荐，而根本不会考虑到物品本身的属性。<br>可分成两类：<br>1、基于用户（user-based）的协同过滤<br>2、基于商品（item-based）的协同过滤</p>
<p>1.1.1.基于用户的协同过滤<br>基本思想：<br>基于用户对物品的偏好找到邻居用户（相似用户），然后将邻居用户（相似用户）喜欢的东西推荐给当前用户。</p>
<p>计算方法：<br>将一个用户对所有物品的偏好作为一个向量，计算用户之间的相似度。找到邻居后，根据邻居的相似度权重以及他们对物品的偏好，预测当前用户未涉及的物品，计算得到一个排序的物品列表作为推荐。<br>相似度即为两个向量之间的距离。距离越小相似度越大。</p>
<p>例子：<br>比如：用户A与用户C相似，那么就会给用户A推荐“用户A未涉及但是用户C喜欢的东西”，也就是物品D了。<br>缺点：<br>基于用户的协同过滤难以形成有意义的邻居集合。<br>在很多时候，很多用户两两之间只有很少几个共同评分，也就是用户之间的重合度并不高。而仅有的共同打了分的物品，往往是一些很常见的物品（如票房大片，如生活必需品）。<br>再者，用户之间的距离可能变得很快，这种离线算法难以瞬间更新推荐结果。</p>
<p>1.1.2.基于物品的协同过滤<br>算法思想：<br>基于用户对物品的偏好找到相似的物品，然后根据用户的历史偏好，推荐相似的物品。</p>
<p>计算方法：<br>将所有用户对某个物品的偏好作为一个向量来计算物品之间的相似度。<br>得到物品的相似物品后，根据用户历史的偏好预测当前用户还没有涉及的物品的偏好，计算得到一个排序的物品列表作为推荐。</p>
<p>例子：<br>比如：物品A和物品C都被用户A和用户B所查看，所以物品A和物品C比较相似。又由于用户C看了物品A，所以我们就会推荐与之相似的物品C给用户C。</p>
<p>优点：<br>物品之间的距离可能是根据成百上千万的用户的评分计算得出，往往能在一段时间内保持稳定。因此，这种算法可以预先计算距离，其在线部分能更快地生产推荐列表。</p>
<p>缺点：<br>不同领域的最热门物品之间经常具有较高的相似度。比如，基于本算法，我们可能会给喜欢《算法导论》的同学推荐《哈利波特》，也就是推荐不同领域的畅销作品，这样的推荐结果可能并不是我们想要的。</p>
<p>1.1.3.实现协同过滤的步骤<br>1、收集用户偏好</p>
<p>2、找到相似的用户或物品<br>计算相似度的方式（此部分了解方法即可，考试时并不会要求直接计算）：<br>（1）欧氏距离<br>（2）余弦距离<br>（3）Tanimoto 系数<br>（4）k近邻或基于相似度门槛</p>
<p>3、计算推荐</p>
<p>额外考虑时间因素：<br>1、在基于商品的协同过滤中：<br>（1）同一个用户在间隔很短的时间内喜欢的两件商品之间，可以给予更高的相似度。<br>（2）在描述目标用户偏好时，给其最近喜欢的商品较高权重。<br>2、在基于用户的协同过滤中：<br>（1）如果两个用户同时喜欢了相同的物品，那么可以给这两个用户更高的相似度。<br>（2）在描述邻居用户的偏好时，给其最近喜欢的物品较高权重。</p>
<p>额外考虑空间因素：<br>1、在基于商品的协同过滤中：<br>（1）同一个用户在同一个地域内喜欢的两件商品之间，可以给予更高的相似度。<br>2、在基于用户的协同过滤中：<br>（2）把类似地域用户的行为作为推荐的主要依据。</p>
<p>1.2.基于内容的推荐<br>基本思想：<br>根据推荐物品或内容的元数据，发现物品或者内容的相关性，然后基于用户以往的喜好记录，推荐给用户相似的物品。</p>
<p>例子：<br>电影A和C的类型都是爱情和浪漫，那么就会给看过电影A的人推荐电影C</p>
<p><strong>基于用户的协同过滤：</strong><br>适于物品比用户多、物品时效性较强的情形，否则计算慢。<br>推荐结果的个性化较弱、较宽泛，但能实现跨领域、惊喜度高的结果。</p>
<p><strong>基于物品的协同过滤：</strong><br>应用最广泛，尤其以电商行业为典型。<br>适于用户多、物品少的情形，否则计算慢<br>在物品冷启动、数据稀疏时效果不佳<br>推荐精度高，更具个性化<br>倾向于推荐同类商品，推荐的多样性不足，形成信息闭环</p>
<p><strong>基于内容的推荐：</strong><br>是最直观的算法<br>容易受限于对文本、图像、音视频的内容进行描述的详细程度<br>常借助文本相似度计算<br>不存在冷启动问题<br>但推荐精度通常垫底<br>主题过于集中，惊喜度不足</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E5%A4%8D%E7%9B%98%E6%80%BB%E7%BB%93/" rel="tag">复盘总结</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/" rel="tag">推荐系统</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-字节跳动推荐算法------学习笔记与思考" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/05/25/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95------%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8E%E6%80%9D%E8%80%83/"
    >推荐算法------学习笔记与思考</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/05/25/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95------%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8E%E6%80%9D%E8%80%83/" class="article-date">
  <time datetime="2019-05-24T16:00:00.000Z" itemprop="datePublished">2019-05-25</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E6%A1%86%E6%9E%B6%E4%B8%8E%E6%9E%B6%E6%9E%84/">框架与架构</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>  对字节的推荐算法着实感兴趣，于是乎，百忙之中还是记录了这篇文章，一切来自喜欢折腾和研究。 </p>
<h2 id="一、好奇心"><a href="#一、好奇心" class="headerlink" title="一、好奇心"></a>一、好奇心</h2><p>  俞军老师曾说：人是灵长类动物，为了生存，它会选择一种付出代价最低的生活方式，而且是尽他能力所能发现到效用最大化的生存方式。最好就是不用动、不用思考、不要早起，懒着就挺好。当他面前摆着几个选项的时候，他会通过货比三四五六七家而得出，哪个才是个人总效用最大化的方式。但效用这种东西很神奇，它是用各种各样的行为成本加总计算的。俞军老师的话总是简洁精辟，深入浅出，常读常新，老师的产品方法论，我每天晚上睡觉都要捧读一阵，慢慢吸收其中的思想精髓~<br>  老师举的例子：<br> 以前没有网络的时候，获取信息要靠看报纸、看电视，否则你啥也不知道，那个时候没人会想着做所谓的自媒体，毕竟渠道宣传费用高，信息推送效率低下。相对于用户来说，这个时候个人效用最大化的，就是买报纸或者买电视机。<br>但后来网络发展起来，新技术的出现导致消息推送效率大大提升，渠道宣传的成本急剧下降，去中心化的内容家喻户晓。<br>这个时候，同样是一件事，但供给的重心变了，导致用户个人效用最大化的方式也变了，现在基本很少人通过报纸和电视来获取信息了。<br>竞争的本质是影响用户决策，用户决策的约束力，来自于市场上什么东西贵了，什么东西便宜了，这才是突破口。<br>所以以上分析表明：<strong>抖音的成功来自：商业策略和强大算法算力。</strong></p>
<h2 id="二、初步理解"><a href="#二、初步理解" class="headerlink" title="二、初步理解"></a>二、初步理解</h2><p> 以下文段来自曹博士的PPT分享~在此手动大点赞。<br> 推荐系统，如果用形式化的方式去描述，实际上是拟合一个用户对内容满意度的函数，这个函数需要输入三个维度的变量。<br> 第一个维度是<strong>内容</strong>。头条现在已经是一个综合内容平台，<strong>图文、视频、UGC小视频、问答、微头条，</strong>每种内容有很多自己的特征，需要考虑怎样提取不同内容类型的特征做好推荐。<br> 第二个维度是<strong>用户特征</strong>。包括各种兴趣<strong>标签，职业、年龄、性别</strong>等，还有很多模型刻划出的<strong>隐式用户兴趣</strong>等。第三个维度是<strong>环境特征</strong>。这是移动互联网时代推荐的特点，用户随时随地移动，在工作场合、通勤、旅游等不同的场景，信息偏好有所偏移。<br> 结合三方面的维度，模型会给出一个预估，即<strong>推测推荐内容在这一场景下</strong>对这一用户是否合适。</p>
<h2 id="三、文本分析"><a href="#三、文本分析" class="headerlink" title="三、文本分析"></a>三、文本分析</h2><p> <strong>这里还有一个问题，如何引入无法直接衡量的目标？</strong><br>推荐模型中，<strong>点击率、阅读时间、点赞、评论、转发</strong>都是可以量化的目标，能够用模型直接拟合做预估，看线上提升情况可以知道做的好不好。<strong>但一个大体量的推荐系统，服务用户众多，不能完全由指标评估，引入数据指标以外的要素也很重要。</strong><br>这一点我有个疑问，就是用户第一次登录的时候冷启动的问题，当我们还没有对用户的ID和地址定位做出推理判断时，如何打造开篇之战呢？下次想去请教一下！<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0cUlacVdYVHJGU09Ma3pydlI3TktnVmZPSlo2b0lQQlNiaWNCMnE0UkdoaGliN25iM1JhTWExaEEvMA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>曹博士举的例子：比如广告和特型内容频控。像问答卡片就是比较特殊的内容形式，其推荐的目标不完全是让用户浏览，还要考虑吸引用户回答为社区贡献内容。这些内容和普通内容如何混排，怎样控制频控都需要考虑。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0ZUNraWNyVUNaWWhvcWRQUDBKMXQ4bzFWbGhQM01VWmIzS1hpYXg3ZTU5cjkwSENsMXM4ck5ZQlEvMA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>此外，平台出于内容生态和社会责任的考量，像低俗内容的打压，标题党、低质内容的打压，重要新闻的置顶、加权、强插，低级别账号内容降权都是算法本身无法完成，需要进一步对内容进行干预。毕竟营造安全干净的环境是抖音的一大重任，现在的策略是优质内容输出，所以这一点的重要性毋庸置疑。</p>
<p>那么上述算法目标到底怎么实现呢？<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0RDc5bmljenp6cG5IcG1rMUVpYXRhOWM4eE5yWWt4bGljNWFpYm9VRXNBNUF5a2JWbWdjZ2Z3dHU0US8w?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>前面提到的公式y = F(Xi ,Xu ,Xc)，是一个很经典的监督学习问题。<br>可实现的方法有很多，比如传统的协同过滤模型，监督学习算法Logistic Regression模型，基于深度学习的模型，Factorization Machine和GBDT等。这些传统算法都可以不同施以不同的参数和算力，通过数据监控和调参达到目标，但是真正落地还有考虑很多因素。<br><strong>一个优秀的工业级推荐系统需要非常灵活的算法实验平台，可以支持多种算法组合，包括模型结构调整</strong>。因为很难有一套通用的模型架构适用于所有的推荐场景。现在很流行将LR和DNN结合，前几年Facebook也将LR和GBDT算法做结合。<br>今日头条旗下几款产品都在沿用同一套强大的算法推荐系统，但根据业务场景不同，模型架构会有所调整。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0eEd2Z2hXbzRQeW96ZTJBYzAwdmljT3dXczF0eWtzMHlpYnllVXdObzZoQzNraWFzajdJUE5iU09RLzA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>主要有四类特征会对推荐起到比较重要的作用。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0T1hsMElJUmY1YmZpYjlhd2hKWFlpY24yVVZFYXpEc0VkZVNJRDAzdjJjeW9WNGVvTXhWU01JMEEvMA?x-oss-process=image/format,png" alt="在这里插入图片描述">第一类是相关性特征，就是评估内容的属性和与用户是否匹配。<br>显性的匹配包括关键词匹配、分类匹配、来源匹配、主题匹配等。像FM模型中也有一些隐性匹配，从用户向量与内容向量的距离可以得出。<br>第二类是环境特征，包括地理位置、时间。这些既是bias特征，也能以此构建一些匹配特征。<br>第三类是热度特征。包括全局热度、分类热度，主题热度，以及关键词热度等。内容热度信息在大的推荐系统特别在用户冷启动的时候非常有效。<strong>到这里竟然解决了我的疑惑enenen…….但是这个权重和比例怎么调整呢？</strong><br>第四类是协同特征，它可以在部分程度上帮助解决所谓算法越推越窄的问题。协同特征并非考虑用户已有历史。而是通过用户行为分析不同用户间相似性，比如点击相似、兴趣分类相似、主题相似、兴趣词相似，甚至向量相似，从而扩展模型的探索能力。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0RUxDcWdmajBieFJOZHNLbGh3YmZkcDRtYlI3dXppYkl0bm54RmwwamRjVDUzY3h1N3hDZzBvZy8w?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>模型的训练上，头条系大部分推荐产品采用实时训练。<br>实时训练省资源并且反馈快，这对信息流产品非常重要。用户需要行为信息可以被模型快速捕捉并反馈至下一刷的推荐效果。<br>头条线上目前基于storm集群实时处理样本数据，包括点击、展现、收藏、分享等动作类型。<br>模型参数服务器是内部开发的一套高性能的系统，因为头条数据规模增长太快，类似的开源系统稳定性和性能无法满足，所以其实头条内部做了很多优化，大量的研发哥哥们对自研的系统底层做了很多针对性的优化，提供了完善运维工具，更适配现有的业务场景。</p>
<p>目前来看呢，头条的推荐算法模型在世界范围内也是比较大的，包含几百亿原始特征和数十亿向量特征。<br>整体的训练过程是线上服务器记录实时特征，导入到Kafka文件队列中，然后进一步导入Storm集群消费Kafka数据，客户端回传推荐的label构造训练样本，随后根据最新样本进行在线训练更新模型参数，最终线上模型得到更新。<br><strong>这个过程中主要的延迟在用户的动作反馈延时，因为文章推荐后用户不一定马上看，不考虑这部分时间，整个系统是几乎实时的。</strong>我听到这里的时候，认为这里是很重要的，学习前端的时候，大部分课程比较注重性能优化，什么减少首屏时间啦，增加缓存啦，SEO啥的，前端主要是从异步加载文件资源和懒加载、预加载等角度入手，当前现在vue和React底层的diff算法也将时间复杂度从ON<em>3降到了ON级别，这是框架的作用。<br>特别是*</em>在5G普及的现在，快、准、狠 简直就是推荐算法的三大利器！**</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0TXJtTWJ4RmJpY05TakVNdmttWGljREZvQ0NySUtSZTNXS1h0SmN2U0hUcEZEc1ZmNWhGWk9hdVEvMA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>因为头条目前的内容量非常大，加上小视频内容有千万级别，推荐系统不可能所有内容全部由模型预估。所以需要设计一些召回策略，<br>每次推荐时从海量内容中筛选出千级别的内容库。召回策略最重要的要求是性能要极致，一般超时不能超过50毫秒。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0aGxiNnFJUW9RWFVXMHg1UGhLYzZERnFuN0FXM0JHcFAzMXhVbk4zYzh5UDR6STZZbDNpY2hmZy8w?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>召回策略种类有很多，头条主要用的是倒排的思路。离线维护一个倒排，这个倒排的key可以是分类，topic，实体，来源等，排序考虑热度、新鲜度、动作等。线上召回可以迅速从倒排中根据用户兴趣标签对内容做截断，高效的从很大的内容库中筛选比较靠谱的一小部分内容。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0eVM2S2JXd09uVFdqbGNiTGFvTWFTVldBVHJUQTZqUEo4NDdWem9laWE2T1pXWWxncmFGeHp0US8w?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<h2 id="四、内容分析"><a href="#四、内容分析" class="headerlink" title="四、内容分析"></a>四、内容分析</h2><p>内容分析包括文本分析，图片分析和视频分析。<br>头条一开始主要做资讯，文本分析在推荐系统中一个很重要的作用是用户兴趣建模。没有内容及文本标签，无法得到用户兴趣标签。<br>举个例子，只有知道文章标签是互联网，用户看了互联网标签的文章，才能知道用户有互联网标签，其他关键词也一样。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0RDc5bmljenp6cG5IcG1rMUVpYXRhOWM4eE5yWWt4bGljNWFpYm9VRXNBNUF5a2JWbWdjZ2Z3dHU0US8w?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>另一方面，文本内容的标签可以直接帮助推荐特征，比如魅族的内容可以推荐给关注魅族的用户，这是用户标签的匹配。<br>如果某段时间推荐主频道效果不理想，出现推荐窄化，用户会发现到具体的频道推荐（如科技、体育、娱乐、军事等）中阅读后，再回主feed,推荐效果会更好。<br>因为整个模型是打通的，子频道探索空间较小，更容易满足用户需求。只<br>通过单一信道反馈提高推荐准确率难度会比较大，子频道做的好很重要。而这也需要好的内容分析。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0OTc3eDlJZ0s5bWt3YVJNZjVNeHJQREFMZmVYbHZpYmRLSDFzcTNROXpTamFPQkRrdG1FT2liQkEvMA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>上图是今日头条的一个实际文本case。曹博士指出，这篇文章有分类、关键词、topic、实体词等文本特征。当然不是没有文本特征，推荐系统就不能工作，推荐系统最早期应用在Amazon,甚至沃尔玛时代就有，包括Netfilx做视频推荐也没有文本特征直接协同过滤推荐。但对资讯类产品而言，大部分是消费当天内容，没有文本特征新内容冷启动非常困难，协同类特征无法解决文章冷启动问题。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0S0Y3MnJJQU13NnkwZnp0NnEwMVhUYWliUm1qUVFaaEJRTlF4d0xwZVJZd1J2bmJXMWZreEZudy8w?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>今日头条推荐系统主要抽取的文本特征包括以下几类。<br>首先是语义标签类特征，显式为文章打上语义标签。<br>这部分标签是由人定义的特征，每个标签有明确的意义，标签体系是预定义的。<br>此外还有隐式语义特征，主要是topic特征和关键词特征，其中topic特征是对于词概率分布的描述，无明确意义。<br>而关键词特征会基于一些统一特征描述，无明确集合。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0SGljNWlidkY3c2lic2lheVgyT3JIdFdyQThnN1ZBZGljdHdUa0VQcElLa1c0RTBkZFVWb3JwS2twdkEvMA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>另外文本相似度特征也非常重要。在头条，曾经用户反馈最大的问题之一就是为什么总推荐重复的内容。<br><strong>这个问题的难点在于，每个人对重复的定义不一样。</strong>举个例子，有人觉得这篇讲皇马和巴萨的文章，昨天已经看过类似内容，今天还说这两个队那就是重复。但对于一个重度球迷而言，尤其是巴萨的球迷，恨不得所有报道都看一遍。<br><strong>解决这一问题需要根据判断相似文章的主题、行文、主体等内容，根据这些特征做线上策略。</strong></p>
<p>同样，还有时空特征，分析内容的发生地点以及时效性。比如武汉限行的事情推给北京用户可能就没有意义。<br>最后还要考虑质量相关特征，判断内容是否低俗，色情，是否是软文，鸡汤？</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0Y2liVDNVb0dSTEpjYmdoNmF6THo1dXRYUnk0WWQxZlN6N0RXNHYzR2M4elBUVWdXbXpXQnRTQS8w?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>上图是头条语义标签的特征和使用场景。<strong>他们之间层级不同，要求不同。</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0eHlidHF3UEx0Y1Fyb3lnS0ViQ3pWVnFHYXhWR1ppY3BiOUlZbEhSS0Y0UjVSN0VnM0thT1lldy8w?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>分类的目标是覆盖全面，希望每篇内容每段视频都有分类；<br>而实体体系要求精准，相同名字或内容要能明确区分究竟指代哪一个人或物，但不用覆盖很全。<br>概念体系则负责解决比较精确又属于抽象概念的语义。<br>实践中头条总部发现分类和概念在技术上能互用，后来统一用了一套技术架构。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0WVRWUGpwU2Fqa0RDUjYyNDJzWFA0dnlVWjNzcDR1UzhtN1ZJNnJaS0dacklxb2hRcEoxeGNnLzA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>目前，隐式语义特征已经可以很好的帮助推荐，而语义标签需要持续标注，新名词新概念不断出现，标注也要不断迭代。<br>其做好的难度和资源投入要远大于隐式语义特征，那为什么还需要语义标签？<br>有一些产品上的需要，比如频道需要有明确定义的分类内容和容易理解的文本标签体系。<br>语义标签的效果是检查一个公司NLP技术水平的试金石。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0MGZrbTBLd3V3Q0JvSEV0dnhSMHk5MkxDckVqWmpaeUJ4Z1FXOWFMaWFJWXl6WDJYcWVOWGljbXcvMA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>今日头条推荐系统的线上分类采用典型的层次化文本分类算法。<br>最上面Root，下面第一层的分类是像科技、体育、财经、娱乐，体育这样的大类，再下面细分足球、篮球、乒乓球、网球、田径、游泳等，足球再细分国际足球、中国足球，中国足球又细分中甲、中超、国家队等，相比单独的分类器，利用层次化文本分类算法能更好地解决数据倾斜的问题。<br>有一些例外是，如果要提高召回，可以看到我们连接了一些飞线。这套架构通用，但根据不同的问题难度，每个元分类器可以异构，像有些分类SVM效果很好，有些要结合CNN，有些要结合RNN再处理一下。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0czlXSkdkMEFHT2JqYnZIY3dMREF6d2g3aWNiUldVblVPTWExNkRLVldWM2liWGxnYVpIMnFuR0EvMA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>上图是一个实体词识别算法的case。<br>基于分词结果和词性标注选取候选，期间可能需要根据知识库做一些拼接，有些实体是几个词的组合，要确定哪几个词结合在一起能映射实体的描述。<br>如果结果映射多个实体还要通过词向量、topic分布甚至词频本身等去歧，最后计算一个相关性模型。</p>
<h2 id="五、用户标签"><a href="#五、用户标签" class="headerlink" title="五、用户标签"></a>五、用户标签</h2><p>内容分析和用户标签是推荐系统的两大基石。内容分析涉及到机器学习的内容多一些，相比而言，用户标签工程挑战更大。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0N2FnR0hDWW9TMWFpY1RzN1FrMFJVSDcweFI0TGRKV3hjcXRjUWtmZjBpY0pscmtZNzAxQndSdXcvMA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>今日头条常用的用户标签包括用户感兴趣的类别和主题、关键词、来源、基于兴趣的用户聚类以及各种垂直兴趣特征（车型，体育球队，股票等）。<br>还有性别、年龄、地点等信息。<br>性别信息通过用户第三方社交账号登录得到。<br>年龄信息通常由模型预测，通过机型、阅读时间分布等预估。<br>常驻地点来自用户授权访问位置信息，在位置信息的基础上通过传统聚类的方法拿到常驻点。<br>常驻点结合其他信息，可以推测用户的工作地点、出差地点、旅游地点。这些用户标签非常有助于推荐。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0V1dCdEhSRGFFVk00TE5ybTR3T3FjT2wwRzBYaWFFOGlhQ29pYkZnbUNxSUVMNGtsVHlyT2ZIdlhnLzA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>当然最简单的用户标签是浏览过的内容标签。<br>但这里涉及到一些数据处理策略。<br>主要包括：<br>一、过滤噪声。通过停留时间短的点击，过滤标题党。<br>二、热点惩罚。对用户在一些热门文章（如前段时间PG One的新闻）上的动作做降权处理。<br>理论上，传播范围较大的内容，置信度会下降。<br>三、时间衰减。用户兴趣会发生偏移，因此策略更偏向新的用户行为。因此，随着用户动作的增加，老的特征权重会随时间衰减，新动作贡献的特征权重会更大。<br>四、惩罚展现。如果一篇推荐给用户的文章没有被点击，相关特征（类别，关键词，来源）权重会被惩罚。<br>当然同时，也要考虑全局背景，是不是相关内容推送比较多，以及相关的关闭和dislike信号等。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0STRpYnJWOXRqZGY1YUJNczJEOE9MenBBQWhqU2g2NFRLRWhpY1BCMzV1ODJLZ0NRRlJLOE1pYlN3LzA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>用户标签挖掘总体比较简单，主要还是刚刚提到的工程挑战。<br>头条用户标签第一版是批量计算框架，流程比较简单，每天抽取昨天的日活用户过去两个月的动作数据，在Hadoop集群上批量计算结果。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0bTlwUlEzY3lDN3Z4QU1FcDIyUmRTNHVUdlZGZncwYVRjUkNxQklTOEJkQ2ljdWhCVWlhT3JKMUEvMA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>但问题在于，随着用户高速增长，兴趣模型种类和其他批量处理任务都在增加，涉及到的计算量太大。<br>2014年，批量处理任务几百万用户标签更新的Hadoop任务，当天完成已经开始勉强。集群计算资源紧张很容易影响其它工作，集中写入分布式存储系统的压力也开始增大，并且用户兴趣标签更新延迟越来越高。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0bXFDcmJRMktxTGljNEdlSVdma3IwckhpYXRlWTJybGNOdmtxUFBzSXNQUGZ3eHFlZnh3bEhFdXcvMA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>面对这些挑战。<br>2014年底今日头条上线了用户标签Storm集群流式计算系统。<br>改成流式之后，只要有用户动作更新就更新标签，CPU代价比较小，可以节省80%的CPU时间，大大降低了计算资源开销。<br>同时，只需几十台机器就可以支撑每天数千万用户的兴趣模型更新，并且特征更新速度非常快，基本可以做到准实时。这套系统从上线一直使用至今。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0b0ozeEFieG9ya2tKY3NnaWFqNTRWbEJxZlA5c2ljNU5RVEh5R0NsWDU3Y1lXWm1ZNklwakliWXcvMA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>当然，并非所有用户标签都需要流式系统。像用户的性别、年龄、常驻地点这些信息，不需要实时重复计算，就仍然保留daily更新。</p>
<h2 id="六、评估分析"><a href="#六、评估分析" class="headerlink" title="六、评估分析"></a>六、评估分析</h2><p>上面介绍了推荐系统的整体架构，那么如何评估推荐效果好不好？</p>
<p>有一句我认为非常有智慧的话，“一个事情没法评估就没法优化”。对推荐系统也是一样。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0bGtlT1A2eVphNGthOFlCOW1LYmZ5Mm9DaWI1eGFDSHlzVWN4RjJHV3J3cjRadU9LUGMwelZpYXcvMA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>事实上，很多因素都会影响推荐效果。<br>比如侯选集合变化，召回模块的改进或增加，推荐特征的增加，模型架构的改进在，算法参数的优化等等，不一一举例。<br>评估的意义就在于，很多优化最终可能是负向效果，并不是优化上线后效果就会改进。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0aklER0dEaWFEbVZBSlF2MmljblRDWld2MUxpYW9BZXMxcXlKbTZRT045NFF5bVlPVzZsUUJ6aWJtUS8w?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>全面的评估推荐系统，需要完备的评估体系、强大的实验平台以及易用的经验分析工具。<br>所谓完备的体系就是并非单一指标衡量，不能只看点击率或者停留时长等，需要综合评估。过去几年我们一直在尝试，能不能综合尽可能多的指标合成唯一的评估指标，但仍在探索中。<br>目前，头条上线还是要由各业务比较资深的同学组成评审委员会深入讨论后决定。<br>很多公司算法做的不好，并非是工程师能力不够，而是需要一个强大的实验平台，还有便捷的实验分析工具，可以智能分析数据指标的置信度。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0QWlhcG5xVHFYYTh3REk2ZmRmSnJta09qbllScDNtZjhvU0NVZGFqZFMxSGJDOVd4UEJuTVRzUS8w?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>一个良好的评估体系建立需要遵循几个原则，首先是兼顾短期指标与长期指标。<br>很多策略调整短期内用户觉得新鲜，但是长期看其实没有任何助益。<br>其次，要兼顾用户指标和生态指标。今日头条作为内容分创作平台，既要为内容创作者提供价值，让他更有尊严的创作，也有义务满足用户，这两者要平衡。还有广告主利益也要考虑，这是多方博弈和平衡的过程。<br>另外，要注意协同效应的影响。实验中严格的流量隔离很难做到，要注意外部效应。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0TGFqQUVyTkppYXQzU25hMDgzcnlvb2FsT0JMQTJIaWFWdFFOMXlWdURTbkVRZ3lpY2pzN1J6QzRBLzA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>强大的实验平台非常直接的优点是，当同时在线的实验比较多时，可以由平台自动分配流量，无需人工沟通，并且实验结束流量立即回收，提高管理效率。<br>这能帮助公司降低分析成本，加快算法迭代效应，使整个系统的算法优化工作能够快速往前推进。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0REhSSzF2bEhaRGlhU3BCbXA5VmJMSW9PZnpvM1FUZmJwajAybGdrNEE1Zlo5OXJadmxvSFJudy8w?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>这是头条A/B Test实验系统的基本原理。<br>首先工程师会在离线状态下做好用户分桶，然后线上分配实验流量，将桶里用户打上标签，分给实验组。<br>举个例子，开一个10%流量的实验，两个实验组各5%，一个5%是基线，策略和线上大盘一样，另外一个是新的策略。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0d0JFZm5FeThuN3dRaWJkSENveGRLdnVUS1A4SmhpY09UUzJkNHNlaWE0cU9Sc0xHSjJUakVMbkd3LzA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>实验过程中用户动作会被搜集，基本上是准实时，每小时都可以看到。<br>但因为小时数据有波动，通常是以天为时间节点来看。动作搜集后会有日志处理、分布式统计、写入数据库，非常便捷。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0REp2ODk5Yzg2M2lhdlhGSGh5bE80dVI3MjAxN1ljcHVmclN3TlBBS1BVOEVvM3hpYXdVZlN1MXcvMA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>在这个系统下工程师只需要设置流量需求、实验时间、定义特殊过滤条件，自定义实验组ID。<br>系统可以自动生成：实验数据对比、实验数据置信度、实验结论总结以及实验优化建议。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0VTlpY2lhcERITG05aWNMUjVZZ2FaVDh3bFpqNVlpYXlYR0RFMjFEczJGQklCYXBVZEkweDdQS3NBQS8w?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>当然，只有实验平台是远远不够的。<br>线上实验平台只能通过数据指标变化推测用户体验的变化，但数据指标和用户体验存在差异，很多指标不能完全量化。<br>很多改进仍然要通过人工分析，重大改进需要人工评估二次确认。</p>
<h2 id="七、内容安全"><a href="#七、内容安全" class="headerlink" title="七、内容安全"></a>七、内容安全</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0QUtoY2xVMFdqMmVRN1dROW92VjZmU2hsZHNrZ1B1WWlhQWlieVgwbmdEZUhVN25tRGRaYmliRk93LzA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>最后是曹博士介绍今日头条在内容安全上的一些举措。<br>头条现在已经是国内最大的内容创作与分发凭条，必须越来越重视社会责任和行业领导者的责任。如果1%的推荐内容出现问题，就会产生较大的影响。<br>因此头条从创立伊始就把内容安全放在公司最高优先级队列。成立之初，已经专门设有审核团队负责内容安全。当时研发所有客户端、后端、算法的同学一共才不到40人，头条非常重视内容审核。<br>现在，今日头条的内容主要来源于两部分:<br>一是具有成熟内容生产能力的PGC平台，一是UGC用户内容，如问答、用户评论、微头条。<br>这两部分内容需要通过统一的审核机制。如果是数量相对少的PGC内容，会直接进行风险审核，没有问题会大范围推荐。<br>UGC内容需要经过一个风险模型的过滤，有问题的会进入二次风险审核。<br>审核通过后，内容会被真正进行推荐。这时如果收到一定量以上的评论或者举报负向反馈，还会再回到复审环节，有问题直接下架。<br>整个机制相对而言比较健全，作为行业领先者，在内容安全上，今日头条一直用最高的标准要求自己。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfanBnL3djN1lOUG0zWXhXSkJiZ0tsV3dZNXZTaFpvSDZQNkd0OVRNbmZvaWNac1IzR2YzU1N4YmljU2liaE9hWVlsSGM2bTg5M0pEakdndTVuUm5MVGhoZTZBY1dBLzA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>   分享内容识别技术主要鉴黄模型，谩骂模型以及低俗模型。今日头条的低俗模型通过深度学习算法训练，样本库非常大，图片、文本同时分析。这部分模型更注重召回率，准确率甚至可以牺牲一些。<br>谩骂模型的样本库同样超过百万，召回率高达95%+，准确率80%+。如果用户经常出言不讳或者不当的评论，会有一些惩罚机制。<br>泛低质识别涉及的情况非常多，像假新闻、黑稿、题文不符、标题党、内容质量低等等，这部分内容由机器理解是非常难的，需要大量反馈信息，包括其他样本信息比对。目<br>前低质模型的准确率和召回率都不是特别高，还需要结合人工复审，将阈值提高。目前最终的召回已达到95%，这部分其实还有非常多的工作可以做。头条人工智能实验室李航老师目前也在和密歇根大学共建科研项目，设立谣言识别平台。</p>
<h2 id="八、我的思考与体会"><a href="#八、我的思考与体会" class="headerlink" title="八、我的思考与体会"></a>八、我的思考与体会</h2><p>1.我们经历了从毛遂自荐，口碑相传的个体推荐形式，逐步过渡到1/2或者2/3简单多数规则的群体推荐形式，以及进一步转化到涉及各种权重、混合、360度全方位等复杂规则的群体推荐形式。<br>然而，不管是个体自荐和推荐，还是群体推荐；抑或不论是简单多数规则，还是复杂规则；本质上都属于一种人为推荐形式。而人为推荐则必然不同程度地存在着诸多如暗箱操作、感情用事、趋利避害、标准不一的主观性意见缺陷，导致难以得到客观化的满意结果。<br>2.为使推荐的结果更加合乎实际和更加客观化，通过计算机采取一定技术方法的算法推荐系统就应运产生了。与人为推荐系统的发展历程一样，早期计算机推荐系统中的算法和技术也是十分简单和粗糙的，如打分预测，即通过用户（User）对物品（Item）的打分（Rating）进行评分预测推荐；或相似评估，即通过对用户和物品一些较为粗糙简单的明显属性进行分析评判推荐。<br>只是在进入互联网时代后，随着云计算和大数据分析等技术的发展，在运算和存储能力跃入新的层级之后，推荐算法不仅在数量的广度上，而且在技术的深度上都达到了前所未有的一个水平。<br>3.目前各种具体推荐算法很多，而且分类标准也不尽相同，但万变不离其宗，由于推荐系统本质是向用户推荐合适物品的个性化服务，主要涉及到用户和物品二个对象。<br>4.正如同古希腊大哲学家苏格拉底所说的那样，人最难认识的是自己，有时用户很难用恰当的关键词语来描述自己的需求和想法，又或是无法对自己未知而又可能感兴趣的信息做出描述而显得无所适从或者说无可选择。因此，通过机器算法的推荐系统能得到进一步的发展和应用就成为顺理成章的事情了。从用户的角度来思考：我们一方面规避不了人性的懒惰，不自觉的被动接受社会提供之物，一方面又渴求感兴趣的猎物，想要自己的圈子和需求，人性真是个复杂又奇妙精灵，怎样在残酷流量争夺的大背景下，充分发掘人性真需求，部署好算法和算力，应该是AI产品经理要深入思考学习的重点。在这里，先列举两种比较单纯的思路。</p>
<blockquote>
<p>1、以人为中心的“人以群分”推荐算法<br>这种推荐系统的内在原理有一个假设前提，即相同群体中的成员拥有共同的兴趣爱好，因此同类人喜欢什么就推荐什么。很明显在这种推荐系统中，关键点是如何全面准确地划定人“群”的属性，即“群”的相似度和近似度对个体的影响力权重程度。一般地，最常见的是基于人口统计学中个体自然的基本属性而推荐。<br>因此，根据个体的基本属性在理论上就会出现很多推荐子系统，如基于性别的，基于年龄的，基于学历的，基于地域的等等推荐系统，这里的关于人的推荐系统是平行关系的，与下面的物品推荐系统层级关系有所不同。当然在实际经济中，并不是所有的推荐系统都是有用或者说有效的，因此就必须根据个体和物品进行有目的的筛选淘汰了。<br>栗子：基于年龄的推荐系统<br>这里的“群”就是年龄，而且假设年龄对物品和用户的影响力权重占第一位。推荐原理如下：<br>第一步：机器通过大数据以“年龄”为关键属性搜寻找到各个用户之间的相似度和邻近度。<br>第二步：对不同用户A,B,C的相似度进行排序。<br>第三步：选出与当前用户A最相近的用户C。<br>第四步：将用户A喜欢的物品a推荐给没有接触过的用户C。<br>这是较为通俗易懂的基于用户简单推荐方式，当然在实际经济生活中，“群”属性确定，推荐方式和具体运算过程则要复杂得多，但基本原理相似。<br>2、以物为中心的“物以类聚”推荐算法<br>与“人以群分”的推荐方式相类似，它是以物品的相似度代替了用户的相似度。这种推荐系统也有一个假设前提，即同一用户对相同类型的物品具有共同的兴趣爱好或者说吸引力，因此用户喜欢什么就推荐相同类型的物品。一样的道理，在这种推荐系统中，关键点是如何全面准确地划定物品的“类”的属性，即物品的“类”属性相似度和近似度对个体的影响力权重程度。<br>与“人以群分”推荐算法中“群”的各个属性划分是基于横向平行关系不同，在“物以类聚”推荐算法中物品的“类”是基于纵向层级关系而划定。而且由于大千世界各种物品成千上万，因此首先必须确定一个物品分门别类的划分标准，或者说确定一个比较合适的划分标准就显得十分重要。<br>物品具有自然属性和商品属性，因此可以按生物标准进行自然属性分类，也可以按经济属性进行商品属性分类；但由于我们都处于经济社会中，因此一般地，我们将物品的类别划分确定为以商品经济属性为主，兼顾生物自然属性进行划分。第一层先划分为有形产品和无形服务；第二层再根据惯例按国民经济行业有关第一产业、第二产业、第三产业进行行业分类。然后每一层按照从大到小，结合物品的品类、品种等自然生物属性和功能、用途、产地等商品属性逐层进行细分，直至分解到最后的最底层每一个单品sku。</p>
</blockquote>
<p>5.写在最后：推荐算法的实际落地场景真的要考虑很多因素，这次实习，接触到了很多架构应用和优化，虽然很多业务不能亲自体验，但我也从分享会和日常的观察中学到了很多知识，看到了AI的影响力，想要做好AI产品经理，除了之前积累的沟通技巧、对用户的同理心、运营策略、产品sense，还有有深厚的背景知识和架构理论。原来我们在实验室做的那一套深度学习网络，在实际大厂中，要反复迭代这么多版本~<br>水能载舟，亦能覆舟，AI就好像神奇的精灵，把AI驯服掌控在人力的盘查和监控下，才能正向反馈，激活商业策略的原动力！</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/AI%E4%BA%A7%E5%93%81%E7%9A%84%E6%80%9D%E8%80%83/" rel="tag">AI产品的思考</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/" rel="tag">推荐算法</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-学习微博数据库的设计思想" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/05/18/%E5%AD%A6%E4%B9%A0%E5%BE%AE%E5%8D%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"
    >学习微博数据库的设计思想</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/05/18/%E5%AD%A6%E4%B9%A0%E5%BE%AE%E5%8D%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/" class="article-date">
  <time datetime="2019-05-17T16:00:00.000Z" itemprop="datePublished">2019-05-18</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88/">系统架构方案</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="初创阶段"><a href="#初创阶段" class="headerlink" title="初创阶段"></a>初创阶段</h2><p>   初期微博作为一个内部创新产品，功能比较简洁，数据库架构采用的是标准 1M/2S/1MB 结构，按照读写分离设计，主库承担写入，而从库承担访问。如果访问压力过大，可以从库的数量 获得 scale out 的能力。 在初期，这种架构其实就可以满足业务的增长了，没有必要进行过度设计，开始就搞得过于复杂可能会导致丧失敏捷的可能。 </p>
<h2 id="爆发阶段"><a href="#爆发阶段" class="headerlink" title="爆发阶段"></a>爆发阶段</h2><p>   随着微博上线之后用户活跃度的增高，数据库的压力也与日俱增，这时要通过采购高性能的硬件设备来对单机性能进行 scale up，以达到支撑业务高速发展的需求。然后，通过使用高性能设备争取来的时间对微博进行整体上的业务垂直拆分，将用户、关系、博文、转发、评论等功能模块分别独立存储，并在垂直拆分的基础上，对于一些预期会产生海量数据的业务模块再次进行二次拆分。<br>  由于微博最开始的时候就出现了一个很高的用户增长峰值，在这个阶段技术上的积累不是很丰富，而且最主要的是没有时间进行架构改造，所以通过购买 PCIE­ Flash 设备来支持的很多核心业务，最开始的 feed 系统是重度依赖 MySQL 的。 虽然看上去高性能硬件的价格会比普通硬件高很多，但是争取来的时间是最宝贵的，很有可能在产品生命的初期由于一些性能上的问题引发产品故障，直接导致用户流失，更加得不偿失。所以在前期的爆发阶段，暴力投入资金解决问题反而是最划算的。<br>  博文是微博用户主要产生的内容，随着时间维度不断增 大，最终会变得非常巨大，如何在满足业务性能需求的情况下，尽可能地使用较少的成本存储，是一个比较有挑战性的问题。<br>  因为索引所需存储空间较少，而内容存储所需空间较大， 且这两者的使用需求也不尽相同，访问频次也会不同，需要区别对待。解决方案有分别对索引和内容采用先 hash，再按照时间维度拆分的方式进行水平拆分，尽量保障每张表的容量在可控范围之内，以保证查询的性能指标。 最后，业务先通过索引获得实际所需内容的 id，再通过内容库获得实际的内容，并通过部署 memcached 来加速整个过程，虽然看上去步骤变多，但实际效果完全可以满足业务需求。<br>  微博中的索引和内容各自分了很多的端口，每个端口中又分了很多的 DB，每个 DB 下的表先 hash 后按照时间维度进行了拆分，这样就可以在后期遇到容量瓶颈或者性能瓶颈的时候，选择做归档或者调整部署结构，无论选择哪种都非常的方便。另外，在做归档之后，还可以选择使用不同的硬件来承担不同业务，提高硬件的利用率、降低成本。<br>  在这个阶段，肖鹏老师对很多的微博功能进行了拆分改造，比如用户、关系、博文、转发、评论、赞 等，基本上将核心的功能都进行了数据拆分，以保障在遇到瓶颈的时候可以按照预案进行改造和调整。</p>
<h2 id="沉淀阶段"><a href="#沉淀阶段" class="headerlink" title="沉淀阶段"></a>沉淀阶段</h2><p>  在上一个阶段，微博的数据库经历了很多的拆分改造，这也就直接造成了规模成倍增长的状况，而业务经历了高速增长之后，也开始趋于稳定。在这个阶段，微博开始着重进行自动化的建设，将之前在快速扩张期间积攒下来的经验用自动化工具加以实现，对外形成标准化和流程化的平台服务。 相继建设改造了备份系统、监控系统、AutoDDL 系统、MHA 系统、巡检系统、慢查系统、 maya 中间件系统。并且为了提高业务使用效率、降低沟通成倍，相对于内部管理系统，重新开发 了 iDB 系统供数据库平台的用户使用。通过 iDB 系统，用户可以很便捷地了解自己业务数据库的运行状态，并可以直接提交对数据库的 DDL 修改需求，DBA 仅需点击审核通过，即可交由 Robot 处理。<br>    其实个人理解，在产品发展到一定阶段之后 无论如何运维都会进入到自动化阶段，因为前期活儿少，人工足够支持变更和其中操作，且有很多特殊情况需要人，尤其是人脑的介入判断和处理。以 MySQL 开发规范来说，如果提前做好约定，并进行好限制，虽然开发人员在使用的过程中会感觉受到的约束，但是这可以避免线上发生完全不可控的故障，并且有些问题由于规范的存在就永远不会发生了。<br>    举个例子，MySQL 的慢查是导致线上性能慢的罪魁祸首，但是很多时候并不是没有 index，只是由于代码写得有问题，引起了隐式转换等问题。在这种情况下，一般建议所有的 where 条件都加上双引号，这样就可以直接消除隐式转换的可能性了，开发人员在写代码的时候也不用刻意去考虑到底是字符型还是 int 型。 继续说自动化。过了初期阶段、规模扩大之后，就会出现活多人少的情况，这种压力会促使大家自 动去寻求解决方案，也就自然而然地进行了自动化改造了。<br>     自动化分为两个阶段。第一个阶段是机器替代人工，也就是将大部分机械劳动交给程序来 实现，解决的是批量操作，重复性劳动的问题；第二个阶段是机器替人，也就是机器可以替人进行一定的判断之后进行自我选择，解放的是人力。<br>     不过第二个阶段是企业一直追求的理想状态，至今也仅完成了很简单的一些小功能，比如动态调整 max mem 等逻辑非常简单的功能。  数据库平台并不仅有 MySQL 还有 Redis、Memcached、HBase 等数据库服务，而在缓存为王的趋势下，微博 2015 年重点将研发精力投入在 Redis 上。 微博使用 Redis 的时间较早，并且一开始量就很大，于是在实际使用过程中会遇到很多实际的问题，内部分支版本要针对这些实际问题进行优化，</p>
<blockquote>
<p>增加基于 pos 位同步功能。在 2.4 版本中，Redis 的同步一旦出现中断就会重新将主库的数据”全 部”传输到从库上，这会造成瞬时的网络带宽峰值，并且对于数据量较大的业务来说，从库恢复的时间较慢,借鉴 MySQL 的主从同步复制机制，将 Redis 的 aof 改造 为记录 pos 位，并让从库记录已经同步的 pos 位，这样在网络出现波动的时候即使重传，也仅是一部分数据，并不会影响业务。<br>在线热升级。在使用初期，由于很多新功能的加入，Redis 版本不断升级，为了不影响业务, 每次 升级都需要进行主库切换，给运维带来了很大的挑战，于是开发了热升级机制，通过动态加载 libredis.so 来实现版本的改变，不再需要进行主库切换，极大地提升了运维效率，也降低了变更带来的风险。<br>定制化改造。在使用 Redis 的后期，由于微博产品上技术类的需求非常多，为此专门开发了兼容 Redis 的 redisscounter，用以专门存储技术类数据，通过使用 array 替换 hash table 极大地降低 内存占用。而在此之后，开发了基于 bloom filter 的 phantom 解决判断类场景需求。 Redis 中间件 在 2015 年肖鹏老师自研的 Redis 中间件 tribe 系统完成了开发和上线，tribe 采用有中心节点的 proxy 架构设计，通过configer server 管理集群节点，并借鉴官方 Redis cluster 的 slot 分片的设计思路来完成数据存储，最终实现了路由、分片、自动迁移、fail over 等功能，并且预留了操作和监控 的 API 接口，以便同其他的自动化运维系统对接。</p>
</blockquote>
<p>  关于重复造轮子，个人认为每个公司都有自己的场景，开源软件可以给我们提供一个很好的解决思路，但并不能百分百适应应用场景，所以重构并不是坚决不可接受的，有些事情要借鉴老祖宗的折衷思想。<br> 微博后期开发了 Databus，可以基于 MySQL 的 binlog 将数据同步到其他异构的数据库中，并且支持自定义业务逻辑。目前已经实现了 MySQL 到 Redis 和 MySQL 到 HBase 的数据流向，下一步计划开发 Redis 到 MySQL 的数据流向。开发 databus 最初的初衷是解决写Redis 的问题，由于有些数据即需要写入 MySQL 中，也需要写入 Redis 中。如果在前端开启双写也是可以解决的，但是这会造成代码复杂现象；如果在后端 实现一个数据链路，会让代码更加清晰，同时也可以保障数据的最终一致性。后来在实际应用中， databus 慢慢也开始承担导数据的功能。<br>    下面说一下目前微博积累下来的数据库的设计习惯。通常来说我们都会采用一些“反范式”的设计思路，而“反范式“设计带来便利的同时确实也带来了一些问题，尤其是在数据规模变大之后。有如下几种解决方案。<br>    预拆分。在接到需求的时候提前针对于容量进行评估，并按照先垂直后水平进行拆分，如果可以按照时间维度设计，那就纳入归档机制。通过数据库的库表拆分，解决容量存储问题。<br>    引入消息队列。利用队列的一写多读特性或多队列来满足冗余数据的多份写入需求，但仅能保障最终一致性，中间可能会出现数据延迟。         引入接口层。通过不同业务模块的接口将数据进行汇总之后再返回给应用层，降低应用层开发的编码复杂度。 另外一点就是，如果数据库预估量比较大的话，要参考博文的设计思路，在最开始的时候进行索引和内容的分离，并设计好 hash 和时间维度的分表，最大可能地减少后续拆分时可能遇到的问题和困难。<br>    总之，要尝试利用各大云计算资源，实现 cache 层的动态扩缩容，充分利用云计算的弹性资源，解决业务访问波动的问题。<br>    下面是一些问题与思考的收集，来自肖鹏老师答疑，后期来深入学习理解。</p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h2><pre><code>1. 数据和索引分离是业务层做还是中间件做？感觉中间件做了很多工作，这部分能不能稍微展开一 下？由于在当初拆分改造的时候并没有考虑中间件的方案，故目前是业务逻辑上实现的索引和内容的分离。
  以我个人的经验来看，即使使用中间件的解决方案，依然应该在业务逻辑层将索引和内容分割。中间件最核心的功能就是让程序和后端资源隔离，后端不管有多少资源，对于程序来说都是一个统 一的入口，所以中间件解决的是水平拆分的问题，而索引和内容分离属于垂直拆分的范围，个人认为不应该由中间件解决。 
  2. 印象最深的一次数据库服务故障能否回忆并说几点注意事项？ 
  要说印象最深的一次就是数据库服务的故障，当时有个同事不小心执行了 drop table 命令，了解数 据库的人都知道这个命令有多大的威力，我们利用架构上面争取来的时候紧急进行了单表恢复，虽然降级了一段时间，但是整体上并没有影响用户。 对此我要说的注意事项就是规范。自那之后，我们修改了所有删表需求的流程，并保证严格执行， 无论多么紧急的删除需求都必须进行24小时的冷却，具体如下。 执行 rename table 操作，将 table rename 成 table—will­drop。 等待 24 小时之后再执行 drop 操作。 
  3. 在微博暴涨阶段，对表进行拆分的部分，“对索引和内容进行hash，之后再按着时间纬度进行拆 分”，这个做hash的部分是否能展开说一下？ 这个其实没有那么复杂。首先我们会预估一下一年大概的数量级别，然后计算需要拆分的表数目， 并且尽量将每个表控制在 3 千万行记录以内（当然这只是希望，现实证明计划赶不上变化）。比如我们使用模 1024 的办法，根据博文 id 将所有产生的博文分到 1024 张表中（这个博文 id 又涉及我 们的 uuid 全局发号器就不展开了）。 由于微博大部分用户产生的内容都会和时间挂钩，所以时间维度对我们来说是强属性，基本都会 有，假设每个月都建表，这样就等于每个月会生产 1024 张表。如果数据库的容量出现瓶颈了，我 们就可以根据时间维度来解决，比如将 2010 年的所有表都迁移到其他的数据库中。 
2. 问题 1 中说的索引是指什么，如何找到对应内容的算法？ 索引其实指的并不是内容的算法，举个例子，如果你需要存储博文，那么必然会存储一个唯一的 id 来进行区分，然后会存储一些这个博文发表时候的状态，比如谁发的、什么时候发的、我们认为这些状态和 id 都是索引；而博文内容就是实际的内容，由于内容比较大，和索引存储在一起会导致 MySQL 的性能下降，而且很多查询只需要最终拿到博文 id 其实就等于拿到了实际的博文。 我们可以对索引进行各种过滤之后得到一个最终要输出给用户的索引 list，再根据这个 list 从内容库 中查找实际内容，这样就符合 MySQL 的返回结果集越小性能越高的规律，从而起到优化的效果。 
3. NoSQL发挥着哪些作用？ 在微博NoSQL发挥了越来越重要的作用，比如说 rediscounter，我们自研的计数服务，当初计数存 贮在 MySQL 中，由于所有计数都是 update set count = count +1 这种高并发对单行数据的写操 作，会引发MySQL多种锁，而且并发越高锁得越厉害。 由下图可见，如果对单行的并发操作达到500 以上，tps就会从上万变成几百，所以MySQL无论怎么 优化都无法很好地支持这个业务场景，而Redis就可以。 我个人认为，NoSQL 就像瑞士军刀，在最适合的地方它就是最优的方案，个人认为这也是 NoSQL 未来发展的方向，每一个都有一个最佳场景。
4.我们公司将来会有很多智能设备，今年或许就两万个以上的设备，一年后可能再翻很多倍，要收 集数据，都是 JSON 报文格式，JSON 里字段标识不同类型的报文，看似不太适合以字符串存进 varchar 或 longtext 字段，DB 存储是否可充分利用 MYSQL 的原生JSON，存一列就搞定，而 不必用无法扩展的“宽列”进行存储，或者POSTGRES 还是其他的 DB 能提供更方便的存储吗？前 期还用的时候，MySQL 5.7 还没 FINAL, 利用 mariadb 多主分担N多设备接进来，DB 写入层的负 载，对这种大量设备一直要传数据的写入场景有什么指导？ 我们其实也在看 MySQL 5.7 的新特性，其中 JSON 对于数据库设计会带来比较大的冲击，按照你 的说法，确实不应该使用 varchar 或者 text 之类的字段，不过我个人建议智能设备这种场景，如果 有可能，最好直接上 HBase，因为迟早数据量会变得 MySQL 难以支撑，这属于天生没有优势。 
5. “数据和索引分离”是什么意思呢，是数据文件和索引文件分开存放到不同机器上吗？ 应该是内容和索引，这样更好理解，大家把这个理解为业务层上的垂直拆分就好。由于进行了垂直 拆分，必然存在于不同的数据库实例中，所以可以放在一台物理机上，也可以放到不同的物理机 上，我们按照习惯都是放在不同的物理机上的，以避免互相干扰。 
6. 哪些信息存MySQL？哪些存NoSQL？用的是哪种NoSQL？ 这就涉及一个分层存储的问题了，目前我们主流是 MySQL + Redis+mc，mc 和 Redis 都用来抗热 点和峰值，而 MySQL 则为数据落地，保障最终有原始数据可查。大部分请求会到 mc 或者 Redis 层就返回了，只有不到 1% 的数据会到 MySQL上。</code></pre>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E6%9E%90/" rel="tag">数据库分析</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-csdn_export_md" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2018/06/20/csdn_export_md/"
    >第三周实习复盘总结---灵活多维度拉新</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2018/06/20/csdn_export_md/" class="article-date">
  <time datetime="2018-06-19T16:00:00.000Z" itemprop="datePublished">2018-06-20</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE%E6%8F%90%E6%A1%88/">实习项目提案</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<p>实习第三周<del>经过无数次的头脑风暴、研讨优化、版本修改、迭代管理之后，泡泡小程序的运营方案终于新鲜出炉！<br>看着改了N次的运营流程图，想起昨天凌晨两点还在思考的优化细节，我露出了老母亲般的笑容，终于明白为什么leader说产品就是自己的孩子了</del> 当然，苦累都是值得的，在困难和思考中才能让自己迅速成长！</p>
<h2 id="底层需求-有效闭环"><a href="#底层需求-有效闭环" class="headerlink" title="底层需求+有效闭环"></a>底层需求+有效闭环</h2><p>   想到了勒庞在《乌合之众》中描述的群体心理，这个万金油一般神奇的心理战术用在社区运营上再恰当不过了<del>真理似乎一直在不断地被循环印证。古老的心理学加上流行元素的碰撞，让我们像古代的魔法师一般，操控着蠢蠢欲动的集结群体。<br>  勒庞认为：“自觉地个性的消失，以及感情和思想转向一个不同的方向，是就要变成组织化群体的人所表现出的首要特征。”比如，在五四运动初期，“民主和自由”的口号指导着人民去救亡图存，当运动如火如荼的开展后，个人情绪在群体中被格外放大，口号与主题的分化不明确，让群体做出了类似“火烧赵家楼”的事件。<br>  <strong>群体的基本特征可以大致归为两方面，一是个性的消失，二是感情的强化。再者便是“无意识品质占上风”</strong>，当群众聚集时往往都会情绪高涨，使个人的感情不分青红皂白的归顺集体思想，从而不自觉地进入到集体意识中去，群体行为脱离理性的的最明显体现就在于群体的无意识行为代替了个人的有意识行为。<br>  在我看来，泡泡模块的拉新方案是打造一个影视、明星、粉丝的密切互动平台，囊括 了明星、影视、文化、兴趣等各种交流圈。通过引入并不断夸大私域流量池的方法，奠定后续留存与促活的群体基础。<strong>拉新的首要是精确刻画用户画像和一丝不苟的、滴水不漏的分析用户需求！</strong>需求对了，就可以很轻松地实现用户无限裂变拉新，就好像茫茫沙漠中的一场及时雨，一出场就迎来饥肠辘辘、求贤若渴的大批用户。正所谓：思路对了，事半功倍。所以我认为“用户拉新”方案的最高境界就是从用户的底层需求出发，探寻人性最深处的弱点。一个点足够，但是一定要保证是足够精准的，且绝对符合用户底层需求的，然后用它来作为贯穿整场活动的连接点。在刻画用户画像的时候，我认为要具体到个人，世上没有两片完全相同的叶子，同理，也没有完全一致的需求。社区是一切相似需求的集合体，要想引入私域流量，有两点很重要。<br>  <strong>1.以个体的眼光去观察最真实最细微的需求，具体到这个需求的频次与场景，类型和大小。充分利用用户的异质性和产品的情景性去打造流量池的入口！</strong><br>  <strong>2.以群体的策略去营销，用户的需求大小不一，主次不同，</strong>就算是调查问卷上清清楚楚的圈点与钩叉，也只是某一个情景下用户不假思索的反应，它的来源具有参考性但不具备完全正确性，但是呢，人是很奇妙的动物，流量池的原理就是利用了人性的从众、贪婪、趋利避害和虚荣心。从这个角度来说，用户是具有可塑性的，<strong>流量池的初衷就是把一个个具象的需求同治化、抽离最核心的要素，包装成一个大众需求的模样，就像过滤器一样，筛选出可以划分在一个集合的大众需求，再通过整形、转化、把不同的需求变成具有同样诉求的心理渴望，再充分利用人性的可塑性、脆弱性和同理心，弱化甄别需求，求同存异，</strong>在同化的过程中顺藤摸瓜，让用户以为这就是她的归属和家，这就是她苦苦追寻的精神家园</del>最终，以群体的角度去拉新促活。仔细思考一下，吃播文化的兴起，Papi酱的爆红，粉丝后援会的建立不都是利用了《乌合之众》里面的心理学战术吗？直播带货其实也就是网红与自己的私域流量进行物理经营、情感交互，最终使他们心甘情愿的掏出腰包的过程。<br>  <strong>这一点，很像算法里面的分治与归并，先切分、细化、再汇总、同治！</strong><br>思路对了，更重要的就是数据来源了，爱奇艺泡泡社区圈就像一种另类的订阅制电商，明星追踪就相当于个人订阅的某种服务。这种类似订阅模式通常具备较高的回购率，可以持续吸引用户付费，获取较好的现金流。通过明星圈、影视圈的互动，让用户及时了解爱豆动态，观看爱豆参与的综艺， 电影或者电视剧并在相关圈子群聊、发帖以及评论点赞，为爱豆打榜。这也符合泡泡社区 “泡圈、泡剧、泡 idol”的定位以及打通视频-明星-粉丝关系链的目标。和竞品比较，比较出新的一点就是线下的粉丝后援见面会活动，当我向leader提出这个方案时，一开始是被否定的，但是我经过大量的统计和调查之后，向leader说明了这种方案的可行性和必要性，最终被采用还是感到非常荣幸和有成就感的~<br><strong>我提出这个需求的背景是：</strong><br>我们几个实习生确定好了调研方向、设计调查问卷之后、通过实地访谈，朋友圈、泡泡圈发帖以及微博发放，收集了300余份的有效问卷之后，我分析得出用户的线<strong>下情感诉求很强烈。</strong>这个逻辑很简单，如果没有差异化优势，就会出现腾讯视频、优酷视频和爱奇艺视频三足鼎立的局面，毕竟功能和界面的改造不会拉开太大差距，<strong>如果功能相同、设计slogan相似，用户就会纠结于哪种渠道，当用户产生犹豫时，从那一刻起，我们就失去了焦点和热度。</strong><br>品牌的影响力就是提到什么，用户就能不假思索的想到并参与使用。<br>1.如果仅仅是线上的打卡问候与花絮回看，<strong>用户触摸不到最真实的场景和最新鲜的热度，自然就不会高效率地促进留存和转化环节</strong>。毕竟，亲自参与花絮拍摄、探班送祝福、粉丝机场见面会都能让用户真实真切的参与其中，<strong>通过这种肌肉型的强化记忆和亲身体验，提高用户粘性。</strong>当流量入口过于依赖单一平台时，一旦遇到不可抗力影响，就只能沦为待宰的羔羊。<strong>因此，我的思路是依托于平台的“点”、“面”、“线”主动去寻找更多元化的方式。泡泡圈建立，不是为了立刻就有转化。</strong>很多时候是为了建立社区关系或者是单纯的品牌形象维护，接下来才有可能进一步构建深层次的社区商务关系。销售活动的结果是销量，营销活动的结果是深化联系。线下见面会的根本目的就是为了深化联系、扩大社群影响力。<br>2.这条生态链的拉新和促动还可以带来很多流量引擎，在线下的见面会活动中，品牌赞助、运营商入驻、广告宣传、通过一系列的明星效应可以带动整个生态的资金流量，这也是商家盈利的契机。<strong>《大连接》里写道：连接行为本身就是自然选择的结果。我们必须与他人合作，判断他们的意图，影响他们或者被他们所影响。</strong>品牌、KOC与流量之间必须要在需求维度、交互维度、兴趣维度、信任维度上建立联系，这四个维度叠加在一起就是成交量的增加。<strong>缺乏感情色彩的泡泡圈很难走的健壮而长远。</strong>对比一下基于圈层文化的社群营销，他们有共同的爱好，彼此之间相互信任，相关产品自带感情色彩。这类群体往往会主动给别人“种草”的机会，就像一些喜欢二次元的人群会关注一些手办、漫画，然后会为这些东西赴约、买单是一个道理。<br>3.既然爱奇艺的slogan是悦享品质，用户画像是爱奇艺泡泡圈粉丝和热衷追剧追星的人群，偏女性和年轻化<strong>，那我们的主打方案就是高配服务，线上打榜，线下互动集群，开展见面会，打通线上线下、视频–花絮–明星追踪–粉丝见面的强大生态链。</strong>除了广告平台、头部品牌商，还有许多小微电商商家、线下零售商、饭店、酒店都可以在这条生态链中盈利，获取自己私域流量池的价值。<br><strong>我提出这个需求的灵感来源：</strong><br>1.<strong>私域流量没有“万能钥匙”：普遍玩法解决不了特殊难题。</strong>在流量质量大于流量数量，留存大于拉新的场景下，<strong>只有人、货、场这三者都对了，才能形成有效的成交和转化。</strong>爱奇艺每种类型圈子粉丝的活跃程度不同，有些圈子特别活跃而有些就相对冷清，这说明服务类别、消费频次、人群定位、范围定位的重要性。当入群成为一种常态，新鲜感不再的时候，我们就要抢占先机，最大程度激活用户的兴趣和痛点，在线下环节做到天时地利人和，让用户自主自愿的为爱豆买单。<br>2.“唯流量论”在各个领域生根发芽，但有了流量还有考虑高转化率，互联网平台不缺流量，腾讯视频、优酷视频背靠强大的流量引擎，在产品同质化、多元化的情况下，扩大私域流量池、下沉距离用户才是爱奇艺的出路。从认知心理学的思维来看，人是一个处理信息的系统。信息过少不敷使用，过多同样有害。各种爆料新闻、花絮追踪发放的频率要根据数据做好监控，实时修改发布策略。普遍真理就是欲速则不达，<strong>线上线下就是一个节奏调节器，通过这种物理上的缓存作用，让用户真实感受到泡泡圈的美好存在，延长粉丝生命周期才是应对竞争对手和流量变化不确定性的关键。</strong><br>3.我从新零售的思路想到了这个打通链接的方式。首先，“新零售”是指“以消费者体验为中心的数据驱动的泛零售形态”。大润发中国董事长黄明瑞认为，新零售是一种流程再构成，<strong>是线上线下融合</strong>，但它不仅是新技术的应用，同时也是新的思维方式。新零售意味着要对零售商业的产业价值链进行重新构造。而苏宁董事长张进东曾经说过：新零售是运用互联网、物联网技术，<strong>感知消费习惯，预测消费趋势，引导生产制造，为消费者提供多样化、个性化的产品和服务。</strong>我向leader提出爱奇艺泡泡的线下活动方案就是来源于这种新的思维方式，虽然初期不一定对，但是从目前的日活指数和粉丝入驻数量来看，方向是对的并且大有火热趋势。因为新零售的核心是以人为本，利用当下发达的数字技术充分逼近消费者的内心需求，重构人货场，实现“以消费者体验为中心”，所以作为链接明星和粉丝的品牌方，我们要做的就是打通双向渠道，充分给与双方表达的平台，为明星强力助势，为粉丝优化体验，形成一个良性发展的有效闭环！</p>
<h2 id="情感共鸣-个性化表达"><a href="#情感共鸣-个性化表达" class="headerlink" title="情感共鸣+个性化表达"></a>情感共鸣+个性化表达</h2><p>除了上文的开展线下流程，打造全联通方案之后，我提出了一个很大胆的想法，那就是在爱奇艺的泡泡圈子中，开通明星的个人vlog，分享明星认为有趣、好玩、有价值的视频，有点类似花絮和个人真人秀，但是时长要短，并且要更新迭代快，这样可以促进日活，让用户感觉自己每天在追踪爱豆行踪，形成一种打卡似的登录习惯！在这个圈子中，粉丝可以通过写信和打榜爱心助力明星的火热等级排序，可以点赞、评论、设置爱豆加油包和加油话题圈，明星可以全方位多时空与粉丝交流见面，打通这个链路的思路是拿出终极的情感好牌~<br>我提出这个需求的原因如下：<br>1.用户对于喜爱的产品会爱不释手，而对于一般喜欢的产品则很容易“见异思迁”。情感化设计的指导思想就是：<strong>要让用户在使用产品的过程中产生强烈的情感共鸣，从而培养用户的忠诚度</strong>。人的基本情绪分别是：生气（Anger）、厌恶（Disgust）、恐惧（Fear）、悲伤（Sadness）、期待（Anticipation）、快乐（Joy）、惊讶（Surprise）、信任（Trust）。情绪的定义是生物体在进化过程中出现的、对环境变化的反馈行为，其目的是为了使生物体更好的解决生存适应问题。虽然在不同的生物体中，情绪反应的出现条件和表现形式各有不同，但是有一些基本的情绪元素是普遍存在于不同物种之间的。仔细调查一下我们周围的APP，一个小图标的风格，一个触摸屏的设计，甚至是一个界面的底色，都可以会触发用户的情感体验。<br>2.<strong>用户追星的本质需求是什么 ？<br>（1）</strong>逃离现实生活的琐碎和苦难，在明星的光环下构想美丽人生。正如每个女生都渴望自己拥有白马王子，生活富裕，生命有趣一样，明星就是理想生活的假设和精神寄托，其实每一个人都是双重性格的，一方面我们渴望成功和金钱，想要特立独行，仗剑天涯，希望活出不一样的自己。<br>（2）但是另外一个方面，我们又不得不向世界妥协，在现实的打击中踌躇满志，窝藏舒适圈。人的生活和生存，就是在这两个模式中左右切换，只是很多时候我们没有发掘罢了。追星的本质需求是在自己喜欢的明星上找到当年那个怀揣梦想、不惧年龄勇敢追梦的自己的影子。明星可以通过流量、热度、外貌、人设火热一时，但是我发现，真正的脑残粉僵尸粉一定是把自身的精神需求和假设寄托在某一个明星的特质上的。所以明星写故事、明星真人秀才能真正触动用户的精神诉求，让追星升华成个人价值认同和同化的情感诉求。营销最本质的，就是找准人设、个人标签，然后通过合适的渠道，投放到对口的平台，只要输入和输出的入口找准了，不火都难。<br>基于以上分析，我提出了这个互动模块的方案，不过评审和迭代还在讨论中，不管最后的结果能否通过，我都想坚持一下这个想法，也希望能和前辈们多学习怎样强化个性化表达产品方案！<br>总之，第三周，仍然是不停的改版本改方案，楼上楼下沟通交流，不过我很喜欢这种工作节奏和状态，也觉得自己每天都在成长，当我全身心去思考优化的时候，就像解数学题那样惊心动魄又酣畅淋漓，在和UI、研发小哥哥沟通的过程中，我也慢慢找到了谈话的技巧和交流的要素，这种感觉真的很棒！看着自己的头脑风暴在讨论会上评估、投票，真滴很开心，哈哈，如果以后不考研，我就要在PM的道路上坚定不移的走下去啦！<br><strong>不畏艰难!  不留遗憾  ! 追踪梦想<br>   以热爱的态度对待一切就是对自己的温柔<br>   秋霞小朋友，坚持热爱你的，  和你所热爱的一切！</strong></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E4%BA%BA%E6%80%A7%E9%9C%80%E6%B1%82/" rel="tag">人性需求</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E5%A4%8D%E7%9B%98%E6%80%BB%E7%BB%93/" rel="tag">复盘总结</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-第三周实习复盘总结---灵活多维度拉新 - 副本" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2018/06/20/%E7%AC%AC%E4%B8%89%E5%91%A8%E5%AE%9E%E4%B9%A0%E5%A4%8D%E7%9B%98%E6%80%BB%E7%BB%93---%E7%81%B5%E6%B4%BB%E5%A4%9A%E7%BB%B4%E5%BA%A6%E6%8B%89%E6%96%B0%20-%20%E5%89%AF%E6%9C%AC/"
    >第三周实习复盘总结---灵活多维度拉新</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2018/06/20/%E7%AC%AC%E4%B8%89%E5%91%A8%E5%AE%9E%E4%B9%A0%E5%A4%8D%E7%9B%98%E6%80%BB%E7%BB%93---%E7%81%B5%E6%B4%BB%E5%A4%9A%E7%BB%B4%E5%BA%A6%E6%8B%89%E6%96%B0%20-%20%E5%89%AF%E6%9C%AC/" class="article-date">
  <time datetime="2018-06-19T16:00:00.000Z" itemprop="datePublished">2018-06-20</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE%E6%8F%90%E6%A1%88/">实习项目提案</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<p>实习第三周经过无数次的头脑风暴、研讨优化、版本修改、迭代管理之后，泡泡小程序的运营方案终于新鲜出炉！<br>看着改了N次的运营流程图，想起昨天凌晨两点还在思考的优化细节，我露出了老母亲般的笑容，终于明白为什么leader说产品就是自己的孩子了。当然，苦累都是值得的，在困难和思考中才能让自己迅速成长！</p>
<h2 id="底层需求-有效闭环"><a href="#底层需求-有效闭环" class="headerlink" title="底层需求+有效闭环"></a>底层需求+有效闭环</h2><p>   想到了勒庞在《乌合之众》中描述的群体心理，这个万金油一般神奇的心理战术用在社区运营上再恰当不过了。真理似乎一直在不断地被循环印证。古老的心理学加上流行元素的碰撞，让我们像古代的魔法师一般，操控着蠢蠢欲动的集结群体。<br>  勒庞认为：“自觉地个性的消失，以及感情和思想转向一个不同的方向，是就要变成组织化群体的人所表现出的首要特征。”比如，在五四运动初期，“民主和自由”的口号指导着人民去救亡图存，当运动如火如荼的开展后，个人情绪在群体中被格外放大，口号与主题的分化不明确，让群体做出了类似“火烧赵家楼”的事件。<br>  <strong>群体的基本特征可以大致归为两方面，一是个性的消失，二是感情的强化。再者便是“无意识品质占上风”</strong>，当群众聚集时往往都会情绪高涨，使个人的感情不分青红皂白的归顺集体思想，从而不自觉地进入到集体意识中去，群体行为脱离理性的的最明显体现就在于群体的无意识行为代替了个人的有意识行为。<br>  在我看来，泡泡模块的拉新方案是打造一个影视、明星、粉丝的密切互动平台，囊括 了明星、影视、文化、兴趣等各种交流圈。通过引入并不断夸大私域流量池的方法，奠定后续留存与促活的群体基础。<strong>拉新的首要是精确刻画用户画像和一丝不苟的、滴水不漏的分析用户需求！</strong>需求对了，就可以很轻松地实现用户无限裂变拉新，就好像茫茫沙漠中的一场及时雨，一出场就迎来饥肠辘辘、求贤若渴的大批用户。正所谓：思路对了，事半功倍。所以我认为“用户拉新”方案的最高境界就是从用户的底层需求出发，探寻人性最深处的弱点。一个点足够，但是一定要保证是足够精准的，且绝对符合用户底层需求的，然后用它来作为贯穿整场活动的连接点。在刻画用户画像的时候，我认为要具体到个人，世上没有两片完全相同的叶子，同理，也没有完全一致的需求。社区是一切相似需求的集合体，要想引入私域流量，有两点很重要。<br>  <strong>1.以个体的眼光去观察最真实最细微的需求，具体到这个需求的频次与场景，类型和大小。充分利用用户的异质性和产品的情景性去打造流量池的入口！</strong><br>  <strong>2.以群体的策略去营销，用户的需求大小不一，主次不同，</strong>就算是调查问卷上清清楚楚的圈点与钩叉，也只是某一个情景下用户不假思索的反应，它的来源具有参考性但不具备完全正确性，但是呢，人是很奇妙的动物，流量池的原理就是利用了人性的从众、贪婪、趋利避害和虚荣心。从这个角度来说，用户是具有可塑性的，<strong>流量池的初衷就是把一个个具象的需求同治化、抽离最核心的要素，包装成一个大众需求的模样，就像过滤器一样，筛选出可以划分在一个集合的大众需求，再通过整形、转化、把不同的需求变成具有同样诉求的心理渴望，再充分利用人性的可塑性、脆弱性和同理心，弱化甄别需求，求同存异，</strong>在同化的过程中顺藤摸瓜，让用户以为这就是她的归属和家，这就是她苦苦追寻的精神家园。最终，以群体的角度去拉新促活。仔细思考一下，吃播文化的兴起，Papi酱的爆红，粉丝后援会的建立不都是利用了《乌合之众》里面的心理学战术吗？直播带货其实也就是网红与自己的私域流量进行物理经营、情感交互，最终使他们心甘情愿的掏出腰包的过程。<br>  <strong>这一点，很像算法里面的分治与归并，先切分、细化、再汇总、同治！</strong><br>思路对了，更重要的就是数据来源了，爱奇艺泡泡社区圈就像一种另类的订阅制电商，明星追踪就相当于个人订阅的某种服务。这种类似订阅模式通常具备较高的回购率，可以持续吸引用户付费，获取较好的现金流。通过明星圈、影视圈的互动，让用户及时了解爱豆动态，观看爱豆参与的综艺， 电影或者电视剧并在相关圈子群聊、发帖以及评论点赞，为爱豆打榜。这也符合泡泡社区 “泡圈、泡剧、泡 idol”的定位以及打通视频-明星-粉丝关系链的目标。和竞品比较，比较出新的一点就是线下的粉丝后援见面会活动，当我向leader提出这个方案时，一开始是被否定的，但是我经过大量的统计和调查之后，向leader说明了这种方案的可行性和必要性，最终被采用还是感到非常荣幸和有成就感的。<br><strong>我提出这个需求的背景是：</strong><br>我们几个实习生确定好了调研方向、设计调查问卷之后、通过实地访谈，朋友圈、泡泡圈发帖以及微博发放，收集了300余份的有效问卷之后，我分析得出用户的线<strong>下情感诉求很强烈。</strong>这个逻辑很简单，如果没有差异化优势，就会出现腾讯视频、优酷视频和爱奇艺视频三足鼎立的局面，毕竟功能和界面的改造不会拉开太大差距，<strong>如果功能相同、设计slogan相似，用户就会纠结于哪种渠道，当用户产生犹豫时，从那一刻起，我们就失去了焦点和热度。</strong><br>品牌的影响力就是提到什么，用户就能不假思索的想到并参与使用。<br>1.如果仅仅是线上的打卡问候与花絮回看，<strong>用户触摸不到最真实的场景和最新鲜的热度，自然就不会高效率地促进留存和转化环节</strong>。毕竟，亲自参与花絮拍摄、探班送祝福、粉丝机场见面会都能让用户真实真切的参与其中，<strong>通过这种肌肉型的强化记忆和亲身体验，提高用户粘性。</strong>当流量入口过于依赖单一平台时，一旦遇到不可抗力影响，就只能沦为待宰的羔羊。<strong>因此，我的思路是依托于平台的“点”、“面”、“线”主动去寻找更多元化的方式。泡泡圈建立，不是为了立刻就有转化。</strong>很多时候是为了建立社区关系或者是单纯的品牌形象维护，接下来才有可能进一步构建深层次的社区商务关系。销售活动的结果是销量，营销活动的结果是深化联系。线下见面会的根本目的就是为了深化联系、扩大社群影响力。<br>2.这条生态链的拉新和促动还可以带来很多流量引擎，在线下的见面会活动中，品牌赞助、运营商入驻、广告宣传、通过一系列的明星效应可以带动整个生态的资金流量，这也是商家盈利的契机。<strong>《大连接》里写道：连接行为本身就是自然选择的结果。我们必须与他人合作，判断他们的意图，影响他们或者被他们所影响。</strong>品牌、KOC与流量之间必须要在需求维度、交互维度、兴趣维度、信任维度上建立联系，这四个维度叠加在一起就是成交量的增加。<strong>缺乏感情色彩的泡泡圈很难走的健壮而长远。</strong>对比一下基于圈层文化的社群营销，他们有共同的爱好，彼此之间相互信任，相关产品自带感情色彩。这类群体往往会主动给别人“种草”的机会，就像一些喜欢二次元的人群会关注一些手办、漫画，然后会为这些东西赴约、买单是一个道理。<br>3.既然爱奇艺的slogan是悦享品质，用户画像是爱奇艺泡泡圈粉丝和热衷追剧追星的人群，偏女性和年轻化<strong>，那我们的主打方案就是高配服务，线上打榜，线下互动集群，开展见面会，打通线上线下、视频–花絮–明星追踪–粉丝见面的强大生态链。</strong>除了广告平台、头部品牌商，还有许多小微电商商家、线下零售商、饭店、酒店都可以在这条生态链中盈利，获取自己私域流量池的价值。<br><strong>我提出这个需求的灵感来源：</strong><br>1.<strong>私域流量没有“万能钥匙”：普遍玩法解决不了特殊难题。</strong>在流量质量大于流量数量，留存大于拉新的场景下，<strong>只有人、货、场这三者都对了，才能形成有效的成交和转化。</strong>爱奇艺每种类型圈子粉丝的活跃程度不同，有些圈子特别活跃而有些就相对冷清，这说明服务类别、消费频次、人群定位、范围定位的重要性。当入群成为一种常态，新鲜感不再的时候，我们就要抢占先机，最大程度激活用户的兴趣和痛点，在线下环节做到天时地利人和，让用户自主自愿的为爱豆买单。<br>2.“唯流量论”在各个领域生根发芽，但有了流量还有考虑高转化率，互联网平台不缺流量，腾讯视频、优酷视频背靠强大的流量引擎，在产品同质化、多元化的情况下，扩大私域流量池、下沉距离用户才是爱奇艺的出路。从认知心理学的思维来看，人是一个处理信息的系统。信息过少不敷使用，过多同样有害。各种爆料新闻、花絮追踪发放的频率要根据数据做好监控，实时修改发布策略。普遍真理就是欲速则不达，<strong>线上线下就是一个节奏调节器，通过这种物理上的缓存作用，让用户真实感受到泡泡圈的美好存在，延长粉丝生命周期才是应对竞争对手和流量变化不确定性的关键。</strong><br>3.我从新零售的思路想到了这个打通链接的方式。首先，“新零售”是指“以消费者体验为中心的数据驱动的泛零售形态”。大润发中国董事长黄明瑞认为，新零售是一种流程再构成，<strong>是线上线下融合</strong>，但它不仅是新技术的应用，同时也是新的思维方式。新零售意味着要对零售商业的产业价值链进行重新构造。而苏宁董事长张进东曾经说过：新零售是运用互联网、物联网技术，<strong>感知消费习惯，预测消费趋势，引导生产制造，为消费者提供多样化、个性化的产品和服务。</strong>我向leader提出爱奇艺泡泡的线下活动方案就是来源于这种新的思维方式，虽然初期不一定对，但是从目前的日活指数和粉丝入驻数量来看，方向是对的并且大有火热趋势。因为新零售的核心是以人为本，利用当下发达的数字技术充分逼近消费者的内心需求，重构人货场，实现“以消费者体验为中心”，所以作为链接明星和粉丝的品牌方，我们要做的就是打通双向渠道，充分给与双方表达的平台，为明星强力助势，为粉丝优化体验，形成一个良性发展的有效闭环！</p>
<h2 id="情感共鸣-个性化表达"><a href="#情感共鸣-个性化表达" class="headerlink" title="情感共鸣+个性化表达"></a>情感共鸣+个性化表达</h2><p>除了上文的开展线下流程，打造全联通方案之后，我提出了一个很大胆的想法，那就是在爱奇艺的泡泡圈子中，开通明星的个人vlog，分享明星认为有趣、好玩、有价值的视频，有点类似花絮和个人真人秀，但是时长要短，并且要更新迭代快，这样可以促进日活，让用户感觉自己每天在追踪爱豆行踪，形成一种打卡似的登录习惯！在这个圈子中，粉丝可以通过写信和打榜爱心助力明星的火热等级排序，可以点赞、评论、设置爱豆加油包和加油话题圈，明星可以全方位多时空与粉丝交流见面，打通这个链路的思路是拿出终极的情感好牌~<br>我提出这个需求的原因如下：<br>1.用户对于喜爱的产品会爱不释手，而对于一般喜欢的产品则很容易“见异思迁”。情感化设计的指导思想就是：<strong>要让用户在使用产品的过程中产生强烈的情感共鸣，从而培养用户的忠诚度</strong>。人的基本情绪分别是：生气（Anger）、厌恶（Disgust）、恐惧（Fear）、悲伤（Sadness）、期待（Anticipation）、快乐（Joy）、惊讶（Surprise）、信任（Trust）。情绪的定义是生物体在进化过程中出现的、对环境变化的反馈行为，其目的是为了使生物体更好的解决生存适应问题。虽然在不同的生物体中，情绪反应的出现条件和表现形式各有不同，但是有一些基本的情绪元素是普遍存在于不同物种之间的。仔细调查一下我们周围的APP，一个小图标的风格，一个触摸屏的设计，甚至是一个界面的底色，都可以会触发用户的情感体验。<br>2.<strong>用户追星的本质需求是什么 ？<br>（1）</strong>逃离现实生活的琐碎和苦难，在明星的光环下构想美丽人生。正如每个女生都渴望自己拥有白马王子，生活富裕，生命有趣一样，明星就是理想生活的假设和精神寄托，其实每一个人都是双重性格的，一方面我们渴望成功和金钱，想要特立独行，仗剑天涯，希望活出不一样的自己。<br>（2）但是另外一个方面，我们又不得不向世界妥协，在现实的打击中踌躇满志，窝藏舒适圈。人的生活和生存，就是在这两个模式中左右切换，只是很多时候我们没有发掘罢了。追星的本质需求是在自己喜欢的明星上找到当年那个怀揣梦想、不惧年龄勇敢追梦的自己的影子。明星可以通过流量、热度、外貌、人设火热一时，但是我发现，真正的脑残粉僵尸粉一定是把自身的精神需求和假设寄托在某一个明星的特质上的。所以明星写故事、明星真人秀才能真正触动用户的精神诉求，让追星升华成个人价值认同和同化的情感诉求。营销最本质的，就是找准人设、个人标签，然后通过合适的渠道，投放到对口的平台，只要输入和输出的入口找准了，不火都难。<br>基于以上分析，我提出了这个互动模块的方案，不过评审和迭代还在讨论中，不管最后的结果能否通过，我都想坚持一下这个想法，也希望能和前辈们多学习怎样强化个性化表达产品方案！<br>总之，第三周，仍然是不停的改版本改方案，楼上楼下沟通交流，不过我很喜欢这种工作节奏和状态，也觉得自己每天都在成长，当我全身心去思考优化的时候，就像解数学题那样惊心动魄又酣畅淋漓，在和UI、研发小哥哥沟通的过程中，我也慢慢找到了谈话的技巧和交流的要素，这种感觉真的很棒！看着自己的头脑风暴在讨论会上评估、投票，真滴很开心，哈哈，如果以后不考研，我就要在PM的道路上坚定不移的走下去啦！<br><strong>不畏艰难!  不留遗憾  ! 追踪梦想<br>   以热爱的态度对待一切就是对自己的温柔<br>   秋霞小朋友，坚持热爱你的，  和你所热爱的一切！</strong></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E4%BA%BA%E6%80%A7%E9%9C%80%E6%B1%82/" rel="tag">人性需求</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E5%A4%8D%E7%9B%98%E6%80%BB%E7%BB%93/" rel="tag">复盘总结</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="../3/">上一页</a><a class="page-number" href="../../">1</a><a class="page-number" href="../2/">2</a><a class="page-number" href="../3/">3</a><span class="page-number current">4</span>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2020
        Wangqiuxia
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    <aside class="sidebar">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="../../index.html"><img src="/images/ayer-side.svg" alt="爱产品，爱前端！"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../index.html">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../tags/%E6%8A%80%E6%9C%AF/">小程序</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../http:/shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../https:/v.xiumi.us/stage/v5/4IeLH/197507179">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="../../atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="../../images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="../../images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="../../js/jquery-2.0.3.min.js"></script>


<script src="../../js/jquery.justifiedGallery.min.js"></script>


<script src="../../js/lazyload.min.js"></script>


<script src="../../js/busuanzi-2.3.pure.min.js"></script>


<script src="../../js/share.js"></script>



<script src="../../fancybox/jquery.fancybox.min.js"></script>




<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['做一个有情怀懂产品的程序媛！','业精于勤荒于嬉！行成于思毁于随！','越努力越幸运'],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script>
  var ayerConfig = {
    mathjax: false
  }
</script>


<script src="../../js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=518895142&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>