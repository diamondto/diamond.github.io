<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     爱产品，爱前端！
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="../../css/style.css">

  
<script src="../../js/pace.min.js"></script>


  

  

<link rel="alternate" href="atom.xml" title="爱产品，爱前端！" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/diamondto.github.io"
        target="_blank"><img width="149" height="149" src="../../images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="../../index.html">爱产品，爱前端！</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-“新基建”的智能化思考" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/12/25/%E2%80%9C%E6%96%B0%E5%9F%BA%E5%BB%BA%E2%80%9D%E7%9A%84%E6%99%BA%E8%83%BD%E5%8C%96%E6%80%9D%E8%80%83/"
    >“新基建”的智能化思考</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/12/25/%E2%80%9C%E6%96%B0%E5%9F%BA%E5%BB%BA%E2%80%9D%E7%9A%84%E6%99%BA%E8%83%BD%E5%8C%96%E6%80%9D%E8%80%83/" class="article-date">
  <time datetime="2019-12-24T16:00:00.000Z" itemprop="datePublished">2019-12-25</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%80%9D%E8%80%83/">人工智能的思考</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="多足鼎立，工业互联网加快建设"><a href="#多足鼎立，工业互联网加快建设" class="headerlink" title="多足鼎立，工业互联网加快建设"></a>多足鼎立，工业互联网加快建设</h2><p>   众所周知，目前，云办公、云教育、云医疗、云游戏等服务需求激增，同时也带动了企业对高质量云服务的的需求，包括要<strong>更快的网络速度，更优的存储成本，更强大的计算能力以及更流畅的直播</strong>等功能应用。<br>   百度推出EasyDL将阳春白雪的“深度学习”下放到中小型企业，为企业和开发者提供了从<strong>完善安全的数据服务、大规模分布式模型训练、丰富灵活的模型部署</strong>到预测的一站式服务。作业帮、国家中小学网络云平台等企业通过百度智能云实现快速扩容，“空中课堂”没有出现卡顿，实现“丝滑般”的用户体验。个人见解，百度揭开“高大上”的深度学习面纱，将科研界蓬勃发展的AI技术真正应用到企业平台中，帮助企业灵活部署训练完成的模型，比如<strong>针对零售场景专项算法调优</strong>，结合<strong>图像合成与增强技术</strong>提升模型泛化能力，提升了货架巡检业务场景的模型高可用性，通过零售商品的识别调整货架成列规则、优化自助结算服务；通过视频图像监控，为自动化驾驶保障出行安全；还有工业生产质检、良优品分类、医疗和农业中的物料细分等应用，为了优化企业体验，减少部署难度，百度提供了强大的API接口，智能化的整合了<strong>公有云API、设备端SDK、私有服务器部署</strong>、软硬一体化的方案，灵活地适配了各种使用场景。<strong>据报道</strong>，在<strong>城市智慧政务领域</strong>，百度推出的AI测温系统、智能外呼平台、电子出入证等一揽子解决方案，快速落地应用在交通枢纽，基层街道社区，工厂园区、商业写字楼等，让社区防护工作有堵有疏；<strong>智慧医疗领域</strong>，灵医智惠推出的智能咨询助手助力第三方机构为公众提供在线问诊服务，倍数级提升人工在线咨询效率；智能质检帮助制造企业安全生产。<strong>世界日新月异，删繁就简作为最朴素的真理其实是最适用的</strong>，从抖音的“短小精悍”、到拼多多的“物美价廉”、微信小程序的“用完即走”    快捷、经济、方便、“傻瓜式使用”已经成为火热产品的标签，好的产品，大道至简，这也应征了云服务的未来发展趋势：<strong>更快的网络速度，更优的存储成本，更强大的计算能力以及更流畅的直播应用。</strong>怀揣着AI产品梦的我，也要深入思考<strong>AI能力与应用场景的融合创新</strong>，怎样打通人工智能产业化应用落地的全部流程？怎么优化AI技术的标准化、自动化、模块化？怎样使得开发者、企业无需从头学习难度高、迭代快的前沿科技，就能低成本快速开发自己的应用产品？怎样让AI产品更加富有情怀和温度，打通人性深处最柔软的共鸣？一切都来自于细致观察，深入思考，勤做笔记，开阔视野！雷军说：创业要大成，一定要找到能让猪飞上天的台风口。勤奋、努力加坚持等等，这些只是成功的必要条件，最关键的是在对的时候做对的事情。看国家最新出台政策，云来云往，在互联网大潮中轻装上阵，删繁就简，快、准、狠地抓住需求和痛点，才能游刃有余，脱颖而出。<br>   <img src="https://img-blog.csdnimg.cn/20200312083250994.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>   如果说百度EasyDL的策略是删繁就简，简化企业应用流程，解决落地后顾之忧，那么腾讯AI加速器的策略就是更注重细分构建场景、在算法优化、硬件设施构建和AI算力上抢占先机了。放眼大观，本土科技企业、知名国际加速器纷纷通过<strong>新设业务或分部的方式入局AI加速器</strong>，既有腾讯这样的航母级企业走出去寻找项目，也有微软加速器这样的外来者扎根本土培育优质项目。<br>  把目光转移到腾讯：2019年8月16日，腾讯AI加速器三期名单出炉。TOP30项目从1500个报名者中脱颖而出，录取率仅2%，三期项目总估值超200亿。腾讯把项目目标聚焦于<strong>金融、教育、安全、工业、机器人、IoT、云计算、5G</strong>等。12月21日至12月22日，腾讯产业加速器之AI与SaaS第二次融合课程在深圳举行。腾讯云副总裁、大数据人工智能总经理王龙带来《现状和未来，协作与创新-人工智能行业落地探讨》的主题分享。报告内容高屋建瓴，眼光独到，让人醍醐灌顶，获益匪浅。王龙老师提到：<strong>AI进入落地考核期，“剩”者为王</strong>。老师提到，未来没有硬实力的公司会与泡沫一同消散，<strong>真正具有商业价值的公司才能存活</strong>，腾讯犀牛鸟云开发人才培养计划也完美印证了这一人才揽收策略。<br>  <img src="https://img-blog.csdnimg.cn/20200312092409250.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 腾讯侧重在玩法上进行“升级”，聚焦医疗、智慧零售、智慧楼宇等赛道，同时也广邀农业、工业、旅游、环保、内容等行业合作伙伴的加入。加速意味着<strong>更高要求的技术细节调控</strong>、云计算和硬件平台支持已经无法被“孵化”所满足，加速模式应运而生。换句话说，<strong>孵化器解决从0到1的问题，加速器解决从1到X的问题</strong>，是做乘法的过程，相对于泛滥的、低门槛的孵化器，存在的必要性和价值大大提升。在这之前的9个月，首期腾讯AI加速器29个项目整体估值从70亿增长到200多亿。<br>而稍早前的3月，百度AI加速器第一期项目结项时一场声势浩大的Demo Day显示出百度把AI加速器提到了重要的战略位置。<br>  虽然还没有入局，但马云曾说过投资1000亿的达摩院真正要做的是把技术进行普惠,看起来，相互争斗不止的BAT在AI加速器这里的会战也一定少不了，催热“AI加速器”、最近又动作频频的腾讯则暂时处在领先位置上。</p>
<h2 id="同质化竞争，谁主争锋？"><a href="#同质化竞争，谁主争锋？" class="headerlink" title="同质化竞争，谁主争锋？"></a>同质化竞争，谁主争锋？</h2><p>  <img src="https://img-blog.csdnimg.cn/20200312092736730.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>  仅从市场角度，这对“获客”显然十分不利，你也开放我也开放，你标榜技术强大我也说自己技术厉害，并没有太多差异化“卖点”。于是，加速项目就成了“开放”关键词外笼络更多用户的差异化手段。腾讯可能率先认识到了这一点，提前点燃了AI加速器。除了开放技术给用户，还扶持用户加速用户成长，这种方式显然更容易赢得市场。<br>  构建差异化卖点是茫茫大潮中出类拔萃的基本要素。AI加速器的意义在于能够提前甄选到优质用户并加以扶持，除了<strong>丰富平台用户量获得生态优势</strong>，更重要的是这种“<strong>一手扶持</strong>”下获取的用户很容易成为平台的核心用户并带来更为紧密的生态效应，例如腾讯AI开放平台上的慧川智能、Bello智能招聘、追一科技等归属度极强的用户都来自于AI加速器。最终，创造伙伴让它们与平台先天联结，<strong>高替代成本造就了高用户忠诚。</strong><br>  细研腾讯的案例。目前，腾讯对外宣称的AI的布局主要围绕以下三个层面展开：<br>1.以AI lab、优图、腾讯云等部门为主体，侧重方向是基础技术研究；<br>2.与腾讯社交、游戏、支付、云计算、零售等自有业务或生态圈业务相结合，<strong>在场景中把AI落地；</strong><br>3.在基础、业务层面上对外开放，连接腾讯内部和合作伙伴的资源与能力，打造生态。<br>显然，AI加速器正是第三层面的主要载体，而腾讯经常对外表达的<strong>构建AI创业生态、扶持AI创业、助力AI技术产业化</strong>等概念，其实在AI体系上打开了<strong>链接外部、与外部互动的口子</strong>，同时又把内外部的层次理清楚避免混乱，为腾讯开放平台运营的AI加速器<strong>提供了诸多管理上、流程上、技术上的便利。</strong><br>百度的AI架构也有类似特点，主打一站式服务，但很多时候，受限于本身业务单一，例如360AI、小米AI、科大讯飞AI等，在AI布局上把基础研发、业务、对外生态等不同内容混合到一起，仅从实操上来说并不一定利于对外延展出AI加速器。</p>
<h2 id="把控风口，依靠强资源-高匹配度-垂直化深耕"><a href="#把控风口，依靠强资源-高匹配度-垂直化深耕" class="headerlink" title="把控风口，依靠强资源+高匹配度+垂直化深耕"></a>把控风口，依靠强资源+高匹配度+垂直化深耕</h2><p>对普通孵化器来说，资金、人才、运营、技术等支持是通用的，而加速器所需要的资源带有浓烈的AI“个性”。从腾讯的案例来看，这种“个性”体现在：</p>
<p>（1）技术资源层面</p>
<p>仅仅IT技术、云计算等支撑是不够的。腾讯AI加速器提供的技术能力来自腾讯AI Lab、优图实验室、WeChat AI以及腾讯云，提供约60+项AI技术能力，以及10+AI技术课程。除此之外，加速器还为项目提供定制化的开发及辅导，一些时候甚至需要采用1V1的模式，帮助技术找到应用场景。</p>
<p>（2）创投资源层面</p>
<p>不是“给钱就行”，对资本与AI的契合度也有一定的要求。因此，腾讯AI加速器找到的资本合作伙伴包括腾讯投资、英诺天使、蓝驰创投、松禾远望、金沙江、北极光 、IDG 、创新工场等在AI领域投资比较活跃的投资方。</p>
<p>（3）导师资源层面</p>
<p>不只是那些能够对互联网“指点江山”的所谓大咖，AI加速器更需要对AI有深度认知的“导师”，它不是一种能够泛泛指导的技术门类。腾讯为此配备了产业、学术、工业、设计、投资界与AI相关的辅导人，提供数月的指导。</p>
<p>（4）渠道资源层</p>
<p> 从业务实现的角度，决定开发者选用哪个AI平台，首先是<strong>该平台能否实现自己想实现的功能</strong>，其次是使用某平台<strong>实现起来的难度有多大</strong>，最后是**效率有多高。AI加速器就是抓住了这些痛点和需求，腾讯借助得天独厚的互联网地位，聚焦多重开放平台、云、互联网+等渠道帮助项目触达行业大客户。</p>
<p>  问题来了，一旦所有的AI开放平台都开始做AI加速器时，差异化将再次消失。AI加速器越往后走，关于接口搭设、资源匹配及赋能等玩法就越变得普遍，毕竟，能够做得起AI开放平台的企业，做AI加速器并不会那么困难，只是时间长短和先后的问题。</p>
<p>对于先把AI加速器捂热，又暂时处在领先位置的腾讯来说，尽快在加速上再走出差异化步骤十分重要。而对那些追赶者而言，如果能够有所创新、改变雷同的玩法，也或将赢得后发优势。</p>
<p>这次腾讯AI加速器就发生了<strong>关键词的转变</strong>，按照腾讯开放平台副总经理、腾讯众创空间总经理王兰的说法，第二期要打造的是“<strong>面向垂直行业的AI解决方案</strong>”，引入腾讯觅影、传统零售商、腾讯众创等合作伙伴，具体实现包括<strong>医疗、智慧零售、智慧楼宇</strong>等解决方案。</p>
<p>AI加速器必须解决的一个重要问题是投入线性增长问题。在第一期AI加速器多行业出击的基础上，这次腾讯在重庆宣布将聚焦探索医疗、智慧零售、智慧楼宇三大垂直领域，此外也延展至农业、工业、旅游、环保、内容等垂直行业寻找合作伙伴的加入，料想腾讯是以<strong>3+N的模式逐步开展AI加速器的垂直化。</strong></p>
<p>而从成本投入角度，除了AI垂直领域的积淀，<strong>垂直化最有利于解决成本线性增长的问题</strong>。也即，如果持续深耕某些垂直领域，当“通用经验”积累到足够程度后，在类似的行业特性下总结出<strong>垂直领域统一的“加速范式”</strong>，既能够保证个性化加速效果，<strong>也能够实现较为明显的运营复制从而降低成本</strong>，<strong>垂直挖掘得越深，这种双重效应越明显。</strong></p>
<p>通过AI加速器获得用户优势，一定要先走垂直化深耕的道路。这意味着，腾讯“AI开放”层面正从去年面向广大开发者的AI技术能力开放<strong>转为面向政府、企业等行业伙伴的AI解决方案的开放</strong>，<strong>从“工具箱”开始向“方法库”升级，</strong>这可能是腾讯保持差异化优势的策略。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/AI%E8%83%BD%E5%8A%9B%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E7%9A%84%E8%9E%8D%E5%90%88%E5%88%9B%E6%96%B0%E6%80%9D%E8%80%83/" rel="tag">AI能力与应用场景的融合创新思考</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-深入分析懒加载、预加载" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/11/14/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E6%87%92%E5%8A%A0%E8%BD%BD%E3%80%81%E9%A2%84%E5%8A%A0%E8%BD%BD/"
    >深入分析懒加载、预加载</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/11/14/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E6%87%92%E5%8A%A0%E8%BD%BD%E3%80%81%E9%A2%84%E5%8A%A0%E8%BD%BD/" class="article-date">
  <time datetime="2019-11-13T16:00:00.000Z" itemprop="datePublished">2019-11-14</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="懒加载的原理（延迟加载）"><a href="#懒加载的原理（延迟加载）" class="headerlink" title="懒加载的原理（延迟加载）"></a>懒加载的原理（延迟加载）</h2><p>1.图片进入<strong>可视区域之后</strong>再去请求图片资源，不要请求无效资源。<br>2.适用于电商等图片很多，页面很长的业务场景。<br>3.减少无效资源的加载。<br>4.并发加载的资源过多会阻塞JS的加载，影响网站的正常使用（浏览器有并发请求上限），图片在JS的上面。<br>5.SRC属性设置之后会请求SRC资源，后面的SRC先不设置，换成占位符。<br>6.监听滚轮事件，当进入相关图片的可视区域之后，才会去动态设置图片的src属性。<br>7.电商产品应用广泛。</p>
<h2 id="预加载原理（提前加载）"><a href="#预加载原理（提前加载）" class="headerlink" title="预加载原理（提前加载）"></a>预加载原理（提前加载）</h2><p>1.图片等静态资源在使用之前的<strong>提前请求。</strong><br>2.资源使用到时能从缓存中加载，不去网络请求，提升用户体验。<br>3.页面展示的依赖关系维护。比如当前页面会依赖音乐图片等，这样预加载之后页面渲染不会阻塞。<br>4.九宫格抽奖。频繁切换选中和非选中状态，要保障样式的展示。<br>5.动画展示。资源加载完了之后再去页面加载。</p>
<h2 id="懒加载的方法"><a href="#懒加载的方法" class="headerlink" title="懒加载的方法"></a>懒加载的方法</h2><blockquote>
<p>先将img标签中的src链接设为同一张图片(空白图片)，将其真正的图片地址存储再img标签的自定义属性中(比如data-img)。</p>
</blockquote>
<blockquote>
<p>当js监听到该图片元素进入可视窗口时，即将自定义属性中的地址存储到src属性中，达到懒加载的效果。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">"item"</span>&gt;</span><br><span class="line">    &lt;a href=<span class="string">"javascript:void(0)"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">data-img</span>=<span class="string">"$&#123;p.pic&#125;"</span> <span class="attr">src</span>=<span class="string">"img/blank.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/li&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装懒加载函数</span></span><br><span class="line"><span class="keyword">var</span> lazyLoad = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//匿名函数自调，避免全局污染</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $(<span class="built_in">window</span>).on(<span class="string">"scroll"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//监听窗口滚动事件</span></span><br><span class="line">            <span class="keyword">var</span> clock = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//启动定时器，加载图片</span></span><br><span class="line">                $(<span class="string">".item img"</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="comment">//遍历每张图片</span></span><br><span class="line">                    <span class="keyword">var</span> $cur = $(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">if</span>(checkShow($cur))</span><br><span class="line">                    <span class="comment">//调用检查函数，如果元素在可视范围内</span></span><br><span class="line">                        $cur.attr(<span class="string">'src'</span>, $cur.attr(<span class="string">'data-img'</span>));</span><br><span class="line">                        <span class="comment">//显示图片</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,<span class="number">300</span>);</span><br><span class="line">            <span class="keyword">if</span>(clock) clearTimeout(clock);</span><br><span class="line">            <span class="comment">//停止定时器</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查元素是否在可视范围内</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkShow</span>(<span class="params">$node</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> scrollH = $(<span class="built_in">window</span>).scrollTop(),</span><br><span class="line">        <span class="comment">//获取窗口滚动高度</span></span><br><span class="line">        winH = $(<span class="built_in">window</span>).height(),</span><br><span class="line">        <span class="comment">//获取窗口高度</span></span><br><span class="line">        top = $node.offset().top;</span><br><span class="line">        <span class="comment">//获取图片距离窗口顶部偏移高度</span></span><br><span class="line">        <span class="keyword">if</span>(top &lt; winH + scrollH)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回init函数</span></span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        load:init;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用懒加载函数,首屏要手动调动</span></span><br><span class="line">lazyLoad.load();</span><br></pre></td></tr></table></figure>
<p>Zepto就是jQuery的移动端版本, 可以看做是一个轻量级的jQuery<br>注意点:<br>Zepto的设计目的是提供 jQuery 的类似的API，但并不是100%覆盖 jQuery<br>jQuery的底层是通过DOM来实现效果的， zepto.js 是用css3 来实现的；<br>官网下载的zepto,就已经包含了官网所述的默认模块了<br>github上下载的zepto模块需要自己导入</p>
<p>与图片一样，视频同样可以延迟加载，来达到性能优化的目的。</p>
<p>正常情况下加载视频，都是使用<video>标签，那么对于一些需要用户自己播放的视频，最好指定<video>标签的preload属性为none，这样浏览器就不会预加载任何视频数据。<br>为了占用空间，我们用poster属性为其占位</video></video></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;video controls preload=<span class="string">"none"</span> poster=<span class="string">"占位图"</span>&gt;</span><br><span class="line">	&lt;source src=<span class="string">"视频资源同名.webm"</span> type=<span class="string">"video/webm"</span>&gt;</span><br><span class="line">	&lt;source src=<span class="string">"视频资源名.mp4"</span> type=<span class="string">"video/mp4"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/video&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="实现预加载的几种办法"><a href="#实现预加载的几种办法" class="headerlink" title="实现预加载的几种办法"></a>实现预加载的几种办法</h2><p>使用HTML标签<br><img src="http://pic26.nipic.com/20121213/6168183 0044449030002.jpg" style="display:none"><br>使用Image对象</p>
<script src="./myPreload.js"></script>
<p>使用XMLHttpRequest对象,<strong>虽然存在跨域问题，但会精细控制预加载过程</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttprequest=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"> xmlhttprequest.onreadystatechange=callback;</span><br><span class="line"> xmlhttprequest.onprogress=progressCallback;</span><br><span class="line"> xmlhttprequest.open(<span class="string">"GET"</span>,<span class="string">"http://image.baidu.com/mouse,jpg"</span>,<span class="literal">true</span>);</span><br><span class="line"> xmlhttprequest.send();</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(xmlhttprequest.readyState==<span class="number">4</span>&amp;&amp; xmlhttprequest.status==<span class="number">200</span>)&#123;</span><br><span class="line">     <span class="keyword">var</span> responseText=xmlhttprequest.responseText;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Request was unsuccessful:"</span>+xmlhttprequest.status);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">progressCallback</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line"> e=e || event;</span><br><span class="line"> <span class="keyword">if</span>(e.lengthComputable)&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"Received"</span>+e.loaded+<span class="string">"of"</span>+e.total+<span class="string">"bytes"</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>PreloadJS提供了一种预加载内容的一致方式，以便在HTML应用程序中使用。预加载可以使用HTML标签以及XHR来完成。默认情况下，PreloadJS会尝试使用XHR加载内容，因为它提供了对进度和完成事件的更好支持，但是由于跨域问题，使用基于标记的加载可能更好。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用preload.js</span></span><br><span class="line"><span class="keyword">var</span> queue=<span class="keyword">new</span> createjs.LoadQueue();<span class="comment">//默认是xhr对象，如果是new createjs.LoadQueue(false)是指使用HTML标签，可以跨域</span></span><br><span class="line">queue.on(<span class="string">"complete"</span>,handleComplete,<span class="keyword">this</span>);</span><br><span class="line">queue.loadManifest([</span><br><span class="line">&#123;<span class="attr">id</span>:<span class="string">"myImage"</span>,<span class="attr">src</span>:<span class="string">"http://pic26.nipic.com/20121213/6168183  0044449030002.jpg"</span>&#125;,</span><br><span class="line">&#123;id：<span class="string">"myImage2"</span>，src:<span class="string">"http://pic9.nipic.com/20100814/2839526  1931471581702.jpg"</span>&#125;</span><br><span class="line">]);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleComplete</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> image=queue.getResuLt(<span class="string">"myImage"</span>);<span class="comment">//队列存放资源</span></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两者都是提高页面性能有效的办法，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。<br>懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">前端性能优化</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-详细剖析强缓存和协商缓存" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/11/14/%E8%AF%A6%E7%BB%86%E5%89%96%E6%9E%90%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/"
    >详细剖析强缓存和协商缓存</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/11/14/%E8%AF%A6%E7%BB%86%E5%89%96%E6%9E%90%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/" class="article-date">
  <time datetime="2019-11-13T16:00:00.000Z" itemprop="datePublished">2019-11-14</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="Cache-control"><a href="#Cache-control" class="headerlink" title="Cache-control"></a>Cache-control</h2><p>1.public：<strong>所有内容都将被缓存（客户端和代理服务器都可缓存）</strong>。具体来说响应可被任何中间节点缓存，如 Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server，中间的proxy可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给 Browser 而不再向proxy2要。</p>
<p>private：所有内容<strong>只有客户端可以缓存，Cache-Control的默认取值。</strong>具体来说，表示中间节点不允许缓存，对于Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server，proxy 会老老实实把Server 返回的数据发送给proxy1,自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据。</p>
<p>no-cache：客户端缓存内容<strong>，是否使用缓存则需要经过协商缓存来验证决定。表</strong>示不使用 Cache-Control的缓存控制方式做前置验证，<strong>而是使用 Etag 或者Last-Modified字段来控制缓存</strong>。需要注意的是，no-cache这个名字有一点误导。设置了no-cache之后，<strong>并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。</strong></p>
<p>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</p>
<p>max-age：max-age=xxx (xxx is numeric)表示缓存内容将在xxx秒后失效,优先级大于expires</p>
<p>s-maxage（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires header。</p>
<p>max-stale：能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）。</p>
<p>min-fresh：能够容忍的最小新鲜度。min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。<br>Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8zMTc0NzAxLThmZjk4MTYwM2NkZmRlZDA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<h2 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h2><ol>
<li>Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires<ol start="2">
<li>在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。</li>
</ol>
</li>
<li><strong>强缓存</strong>判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会<strong>导致加载文件不是服务器端最新的内容.</strong></li>
<li>如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到<strong>协商缓存策略。</strong></li>
</ol>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：<br>1.协商缓存生效，返回304和Not Modified<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8zMTc0NzAxLTY2MGZkMTYzMzI5ZDA4MGI?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>2. 协商缓存失效，返回200和请求结果<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8zMTc0NzAxLTI0OTUzMDc5Y2ZlYmYyYmY?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。</p>
<h2 id="Last-Modified和If-Modified-Since"><a href="#Last-Modified和If-Modified-Since" class="headerlink" title="Last-Modified和If-Modified-Since"></a>Last-Modified和If-Modified-Since</h2><p>浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header；<br>浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，<br><strong>如果没有变化，返回304和空的响应体，直接从缓存读取<br>  如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200</strong><br>但是 Last-Modified 存在一些弊端：<br>1.如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源<br>2.因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源<br>既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？<br><strong>所以在 HTTP / 1.1 出现了 ETag 和If-None-Match</strong></p>
<h2 id="ETag和If-None-Match"><a href="#ETag和If-None-Match" class="headerlink" title=".ETag和If-None-Match"></a>.ETag和If-None-Match</h2><p>1.Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，<strong>只要资源有变化，Etag就会重新生成。</strong><br>2.浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的I<strong>f-None-Match跟自己服务器上该资源的ETag是否一致，</strong>就能很好地判断资源相对客户端而言是否被修改过了。<br>3.如果服务器发现ETag匹配不上，那么直接以常规GET 200形式将新的资源（当然也包括了新的ETag）发给客户端。<br>4.如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可<strong>。</strong></p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>1.首先在精确度上，Etag要优于Last-Modified。<br>2.Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。<br>3.第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。<br>4.第三在优先级上，<strong>服务器校验优先考虑Etag</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>1.强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，<br> 2.若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，<br> 3.协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标   识，再存入浏览器缓存中；<br> 4.生效则返回304，继续使用缓存。</p>
</blockquote>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>1.对于频繁变动的资源，首先需要使用Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。<br>2.不常变化的场景：通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 max-age，这样浏览器之后请求相同的 URL 会命中强制缓存。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">前端性能优化</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-接口防刷解决思路" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/11/13/%E6%8E%A5%E5%8F%A3%E9%98%B2%E5%88%B7%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF/"
    >接口防刷解决思路</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/11/13/%E6%8E%A5%E5%8F%A3%E9%98%B2%E5%88%B7%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF/" class="article-date">
  <time datetime="2019-11-12T16:00:00.000Z" itemprop="datePublished">2019-11-13</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E6%A1%86%E6%9E%B6%E4%B8%8E%E6%9E%B6%E6%9E%84/">框架与架构</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="场景和原因："><a href="#场景和原因：" class="headerlink" title="场景和原因："></a>场景和原因：</h2><p>1.在项目中后台只需要提供一套API接口，就可以接入安卓、小程序、IOS、web等多个应用程序，这样可以节约开发成本。<br>但是一个后台接入这么多应用程序的http请求，必然导致后端的压力非常大。对于这些情况我们需要对用户的访问进行限流访问，我们可以依次对Nginx、tomcat、接口进行限流。<br>2.对于一些请求进行过滤和拦截是非常有必要的，能够有效地减轻后台的压力。<br>3.考虑线上环境 很多接口 如果不做缓存 可能导致有人拿到url  每秒几万次的访问后台程序,导致系统down机。<br>4.短时间接口被大量调用（攻击），出现系统崩溃和系统爬虫问题，怎么样提升服务的可用性？</p>
<h2 id="商讨解决方法"><a href="#商讨解决方法" class="headerlink" title="商讨解决方法"></a>商讨解决方法</h2><p>1.最简单有效的防护就是图片验证码，采用点触验证，验证滑动或者是第三方验证码服务，普通的图片验证码很容易被破解<br>2.频率，或者叫接口防刷，通过用户具有唯一性的ip验证用户的身份,模拟一个场景，每次用户调用接口，将此用户的ip进行记录，在有效的时间之内，用户每调用一次接口，给调用的次数+1,当超过（次数根据自己的时间情况进行定义）指定的次数时，将调用这个接口的用户ip加入黑名单中，锁定时间到了（锁定时间根据实际情况进行定义）之后移除在黑名单中的用户ip，进行解锁，但是每次用户在短时间内调用接口，实时记录的ip，次数，时间存到什么地方呢？<br>数据库，文件，memcache, redis？<br>最终的方案是redis！<br><strong>redis是一种基于内存的分布式缓存，数据存到数据库，因为redis支持的数据类型更多，支持永久存储，redis有部分数据是存储在了硬盘上</strong><br>3.网关控制流量洪峰，对在一个时间段内出现流量异常，可以拒绝请求。<br>4.源ip请求个数限制。对请求来源的ip请求个数做限制。<br>5.http请求头信息校验；（例如host，User-Agent，Referer）<br>6.对用户唯一身份uid进行限制和校验。例如基本的长度，组合方式，甚至有效性进行判断。或者uid具有一定的时效性<br>7.前后端协议采用二进制方式进行交互或者协议采用签名机制<br>8.人机验证，验证码，短信验证码，滑动图片形式，12306形式<br>9.签名，API接口启用签名策略，签名可以保障请求URL的完整安全，签名匹配再继续下一步操作，<br>10.token，对于重要的API接口，生成token值，做验证</p>
<h2 id="接口安全问题"><a href="#接口安全问题" class="headerlink" title="接口安全问题"></a>接口安全问题</h2><p>应对接口安全，我们可以对数据进行加密，不明文传输数据，可以选择对称加密（DES 2DES）或者是非对称加密（RSA），虽然说两者都是加密，但是又很大的区别，对称加密的速度快，但是相对非对称加密来说是不安全的，一旦一方泄露密钥，所有的数据将全部泄露，对于加密的长度来说非对称加密有长度限制，密钥的长度是1024，值能加密117个字符，如果长度过长，还需要分段加密，分段解密，效率更低，但是相对来说比较安全。</p>
<h2 id="怎样解决http频繁请求同一接口，但数据库来不及写入导致数据不一致的问题"><a href="#怎样解决http频繁请求同一接口，但数据库来不及写入导致数据不一致的问题" class="headerlink" title="怎样解决http频繁请求同一接口，但数据库来不及写入导致数据不一致的问题"></a>怎样解决http频繁请求同一接口，但数据库来不及写入导致数据不一致的问题</h2><p>1.这有点类似文件的情况，有一个test.dat文件，很多进程都要读写，为了避免冲突，会在操作文件时创建test.lck文件用于被其他进程发现，该文件已经处于被操作状态，这个过程中的互斥并没有改变目标文件的任何内容，而是通过外部数据加锁。<br>2.令牌算法限流<br>令牌桶算法最初来源于计算机网络。在网络传输数据时，为了防止网络拥塞，需限制流出网络的流量，使流量以比较均匀的速度向外发送。令牌桶算法就实现了这个功能，可控制发送到网络上数据的数目，并允许突发数据的发送。<br>3.限流的常用处理手段有：计数器、滑动窗口、漏桶、令牌。<br>4.总之一句话，让系统的流量，先到队列中排队、限流，不要让流量直接打到系统上。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E9%A1%B9%E7%9B%AE%E6%80%9D%E8%80%83/" rel="tag">项目思考</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" rel="tag">高并发</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-浏览器存储方式对比" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/11/13/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94/"
    >浏览器存储方式对比</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/11/13/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94/" class="article-date">
  <time datetime="2019-11-12T16:00:00.000Z" itemprop="datePublished">2019-11-13</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E8%B0%88%E8%B0%88%E7%BC%93%E5%AD%98/">谈谈缓存</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>1.因为HTTP请求无状态，所以需要Cookie去维持客户端状态。<br>2.浏览器客户端记录保存Cookie,服务端辨别用户的信息。<br>3.Cookie的生成方式：http response header 中的set-cookie，由服务端生成，客户端把Cookie存储和维护。<br>4.JS中可以通过document.cookie来读写cookie。<br>5..之后的请求都携带Cookie,就像健身房办卡，维护会员的信息。<br><strong>作用：<br>1.用于浏览器和服务器的交互。<br>2.客户端自身数据的存储。</strong><br>Cookie初衷是为了维护客户端的状态<br>存储的限制：大小4KB，需要设置过期时间。<br>Cookie的存储能力被localstorage代替<br>httponly为了保证安全，不支持JS读写，防止黑客攻击。<br>Cookie在相关域名下面会带来CDN的流量损耗，因为只要是这个域名下的信息都会携带cookie<br>对于静态资源来说，每次都在HTTP头部中携带Cookie信息，对大流量来说经济损失很大<br><strong>解决：CDN的域名和主站的域名要分开</strong></p>
<h2 id="Localstorage"><a href="#Localstorage" class="headerlink" title="Localstorage"></a>Localstorage</h2><p>1.接口封装好<br>2.浏览器的本地缓存方案<br>3.大小在5Mz左右<br>4.仅在客户端存在，不和服务端交互<br>5.场景：网速慢，本地缓存，在网不好的情况下，第一次请求来的信息我会保存，把首屏上的不变的信息存下来，不会有首屏的白屏情况，后期有接口返回的新数据，再重新渲染，提升首屏渲染速度。</p>
<h2 id="Sessionstorage"><a href="#Sessionstorage" class="headerlink" title="Sessionstorage"></a>Sessionstorage</h2><p>1.大小为5M左右<br>2.会话级别的浏览器存储<br>3.接口封装好<br>4.对于表单信息的维护，将表单信息存储，关闭之后是空的，下一步那种，可以存储。<br>5可以存储数组、数字、对象等可以被序列化为字符串的内容，不通信，仅存储</p>
<h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>1.在客户端存储大量结构化数据，使用索引来实现对数据库的高性能搜索。<br>2.为应用创建离线版本。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>sessionStorage操作的方法与localStroage是一样的，区别在于 sessionStorage 在关闭页面后即被清空，而 localStorage 则会一直保存。很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用sessionStorage就比较方便。</p>
<p>注意，刷新页面sessionStorage不会清除，但是打开同域新页面访问不到。</p>
<p>1.cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。<br>2. 存储大小限制不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。<br>3.数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；<br>localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；<br>cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。<br>4.作用域不同，sessionStorage不在不同的浏览器页面中共享，即使是同一个页面；<br>localStorage 在所有同源窗口中都是共享的；<br>cookie也是在所有同源窗口中都是共享的。<br>Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。<br>Web Storage 的 api 接口使用更方便，cookie的原生接口不友好，需要自己封装。<br>5. 安全性<br>需要注意的是，不是什么数据都适合放在 Cookie、localStorage 和 sessionStorage 中的，因为它们保存在本地容易被篡改，使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。所以千万不要用它们存储系统中的敏感数据。</p>
<h2 id="Service-Workers"><a href="#Service-Workers" class="headerlink" title="Service Workers"></a>Service Workers</h2><p><strong>1.JS是单线程的，JS与UI渲染是互斥的，优化就要调用SW<br>2.避免主线程的阻塞，3D模型很大<br>3.做离线化，与主页面通信</strong><br>SW是由事件驱动的,具有生命周期，可以拦截处理页面的所有网络请求(fetch)，可以访问cache和indexDB，支持推送，并且可以让开发者自己控制管理缓存的内容以及版本，为离线弱网环境下的 web 的运行提供了可能，让 web 在体验上更加贴近 native。<br>换句话说他可以把你应用里的<strong>所有静态动态资源根据不同策略缓存起来</strong>，在你下次打开时不再需要去服务器请求，这样一来就<strong>减少了网络耗时，使得web应用可以秒开</strong>，并且在离线环境下也变得可用。做到这一切你只需要增加一个sw文件，不会对原有的代码产生任何侵入，是不是很perfect？</p>
<h2 id="Service-Worker基本特征"><a href="#Service-Worker基本特征" class="headerlink" title="Service Worker基本特征"></a>Service Worker基本特征</h2><ul>
<li>无法操作DOM<pre><code>只能使用HTTPS以及localhost
可以拦截全站请求从而控制你的应用
与主线程独立不会被阻塞（不要再应用加载时注册sw）
完全异步，无法使用XHR和localStorage
一旦被 install，就永远存在，除非被 uninstall或者dev模式手动删除
独立上下文
响应推送
后台同步</code></pre></li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/" rel="tag">浏览器缓存</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-页面加载渲染的优化（一）" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/11/13/%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%B8%B2%E6%9F%93%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/"
    >页面加载渲染的优化（一）</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/11/13/%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%B8%B2%E6%9F%93%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/" class="article-date">
  <time datetime="2019-11-12T16:00:00.000Z" itemprop="datePublished">2019-11-13</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<p><img src="https://img-blog.csdnimg.cn/20200304125232265.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>1.HTML本身是通过网址请求回来的，由字节流转换成字符流，浏览器进行词法分析，分析成词法的token，从上到下，不同  &gt;的标签类型会解析成不同的对象，然后加载到DOM树上。<br>2.HTML中会通过link引入其他资源，这时会并发的请求静态资源，请求回来之后会和CSS资源进行结合，生成渲染树。<br>3.只有DOM树和CSS树都生成之后才会进行渲染，布局，绘制。<br>特点<br>1.顺序执行，并发加载（设3-4个CDN域名去最大化并发加载）<br>2.是否阻塞<br>3.依赖关系<br>4.引入方式</p>
</blockquote>
<p>场景：<br>1.页面出来了，样式没有出来，闪退等，是因为没有遵循好依赖关系，如果CSS放在header中去引入，那么页面就会等待CSS加载完毕生成CSS树之后再渲染，就不会出现闪动。<br>2.JS的执行顺序，通过JS 的async标签进行异步加载，梳理好依赖关系。<br>3.方式：JS通过script会有阻塞问题，可以通过defer,async标签更好。<br>3.是否动态引入？判断是不是在需要的时候再去加载。SPA单页应用应该在路由到某个页面的时候再去加载那个路由的内容，要异步动态的去引入内容。</p>
<h2 id="顺序执行，并发加载"><a href="#顺序执行，并发加载" class="headerlink" title="顺序执行，并发加载"></a>顺序执行，并发加载</h2><p>1.词法分析时，token的获取是从下到下顺序执行的<br>2.并发请求外部资源<br>3.并发上限：某个域名的限制</p>
<h2 id="CSS阻塞"><a href="#CSS阻塞" class="headerlink" title="CSS阻塞"></a>CSS阻塞</h2><p>1.CSS在head中会阻塞页面的渲染，页面需要link标签里面的样式内容才能去渲染，但为了避免闪动，还是要这样引入。<br>2.CSS阻塞JS的执行，JS去操作DOM，这时可能会有样式的修改，JS要依赖CSS之前加载完的样式效果。<br>3.CSS不阻塞外部脚本的加载，原因是webkit有HTML-preloader-scanner这样一个类，会预先扫描词法，通过预先加载器来请求后期加载所需要的资源。</p>
<h2 id="JS阻塞"><a href="#JS阻塞" class="headerlink" title="JS阻塞"></a>JS阻塞</h2><p>1.没有通过defer和async的，直接通过script标签的JS 会阻塞页面的渲染。<br>2.JS不会阻塞资源的加载。<strong>因为webkit有预先扫描器，有引用其他资源时，会并发去请求所需的资源，进行预先加载。</strong><br>3.JS顺序执行，阻塞后续JS逻辑的执行。JS有可能会调用document.write的方式，去修改DOM结构，那么由于动态修改了文档，JS会阻塞后面节点的创建。文档结构的分析和渲染会等到JS代码执行完成之后再去调用html.parse进行词法分析。<br>4.JS是顺序执行的，不管返回的情况如何，JS都会保存引入的依赖关系进行单线程加载。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">前端性能优化</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Node.js的三大特点" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/11/12/Node.js%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E7%82%B9/"
    >Node.js的三大特点</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/11/12/Node.js%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E7%82%B9/" class="article-date">
  <time datetime="2019-11-11T16:00:00.000Z" itemprop="datePublished">2019-11-12</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7Node/">打怪升级Node</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>Nodejs跟Nginx一样都是单线程为基础的，这里的单线程指主线程为单线程，所有的阻塞的全部放入一个线程池中，然后主线程通过队列的方式跟线程池来协作。线程池主要由一堆callback回调函数构成的，然后主线程在循环间隙中适当调用，并清空队列。<br>在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程。而每个线程需要耗费大约2MB内存。也就是说，理论上，一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。<br><strong>Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。</strong>当有用户连接了，就触发一个内部事件，<strong>通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。</strong>使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。</p>
<blockquote>
<p>另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。<br>坏处，就是一个用户造成了线程的崩溃，整个服务都崩溃了，其他人也崩溃了。</p>
</blockquote>
<p>话不多说，上图！<br><img src="https://img-blog.csdn.net/20180526131849738?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0wxMDYxMjU2MjY4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述">)<img src="https://img-blog.csdn.net/20180526131834846?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0wxMDYxMjU2MjY4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br>上图说明，单线程也能造成宏观上的“并发”。</p>
<h2 id="非堵塞I-O"><a href="#非堵塞I-O" class="headerlink" title="非堵塞I/O"></a>非堵塞I/O</h2><p>当用户在访问数据库取得数据的时候，需要一段请求时间。在传统的单线程处理机制中，在执行了访问数据库代码之后，整个线程都将暂停下来，等待数据库返回结果，才能执行后面的代码。也就是说，I/O阻塞了代码的执行，极大地降低了程序的执行效率。<br><strong>由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。</strong><br> <strong>当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。</strong><br>阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。Node.js中所有的I/O都是异步的，回调函数套回调函数。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命干活~</p>
<p>Node.js文件操作的函数基本都是异步的回调函数。</p>
<p>一个异步I/O的大致流程：</p>
<ol>
<li>发起I/O调用</li>
</ol>
<p>①用户通过js代码调用nodejs的核心模块，将回调函数和参数传入核心模块</p>
<p>②将回调函数和参数封装。</p>
<ol start="2">
<li>执行回调</li>
</ol>
<p>①操作完成后，将结果储存到请求对象的result属性上，并发出完成通知。</p>
<p>②循环事件，如果有未完成的，就进入请求对象的I/O观察者队列，之后当做异步事件来处理。</p>
<h2 id="异步事件驱动"><a href="#异步事件驱动" class="headerlink" title="异步事件驱动"></a>异步事件驱动</h2><p>在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件（比如，又有新用户连接了），然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。<br>Node.js底层是C++（V8也是C++写的）。<strong>底层代码中，近半数都用于事件队列、回调函数队列的构建。用事件驱动来完成服务器的任务调度。**</strong><br><img src="https://img-blog.csdn.net/20180526131824358?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0wxMDYxMjU2MjY4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p>
<blockquote>
<p>单线程的好处，减少了内存开销，操作系统的内存换页。</p>
</blockquote>
<blockquote>
<p>如果某一个事情，进入了，但是被I/O阻塞了，所以这个线程就阻塞了。</p>
</blockquote>
<blockquote>
<p>非阻塞I/O， 不会傻等I/O语句结束，而会执行后面的语句。</p>
</blockquote>
<blockquote>
<p>非阻塞就能解决问题了么？比如执行着用户A的业务，执行过程中，用户B的I/O回调完成了，此时怎么办？只能采用事件环的机制来等待调度，就是说不管是新用户的请求，还是老用户的I/O完成，都将以事件方式加入事件环，去等待调度。<br>看上图就是构成一个每分每秒都在调度运行的闭环，这个闭环上只有一个搬运工，但是，人家不用休息！</p>
</blockquote>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/Node/" rel="tag">Node</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-用户鉴权场景" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/11/12/%E7%94%A8%E6%88%B7%E9%89%B4%E6%9D%83%E5%9C%BA%E6%99%AF/"
    >用户鉴权场景</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/11/12/%E7%94%A8%E6%88%B7%E9%89%B4%E6%9D%83%E5%9C%BA%E6%99%AF/" class="article-date">
  <time datetime="2019-11-11T16:00:00.000Z" itemprop="datePublished">2019-11-12</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/">前后端交互</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="谈谈cookie和session-token"><a href="#谈谈cookie和session-token" class="headerlink" title="谈谈cookie和session token"></a>谈谈cookie和session token</h2><p>鉴权：就是验证用户是不是拥有访问的权力。</p>
<p>为什么衍生cookie,session,token?</p>
<p>1.HTTP协议是无状态的，就是说上一次请求和这次请求 是没有关系的，无法共享信息，没有历史记录，好处是速度快 ，假设有1000000个用户同时观看一个视频，频繁请求，这种无状态就减少了服务器的压力。比如淘宝，京东，爱奇艺这种高并发的APP。</p>
<p>2.WEB的扩展功能：很多场景下，我们要记录用户在登录时浏览了什么文档，发帖，浏览记录，共享信息的问题，还要用户免登技术等。</p>
<p>区别：</p>
<p>1.cookie最简单、方便:在控制台中，我们可以看到以下存储：Local Storage  Session Storage  IndexedDB  Web SQL</p>
<p>Cookies,每一个域名不同，Cookies也是不同的，Cookie有一个失效时间，可以设置这个时间，其实就是一个浏览器的文件，存的是用户的信息，存在本地了，比如刷京东，并没有登录，但用户名有显示，这时Cookies存的就是用户名，可以存储一些不太铭感的数据，比如手机号，地理位置，这是一种浏览器的缓存，不能存金额，只能存字符串类型。</p>
<p>优点是轻便，小，对于服务端压力小，一般不要禁用。</p>
<p>2.session:是基于cookie的，服务器为每一个用户生成一个不一样的随机字符串，用户每次向服务器发送请求的时候，把这个字符串传给服务器，用来和服务器交互的，session在没有登录的时候是没有的，鉴权中的会话，登录了才有，称为会话，sessionID。</p>
<p>完成登录之后获取带有session信息的cookie，再次请求的时候加入。</p>
<p>SESSION的缺点：</p>
<p>资源开销：对于客户端来说很好，只要cookie存一个字符串就行，但是服务器必须存所有在线的用户session,CPU,内存大，影响性能，可以去扩展服务器做集群，但也会出现分布式session问题，可以采用session粘袋或者redis 就是session集中式管理。</p>
<p>客户端发送已经登录的ID和密码，给服务器，服务器记录认证的状态，向用户发送Session ID,发送包含SessionID的Cookie信息给客户端，客户端再把这个相同的信息给服务端，服务端验证SessionID来判定对方是不是真实的用户，SessionIDc存在服务器端。session是后台生成的，用cookie回写，每次请求cookie是自动携带的，session要靠Cookie 完成。cookie只要有效会自动携带。客户端和服务端都可以生成cookie，存放在客户端，只能是字符串，可以JSON{}</p>
<p>session在服务端生成，可以存放任意类型的数据，session必须依赖cookie实现，才能区别谁是谁，java中session可以存放任意对象。</p>
<p>两次信息一样就鉴权成功。登录了才有session.登录请求响应是自动回来的，登录成功会把cookie带过来，拿到cookie的值，请求接口，带上/cookie，在头里面去加cookie.</p>
<p>3.TOKEN：减轻服务端的压力，服务器只验证不存储，解决session的性能问题。存在这，内存，消耗内存，只要钥匙，TOKEN不用存起来，只是验证样式，有服务器生成，再次请求API时，携带上token,校验就OK，成功返回数据，失败返回状态码。</p>
<p>TOKEN 把钥匙和锁都携带回来，自验证是不是有效，验证是不是有效。</p>
<p>第一部分是头，第二部分是用户的ID 和密码，随意指定，前面的是钥匙，签名是一把锁。</p>
<p>判断钥匙和锁可不可以打开。可以纂改。</p>
<p>签名有头和用户生成的，直接去验证，就验证不出来了，HMAC算法，算法是一样的，数据指头和用户信息，数据没有变化，算法也没有变化，256算法，结果就不会变，算两次看结果是不是一样的，如果数据变了，篡改了，结果就不一样了。</p>
<p>以时间换空间，内存宝贵。</p>
<p>只要每次携带token就可以了，有有效时间的，传给接口，没有篡改就通过。</p>
<p>token是一个字符串，不依赖cookie，跨越更方便一点，无状态，因为不用存储，压力小。服务器生成验证不存储，以cookie或者请求头的方式，传给客户端，客户端同样以相同的样式发给服务端。</p>
<p>session在服务器生成，存储，验证，有状态。</p>
<p>鉴权是在登录之后，成功了把token带回来，注册不用鉴权，创建项目要鉴权。</p>
<p>注意：HTTP1.1不全是明文的。比如图片，视频流，下载文件，本身就是二进制的不是明文的，压缩GZIP，在ngix上去压缩，超过10K去压缩，HTTP2中是用二进制  霍夫曼编码进行压缩的。</p>
<p>HTTP  AUTH:  分为：authorization  :用户名密码的身份认证，登录网站密码哦错了  403</p>
<p>登录成功了但我们在执行一些操作的时候没有权限，比如管理员权限，不足的话就是 401authentication</p>
<p>HTTP 无状态，在第一次请求之后，第二次怎么确保我刚才登录？</p>
<p>1.session:存在内存，服务端。键值对，系一个sessionID，返回给客户，有这个ID就身份认证OK,比较高效，只要到键值对中去拿VAKUE就可以了，默认采用存贮在当前服务器，但若采用分布式，用ngix反向代理了三台服务器，发到第一台返回SID，再请求负载均衡之后打到第二台就不行了，可以配置基于客户端负载均衡HASH 这样的配置，</p>
<p>session存到一个共享的服务器上，比如redis,进行共享，集群分布式。</p>
<p>2.cookie 不要被别人获取，请求头authorization  类型有basic，每次都要重新访问数据库，对整个用户的信息进行base64编码，冒号分隔，认证。</p>
<p>请求都是https，抓包不行，不会被截获。不存在分布式的问题，每次拿出来，再认证数据库比较消费时间。对称加密，相同的key,和函数，不会去重新访问数据库，JWT。</p>
<p>3.bearer:接一个token ,是一个令牌，验证成功 AES，将加密之后的密文传给客户端，放到请求头中。200  OK</p>
<p>MD5加密算法</p>
<p>JWT：</p>
<p>   JSON WEB  tokens  与传统一样，bearer   jwt  Authotion    payloader 消息载体   可以进行解密，校验串</p>
<p>服务端有一个key，判断生成的token是不是合法。</p>
<p>服务端只保存加密串，可以共享，进行交叉登录，</p>
<p>1.认证</p>
<p>traditional   cookie-based AUTH</p>
<p>Modern Token-based  auth</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E7%94%A8%E6%88%B7/" rel="tag">用户</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-重绘与回流" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/11/12/%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81/"
    >重绘与回流</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/11/12/%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81/" class="article-date">
  <time datetime="2019-11-11T16:00:00.000Z" itemprop="datePublished">2019-11-12</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/">前端优化</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="重绘与回流的机制"><a href="#重绘与回流的机制" class="headerlink" title="重绘与回流的机制"></a>重绘与回流的机制</h2><p>CSS外部文件的引入要放到头部，加载CSS的时候页面渲染是被阻塞的，JS也是会阻塞页面渲染的，UI渲染和JS引擎线程是互斥的，不是并行的，CSS的性能会让JS变慢，优化性能，layout painting。</p>
<ol>
<li><p>当render tree中的一部分(或全部)因为元素的规模尺寸，几何属性，布局，隐藏等改变而需要重新构建。这就称为回流。每个页面至少需要一次回流，就是在页面第一次加载的时候。</p>
</li>
<li><p>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。</p>
</li>
</ol>
<p>注：回流必将引起重绘，而重绘不一定会引起回流。</p>
<h2 id="哪些情况会发生重绘，回流？"><a href="#哪些情况会发生重绘，回流？" class="headerlink" title="哪些情况会发生重绘，回流？"></a>哪些情况会发生重绘，回流？</h2><p>不同的条件下发生重排的范围及程度会不同 ：</p>
<p>1.页面初始渲染</p>
<p>2.改变字体，改变元素尺寸（宽、高、内外边距、边框，改变元素位置等</p>
<pre><code>各种情况：

         设置 style 属性的值 

         激活 CSS 伪类，比如 :hover

         操作 class 属性

        css3的某些属性（https://csstriggers.com/  结合此链接查看哪些属性会触发重排、哪些属性会触发重绘以及哪些属性会触发合成；）</code></pre><p>（注意：如果修改属性不影响布局则不会发生重排）</p>
<p>3..改变元素内容（文本或图片等或比如用户在input框中输入文字）</p>
<p>4.添加/删除可见DOM元素（注意：如果是删除本身就display:none的元素不会发生重排；visibility:hidden的元素显示或隐藏不影响重排）</p>
<p>5.fixed定位的元素,在拖动滚动条的时候会一直回流</p>
<ol start="6">
<li>调整窗口大小（Resizing the window）</li>
</ol>
<p>7.计算 offsetWidth 和 offsetHeight 属性【注释2】</p>
<p>【注释2：flush队列】</p>
<p>浏览器是聪明的，当对以下属性进行操作的时候：</p>
<p>包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。</p>
<p>浏览器不会马上操作它们，而是会先缓存在队列中，有一定时间顺序去执行这些操作，但是在这过程中我们需要去获取在该队列中的属性时，浏览器为取得正确的值就会触发重排。这样就使得浏览器的优化失效了。</p>
<p>所以，在多次使用这些值时应进行缓存。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97/" rel="tag">性能优化系列</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-重绘与回流 (2)" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/11/12/%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81%20(2)/"
    >重绘与回流</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/11/12/%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81%20(2)/" class="article-date">
  <time datetime="2019-11-11T16:00:00.000Z" itemprop="datePublished">2019-11-12</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/">优化方案</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="重绘与回流的机制"><a href="#重绘与回流的机制" class="headerlink" title="重绘与回流的机制"></a>重绘与回流的机制</h2><p>CSS外部文件的引入要放到头部，加载CSS的时候页面渲染是被阻塞的，JS也是会阻塞页面渲染的，UI渲染和JS引擎线程是互斥的，不是并行的，CSS的性能会让JS变慢，优化性能，layout painting。</p>
<ol>
<li><p>当render tree中的一部分(或全部)因为元素的规模尺寸，几何属性，布局，隐藏等改变而需要重新构建。这就称为回流。每个页面至少需要一次回流，就是在页面第一次加载的时候。</p>
</li>
<li><p>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。</p>
</li>
</ol>
<p>注：回流必将引起重绘，而重绘不一定会引起回流。</p>
<h2 id="哪些情况会发生重绘，回流？"><a href="#哪些情况会发生重绘，回流？" class="headerlink" title="哪些情况会发生重绘，回流？"></a>哪些情况会发生重绘，回流？</h2><p>不同的条件下发生重排的范围及程度会不同 ：</p>
<p>1.页面初始渲染</p>
<p>2.改变字体，改变元素尺寸（宽、高、内外边距、边框，改变元素位置等</p>
<pre><code>各种情况：

         设置 style 属性的值 

         激活 CSS 伪类，比如 :hover

         操作 class 属性

        css3的某些属性（https://csstriggers.com/  结合此链接查看哪些属性会触发重排、哪些属性会触发重绘以及哪些属性会触发合成；）</code></pre><p>（注意：如果修改属性不影响布局则不会发生重排）</p>
<p>3..改变元素内容（文本或图片等或比如用户在input框中输入文字）</p>
<p>4.添加/删除可见DOM元素（注意：如果是删除本身就display:none的元素不会发生重排；visibility:hidden的元素显示或隐藏不影响重排）</p>
<p>5.fixed定位的元素,在拖动滚动条的时候会一直回流</p>
<ol start="6">
<li>调整窗口大小（Resizing the window）</li>
</ol>
<p>7.计算 offsetWidth 和 offsetHeight 属性【注释2】</p>
<p>【注释2：flush队列】</p>
<p>浏览器是聪明的，当对以下属性进行操作的时候：</p>
<p>包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。</p>
<p>浏览器不会马上操作它们，而是会先缓存在队列中，有一定时间顺序去执行这些操作，但是在这过程中我们需要去获取在该队列中的属性时，浏览器为取得正确的值就会触发重排。这样就使得浏览器的优化失效了。</p>
<p>所以，在多次使用这些值时应进行缓存。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="../3/">上一页</a><a class="page-number" href="../../">1</a><a class="page-number" href="../2/">2</a><a class="page-number" href="../3/">3</a><span class="page-number current">4</span><a class="page-number" href="../5/">5</a><a class="page-number" href="../6/">6</a><a class="extend next" rel="next" href="../5/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2020
        Wangqiuxia
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    <aside class="sidebar">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="../../index.html"><img src="/images/ayer-side.svg" alt="爱产品，爱前端！"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../index.html">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../tags/%E6%8A%80%E6%9C%AF/">小程序</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../http:/shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../https:/v.xiumi.us/stage/v5/4IeLH/197507179">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="../../atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="../../images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="../../images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="../../js/jquery-2.0.3.min.js"></script>


<script src="../../js/jquery.justifiedGallery.min.js"></script>


<script src="../../js/lazyload.min.js"></script>


<script src="../../js/busuanzi-2.3.pure.min.js"></script>


<script src="../../js/share.js"></script>



<script src="../../fancybox/jquery.fancybox.min.js"></script>




<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['做一个有情怀懂产品的程序媛！','业精于勤荒于嬉！行成于思毁于随！','越努力越幸运'],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script>
  var ayerConfig = {
    mathjax: false
  }
</script>


<script src="../../js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=518895142&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>