<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     爱产品，爱前端！
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="../../css/style.css">

  
<script src="../../js/pace.min.js"></script>


  

  

<link rel="alternate" href="atom.xml" title="爱产品，爱前端！" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/diamondto.github.io"
        target="_blank"><img width="149" height="149" src="../../images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="../../index.html">爱产品，爱前端！</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-重绘与回流 (2)" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/11/12/%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81%20(2)/"
    >重绘与回流</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/11/12/%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81%20(2)/" class="article-date">
  <time datetime="2019-11-11T16:00:00.000Z" itemprop="datePublished">2019-11-12</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/">优化方案</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="重绘与回流的机制"><a href="#重绘与回流的机制" class="headerlink" title="重绘与回流的机制"></a>重绘与回流的机制</h2><p>CSS外部文件的引入要放到头部，加载CSS的时候页面渲染是被阻塞的，JS也是会阻塞页面渲染的，UI渲染和JS引擎线程是互斥的，不是并行的，CSS的性能会让JS变慢，优化性能，layout painting。</p>
<ol>
<li><p>当render tree中的一部分(或全部)因为元素的规模尺寸，几何属性，布局，隐藏等改变而需要重新构建。这就称为回流。每个页面至少需要一次回流，就是在页面第一次加载的时候。</p>
</li>
<li><p>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。</p>
</li>
</ol>
<p>注：回流必将引起重绘，而重绘不一定会引起回流。</p>
<h2 id="哪些情况会发生重绘，回流？"><a href="#哪些情况会发生重绘，回流？" class="headerlink" title="哪些情况会发生重绘，回流？"></a>哪些情况会发生重绘，回流？</h2><p>不同的条件下发生重排的范围及程度会不同 ：</p>
<p>1.页面初始渲染</p>
<p>2.改变字体，改变元素尺寸（宽、高、内外边距、边框，改变元素位置等</p>
<pre><code>各种情况：

         设置 style 属性的值 

         激活 CSS 伪类，比如 :hover

         操作 class 属性

        css3的某些属性（https://csstriggers.com/  结合此链接查看哪些属性会触发重排、哪些属性会触发重绘以及哪些属性会触发合成；）</code></pre><p>（注意：如果修改属性不影响布局则不会发生重排）</p>
<p>3..改变元素内容（文本或图片等或比如用户在input框中输入文字）</p>
<p>4.添加/删除可见DOM元素（注意：如果是删除本身就display:none的元素不会发生重排；visibility:hidden的元素显示或隐藏不影响重排）</p>
<p>5.fixed定位的元素,在拖动滚动条的时候会一直回流</p>
<ol start="6">
<li>调整窗口大小（Resizing the window）</li>
</ol>
<p>7.计算 offsetWidth 和 offsetHeight 属性【注释2】</p>
<p>【注释2：flush队列】</p>
<p>浏览器是聪明的，当对以下属性进行操作的时候：</p>
<p>包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。</p>
<p>浏览器不会马上操作它们，而是会先缓存在队列中，有一定时间顺序去执行这些操作，但是在这过程中我们需要去获取在该队列中的属性时，浏览器为取得正确的值就会触发重排。这样就使得浏览器的优化失效了。</p>
<p>所以，在多次使用这些值时应进行缓存。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-React中对单向数据流的思考" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/10/26/React%E4%B8%AD%E5%AF%B9%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E6%80%9D%E8%80%83/"
    >React对单向数据流的思考</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/10/26/React%E4%B8%AD%E5%AF%B9%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E6%80%9D%E8%80%83/" class="article-date">
  <time datetime="2019-10-25T16:00:00.000Z" itemprop="datePublished">2019-10-26</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7React/">打怪升级React</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<p>React的特性中有一个概念叫做“单项数据流”，多数MVVM框架都是单向数据流的框架。传参是业务中要经常使用的，几乎所有框架都是通过props往内层组件传参，props本质是函数执行的参数，然而，复杂类型的数据更新和简单类型的数据更新是不一致的，举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">b.a=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// &#123;a:2&#125;</span></span><br></pre></td></tr></table></figure>
<p>假设我往一个函数内传递一个对象参数，如果在这个函数里修改了这个对象，那么函数外的对象也是会随着改动的(因为本质是一个内存里的东西)。<br>那么设想这样的情景：假设父组件的数据通过props传递给子组件，而子组件里更新了props，导致父组件更新——毫无疑问，这是会导致数据紊乱的、不可控的操作。因此绝大多数框架在这方面做了处理。<br><strong>而react在这方面的处理，就是直接规定了(对组件而言，它的)props是只读的，而不是可更改的。</strong><br>想对而言，小程序和vue对props的限制上显得更加自由， react的编程思想是严谨且周密的，它约束了花里胡哨的花式操作，这是为了确保在使用react构建复杂项目的时候不会出现太多问题。<br>当然啦，好处也是显而易见的——我在写react项目时，出现过一些问题，根源几乎集中在props和state这俩实例属性上。<br>单向数据流是react规范的数据流向,它的作用呢，极大的降低了我们组件间通信的代码耦合！让组件间的通信更为清晰，debug直接往props中找，数据的流向只能通过props由外层到内层 一层一层往里传递。<br>问题来了，当我想改变父级组件时怎么办呢？看以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.state.list.map(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                &lt;XiaojiejieItem </span><br><span class="line">                key=&#123;index+item&#125;  </span><br><span class="line">                content=&#123;item&#125;</span><br><span class="line">                index=&#123;index&#125;</span><br><span class="line">                list=&#123;<span class="keyword">this</span>.state.list&#125;</span><br><span class="line">                deleteItem=&#123;<span class="keyword">this</span>.deleteItem.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br></pre></td></tr></table></figure>

<p>其实这样传是没有问题的，问题是我只能使用这个值，而不能修改这个值，如果修改了，比如把代码写成这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">handleClick()&#123;</span><br><span class="line">    <span class="comment">//关键代码——---------start</span></span><br><span class="line">    <span class="keyword">this</span>.props.list=[]</span><br><span class="line">    <span class="comment">//关键代码-----------end</span></span><br><span class="line">    <span class="keyword">this</span>.props.deleteItem(<span class="keyword">this</span>.props.index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就会报下面的错误；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TypeError</span>: Cannot assign to read only property <span class="string">'list'</span> <span class="keyword">of</span> object <span class="string">'#&lt;Object&gt;'</span></span><br></pre></td></tr></table></figure>

<p>意思就是list是只读的单项数据流。那如果要改变这里边的值怎么办?  查阅资料明白了以下的应用场景和方法~</p>
<p>首先定义一个父组件，名字为Parent</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            name: <span class="string">'我是父组件'</span>,</span><br><span class="line">            msg: <span class="string">'父组件传值给子组件'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;&#123; <span class="keyword">this</span>.state.name &#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次定义一个子组件 ，名字为Children</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Children</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            name: <span class="string">'我是子组件'</span>,</span><br><span class="line">            msg: <span class="string">'子组件传值给父组件'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;&#123; <span class="keyword">this</span>.state.name &#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在App.js里引入父组件Parent</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Parent <span class="keyword">from</span> <span class="string">'./component/Parent'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">          &lt;Parent/&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>
<p>父组件Parent引入子组件Children</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Children <span class="keyword">from</span> <span class="string">'./Children'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            name: <span class="string">'我是父组件'</span>,</span><br><span class="line">            msg: <span class="string">'父组件传值给子组件'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;&#123; <span class="keyword">this</span>.state.name &#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">                &lt;h3&gt;我要引入子组件了：&lt;/</span>h3&gt;</span><br><span class="line">                &lt;hr/&gt;</span><br><span class="line">                &lt;Children/&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>情况一：下面就来实现子组件Children传值(msg)给父组件Parent~注意这里传的是某一个属性，而不是全部。<br>子组件传值给父组件的步骤：</p>
<p>1.父组件在调用子组件时，传入一整个组件给子组件。<br>2.父组件中定义一个方法getChildrenMsg(resulet, msg)，用来获取子组件传来的值以及执行其他操作。<br>3.子组件在通过this.props来获取到一整个组件this.props.parent或者this.props[parent]。<br>4.子组件调用父组件步骤2里定义的方法，通过bind绑定传值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Children <span class="keyword">from</span> <span class="string">'./Children'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            name: <span class="string">'我是父组件'</span>,</span><br><span class="line">            msg: <span class="string">'父组件传值给子组件'</span>,</span><br><span class="line">            childrenMsg: <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getChildrenMsg = <span class="function">(<span class="params">result, msg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// console.log(result, msg)</span></span><br><span class="line">        <span class="comment">// 这里的result就是子组件那bind的第一个参数this，msg是第二个参数</span></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            childrenMsg: msg</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;&#123; <span class="keyword">this</span>.state.name &#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">                &lt;h3&gt;子组件传来的值为：&#123; this.state.childrenMsg &#125;&lt;/</span>h3&gt;</span><br><span class="line">                &lt;h3&gt;我要引入子组件了：&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">                &lt;hr/</span>&gt;</span><br><span class="line">                &lt;Children parent=&#123; <span class="keyword">this</span> &#125; /&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Children</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            name: <span class="string">'我是子组件'</span>,</span><br><span class="line">            msg: <span class="string">'子组件传值给父组件'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toParent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// console.log(this.props.parent.getChildrenMsg.bind(this, this.state.msg))</span></span><br><span class="line">        <span class="keyword">this</span>.props.parent.getChildrenMsg(<span class="keyword">this</span>, <span class="keyword">this</span>.state.msg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;&#123; <span class="keyword">this</span>.state.name &#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123; this.toParent &#125;&gt;子组件传入给父组件&lt;/</span>button&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>情况二：子组件Children给父组件Parent传一整个组件（父组件获取整个子组件）<br>子组件给父组件传一整个组件（父组件获取整个子组件）的步骤：</p>
<p>1.父组件在调用子组件时，通过ref属性，拿到整个子组件。<br>2.父组件中通过this.refs.children或者this.refs[children]获取到一整个子组件实例（注意，要在DOM加载后才能获取！）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Children <span class="keyword">from</span> <span class="string">'./Children'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            name: <span class="string">'我是父组件'</span>,</span><br><span class="line">            msg: <span class="string">'父组件传值给子组件'</span>,</span><br><span class="line">            childrenMsg: <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getChildrenMsg = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            childrenMsg: <span class="keyword">this</span>.refs[<span class="string">'children'</span>].state.msg</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;&#123; <span class="keyword">this</span>.state.name &#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123; this.getChildrenMsg &#125;&gt;获取更新子组件的msg值&lt;/</span>button&gt;</span><br><span class="line">                &lt;h3&gt;子组件传来的值为：&#123; <span class="keyword">this</span>.state.childrenMsg &#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">                &lt;h3&gt;我要引入子组件了：&lt;/</span>h3&gt;</span><br><span class="line">                &lt;hr/&gt;</span><br><span class="line">                &lt;Children ref=<span class="string">"children"</span> /&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Children</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            name: <span class="string">'我是子组件'</span>,</span><br><span class="line">            msg: <span class="string">'子组件传值给父组件'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;&#123; <span class="keyword">this</span>.state.name &#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">                &lt;h3&gt;子组件的msg为：&#123; this.state.msg &#125;&lt;/</span>h3&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>情景三：子组件Children给父组件Parent传方法<br>在获取到整个组件的前提上，再获取方法！<br><strong>我们写原生js的时候，就是通过：<br>在父函数中定义方法，通过参数传递给子函数，子函数调用这个方法并且把自己数据作为参数，那么父函数就可以通过形参拿到了~</strong><br>其实这里的思路是一样的！<br>父函数的方法传递给子函数，被子函数传参调用。<br>父组件中定义函数，通过props传递给子组件，子组件调用这个函数并传参。***<br>嗯…经过思考，子传父这样的逆向通信，实际也是符合单向数据流的概念。无非就是把函数当做参数传递下去呀，类似函数式编程，这样就符合单向数据流的定义了，所以逆向通信和单向数据流是不冲突的~</p>
<p>检索一下大脑，在Vue，React中还有ref 这样一个特殊的实例属性呢！可以利用一下吗？<br>概括一下，react中 ref 具备两种作用：<br>  1、标记dom的话，能获取dom实例;<br>  2、标记子组件的话，能获取子组件实例的所有数据(包括子组件的props，state，定义的方法，实例…)。<br> 那么也就是说，父组件通过this.ref就拿到子组件的任何数据了…ref是不是很像中间人这个送情书的人呢~~<br> 但是呢，文档中特意提到了一点：不要轻易用ref，我猜想是要在DOM加载后才能获取，可能会影响通信的性能响应，这一点是个人思考不一定准确。</p>
<p> 深挖一下，远亲组件的通信怎么实现才能优化性能？<br> 常用思维是：<br>      1、通过缓存  ：  组件A把数据存到缓存中，组件B就可以从中取出;<br>      2、通过url  ：  通过location对象拿到…；<br>      3、通过与后端配合： 组件A把数据扔到接口里去，组件B可以从中拿到…；<br>  以上方式，都是通过第三方媒介的形式。<br>  (想到了redux中的store共享，类似一个中间会话级别的缓存，通过第三方媒介作为一个存储地点，实现数据共享。）<br>  聪明的开发者提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法，那就是大名鼎鼎的 <strong>Context!</strong><br>   react中，同系远亲的话(太太爷爷到重重孙子)，就可以通过context，至于不是很远的关系， 利用props一层一层往内传也是可以的，可以测试一下<del>(例如爷爷传到孙子)<br>   虽然官方不推荐使用，还是去研究了一下</del></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">If you want your application to be stable, don’t use context.</span><br><span class="line">If you aren’t familiar <span class="keyword">with</span> state management libraries like Redux or MobX, don’t use context.</span><br><span class="line">If you’re still learning React, don’t use context.</span><br></pre></td></tr></table></figure>
<p>想象一下，如果没有Context，如何把顶层组件的数据隔若干层传给底层组件？</p>
<p>要么用prop，一层一层地传，要求每一层都要负责传递prop，丢了一个就完了！要不然，就要利用一个全局性的对象，比如Redux中的Store，那就面临如何管理好全局资源的问题， 所以解决办法难以折中。<br> 新版context的使用步骤和方法更好的解释了生产者和消费者模式。<br> 在组件树中，Provider负责提供context，而Consumer用来消费Provider提供的context，而且，它们之间可以隔着任意层级，依然保留心有灵犀，这就是Context的意义。<br>联系一下典型应用场景！那就是界面中的“主题”（Theme)，主题包括颜色样式等内容，主题的设定可以放在顶层的组件中，在这个顶层组件之下的所有React组件都应该能够很方便地访问主题。实现如下：</p>
<p>1，先定义全局context对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> GlobalContext = React.createContext()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> GlobalContext</span><br></pre></td></tr></table></figure>
<p>2，根组件引入GlobalContext，并使用GlobalContext.Provider（生产者）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;GlobalContext.Provider </span><br><span class="line">  value=&#123;&#123;</span><br><span class="line">    background: <span class="string">'green'</span>, </span><br><span class="line">    color: <span class="string">'white'</span>,</span><br><span class="line">    content:<span class="keyword">this</span>.state.content,</span><br><span class="line">    methodA:<span class="keyword">this</span>.changeStateByChildren</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line"> </span><br><span class="line">&lt;<span class="regexp">/GlobalContext.Provider&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：传入的value为根context对象的值，如果是动态的，要使用状态管理。<br>3，组件引入GlobalContext并调用context，使用GlobalContext.Consumer（消费者）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;GlobalContext.Consumer&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          context =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">              &lt;div&gt;</span><br><span class="line">              &lt;h1 style=&#123;&#123;<span class="attr">background</span>: context.background, <span class="attr">color</span>: context.color&#125;&#125;&gt;</span><br><span class="line">                &#123;context.content&#125;</span><br><span class="line">              &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">              &lt;Input methodA = &#123;context.methodA&#125; value=&#123;context.content&#125;&gt;&lt;/</span>Input&gt;</span><br><span class="line">              &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            )</span></span><br><span class="line"><span class="regexp">          &#125;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>GlobalContext.Consumer&gt;</span><br></pre></td></tr></table></figure>
<p>注意：GlobalContext.Consumer内必须是回调函数，改变context，通过context方法改变根组件状态。</p>
<p>总结一下Context优缺点：</p>
<p>优点：跨组件访问数据。</p>
<p>缺点：react组件树种某个上级组件shouldComponetUpdate 返回false,当context更新时，不会引起下级组件更新。<br>这个Context对象又包含两个属性，一个叫Provider，另一个叫Consumer，这两个属性都是纯种的React组件。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/Dataflow/" rel="tag">Dataflow</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/React/" rel="tag">React</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-React通信方式梳理" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/10/26/React%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%A2%B3%E7%90%86/"
    >React通信方式梳理（二）</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/10/26/React%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%A2%B3%E7%90%86/" class="article-date">
  <time datetime="2019-10-25T16:00:00.000Z" itemprop="datePublished">2019-10-26</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7React/">打怪升级React</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h1 id="父组件向子组件通信"><a href="#父组件向子组件通信" class="headerlink" title="父组件向子组件通信"></a>父组件向子组件通信</h1><h1 id="子组件向父组件通信"><a href="#子组件向父组件通信" class="headerlink" title="子组件向父组件通信"></a>子组件向父组件通信</h1><h1 id="跨级组件通信"><a href="#跨级组件通信" class="headerlink" title="跨级组件通信"></a>跨级组件通信</h1><h1 id="没有嵌套关系组件之间的通信"><a href="#没有嵌套关系组件之间的通信" class="headerlink" title="没有嵌套关系组件之间的通信"></a>没有嵌套关系组件之间的通信</h1><p>React数据流动是单向的,父组件向子组件通信也是最常见的;父组件通过props向子组件传递需要的信息Child.jsx</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">&#123; name &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.propTypes = &#123;</span><br><span class="line">    name: PropTypes.string.isRequired,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Child name=<span class="string">"Sara"</span> /&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Parent;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>子组件向父组件通信<blockquote>
<p>利用回调函数<br>利用自定义事件机制<br>回调函数<br>实现在子组件中点击隐藏组件按钮可以将自身隐藏的功能</p>
</blockquote>
</li>
</ol>
<p>观察一下实现方法,可以发现它与传统回调函数的实现方法一样.而且setState一般与回调函数均会成对出现,因为回调函数即是转换内部状态是的常用方法。<br>3. 跨级组件通信</p>
<blockquote>
<p>层层组件传递props<br>例如A组件和B组件之间要进行通信,先找到A和B公共的父组件,A先向C组件通信,C组件通过props和B组件通信,此时C组件起的就是中间件的作用<br>使用context<br>context是一个全局变量,像是一个大容器,在任何地方都可以访问到,我们可以把要通信的信息放在context上,然后在其他组件中可以随意取到;<br>但是React官方不建议使用大量context,尽管他可以减少逐层传递,但是当组件结构复杂的时候,我们并不知道context是从哪里传过来的;而且context是一个全局变量,全局变量正是导致应用走向混乱的罪魁祸首.<br>使用context<br>下面例子中的组件关系: ListItem是List的子组件,List是app的子组件</p>
</blockquote>
<p>ListItem.jsx</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListItem</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子组件声明自己要使用context</span></span><br><span class="line">    <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">        color: PropTypes.string,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">        value: PropTypes.string,</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; value &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;li style=&#123;&#123; <span class="attr">background</span>: <span class="keyword">this</span>.context.color &#125;&#125;&gt;</span><br><span class="line">                &lt;span&gt;&#123;value&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>li&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/React/" rel="tag">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/jsx/" rel="tag">jsx</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-趣谈HTTPS协议" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/10/26/%E8%B6%A3%E8%B0%88HTTPS%E5%8D%8F%E8%AE%AE/"
    >趣谈HTTPS协议</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/10/26/%E8%B6%A3%E8%B0%88HTTPS%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time datetime="2019-10-25T16:00:00.000Z" itemprop="datePublished">2019-10-26</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E7%BD%91%E7%BB%9C/">网络</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h1 id="HTTP传输数据存在的问题"><a href="#HTTP传输数据存在的问题" class="headerlink" title="HTTP传输数据存在的问题"></a>HTTP传输数据存在的问题</h1><h1 id="HTTPS与HTTP的区别"><a href="#HTTPS与HTTP的区别" class="headerlink" title="HTTPS与HTTP的区别"></a>HTTPS与HTTP的区别</h1><h1 id="SSL的加密方式"><a href="#SSL的加密方式" class="headerlink" title="SSL的加密方式"></a>SSL的加密方式</h1><h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><h1 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h1><p>HTTP采用明文传输。明文传输在一些需要保护个人隐私的场景是大忌，比如银行卡卡号和密码的输入，个</p>
<p>人信息的录入等。才用明文传输分分钟钟被不法分子截取下来。</p>
<p>HTTP不验证通信双方的身份。HTTP的状态是无请求的，优点在于解放了服务器，每一次请求“点到为止”不会造成不必要连接占用，缺点在于每次请求会传输大量重复的内容信息。</p>
<p>详细解析一下：无状态指的是任意一个Web请求必须完全与其他请求隔离，当请求端提出请求时，请求本身包含了相应端为相应这一请求所需的全部信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 Http协议不像建立了socket连接的两个终端，双方是可以互相通信的，http的客户端只能通过请求服务器来获取相关内容或文件信息。这也是后来为什么后来HTTP2有了服务器推送的原因！</p>
<p>至于为什么无状态，后面在Cookie和Session中详细分析一下~</p>
<p>HTTP无法验证报文的完整性，报文可能被篡改。</p>
<p>升级版！HTTPS：加密算法</p>
<p>对称加密原理：加密的算法是公开的，密钥来加密数据，对称加密使用一个密钥加密，还要使用相同的密钥才能解密！</p>
<p>常用的算法有：DES,3DES,AES</p>
<p>现在用的比较多的是AES，破解难度大，国外用的比较多。</p>
<p>//使用对称加密，AES加密的时候，密钥长度必须是16个字节，arg0表示要加密的数据，arg1表示要加密的密钥。<br>//解密也是两个参数，arg0和arg1，arg0是要解密的数据，arg1是解密的密钥<br>//方法：AES.decryptFromBase64()</p>
<p>加密之后是一个字符串，服务器解密，这时用户和服务器都有一把一样的钥匙！</p>
<p>优点：</p>
<p>1.计算量较小，加密和解密的速度比较快，适合加密比较大的数据</p>
<p>2.缺点:在传输数据之前，要先传输公钥，可能被中间人劫持，可能会被泄密。</p>
<p>3.当用户很多时，一个用户必须要有唯一的密钥，所以管理起来很麻烦，造成服务器压力巨大。</p>
<p>非对称加密：</p>
<p> 1.算法是公开的，公钥和私钥是配对的，公钥加密只能私钥解密，私钥加密只能公钥解密，简单理解就是用不同的钥匙去开锁，打开和关闭的钥匙是不一样的，所以称非对称~服务器会保存公钥 和私钥 </p>
<p>2.公钥和私钥是通过算法生成的，不能随意乱写！</p>
<p>3.典型方法：RSA  有两个方法   RSA.encrypt     RSA.decrypt  </p>
<p>流程：</p>
<p>服务器发送公钥给用户——&gt;用户采用公钥进行加密——&gt;加密之后传输给服务器——&gt;服务器用私钥进行解密</p>
<p>上述流程中，黑客可能同时拿到公钥和数据，但是公钥是解不了密的！所以黑客解不开这时的数据！</p>
<p>非对称加密的算法RSA</p>
<p>优点:   加密和解密采用不同的钥匙，公钥是可以传输的，但不能解开数据</p>
<p>缺点：计算量比较大，加密和解密的速度比较慢。</p>
<p>那么HTTPS是怎么结合的呢？</p>
<p>对称加密+非对称加密(HTTPS采用这种方式)</p>
<p>使用对称密钥的好处是解密的效率比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解，因为就算你拦截到了数据，但是没有对应的私钥，也是不能破解内容的。</p>
<p>举个例子：你抢到了一个保险柜，但是没有保险柜的钥匙也不能打开保险柜。那我们就将对称加密与非对称加密结合起来,充分利用两者各自的优势，在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式。</p>
<p>具体做法是：发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信。所以，HTTPS采用对称加密和非对称加密两者并用的混合加密机制。</p>
<p>但是这样还不够哦！我们聪明的密码学家考虑问题是非常周全的，在实际场景中，会有很多bug~</p>
<p>比如：网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，那如何校验数据的完整性呢？</p>
<p>画押！—–&gt;校验数字签名。</p>
<p>数字签名有两种功效：</p>
<p>1.能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。</p>
<p>2.数字签名能确定消息的完整性,证明数据是否未被篡改过。</p>
<p>HTTPS工作原理：</p>
<p>1.服务器有公钥和私钥，公钥是传给客户端的，但是不是直接传输，而是先通过SSL数字证书，证书上标注了公钥和服务器的身份标志信息，客户端收到SSL证书之后，拆包，解析出公钥，这时呢，客户端会检查一下服务器的身份，是不是我想要去请求的那个服务器呢？是不是过期了呢？如果没有问题的话，客户端会生成一个随机码，使用公钥进行加密！传输加密之后的数据</p>
<p>2.服务器拿到随机码之后（这时已经被公钥加密了！），这个随机码就可以作为对称加密的密钥，这时服务器就有了数据和私钥 </p>
<p>服务器用私钥进行解密之后，拿到随机码， 这时两端都有了相同的数据，这样的话，双方采用相同的随机码作为对称加密的钥匙！就可以对称的拿到解析之后的数据了，为什么这样？因为传输的时候采用对称加密可以提高速度！</p>
<p>3.详细说明一下：</p>
<p>SSL证书包裹这公钥和服务器的身份标志，为什么带上服务器的标志呢？哈哈，这就是为了防止中间人的劫持，如果你不是正规服务器的话，我就不要你的冒牌货的钥匙！这样客户端就可以防止黑客坑骗拐骗拿到我们的信息啦，不过这只是开始~</p>
<p>假设随机码6666是采用公钥AA加密的，采用对称算法，加密之后生成<strong>***</strong>这种字符串，对称加密保证了传输的速度，但是我们又不想让黑客劫持，所以要引入SSL证书来告诉双方，验证真假美猴王~防止双方都不知道对方身份的情况下，被双向迷惑！猜想一下，黑客是很聪明的，他可能伪装成任何一个角色，如果在客户端这里，他伪装成服务端，采用不正规的钥匙和我们通信，那么我们并不知道身份，会被盗取信息，而在服务端，黑客会假冒成客户端，黑客就是双重身份的冒充人！这样，他获取了双方的信息，随意篡改就很危险！而这个时候我们双方是不知情的，所以SSL很重要！必要要带上身份标志才能辨别好。</p>
<p>随机码就是对陈加密的密钥，客户端采用随机码6666进行对称加密，传输<strong><strong>，服务端拿到</strong></strong>，使用私钥BB解密，拿到随机码6666，再用随机码解密用户的信息，这样就保证了双方的通信。细想这样安全吗？</p>
<p>设想一下，刚开始发送SSL的时候，黑客是可以获取公钥AA的，后来传输加密之后的数据时黑客也可以劫持，拿到*****但是这时，公钥是解不开数据的，因为黑客没有私钥BB。</p>
<p>先发公钥AA给用户—-&gt;用户生成一个随机码6666—–&gt;使用AA加密6666生成<strong><strong>—–&gt;传输</strong></strong>给服务器——&gt;服务器使用私钥BB解密<strong><strong>—–&gt;拿到随机码6666，这个随机码的破解是采用的非对称加密哦，因为都是在双方本地完成解析的，所以相对不用考虑解析算法耗时的问题—–&gt;服务器采用6666随机码解密</strong></strong>，到这里我就明白了，为什么要用随机码来作为对称加密的密钥，这一招厉害了哈哈，这个密钥不仅保证了黑客解不开****，还保证了双方解析用户ID时采用对称算法，减少解密时间的效果~</p>
<p>配置密钥库</p>
<p>1.genkey-alias  生成证书别名</p>
<p>2.keyalg   指定密钥算法，默认RSA</p>
<p>3.keysize  默认1024位。</p>
<p>上面就是我的通俗讲解了~密码学家真的很聪明</p>
<p>官方流程参考：</p>
<p>首先看看组成HTTPS的协议：HTTP协议和SSL/TLS协议。HTTP协议就不用讲了，而SSL/TLS就是负责加密解密等安全处理的模块，所以HTTPS的核心在SSL/TLS上面。整个通信如下：</p>
<p>1、浏览器发起往服务器的443端口发起请求，请求携带了浏览器支持的加密算法和哈希算法。</p>
<p>2、服务器收到请求，选择浏览器支持的加密算法和哈希算法。</p>
<p>3、服务器下将数字证书返回给浏览器，这里的数字证书可以是向某个可靠机构申请的，也可以是自制的。</p>
<p>4、浏览器进入数字证书认证环节，这一部分是浏览器内置的TLS完成的：</p>
<p>4.1 首先浏览器会从内置的证书列表中索引，找到服务器下发证书对应的机构，如果没有找到，此时就会提示用户该证书是不是由权威机构颁发，是不可信任的。如果查到了对应的机构，则取出该机构颁发的公钥。</p>
<p>4.2 用机构的证书公钥解密得到证书的内容和证书签名，内容包括网站的网址、网站的公钥、证书的有效期等。浏览器会先验证证书签名的合法性（验证过程类似上面Bob和Susan的通信）。签名通过后，浏览器验证证书记录的网址是否和当前网址是一致的，不一致会提示用户。如果网址一致会检查证书有效期，证书过期了也会提示用户。这些都通过认证时，浏览器就可以安全使用证书中的网站公钥了。</p>
<p>4.3 浏览器生成一个随机数R，并使用网站公钥对R进行加密。</p>
<p>5、浏览器将加密的R传送给服务器。</p>
<p>6、服务器用自己的私钥解密得到R。</p>
<p>7、服务器以R为密钥使用了对称加密算法加密网页内容并传输给浏览器。 </p>
<p>8、浏览器以R为密钥使用之前约定好的解密算法获取网页内容。</p>
<p>附上SHA算法供大家有兴趣研究~可以脑补一下著名的哈希冲突</p>
<p>安全哈希算法（Secure Hash Algorithm）主要适用于数字签名标准（Digital Signature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。对于长度小于2^64位的消息，SHA1会产生一个160位的消息摘要。该算法经过加密专家多年来的发展和改进已日益完善，并被广泛使用。该算法的思想是接收一段明文，然后以一种不可逆的方式将它转换成一段（通常更小）密文，也可以简单的理解为取一串输入码（称为预映射或信息），并把它们转化为长度较短、位数固定的输出序列即散列值（也称为信息摘要或信息认证代码）的过程。散列函数值可以说是对明文的一种”指纹”或是”摘要”所以对散列值的数字签名就可以视为对此明文的数字签名。</p>
<p>最后补充一下：SSL协议并不是一个应用层协议，它是介于应用层和传输层协议之间的一个安全协议。</p>
<p>枯燥但科学的总结一下：HTTPS=HTTP+加密+身份认证+完整性保护。HTTPS并不是一种新的协议，在通信接口使用了SSL和TLS协议而已。HTTP通常直接和TCP通信，而HTTPS中HTTP先和SSL通信，再由SSL和TCP进行通信。模型如下</p>
<p>HTTPS使用两种加密方式的混合加密<br>对称密钥加密方式的优缺点：</p>
<p>优点：处理速度快<br>缺点：但是容易被第三方盗取<br>非对称密钥加密方式的优缺点：</p>
<p>优点：更加安全，不容易被盗取<br>缺点：处理效率相比对称密钥加密要慢，如果在通信时用这种方式加密，效率很低<br>于是HTTPS采用了两者的优点，使用了混合加密的方式</p>
<p>使用非对称密钥加密的方式安全地交换再稍后对称密钥加密中要使用的密钥<br>确保交换的密钥是安全的之后，放弃非对称密钥加密，使用对称密钥加密来进行通信，保证传输效率<br>HTTPS是怎么解决HTTP协议的三大缺点的？<br>防监听：采用对称加密对数据进行加密，采用非对称加密对对称加密的密钥进行加密<br>防伪装：通信双方携带证书，证书有第三方颁发，很难伪造<br>防篡改：采用摘要算法（MD5或是SHA-1），同样的数据由同样的摘要，而只要有一点不同的数据，它的摘要往往不同，只要数据做了篡改，就会被感知到。</p>
<p>HTTP与HTTPS的区别<br>HTTPS更加安全，因为它有加密，身份认证，验证数据完整性等环节<br>HTTPS需要申请证书，要付费（要钱！一年大概600元）<br>加密通信需要消耗更多的cpu和内存资源，如果每次通信都加密，会消耗很多的资源，当访问量很多的那些网站在进行加密处理时，它们所承担着的负载就很多了，这个时候就需要服务器端实现负载均衡。（有专用的https加解密硬件服务器）<br>使用端口不同，HTTP使用的是80端口，HTTPS使用的是443端口<br>所在层次不同，HTTP运行在TCP之上，HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS运行在TCP之上</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/HTTPS/" rel="tag">HTTPS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-深入浅析React" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/10/22/%E6%B7%B1%E5%85%A5%E6%B5%85%E6%9E%90React/"
    >React生命周期（一）</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/10/22/%E6%B7%B1%E5%85%A5%E6%B5%85%E6%9E%90React/" class="article-date">
  <time datetime="2019-10-21T16:00:00.000Z" itemprop="datePublished">2019-10-22</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7React/">打怪升级React</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="Initialization-初始化阶段。"><a href="#Initialization-初始化阶段。" class="headerlink" title="Initialization:初始化阶段。"></a>Initialization:初始化阶段。</h1><h1 id="Mounting-挂载阶段。"><a href="#Mounting-挂载阶段。" class="headerlink" title="Mounting: 挂载阶段。"></a>Mounting: 挂载阶段。</h1><h1 id="Updation-更新阶段。"><a href="#Updation-更新阶段。" class="headerlink" title="Updation: 更新阶段。"></a>Updation: 更新阶段。</h1><h1 id="Unmounting-销毁阶段"><a href="#Unmounting-销毁阶段" class="headerlink" title="Unmounting: 销毁阶段"></a>Unmounting: 销毁阶段</h1><p>什么是生命周期函数？<br>如果非要用一句话把生命周期函数说明白，我觉的可以用这句话来说明：</p>
<p>生命周期函数指在某一个时刻组件会自动调用执行的函数</p>
<p>举例：render()函数，就是一个生命周期函数，它在state发生改变时自动执行。这就是一个标准的自动执行函数。</p>
<p>constructor不算生命周期函数。<br>constructor叫构造函数，它是ES6的基本语法。虽然它和生命周期函数的性质一样，但不能认为是生命周期函数。</p>
<p>我个人把它看成React的Initialization阶段，定义属性（props）和状态(state)。</p>
<p>Mounting阶段<br>Mounting阶段叫挂载阶段，伴随着整个虚拟DOM的生成，它里边有三个小的生命周期函数，分别是：</p>
<p>componentWillMount : 在组件即将被挂载到页面的时刻执行。<br>render : 页面state或props发生变化时执行。<br>componentDidMount : 组件挂载完成时被执行。<br>componentWillMount代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    console.log(&#39;componentWillMount----组件将要挂载到页面的时刻&#39;)</span><br><span class="line">&#125;</span><br><span class="line">componentDidMount代码</span><br><span class="line"></span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">    console.log(&#39;componentDidMount----组件挂载完成的时刻执行&#39;)</span><br><span class="line">&#125;</span><br><span class="line">render代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">render()&#123;</span><br><span class="line">    console.log(&#39;render---组件挂载中.......&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候查看一下控制台，会打出如下提示：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillMount<span class="comment">----组件将要挂载到页面的时刻执行</span></span><br><span class="line">render<span class="comment">----开始挂载渲染</span></span><br><span class="line">componentDidMount<span class="comment">----组件挂载完成的时刻执行</span></span><br></pre></td></tr></table></figure>

<p>注意的问题</p>
<p>componentWillMount和componentDidMount这两个生命周期函数，只在页面刷新时执行一次，而render函数是只要有state和props变化就会执行!</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/React/" rel="tag">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/jsx/" rel="tag">jsx</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-云计算服务竞品分析" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/10/15/%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9C%8D%E5%8A%A1%E7%AB%9E%E5%93%81%E5%88%86%E6%9E%90/"
    >云计算服务竞品分析</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/10/15/%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9C%8D%E5%8A%A1%E7%AB%9E%E5%93%81%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2019-10-14T16:00:00.000Z" itemprop="datePublished">2019-10-15</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE/">人工智能与大数据</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="1-政策背景："><a href="#1-政策背景：" class="headerlink" title="1.政策背景："></a>1.政策背景：</h2><p>   2018年7月23日，为推动企业利用云计算加快数字化、网络化、智能化转型，推进互联网、大数据、人工智能与实体经济深度融合，工业和信息化部印发《推动企业上云实施指南(2018-2020年)》，对云计算应用的方方面面做出详细指导和支持，可谓是手把手教企业上云。随着“互联网+”行动的积极推进，我国云计算应用正从互联网行业向政务、金融、工业、轨道交通等传统行业加速渗透，云计算应用效果开始显现。<br><img src="https://img-blog.csdnimg.cn/20200310201628342.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>近几年，国内云计算产业发展、行业推广、市场监管等重要环节的<strong>宏观政策环境已经日趋完善。</strong><br>2015年，国务院先后出台三项与云计算密切相关的政策文件，为云计算发展奠定了重要政策基础;中央网信办发布了关于党政部门云计算安全管理的文件，在政务云领域发挥重要影响;新版《电信业务分类目录》针对云计算业务形态，明确了互联网资源协作服务业务的概念，相关市场管理政策相继配套出台;工信部于2017年发布《云计算发展三年行动计划(2017-2019年)》，提出了我国云计算发展的指导思想、基本原则、发展目标、重点任务和保障措施。<br>“十二五”末期，我国云计算产业规模已达1500亿元，产业发展势头迅猛、创新能力显著增强、服务能力大幅提升、应用范畴不断拓展，已成为提升信息化发展水平、打造数字经济新动能的重要支撑。但也存在市场需求尚未完全释放、产业供给能力有待加强、低水平重复建设现象凸现、产业支撑条件有待完善等问题。<br>为促进<strong>云计算快速健康发展</strong>，2017年3月30日，工业和信息化部印发《云计算发展三年行动计划(2017-2019年)》，明确了云计算发展的五项重点任务。<br><img src="https://img-blog.csdnimg.cn/20200310202324904.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="2-行业现状"><a href="#2-行业现状" class="headerlink" title="2.行业现状:"></a>2.行业现状:</h2><p>  从中国云计算市场产业链来看，互联网公司提供基于云的网络平台、在线存储等云端服务在云计算领域承担越来越重要的作用，将不断推动云计算产业链逐渐成熟和规范。 国内云计算公司众多，有提供IaaS+PaaS+SaaS全部服务的(比如腾讯云)，也有专做细分市场的(比如网宿、环信)。按背景可以将主流的服务商分为以下五类：<br><img src="https://img-blog.csdnimg.cn/20200310195719693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="3-竞品分类"><a href="#3-竞品分类" class="headerlink" title="3.竞品分类"></a>3.竞品分类</h2><p><img src="https://img-blog.csdnimg.cn/20200310203318750.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>  在能源电力和制造业等传统行业，天翼云和华为云等非互联网公司有着天然的优势。<br>  阿里云创立于2009年，是目前中国最大的云计算平台。<strong>阿里云致力于提供安全、可靠的计算和数据处理能力</strong>。用户通过阿里云，用互联网的方式即可远程获取海量计算、存储资源和大数据处理能力。阿里云已建成的超大规模数据中心包括华东、华北、华南、欧洲、美国、香港、日本、新加坡、欧洲、中东、澳大利亚，阿里云已经在全球主要互联网市场形成云计算基础设施覆盖，将为中国出海企业以及当地企业提供云计算服务。<br>   腾讯云创立于2010年，是腾讯公司打造的面向广大企业和个人的公有云平台。腾讯云有着深厚的基础架构，并且有多年对海量互联网服务的经验，<strong>不管是社交、游戏还是其他领域，都有多年成熟的产品</strong>。腾讯云在金融，电子商务和游戏领域有绝对优势，其中在手游云服务的市场份额已经达到46%。腾讯在云端完成重要部署，<strong>为开发者及企业提供云服务、云数据、云运营等整体一站式服务方案</strong>。作为目前中国互联网综合服务提供商和中国服务用户最多的互联网企业，腾讯正在积极通过云计算、云技术，推进互联网与各行业的融合创新。</p>
<h2 id="4-产品结构与功能分析"><a href="#4-产品结构与功能分析" class="headerlink" title="4.产品结构与功能分析"></a>4.产品结构与功能分析</h2><p>   阿里云产品体系包括云计算基础服务、大数据、安全(云盾)以及域名与网站(万网)四大部分。其中，大数据(数加)提供数据应用、数据分析展现、大数据基础服务以及人工智能四大类服务；安全(云盾)提供防御以及检测两大类服务；域名与网站(万网)提供域名注册、域名交易与转入、域名解析、云虚拟主机、网站建设以及阿里邮箱六大类服务。<br>   在行业解决方案方面，阿里云推出了通用解决方案、行业解决方案、专项解决方案以及大数据解决方案。其中，通用解决方案包括网站解决方案、移动APP解决方案、专有云解决方案和混合云解决方案；行业解决方案覆盖电商、音视频、金融、游戏、医疗、政务、渲染等行业；专项解决方案包括安全、 云存储、容灾、企业互联网架构等；大数据解决方案包括个性化推荐、大数据仓库、云上数据集成方案、 路况预测等。<br>     <img src="https://img-blog.csdnimg.cn/20200310204615296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="阿里云产品体系结构和行业解决方案  "><br>    腾讯云产品体系包括基础产品、域名服务以及大数据与AI三大部分。其中，域名服务模块提供域名注册、域名安全、解析与备案四个功能。除此之外，大数据模块提供大数据处理套件、云搜、文智自然语言处理、机智机器学习、用户洞察分析与云推荐引擎功能，AI提供万象优图、智能语音服务与微金小云客服功能。<br>    腾讯云已经拥有完整的产品体系，为合作伙伴提供多样化、高性能的云服务。腾讯云同时提供通用解决方案、行业解决方案以及技术解决方案。其中，通用解决方案包括视频、位置服务、网站、微信生态、运维等服务；行业解决方案覆盖了游戏、O2O、金融、广告、医疗、在线教育、电商、智能硬件、 旅游、政务行业；技术解决方案提供安全、数据迁移与直播安全服务。<br>    <img src="https://img-blog.csdnimg.cn/20200310204834888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="腾讯云产品体系结构和行业解决方案"></p>
<h2 id="5-行业解决方案对比"><a href="#5-行业解决方案对比" class="headerlink" title="5.行业解决方案对比"></a>5.行业解决方案对比</h2><p>1.阿里云凭着资源量和创新能力，目前在中国的公有云市场占据着绝对优势。<br>2.而腾讯云作为后起之秀，并没有急于占据所有行业云市场，而是把战略重点放在了与原有业务相关的金融，电子商务和游戏领域，使得其迅速在游戏云占据了市场第一的位置。</p>
<h2 id="总结与建议"><a href="#总结与建议" class="headerlink" title="总结与建议"></a>总结与建议</h2><p>总结<br>就产品和服务种类而言，阿里云在国内处于遥遥领先的地位，腾讯云的产品比阿里云略少，但其在游戏、社交、视频、移动等方面有着非常丰富的经验和实力。另外，腾讯云的用户界面设计也略优于阿里云。</p>
<p>建议<br>阿里云：巩固现有龙头地位，积极拓展其他业务，加大在视频直播、游戏研发、移动服务研发的投入，在这些领域追赶腾讯云。</p>
<p>腾讯云：保持现有优势，步步为营，增加业务范畴，条件允许的情况下通过更优惠的价格吸引更多的用户。</p>
<p>随着云计算应用的不断深入，以及对大数据处理需求的不断扩大，云计算市场会进一步扩大，无论是阿里云还是腾讯云都应抓住时机，做好现有产品，推出更多新型产品，才能在未来的云计算服务市场抢占更多的位置。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E4%BA%91%E8%AE%A1%E7%AE%97/" rel="tag">云计算</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-React中绑定this并传参的几种方式" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/10/10/React%E4%B8%AD%E7%BB%91%E5%AE%9Athis%E5%B9%B6%E4%BC%A0%E5%8F%82%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"
    >React中绑定this并传参的几种方式</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/10/10/React%E4%B8%AD%E7%BB%91%E5%AE%9Athis%E5%B9%B6%E4%BC%A0%E5%8F%82%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/" class="article-date">
  <time datetime="2019-10-09T16:00:00.000Z" itemprop="datePublished">2019-10-10</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7React/">打怪升级React</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<blockquote>
<p>在事件处理函数中，直接使用 bind 绑定 this 并传参<br>在构造函数中绑定并传参<br>利用箭头函数的this指向解决<br>bind的作用：为前面的函数，修改函数内部的 this 指向，让函数内部的this，指向 bind 参数列表中的 第一个参数 </p>
</blockquote>
<p>bind 和 call/apply 之间的区别： call/apply 修改完this指向后，会立即调用前面的函数，但是 bind 只是修改this指向，并不会l立即调用，bind会重新返回一个新函数。</p>
<p>注意： bind 中的第一个参数，是用来修改 this 指向的，第一个参数后面的所有参数，都会当作将来调用 前面函数 时候的参数传递进去</p>
<p>接下来具体看代码：<br>第一种方式的代码： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">BindThis</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state=&#123;</span><br><span class="line">      msg:<span class="string">'这是默认的msg'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">      &#123;/* 方式1：在 事件处理函数中，直接使用 bind 绑定 this 并传参 */&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">'绑定This并传参的方式'</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeMsg1.bind(this,</span> '🐷', '🍕')&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;this.state.msg&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>




<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> changeMsg1(arg1, arg2)&#123;</span><br><span class="line">    <span class="comment">//注意：这里的方式，是一个普通的方法，因此，在触发的时候，这里的this是undefined</span></span><br><span class="line">    <span class="comment">// console.log(this);</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      msg:<span class="string">'绑定This并传参的方式'</span>+ arg1 + arg2</span><br><span class="line">    &#125;) </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">第二种方式的代码：</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">BindThis</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state=&#123;</span><br><span class="line">      msg:<span class="string">'这是默认的msg'</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 绑定 this 并传参的方式2: 在构造函数中绑定并传参</span></span><br><span class="line">    <span class="comment">// 注意，当一个函数，调用 bind 改变了this指向后，bind 函数调用的结果，有一个返回值，这个值，就是被改变this指向后的函数的引用</span></span><br><span class="line">    <span class="comment">// 注意： bind 不会修改 原函数的 this 指向</span></span><br><span class="line">    <span class="keyword">this</span>.changeMsg2 = <span class="keyword">this</span>.changeMsg2.bind(<span class="keyword">this</span>, <span class="string">'🚗'</span>, <span class="string">'👫'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"绑定this并传参的方式2"</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeMsg2&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;this.state.msg&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  changeMsg2(arg1,arg2)&#123;</span><br><span class="line">    <span class="comment">//console.log(this)</span></span><br><span class="line">    <span class="comment">// 注意：这里的方式，是一个普通方法，因此，在触发的时候，这里的 this 是 undefined</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      msg: <span class="string">'绑定this并传参的方式2'</span> + arg1 + arg2</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>第二种方式需要注意： 当一个函数，调用 bind 改变了this指向后，bind 函数调用的结果，有一个返回值，这个值，就是被改变this指向后的函数的引用；<br>            bind 不会修改 原函数的 this 指向</p>
</blockquote>
<p> 第三种方式代码： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">BindThis</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state=&#123;</span><br><span class="line">      msg:<span class="string">'这是默认的msg'</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>     </span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"绑定this并传参的方式3"</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123; this.changeMsg3('😊', '😘') &#125;&#125; /&gt;</span></span><br><span class="line"><span class="xml">     </span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;this.state.msg&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  changeMsg3 = <span class="function">(<span class="params">arg1,arg2</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      msg:<span class="string">'绑定this并传参的方式3'</span> + arg1 + arg2</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"绑定this并传参的方式3"</span> onClick=&#123;<span class="keyword">this</span>.changeMsg3(<span class="string">'😊'</span>, <span class="string">'😘'</span>) &#125;/&gt;</span><br></pre></td></tr></table></figure>

<p>注意： 根据第三种方式得上面这一小段代码出现bug！<br>由于传参，通过this.changeMsg3（arg1,arg2）直接调用了这个函数，就是在没有点击时已经调用了，本身onclick事件里面放的是函数，而不是函数的调用的结果，如果这样写，在页面就会直接显示结果。</p>
<blockquote>
<p>解决方式： 就是在onclick事件中放一个箭头函数，在箭头函数内部调用。<br>三种方式都能达到同样的效果，但是性能上还是有很大的差别的。</p>
</blockquote>
<p>总结：</p>
<blockquote>
<p>每次在render的时候都要去绑定this，是性能最差的！</p>
<p>使用构造函数的方式：在每一个实例化之后的this 都会定义该方法，但是该方式其实是定义在prototype 上的，各个实例对象共享该方法。<br>定义在原型链上的方法，在实际调用该方法的时候，其查找的过程是这样的：<br>首先检查this 上是否有该方法的定义，如果没有的话，则去prototype 上查找是否有该方法，所以在方法调用的过程中，会经历一次跨原型链的查找，带来额外的消耗。</p>
</blockquote>
<blockquote>
<p>箭头函数的方式，在实际调用的时候，访问的是外层作用缓存的_this， 所以在作用域查找上有一层消耗。</p>
</blockquote>
<p>问题延申：React组件的this在不同场景下分别是什么？<br>背景：因为JavaScript函数中的this不是在函数声明的时候定义的，而是在函数调用（即运行）的时候定义的（不包括箭头函数）同样，React组件也遵循JavaScript的这种特性，所以组件方法的‘调用者’不同会导致this的不同（这里的 “调用者” 指的是函数执行时的当前对象。<br>ES6中新增了箭头函数这种语法,箭头函数以其简洁性和方便获取this的特性。<br>下面来总结一下他们之间的区别：</p>
<blockquote>
<p>普通函数下的this:<br>在普通函数中的this总是代表它的直接调用者，在默认情况下，this指的是window，<br>在严格模式下,没有直接调用者的函数中的this是 undefined使用<br>call,apply,bind(ES5新增)绑定的,this指的是 绑定的对象<br>箭头函数中的this:<br>箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象),<br>而不是执行时的对象, 定义它的时候,可能环境是window,也有可能是其他的。</p>
</blockquote>
<p>阅读深入浅出React之后的总结：</p>
<blockquote>
<p>React组件生命周期函数中的this指向组件实例；<br>自定义组件方法的this会因调用者不同而不同；<br>为了在组件的自定义方法中获取组件实例，需要手动绑定this到组件实例。</p>
</blockquote>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/React/" rel="tag">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/" rel="tag">事件绑定</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-数组技巧总结 (1)" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/09/12/%E6%95%B0%E7%BB%84%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%20(1)/"
    >数组技巧总结</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/09/12/%E6%95%B0%E7%BB%84%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%20(1)/" class="article-date">
  <time datetime="2019-09-11T16:00:00.000Z" itemprop="datePublished">2019-09-12</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7JS/">打怪升级JS</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="map与for-each"><a href="#map与for-each" class="headerlink" title="map与for each"></a>map与for each</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">			<span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">			<span class="comment">//for each 对数组直接进行循环，相当于直接for循环,没有返回值</span></span><br><span class="line">			<span class="comment">//三个参数是item  index arr不是必须的</span></span><br><span class="line">			<span class="comment">// let result = arr.forEach((item,index,arr)=&gt;&#123;</span></span><br><span class="line">			<span class="comment">// 	console.log(item)</span></span><br><span class="line">			<span class="comment">// 	console.log(index)</span></span><br><span class="line">			<span class="comment">// 	console.log(arr)</span></span><br><span class="line">			<span class="comment">// 	return item</span></span><br><span class="line">			<span class="comment">// &#125;)</span></span><br><span class="line">			<span class="comment">//console.log(result)</span></span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">let</span> arr2 = [<span class="string">'香蕉'</span>,<span class="string">"苹果"</span>,<span class="string">"雪梨"</span>]</span><br><span class="line">			<span class="comment">//map,对数组每一项进行加工，加工完成之后返回1个新的数组！</span></span><br><span class="line">			<span class="comment">// let result2 = arr2.map((item,index,arr)=&gt;&#123;</span></span><br><span class="line">			<span class="comment">// 	let str = index + item + index</span></span><br><span class="line">			<span class="comment">// 	return str</span></span><br><span class="line">			<span class="comment">// &#125;)</span></span><br><span class="line">			<span class="comment">// console.log(result2)</span></span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">let</span> arr3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line">			<span class="comment">//filter过滤，就是将想要的内容进行筛选，不要内容去除，最终返回想要的内容的数组。</span></span><br><span class="line">			<span class="comment">// let result3 = arr3.filter((item,index)=&gt;&#123;</span></span><br><span class="line">			<span class="comment">// 	if(item%2==0)&#123;</span></span><br><span class="line">			<span class="comment">// 		//通过返回true还是false进行选择，true就是想要，false就是去除。</span></span><br><span class="line">			<span class="comment">// 		return true;</span></span><br><span class="line">			<span class="comment">// 	&#125;else&#123;</span></span><br><span class="line">			<span class="comment">// 		return false;</span></span><br><span class="line">			<span class="comment">// 	&#125;</span></span><br><span class="line">			<span class="comment">// &#125;)</span></span><br><span class="line">			<span class="comment">// console.log(result3)</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">//reduce,是对整个数组进行整合，比如要将数组里所有的数字进行相加</span></span><br><span class="line">			<span class="comment">//将数组每一项内容整合后，返回1个内容</span></span><br><span class="line">			<span class="keyword">let</span> arr4 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line">			<span class="keyword">let</span> result4 =arr4.reduce(<span class="function">(<span class="params">pre,next,index</span>)=&gt;</span>&#123;</span><br><span class="line">				<span class="built_in">console</span>.log(pre);</span><br><span class="line">				<span class="built_in">console</span>.log(next);</span><br><span class="line">				<span class="built_in">console</span>.log(index)</span><br><span class="line">				<span class="keyword">return</span> pre+next</span><br><span class="line">			&#125;,<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">console</span>.log(result4)</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//for...in...主要用于遍历对象的，不适用于遍历数组,for(key in obj),里面的每项是key</span></span><br><span class="line">			<span class="comment">//for...of...可以用来遍历数组，类数组的对象，字符串，set/map,generator。</span></span><br><span class="line">			<span class="comment">//for(item of arr),里面的是每一项</span></span><br><span class="line">			<span class="comment">//map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</span></span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">let</span> obj = &#123;</span><br><span class="line">				name:<span class="string">"老陈"</span>,</span><br><span class="line">				type:<span class="string">"帅"</span>,</span><br><span class="line">				content:<span class="string">"前端"</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span>(key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">				<span class="built_in">console</span>.log(<span class="string">"key："</span>+key+<span class="string">";value:"</span>+obj[key])</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">let</span> arr5 = [<span class="string">"范冰冰"</span>,<span class="string">"李晨"</span>,<span class="string">"鹿晗"</span>]</span><br><span class="line">			<span class="comment">//for of循环的是每一项的内容</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr5)&#123;</span><br><span class="line">				<span class="built_in">console</span>.log(item)</span><br><span class="line">			&#125;</span><br><span class="line">		&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p>这是一个非常流行的关于Javascript数组的采访问题，数组去重。这里有一个快速简单的解决方案，可以使用一个新的Set()。我想向您展示两种可能的方法，一种是使用.from()方法，另一种是使用spread操作符(…)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"banana"</span>, <span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"watermelon"</span>, <span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"grape"</span>, <span class="string">"apple"</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// First method</span></span><br><span class="line"><span class="keyword">var</span> uniqueFruits = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(fruits));</span><br><span class="line"><span class="built_in">console</span>.log(uniqueFruits); </span><br><span class="line"><span class="comment">// returns ["banana", "apple", "orange", "watermelon", "grape"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Second method</span></span><br><span class="line"><span class="keyword">var</span> uniqueFruits2 = […<span class="keyword">new</span> <span class="built_in">Set</span>(fruits)];</span><br><span class="line"><span class="built_in">console</span>.log(uniqueFruits2); </span><br><span class="line"><span class="comment">// returns ["banana", "apple", "orange", "watermelon", "grape"]</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>替换数组中的特定值<br>有时在创建代码时需要替换数组中的特定值，有一种很好的简单的方法可以做到这一点，我们可以使用.splice(start、valueToRemove、valueToAdd)，并将所有三个参数传递给它，这些参数可以指定我们希望从哪里开始修改、希望修改多少值和新值。</li>
</ol>
<p>var fruits = [“banana”, “apple”, “orange”, “watermelon”, “apple”, “orange”, “grape”, “apple”];<br>fruits.splice(0, 2, “potato”, “tomato”);<br>console.log(fruits);<br>// returns [“potato”, “tomato”, “orange”, “watermelon”, “apple”, “orange”, “grape”, “apple”]<br>3. 没有map()的映射数组<br>也许每个人都知道数组的map()方法，但是有一个不同的解决方案，它可以用来获得类似的效果和非常干净的代码。我们可以使用.from()方法。</p>
<p>var friends = [<br>    { name: “John”, age: 22 },<br>    { name: “Peter”, age: 23 },<br>    { name: “Mark”, age: 24 },<br>    { name: “Maria”, age: 22 },<br>    { name: “Monica”, age: 21 },<br>    { name: “Martha”, age: 19 },<br>]</p>
<p>var friendsNames = Array.from(friends, ({name}) =&gt; name);<br>console.log(friendsNames);<br>// returns [“John”, “Peter”, “Mark”, “Maria”, “Monica”, “Martha”]<br>4. 空数组<br>您是否有一个满是元素的数组，但是您需要出于任何目的对其进行清理，并且您不想逐个删除项? 很容易就可以在一行代码中完成。要清空一个数组，您需要将数组的长度设置为0，就是这样!</p>
<p>var fruits = [“banana”, “apple”, “orange”, “watermelon”, “apple”, “orange”, “grape”, “apple”];</p>
<p>fruits.length = 0;<br>console.log(fruits);<br> // returns []</p>
<h2 id="将数组转换为对象"><a href="#将数组转换为对象" class="headerlink" title="将数组转换为对象"></a>将数组转换为对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spread运算符(…)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"banana"</span>, <span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"watermelon"</span>];</span><br><span class="line"><span class="keyword">var</span> fruitsObj = &#123; …fruits &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(fruitsObj);</span><br><span class="line"><span class="comment">// returns &#123;0: "banana", 1: "apple", 2: "orange", 3: "watermelon", 4: "apple", 5: "orange", 6: "grape", 7: "apple"&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="用数据填充数组"><a href="#用数据填充数组" class="headerlink" title="用数据填充数组"></a>用数据填充数组</h2><p>在某些情况下，当创建一个数组时，希望用一些数据来填充它，或者需要一个具有相同值的数组，在这种情况下使用fill()方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>).fill(<span class="string">"1"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newArray); </span><br><span class="line"><span class="comment">// returns ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1"]</span></span><br></pre></td></tr></table></figure>

<h2 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h2><p>.concat()方法或spread操作符(…)在处理数组时非常有用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>];</span><br><span class="line"><span class="keyword">var</span> meat = [<span class="string">"poultry"</span>, <span class="string">"beef"</span>, <span class="string">"fish"</span>];</span><br><span class="line"><span class="keyword">var</span> vegetables = [<span class="string">"potato"</span>, <span class="string">"tomato"</span>, <span class="string">"cucumber"</span>];</span><br><span class="line"><span class="keyword">var</span> food = […fruits, …meat, …vegetables];</span><br><span class="line"><span class="built_in">console</span>.log(food); </span><br><span class="line"><span class="comment">// ["apple", "banana", "orange", "poultry", "beef", "fish", "potato", "tomato", "cucumber"]</span></span><br></pre></td></tr></table></figure>

<h2 id="求两个数组的交集"><a href="#求两个数组的交集" class="headerlink" title="求两个数组的交集"></a>求两个数组的交集</h2><blockquote>
<p>为了找到两个数组的交集，以确保数组中的值不重复，使用.filter方法和.include方法。最后，将得到两个数组的交集。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numOne = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> numTwo = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> duplicatedValues = […<span class="keyword">new</span> <span class="built_in">Set</span>(numOne)].filter(<span class="function"><span class="params">item</span> =&gt;</span> numTwo.includes(item));</span><br><span class="line"><span class="built_in">console</span>.log(duplicatedValues); </span><br><span class="line"><span class="comment">// returns [2, 4, 6]</span></span><br></pre></td></tr></table></figure>

<h2 id="从数组中删除假值"><a href="#从数组中删除假值" class="headerlink" title="从数组中删除假值"></a>从数组中删除假值</h2><blockquote>
<p>在Javascript中，假值是false, 0， “ “， null, NaN, undefined  使用.filter()方法。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mixedArr = [<span class="number">0</span>, <span class="string">"blue"</span>, <span class="string">""</span>, <span class="literal">NaN</span>, <span class="number">9</span>, <span class="literal">true</span>, <span class="literal">undefined</span>, <span class="string">"white"</span>, <span class="literal">false</span>];</span><br><span class="line"><span class="keyword">var</span> trueArr = mixedArr.filter(<span class="built_in">Boolean</span>);</span><br><span class="line"><span class="built_in">console</span>.log(trueArr); </span><br><span class="line"><span class="comment">// returns ["blue", 9, true, "white"]</span></span><br></pre></td></tr></table></figure>

<h2 id="从数组中获取随机值"><a href="#从数组中获取随机值" class="headerlink" title="从数组中获取随机值"></a>从数组中获取随机值</h2><blockquote>
<p>有时需要从数组中随机选择一个值。要以一种简单、快速、简短的方式创建它，并保持代码整洁，可以根据数组长度获得一个随机索引号。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"blue"</span>, <span class="string">"white"</span>, <span class="string">"green"</span>, <span class="string">"navy"</span>, <span class="string">"pink"</span>, <span class="string">"purple"</span>, <span class="string">"orange"</span>, <span class="string">"yellow"</span>, <span class="string">"black"</span>, <span class="string">"brown"</span>];</span><br><span class="line"><span class="keyword">var</span> randomColor = colors[(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (colors.length + <span class="number">1</span>)))]</span><br></pre></td></tr></table></figure>

<h2 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a>数组反转</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"blue"</span>, <span class="string">"white"</span>, <span class="string">"green"</span>, <span class="string">"navy"</span>, <span class="string">"pink"</span>, <span class="string">"purple"</span>, <span class="string">"orange"</span>, <span class="string">"yellow"</span>, <span class="string">"black"</span>, <span class="string">"brown"</span>];</span><br><span class="line"><span class="keyword">var</span> reversedColors = colors.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(reversedColors); </span><br><span class="line"><span class="comment">// returns ["brown", "black", "yellow", "orange", "purple", "pink", "navy", "green", "white", "blue"]</span></span><br></pre></td></tr></table></figure>

<h2 id="lastIndexOf-方法"><a href="#lastIndexOf-方法" class="headerlink" title="lastIndexOf()方法"></a>lastIndexOf()方法</h2><blockquote>
<p>允许查找给定元素的最后一次出现的索引。例如，数组有重复的值，可以找到它最后一次出现的位置。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">var</span> lastIndex = nums.lastIndexOf(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(lastIndex); </span><br><span class="line"><span class="comment">// returns 9</span></span><br></pre></td></tr></table></figure>

<h2 id="将数组中的所有值相加"><a href="#将数组中的所有值相加" class="headerlink" title="将数组中的所有值相加"></a>将数组中的所有值相加</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> sum = nums.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y);</span><br><span class="line"><span class="built_in">console</span>.log(sum); </span><br><span class="line"><span class="comment">// returns 14</span></span><br></pre></td></tr></table></figure>

<h2 id="易混辨析"><a href="#易混辨析" class="headerlink" title="易混辨析"></a>易混辨析</h2><p>比如有一个数组a=[1,2,3,4]，还有一个对象a={0:1,1:2,2:3,3:4}，然后运行alert(a[1])，两种情况下的运行结果是相同的！这就是说，数据集合既可以用数组表示，也可以用对象表示，那么我到底该用哪一种呢？<br><strong>数组表示有序数据的集合，而对象表示无序数据的集合。如果数据的顺序很重要，就用数组，否则就用对象。</strong><br>当然，数组和对象的另一个区别是，数组的数据没有”名称”（name），对象的数据有”名称”（name）。<br>但是问题是，很多编程语言中，都有一种叫做”关联数组”（associative array）的东西。这种数组中的数据是有名称的。<br>但是在《javascript DOM》中，不推荐我们使用 关联数组！</p>
<blockquote>
<p><strong>判断一个对象是不是数组类型最可靠的方法是这两种:<br>Object. prototype.toString.call(obj)===[ object Array]和Array. isArray(obj)。</strong></p>
</blockquote>
<p>原因：typeof 检查基本数据类型是可以的，但不准确。<br>Array.isArray() 用于确定传递的值是否是一个 Array。如果对象是 Array，则为true; 否则为false.这个是可以的！<br> <strong>所有 函数的原型对象默认是OBJECT的实例，但OBJECT除外。Function 函数是new自己产生的。</strong><br>但是！bug问题就是研究不深入啊啊啊啊啊啊，作为程序媛，我有点难~<br>A  instance of   B不准确！因为原型链可以改变，只要B构造函数的显示原型对象protptype在左边A的原型链上可以找到就返回TRUE。只要在A 的原型链上找到了B的prototype,，就可以,任何一个就可以说明A是B的一个实例。<br>这种方法有一个问题，就是验证不够严格。 如果对象创建时不是使用数组创建的，但是只要原型链上有数组类型，也认为是数组，如下面一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Test.prototype = <span class="built_in">Array</span>.prototype;</span><br><span class="line"><span class="keyword">let</span> test = <span class="keyword">new</span> Test();</span><br><span class="line">test <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Object. prototype.toString.call(obj)===[ object Array]原理是根据对象的class属性(类属性)，跨原型链调用toString()方法。<br><code>Object.prototype.toString.call(new Date());   //&quot;[object Date]&quot;
Object.prototype.toString.call(Window);       //&quot;[object window]&quot;
Object.prototype.toString.call(/./);          //&quot;[object RegExp]&quot;</code></p>
</blockquote>
<p>解释一下，在js中一个对象一旦被创建，在内部会携带创建对象的类型名，一旦创建就不能被修改了。那么怎么获取这个对象的类型名呢？所谓”纯粹的对象”，就是说该对象是通过”{}“或”new Object”创建的。<br>js中提供了调用对象原型中的toString方法， Object.prototype.toString.call(obj)。因为很多对象继承的toString（）方法被重写了，为了能够调用正确的toString（）版本，也就是最原始的版本。可以使用Function.call()的方法。<br>其中call可以这么理解，相当于obj去借用这个 Object.prototype.toString()<br><strong>举个栗子~</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;,</span><br><span class="line">arr = [];</span><br><span class="line"></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>	<span class="comment">//false</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>	<span class="comment">//true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>	<span class="comment">//true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Object</span>	<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span></span><br><span class="line">var obj = &#123;&#125;,</span><br><span class="line">arr = [];</span><br><span class="line"></span><br><span class="line">obj.constructor === <span class="built_in">Object</span>	<span class="comment">//true</span></span><br><span class="line">arr.constructor === <span class="built_in">Object</span>	<span class="comment">//false</span></span><br><span class="line">obj.constructor === <span class="built_in">Array</span>	<span class="comment">//true！</span></span><br><span class="line">arr.constructor === <span class="built_in">Array</span>	<span class="comment">//false</span></span><br></pre></td></tr></table></figure>



      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/Javascript/" rel="tag">Javascript</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-React" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/08/23/React/"
    >React生命周期（一）</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/08/23/React/" class="article-date">
  <time datetime="2019-08-22T16:00:00.000Z" itemprop="datePublished">2019-08-23</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7React/">打怪升级React</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="Initialization-初始化阶段。"><a href="#Initialization-初始化阶段。" class="headerlink" title="Initialization:初始化阶段。"></a>Initialization:初始化阶段。</h1><h1 id="Mounting-挂载阶段。"><a href="#Mounting-挂载阶段。" class="headerlink" title="Mounting: 挂载阶段。"></a>Mounting: 挂载阶段。</h1><h1 id="Updation-更新阶段。"><a href="#Updation-更新阶段。" class="headerlink" title="Updation: 更新阶段。"></a>Updation: 更新阶段。</h1><h1 id="Unmounting-销毁阶段"><a href="#Unmounting-销毁阶段" class="headerlink" title="Unmounting: 销毁阶段"></a>Unmounting: 销毁阶段</h1><p>什么是生命周期函数？<br>如果非要用一句话把生命周期函数说明白，我觉的可以用这句话来说明：</p>
<p>生命周期函数指在某一个时刻组件会自动调用执行的函数</p>
<p>举例：render()函数，就是一个生命周期函数，它在state发生改变时自动执行。这就是一个标准的自动执行函数。</p>
<p>constructor不算生命周期函数。<br>constructor叫构造函数，它是ES6的基本语法。虽然它和生命周期函数的性质一样，但不能认为是生命周期函数。</p>
<p>我个人把它看成React的Initialization阶段，定义属性（props）和状态(state)。</p>
<p><img src="https://img-blog.csdnimg.cn/20200302110716424.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Mounting阶段<br>Mounting阶段叫挂载阶段，伴随着整个虚拟DOM的生成，它里边有三个小的生命周期函数，分别是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">componentWillMount : 在组件即将被挂载到页面的时刻执行。</span><br><span class="line">render : 页面state或props发生变化时执行。</span><br><span class="line">componentDidMount : 组件挂载完成时被执行。</span><br><span class="line">componentWillMount代码</span><br><span class="line"></span><br><span class="line">componentWillMount()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillMount----组件将要挂载到页面的时刻'</span>)</span><br><span class="line">&#125;</span><br><span class="line">componentDidMount代码</span><br><span class="line"></span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidMount----组件挂载完成的时刻执行'</span>)</span><br><span class="line">&#125;</span><br><span class="line">render代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">render()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render---组件挂载中.......'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看一下控制台，会打出如下提示：</p>
<p>componentWillMount—-组件将要挂载到页面的时刻执行<br>render—-开始挂载渲染<br>componentDidMount—-组件挂载完成的时刻执行<br>这也是生命周期的顺序。有小伙伴会问我，这个函数书写有顺序吗?哪个在前？哪个在后？其实是没有顺序的，你可以随便改动他们的顺序。</p>
<p>注意的问题：</p>
<p>componentWillMount和componentDidMount这两个生命周期函数，只在页面刷新时执行一次，而render函数是只要有state和props变化就会执行，这个一定要注意。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/React/" rel="tag">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/jsx/" rel="tag">jsx</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-推荐算法笔记（二）" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="../../2019/07/12/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"
    >推荐算法笔记（二）</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="../../2019/07/12/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/" class="article-date">
  <time datetime="2019-07-11T16:00:00.000Z" itemprop="datePublished">2019-07-12</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/">实习项目复盘</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="推荐算法背景"><a href="#推荐算法背景" class="headerlink" title="推荐算法背景"></a>推荐算法背景</h2><p>在商品短缺，信息缺失和广告缺乏的时代，人类社会面临着无可奈何的选择不足困境；而在商品过剩，信息过度和广告过多的社会中，人类社会又面临着史无前例的选择过多困境甚至于因为选择过多而产生无从选择的尴尬情景。</p>
<p>在这两种截然不同的社会经济环境中，个体所采取或者说所应对的策略，前一种侧重于自觉地主动搜寻个体需求之物，后一种侧重于不自觉地被动接受社会提供之物。</p>
<p>体现在现实的经济社会中，就是我们现在不仅通过搜索引擎主动地查询搜索购买商品，查询收集浏览新闻信息和广告资讯；而且我们更是被动地接受了由机器深度学习进行系统自动化推荐算法所计算出来的，为个体量身定做而提供的各种推荐商品，信息和广告等个性化服务。</p>
<p>当然，也正如同古希腊大哲学家苏格拉底所说的那样，人最难认识的是自己，有时用户很难用恰当的关键词语来描述自己的需求和想法，又或是无法对自己未知而又可能感兴趣的信息做出描述而显得无所适从或者说无可选择。因此，通过机器算法的推荐系统能得到进一步的发展和应用就成为顺理成章的事情了。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLndvc2hpcG0uY29tL3dwLWZpbGVzLzIwMTgvMDIvdGFKTkpXMmJlZTFLSEN1UlZzaWwucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>虽然这种基于机器各种算法而产生的商品、信息和广告推荐成为各大互联网服务平台的标配，尤其是通过主打算法的个性化推荐类新闻app在近一两年的崛起和称霸，更是成为中国互联网界有目共睹的辉煌成就。</p>
<p>但隐藏在这些热闹表象身后所体现出来的实质上更多地是社会科学技术发展到一定程度所必然出现的结果，即AI技术中有关深度学习技术手段在历史上几次起起落落后应用于推荐系统中的重新崛起和发展。因此，近几年推荐系统的风生水起，与其说是互联网界的成就，不如说是中国科技界，尤其是AI技术的进步。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLndvc2hpcG0uY29tL3dwLWZpbGVzLzIwMTgvMDIvOERUWlZSTkFGZEdqTWM3WjNxelgucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>很明显，深度学习是AI体系中技术层面上的一种运算方法和手段，而推荐系统则是深度学习在具体细分领域的一种技术层面应用，它的重新崛起是社会发展到一定阶段后，人类所形成新的需求矛盾与科技进步发展所形成新的生产力相互结合的必然结果。</p>
<p>它与各种互联网服务平台结合而成的实际应用就是我们现在的个性化推荐商品（电商），新闻（资讯分发），广告以及其他各种个性化服务平台，如下图。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLndvc2hpcG0uY29tL3dwLWZpbGVzLzIwMTgvMDIvWk1WWkdLRDRPYlVzRFBXREpCa08ucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>推荐算法历史与种类<br>实际上，推荐这二个字对我们来说并不陌生，遍布于生活、工作、学习等各个方面，如学习中的三好生推荐，高考中的保送生推荐；工作中的优秀员工推荐，选举时的候选人推荐；生活中的超市购物店长推荐，畅品推荐等等。</p>
<p>而从其纵向的发展历史来看，我们也经历了从毛遂自荐，口碑相传的个体推荐形式，逐步过渡到1/2或者2/3简单多数规则的群体推荐形式，以及进一步转化到涉及各种权重、混合、360度全方位等复杂规则的群体推荐形式。</p>
<p>然而，不管是个体自荐和推荐，还是群体推荐；抑或不论是简单多数规则，还是复杂规则；本质上都属于一种人为推荐形式。而人为推荐则必然不同程度地存在着诸多如暗箱操作、感情用事、趋利避害、标准不一的主观性意见缺陷，导致难以得到客观化的满意结果。</p>
<p>为使推荐的结果更加合乎实际和更加客观化，通过计算机采取一定技术方法的算法推荐系统就应运产生了。与人为推荐系统的发展历程一样，早期计算机推荐系统中的算法和技术也是十分简单和粗糙的，如打分预测，即通过用户（User）对物品（Item）的打分（Rating）进行评分预测推荐；或相似评估，即通过对用户和物品一些较为粗糙简单的明显属性进行分析评判推荐。</p>
<p>只是在进入互联网时代后，随着云计算和大数据分析等技术的发展，在运算和存储能力跃入新的层级之后，推荐算法不仅在数量的广度上，而且在技术的深度上都达到了前所未有的一个水平。</p>
<p>目前各种具体推荐算法很多，而且分类标准也不尽相同，但万变不离其宗，由于推荐系统本质是向用户推荐合适物品的个性化服务，主要涉及到用户和物品二个对象。因此，从大的方向来看，可以划分为基于用户的“人以群分”推荐算法和基于物品的“物以类聚 ”推荐算法，简述如下：</p>
<p>1、以人为中心的“人以群分”推荐算法<br>这种推荐系统的内在原理有一个假设前提，即相同群体中的成员拥有共同的兴趣爱好，因此同类人喜欢什么就推荐什么。很明显在这种推荐系统中，关键点是如何全面准确地划定人“群”的属性，即“群”的相似度和近似度对个体的影响力权重程度。一般地，最常见的是基于人口统计学中个体自然的基本属性而推荐。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLndvc2hpcG0uY29tL3dwLWZpbGVzLzIwMTgvMDIvN3RiMFpCNG9xUVMwOXNmeXN4OVYucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>因此，根据个体的基本属性在理论上就会出现很多推荐子系统，如基于性别的，基于年龄的，基于学历的，基于地域的等等推荐系统，这里的关于人的推荐系统是平行关系的，与下面的物品推荐系统层级关系有所不同。当然在实际经济中，并不是所有的推荐系统都是有用或者说有效的，因此就必须根据个体和物品进行有目的的筛选淘汰了。</p>
<p>栗子：基于年龄的推荐系统</p>
<p>这里的“群”就是年龄，而且假设年龄对物品和用户的影响力权重占第一位。推荐原理如下：</p>
<p>第一步：机器通过大数据以“年龄”为关键属性搜寻找到各个用户之间的相似度和邻近度。<br>第二步：对不同用户A,B,C的相似度进行排序。<br>第三步：选出与当前用户A最相近的用户C。<br>第四步：将用户A喜欢的物品a推荐给没有接触过的用户C。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLndvc2hpcG0uY29tL3dwLWZpbGVzLzIwMTgvMDIveE1Jc2lpdlZBcEdGVDgxZ3JKQzUucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>这是较为通俗易懂的基于用户简单推荐方式，当然在实际经济生活中，“群”属性确定，推荐方式和具体运算过程则要复杂得多，但基本原理相似。</p>
<p>2、以物为中心的“物以类聚”推荐算法<br>与“人以群分”的推荐方式相类似，它是以物品的相似度代替了用户的相似度。这种推荐系统也有一个假设前提，即同一用户对相同类型的物品具有共同的兴趣爱好或者说吸引力，因此用户喜欢什么就推荐相同类型的物品。一样的道理，在这种推荐系统中，关键点是如何全面准确地划定物品的“类”的属性，即物品的“类”属性相似度和近似度对个体的影响力权重程度。</p>
<p>与“人以群分”推荐算法中“群”的各个属性划分是基于横向平行关系不同，在“物以类聚”推荐算法中物品的“类”是基于纵向层级关系而划定。而且由于大千世界各种物品成千上万，因此首先必须确定一个物品分门别类的划分标准，或者说确定一个比较合适的划分标准就显得十分重要。</p>
<p>物品具有自然属性和商品属性，因此可以按生物标准进行自然属性分类，也可以按经济属性进行商品属性分类；但由于我们都处于经济社会中，因此一般地，我们将物品的类别划分确定为以商品经济属性为主，兼顾生物自然属性进行划分。第一层先划分为有形产品和无形服务；第二层再根据惯例按国民经济行业有关第一产业、第二产业、第三产业进行行业分类。然后每一层按照从大到小，结合物品的品类、品种等自然生物属性和功能、用途、产地等商品属性逐层进行细分，直至分解到最后的最底层每一个单品sku。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLndvc2hpcG0uY29tL3dwLWZpbGVzLzIwMTgvMDIvMTBORm03TjFTWkhDbHZjcU4ybmYucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>相应地，根据物品类别在理论上也存在着很多推荐系统，对于有形产品来说，有基于价格的，基于用途的，基于产地的；对于无形服务来说，有基于年代的，基于等级的，基于提供者的等等细分推荐系统。当然也要根据需要进行筛选。</p>
<p>栗子：基于产地的物品推荐系统</p>
<p>这里的“类”就是产地，而且假设产地对用户的影响力权重占第一位。推荐原理如下：</p>
<p>第一步：机器通过大数据以“产地”为关键属性搜寻找到各个物品之间的相似度和邻近度。<br>第二步：对不同物品a,b,c的相似度进行排序。<br>第三步：选出与当前物品a最相近的物品c。<br>第四步：将物品c推荐给没有接触过的用户A。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLndvc2hpcG0uY29tL3dwLWZpbGVzLzIwMTgvMDIvRHZ2R0VGeDh3VWhFWHJRU0ZROFMucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>以上介绍的二种方法是推荐领域最基本的，也是最简单的的方法。但在实际的经济生活中和现实的真实案例推荐中，往往不是那么简单，需要面临着许多复杂多变的情景和任务，因此，在这二种基本推荐基础上的各种混合推荐系统就应运而生了。主要有</p>
<p>3、基于协同过滤推荐系统：这又分为基于用户协同过滤和基于物品协同过滤二种推荐方法<br>基于用户的协同过滤推荐方法原理与基于以人为中心的“人以群分”推荐算法相同，都是通过计算用户的相似度，利用相似，邻近和邻居进行计算推荐；它们的区别是如何计算用户的相似度，基 于以人为中心的“人以群分”推荐算法只考虑个体用户本身的基本特征，而基于用户的协同过滤机制则是在用户的历史偏好数据上计算用户的相似，即考虑用户的历史行为特征。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLndvc2hpcG0uY29tL3dwLWZpbGVzLzIwMTgvMDIvcGxKUVBXT1BUT0NPUlk4MWhMQUwucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>同样，基于物品的协同过滤方法与基于以物为中心的“物以类聚”推荐算法工作原理相似，都是基于物品相似度预测推荐；它们的区别也是物品相似度计算的方法不一样，前者是从用户历史的偏好推断，即物品有关的购买，收藏，评论，点赞等信息，而后者是基于物品本身的基本属性信息。</p>
<p>4、基于关联规则的推荐：就是找不同商品之间的相关性，假设用户喜欢A，A和B有紧密联系，就推荐B。主要指一些互补关系的产品，如香烟与打火机，复印机和色粉盒，也指一些在用途、渠道、购买者等方面相同的一些产品，如奶粉与尿不湿购买者可能为同一人，买了面包的人可能会买牛奶，零食与饮料可互补，海边的五金小店售卖啤酒等等。</p>
<p>5、基于背景的推荐：即找寻发现物品的行业特征以及物品在购买场景、展示场景和使用场景时的一些规律进行合适的推荐，如展示场景推荐系统就是表示如何将推荐产品合理地展示在电商页面的各个部分，以及明确各个部分的大小，顺序，色彩，主次等属性，从而达到重点区域突出，个性化推荐加强，进而提高销量的结果。</p>
<p>还有一些推荐算法，如标签的流行度推荐算法，基于效用的推荐，基于知识的推荐，组合推荐，加权推荐系统，模型推荐等；现归纳如图。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLndvc2hpcG0uY29tL3dwLWZpbGVzLzIwMTgvMDIvNDI3Y01rUjRlQVVmelZ0M0pSZ0oucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>推荐算法应用：精打细算才是出路<br>理论的最终目的是为了应用，是为了更好地指导我们的实践。因此，各种推荐算法在实际经济生活中的运用才是我们所需要考虑的核心问题。算法无好坏，适合是王道。</p>
<p>由于每个推荐算法都不是完美的，都有着不同程度的各自优缺点；因此理想的状态是使用所有推荐算法，取长补短，通过给不同算法的结果加权，从而达到完美的结果。但在实际应用中，基于企业的技术能力，成本压力和时间约束等因素，较为实际的步骤是：</p>
<p>根据所处行业，企业主要产品和主流用户的属性，确定以一个推荐算法为主计算结果，其他1-2个算法为辅论证和调整结果的混合推荐算法系统。<br>具体计算时，兼顾技术上的可能性，经济上的可行性和时间上的可控性三原则，实现推荐算法在技术、经济和效率的有机结合。<br>时空因素的影响：包括时间上有明显淡旺季区别的企业，有某些特定大事影响原有业务和产品运作方式的，如图原先体育栏目中，按项目、国别、球队、球员等维度逐层进行计算，然而在奥运会或者世界杯时期，可能在体育栏目中，就要变成奥运会、国家、运动员这几个维度进行计算了；空间上如交通企业，地域性明显的o2o、风景区和旅行社等。<br>4.不断迭代调整，提高计算准确率，实现更切合实际和满意的结果。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLndvc2hpcG0uY29tL3dwLWZpbGVzLzIwMTgvMDIvdlk4YlVaNUtXeGZKc2hJaDZKalAucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>那么，在电商行业、资讯信息广告行业和各种交互服务行业应用时，如何实现推荐算法的精打细算呢？具体的做法是：</p>
<p>电商行业：按大众化和小众化商品划分</p>
<p>对于那些大众化，老小皆宜的消费品，尤其是快消品，宜采用基于用户为中心的“人以群分”的User  RS 推荐算法，强调用户存在的买点和痛点，兼顾企业的优点和竞争点，也适合于那些选购性的耐用物品。</p>
<p>对于小众化，专业性强，特定品，以及工业品等物品，则应采用基于物品为中心的“物以类聚”的Item RS 推荐算法，强调物品自身的新奇特优等卖点，兼顾企业的优点和竞争点；从而进行精准化推荐，也适合于一些长尾物品以及没有用户画像的新产品冷启动情景。</p>
<p>资讯信息广告行业：按社会化和专业化划分</p>
<p>对于以娱乐消遣休闲为目的社会化新闻和一些常识谈资分享类信息，侧重于User  RS推荐算法。</p>
<p>以科技类，冷知识等专业知识，提高生活、学习和工作水平和能力为目的，侧重于Item RS推荐算法。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E5%A4%8D%E7%9B%98%E6%80%BB%E7%BB%93/" rel="tag">复盘总结</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/" rel="tag">推荐算法</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="../3/">上一页</a><a class="page-number" href="../../">1</a><a class="page-number" href="../2/">2</a><a class="page-number" href="../3/">3</a><span class="page-number current">4</span><a class="page-number" href="../5/">5</a><a class="extend next" rel="next" href="../5/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2020
        Wangqiuxia
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    <aside class="sidebar">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="../../index.html"><img src="/images/ayer-side.svg" alt="爱产品，爱前端！"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../index.html">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../tags/%E6%8A%80%E6%9C%AF/">小程序</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../http:/shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../https:/v.xiumi.us/stage/v5/4IeLH/197507179">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="../../atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="../../images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="../../images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="../../js/jquery-2.0.3.min.js"></script>


<script src="../../js/jquery.justifiedGallery.min.js"></script>


<script src="../../js/lazyload.min.js"></script>


<script src="../../js/busuanzi-2.3.pure.min.js"></script>


<script src="../../js/share.js"></script>



<script src="../../fancybox/jquery.fancybox.min.js"></script>




<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['做一个有情怀懂产品的程序媛！','业精于勤荒于嬉！行成于思毁于随！','越努力越幸运'],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script>
  var ayerConfig = {
    mathjax: false
  }
</script>


<script src="../../js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=518895142&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>