<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     爱产品，爱前端！
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="css/style.css">

  
<script src="/js/pace.min.js"></script>


  

  

<link rel="alternate" href="atom.xml" title="爱产品，爱前端！" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/diamondto.github.io"
        target="_blank"><img width="149" height="149" src="images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="index.html">爱产品，爱前端！</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-短视频流量大战的四大法宝——精准产品定位、打磨垂直内容、完善监管激励、优化创新服务" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/04/03/%E7%9F%AD%E8%A7%86%E9%A2%91%E6%B5%81%E9%87%8F%E5%A4%A7%E6%88%98%E7%9A%84%E5%9B%9B%E5%A4%A7%E6%B3%95%E5%AE%9D%E2%80%94%E2%80%94%E7%B2%BE%E5%87%86%E4%BA%A7%E5%93%81%E5%AE%9A%E4%BD%8D%E3%80%81%E6%89%93%E7%A3%A8%E5%9E%82%E7%9B%B4%E5%86%85%E5%AE%B9%E3%80%81%E5%AE%8C%E5%96%84%E7%9B%91%E7%AE%A1%E6%BF%80%E5%8A%B1%E3%80%81%E4%BC%98%E5%8C%96%E5%88%9B%E6%96%B0%E6%9C%8D%E5%8A%A1/"
    >短视频流量大战的四大法宝——精准产品定位、打磨垂直内容、完善监管激励、优化创新服务</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/04/03/%E7%9F%AD%E8%A7%86%E9%A2%91%E6%B5%81%E9%87%8F%E5%A4%A7%E6%88%98%E7%9A%84%E5%9B%9B%E5%A4%A7%E6%B3%95%E5%AE%9D%E2%80%94%E2%80%94%E7%B2%BE%E5%87%86%E4%BA%A7%E5%93%81%E5%AE%9A%E4%BD%8D%E3%80%81%E6%89%93%E7%A3%A8%E5%9E%82%E7%9B%B4%E5%86%85%E5%AE%B9%E3%80%81%E5%AE%8C%E5%96%84%E7%9B%91%E7%AE%A1%E6%BF%80%E5%8A%B1%E3%80%81%E4%BC%98%E5%8C%96%E5%88%9B%E6%96%B0%E6%9C%8D%E5%8A%A1/" class="article-date">
  <time datetime="2020-04-02T16:00:00.000Z" itemprop="datePublished">2020-04-03</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<blockquote>
<p>行业竞争激烈、人口红利见顶，在这场短视频流量大战中，如何打出漂亮一战？</p>
</blockquote>
<h2 id="行业背景调查"><a href="#行业背景调查" class="headerlink" title="行业背景调查"></a>行业背景调查</h2><p>1、TikTok（抖音海外版）在海外取得极大成功，对于其它视频应用产生了强烈冲击。此举招致了不少制裁，但也从一个侧面反映出TikTok在海外的影响力。据外媒报道，为了应对TikTok强势崛起，谷歌旗下视频网站YouTube将作出应对，并计划在今年年末推出名为Shorts的短视频功能，参与到TikTok的直接竞争中来。不过，与TikTok独立的APP模式相比，Shorts将成为YouTube主应用中的一部分，这或许会使Shorts的竞争力受到影响。</p>
<p>2、疫情当前，各大电影院都纷纷关门。流媒体似乎迎来了百年难得一遇的暖春，尤其是Netflix，凭借最为丰富的剧集资源库，在流媒体中称王，甚至将自己多部作品提前上线，吸取流量。下个月，又有一家全新平台入局流媒体——Quibi。Quibi ，Quickbites 的缩写，译为“速食”，这是一家还未上线便已获得十亿美元融资的短视频平台。 仅服务于手机端用户，内容专注于时下最热的短视频。Quibi的野心是成为「短视频界的Netflix」。在内容播放上，Quibi的每部剧集的总时长控制在2小时左右。</p>
<p>每集大约7-10分钟，每部约10-16集。至于更新频率——采用日更，每部剧每日更新一集。每隔一周就会有26个原创项目上线。这意味着每个礼拜都会有100来集短视频播出。当然，Quibi创办人杰弗里·卡森伯格也说了，“这不是短视频，而是一个个短视频章节组成的长视频。”他们想做的是“Quick bites. Big stories”，用一个零食时间，讲述大故事。</p>
<p>3、中新经纬客户端 4 月 2 日发布新闻，” 爱奇艺随刻版 “App 正式上线。爱奇艺对外宣称，” 爱奇艺随刻版 “App 是爱奇艺全新推出的海量精彩、多元化的综合视频社区产品，并要打造中国版的YouTube。随着 5G 和 AI 商用的发展，爱奇艺加入短视频赛道或许将给视频行业带来新的格局变化。爱奇艺创始人、CEO 龚宇认为，” 迄今为止，由于多种复杂因素的综合影响，YouTube 模式尚未在中国发展成规模，随着 5G 和 AI 技术的部署不断加强，类似 App 的市场潜力将在未来 2-3 年显著增长。为了抓住机遇，爱奇艺已开始做出初步的努力并投资建立规模化的业务模式。”</p>
<p>4、最近一段时间，正在内测的微信视频号引起了全行业的关注，诸多内容创作者纷纷开始研究微信视频号。一时间，微信视频号究竟会不会成为下一个风口，微信视频号能不能顺利突围，也成为大家热议的话题。视频号定位于“人人皆可创作的平台”，与朋友圈并驾齐驱，可见地位的重要性。它是微信的破圈——长短互补，强弱交织，蝴蝶效应，生态闭环——避免微信不被新生的短视频文化需求边缘化。猜想未来，视频号可能是所有市场中，唯一可以实现去中心化的、并且借助微信熟人社交链来打造电商基因 、金融科技、 闭环支付的短内容平台。毕竟，微信得天独厚的强大关系链牵动着十亿中国人的社交网络，这是其他APP望尘莫及的独特优势。</p>
<p>龙头齐聚，纷纷引发头脑风暴，打出自家品牌，如何才能脱颖而出呢？</p>
<p>笔者认为，以史为镜，可以知兴替，想要勇敢破圈、打出漂亮一战，</p>
<p>从产品定位的宏观策略上需要做好以下几点。</p>
<h2 id="精准产品定位"><a href="#精准产品定位" class="headerlink" title="精准产品定位"></a>精准产品定位</h2><p><strong>1、一切从用户出发，从用户中来，到用户中去。</strong></p>
<p>“水能载舟、异能覆舟”。水是用户，古往今来，得民心者得天下！比如汉武帝的成功、共产党的胜利、流芳百世的产品一定是为了满足用户的根本需求，在服务和体验上全身心为用户着想的产品。</p>
<p>抖音让你欲罢不能，为什么呢？全屏沉浸、精准分发、高清流畅、时髦新颖。（短视频）</p>
<p>微信不可替代，为什么呢？简单快捷、轻便舒适、不推销广告、自主订阅、功能齐全。（社交）</p>
<p>支付宝每天必开，为什么呢？花呗消费、余额盈利、风险投资、线下服务，一应俱全。（支付)</p>
<p>所有的成功，都来自合适的场景下，合适的满足了用户的迫切需求，并做到了这个领域的最佳应用体验。所以，流量不是目标，只是用户信任的附属品，赢得用户最根本、持续性的信任，才是高明之策！</p>
<p>互联网时代，从不缺人口和流量。我们缺啥？注意力和信任。注意力是招揽用户的法宝，信任是扩大生态的根本。</p>
<p><strong>2、深挖人性需求、细分使用场景。</strong></p>
<p>很多人说，微视没有打赢抖音，我们仔细去体验一下，真的是内容不好，设计不潮吗？</p>
<p>我想说，其实不是的，微视有自己的特色，主张探索和发现，提供自拍模板，其实也是腾讯的良心之作了。它是家庭影院，需要我们搬好小凳，拿好遥控器、和家人朋友互动，发掘自己的创造力，主打“创造、互动”。</p>
<p>抖音，凭借新潮的音乐和酷炫的节拍、场景，全身心为用户打造极致观看体验，不用用户思考，解放双手，它是3D影院，黑色环境下，你坐好就完事了，啥也不用管，我放啥你看啥，只要推荐算法精准，你肯定不想走，主打“沉浸、消费”。</p>
<p>从人性角度讲，用户是懒惰、贪婪的，所以，他们在巨大的工作、学习压力下想逃避现实的繁琐，选择了抖音，傻瓜式享受，人性所趋。</p>
<p><strong>总结一下，互联网时代，获取用户的两种方法：</strong></p>
<p>1、逃避现实，提供愉悦。打造虚拟世界快感，满足用户虚荣心、在虚拟世界找到更美更有钱更有权利的自己。</p>
<p>比如美拍、抖音、快手、全民K歌、王者荣耀、各大等级游戏。</p>
<p>2、直面现实、抵御恐惧、激励用户成长，跳出舒适圈、看清变化的世界、防止被世界抛弃。</p>
<p>通过线上打卡好友支持，坚持线上flag，目的是改变现实生活的自己，实现现实生活中在学习、工作上的实用价值，关注的是个人现实生活成长体验。</p>
<p>比如得到、微信读书、喜马拉雅、KEEP、薄荷健康、有道云笔记、英语流利说等各大教育机构APP。</p>
<p>下图是马斯洛的需求分级：<img src="https://img-blog.csdnimg.cn/20200403135554265.jpeg#pic_center" alt="在这里插入图片描述"></p>
<p>行业情况告诉我们，以上两种方式，各有玩法，就看怎么制定高级策略了，我认为区别有两点。</p>
<p><strong>提供快感、愉悦，快餐文化消费（最低层次的需求）</strong></p>
<p>1、提供快感（最低层次的需求）根源是逃避现实，是短期消费，利用碎片化时代用户的孤独和无聊情绪，最容易成功吸引，变现容易，但产品生命周期短，如果没有特点，只能昙花一现。</p>
<p>2、入门门槛低，但是不长久，比如，我身边玩抖音的人少了，因为新鲜感没有了。确实是这样，人是矛盾的，需求是动态的，上瘾是一时新鲜，如果没有现实生活的成长，很难长久。</p>
<p>2、一般靠群体实现，基于群体认同感，出发点是人关心虚拟世界中自己在群体中的地位。</p>
<p><strong>直面现实、抵御恐惧、长期习惯消费（自我实现的需求）</strong></p>
<p>1、根源是自我认同感。个人认同追求优越感，我们想要标新立异、想要出类拔萃，打卡、改变、去实现自我价值。</p>
<p>2、成功是上瘾的，当人通过努力获得了现实世界的超脱和破圈后，得到荣誉和赞赏，他会对成功上瘾。人性所趋，古往今来，不曾改变。</p>
<p>3、产品周期长，养成习惯难，但一旦过了缓冲期，产生数字资产的沉淀，用户就不会轻易放弃，用户黏度高。</p>
<p>比如，你写了很久的日记本，你不会轻易丢掉（文字积淀）；你谈了很久的男朋友，你舍不得忘不掉（情感积淀）；你的微信，不可能卸载（那里有您的社交关系链沉淀）。</p>
<p><strong>3、认清行业形势，把握合适时机。</strong></p>
<p>古语云：先下手为强。微视在很早就开始规划了，起了大早，却赶了晚集，可见市场、运营对产品的重要性。</p>
<p>产品从0到1 ，运营从1到100，好的产品是苗子，需要运营来及时呵护、养育，否则，很难茁壮成长。字节跳动的宣传和运营抢占了市场的先机，抖音先入为主，抢占了一部分用户的产品认知。</p>
<p>产品认知是很可怕的，甚至可以扭曲现实，一旦品牌深入人心之后，用户很难再去接受新的认知，尤其是相似性的同质化的产品。</p>
<p>所以，第一印象非常重要，这也是微信步步谨慎、每次改版都要深思熟虑的原理。</p>
<p>反思一下微博出品的绿洲，火不起来是因为没有达到精良设计时就横空出世，好牌也打乱了，很可惜。</p>
<p>所以最好的时机是合适，不是抢占更不是拖延。</p>
<p>因为，第一印象、决定了你在我心中的定位。比如，初次约会~</p>
<p>客观分析，这是市场决策的重要一环。以微视为例子：</p>
<p>2018年春节，腾讯微视通过QQ 走运红包合作发放微视礼包，新增数百万用户。黄子韬、刘昊然、张天爱、迪玛西等数十位明星助阵拜年并入驻微视。 [3]<br>2018年4月2日，腾讯微视发布2018年首次重大更新，推出三大首创功能，视频跟拍、歌词字幕、一键美型， [4]  并打通QQ音乐千万正版曲库，进行全面的品牌及产品升级。增加歌词字幕玩法，用户在选择背景音乐之后，录制视频时可选择显示歌词字幕，实现轻松跟唱。 [5]<br>2019年1月，微视在春节期间推出视频红包的创新玩法，从2月4日（除夕）00:00至2月6日（大年初一）24:00，共有7809万个视频红包在微信、QQ和微视里被领取。 [6-7]<br>2019年2月，微视上线测试个人视频红包玩法，用户可以通过微视制作视频红包，并且分享到微信和QQ，邀请好友领取。[8]<br>2019年4月，微视上线新版本，推出 “创造营助力”、“解锁技能”等全新模板。用户可通过微视的模板制作互动视频，并通过微信、QQ等社交平台分享给好友；好友可直接在微信、QQ里浏览该互动视频，并进行互动操作 [9]<br>2019年6月，微视开启了 30 秒朋友圈视频能力内测。用户在微视发布界面勾选“同步到朋友圈（最长可发布30秒）”按钮，即可将最长30秒的视频同步到朋友圈。<br>从上面的推广流程上看，腾讯也是大力扶持，花费了很多心思，可是还是晚了一点。<br>争夺大战中，规则有三点。<br>1、内容为王，多元全面，但垂直领域又足够精准优质。<br>2、创新为源，玩法新、巧、稀缺、有特色。<br>3、天时、地利、人和。</p>
<h2 id="打磨垂直内容"><a href="#打磨垂直内容" class="headerlink" title="打磨垂直内容"></a>打磨垂直内容</h2><p>现在各大视频主打娱乐、搞笑、影视、资讯，内容同质化严重。</p>
<p>很多内容型产品没有品牌意识，仍处于早期的用户和内容原始积累阶段，因此被克隆后并没有反抗能力。</p>
<p>产品是躯干、内容是血肉，需要产品本身的调性和机制去调节。总的来说、突出明确定位、品牌特色、</p>
<p>突出差异性和稀缺性，就是让用户只能来我们这看，别的地方没有，仅此一家！</p>
<p>其他APP比较泛滥，拿视频号说说我的看法。我认为主攻一下几点。</p>
<p><strong>视频号的垂直化领域区分：</strong><br>1.<strong>基于哲学</strong>：一个基于特定文化或者主题来交流、互动并持续产生内容的空间，简称“同好互动空间”。<br>弱关系社区中，关键是你对和你建立联系的事物，是否产生了感应。比如点赞、评论、分享等互动操作。<br>类比视频版的知乎，缩略般的B站、去中心化版的微博。<br>意义：<br>一部基于物的生活知识的百科全书（好物推荐、种草合集、生活小常识）、一部基于人的经验分享和情感解惑（关乎学习、职场、恋爱）。<br>2.<strong>基于个人</strong>：记录自己，记录世界，记录自己与世界的联系。重要的是减小朋友圈发文的人设压力，在陌生人关系中大胆释放自己。<br>意义：<br>记下生活的灵感和感动，类比个人精炼的成长日记，关乎生活的辛酸苦辣，关乎个人成长历程、心路轨迹。<br>（游戏规则是带有个人简介，我们要清晰自己的定位，也是帮助我们找到自己的差异化优势和稀缺性特质）<br>3.<strong>基于品牌</strong>：记录中小型企业生产品牌的流程，全程拍摄品牌打造、精雕细琢的细节，传达企业的真诚和品牌的优质，让用户亲眼可见、增强对企业的关注度、对品牌的认知度。比如现有的内测的钻石、服装、无人机产业。<br>意义：<br>对于品牌，打通公众号宣传、小程序直播、实现商业化变现的通道。<br>对于用户，真实、快速、立体、全面感知产品的差异化优势，丰富知识面，扩展视野格局，更方便更快速买到更放心的优质产品。<br>4.<strong>基于媒体</strong>：记录时事热点、媒体资讯、关乎天下大事、家国情怀。<br>意义：<br>为社会热点留白，等待时机造势，当媒体活动宣发时，这是很好的流量入口 。<br>（说不定下一个微信红包的热点降临、健康码、出行公交码的热潮会借助视频号来引爆支付产业瓜分半壁江山)。</p>
<h2 id="完善监管激励"><a href="#完善监管激励" class="headerlink" title="完善监管激励"></a>完善监管激励</h2><p>社区监管和激励体系是为了引导内容生产者不去产出同质化内容。</p>
<p>1、<strong>激励是赏</strong>、对创作者的原创内容进行精神鼓励和物质奖励，精神鼓励来自朋友和陌生人的关注、点赞、评论，人都有攀比心和虚荣心，精神奖励甚至超乎了物质奖励。</p>
<p>2、物质奖励来自更多特权和升级，助力创作者升级，当粉丝达到一定数量赋予特权、平台给予更多推送机会、曝光率、传播量、扩大个人影响力。</p>
<p>3、对创作者本人来说，以上措施激发更多创造。对同行业的人来说鼓励原创、激发新鲜点子，类似学校里面的年级排名、职场中的评级等等，都是为了激励同行业的人去打开自己的创造源泉，拿出自己的绝活，拉开和同行人的差距，这样就发挥了每一个个体的创造力和想象力，我们平台方，只需要做好舞台背景、打好灯光，让人们去尽情表演吧，相信大众的创造力和想象力，这是一套完整的闭环法则。</p>
<p>4、<strong>监管是控</strong>，禁止同质内容、加大剽窃账号的惩罚力度，打击平台内侵犯版权的行为，对疑似剽窃的账号封禁、减少曝光机会、降低推送频率、降低等级。</p>
<p>5、禁止使用虚假的信息创建帐号、故意误导他人、干扰真实的平台数据以及其他弄虚作假的行为，保障平台每一个用户的核心利益。</p>
<p>6、<strong>鼓励原创</strong>，提倡分享优质的内容信息，向广大自媒体作者普及版权意识，要求内容不能是旧文、或者全网已有的传播的同质内容。</p>
<p>7、<strong>净化环境。</strong>不允许传播对他人有害、令人极度不适、不利于青少年身心健康等不良信息。禁止传播侵扰用户安宁、造成用户使用体验减损或者影响软件正常使用和运行的内容。</p>
<p>如频繁发送骚扰信息、垃圾信息、广告信息，过度营销或商业推广。</p>
<h2 id="优化创新服务"><a href="#优化创新服务" class="headerlink" title="优化创新服务"></a>优化创新服务</h2><p>用户体验包含了内容和形式。</p>
<p>例子：知乎主打问答模式、简书注重创作形式、爱奇艺推出5G  VR  360度旋转体验。</p>
<p>从内容和形式这两个维度入手，打造更有特色的体验才能塑造好产品的风格、调性、差异性，优化品牌意识。</p>
<p>具体可以从结构层的信息架构、框架层的信息设计、表现层的视觉设计入手。</p>
<p>以下是我的三点想法：</p>
<p>1、<strong>载体上</strong>：找到合适的形式。比如文字、图片、语言、视频，各种形式可以主打或者组合。</p>
<p>比如“得到”推荐音频、B站长视频、视频号一分钟短视频、知乎文字、朋友圈图文。</p>
<p>2、<strong>分发上：</strong>确定算法推荐、热点搜索、个性化推荐还是主动订阅。这个比较复杂，以后专门谈。</p>
<p>3、<strong>互动形式上</strong>：深挖用户场景和习惯，不一样的互动形式会打造不同使用体验。</p>
<p>比如：快手双击666，新浪微博站内转载、视频号折叠评论等等。</p>
<p>4、<strong>播放形式上</strong>：瀑布流怎么布局，全屏还是小屏、评论是否隐藏、5G  VR怎么利用。</p>
<p>比如：</p>
<p>快手双列信息流，因为算法推荐更关注了长尾小号，所以怕用户不喜欢，分发不精准，采用双列让用户多了选择，减小平台的分发误判率。</p>
<p>抖音全屏体验，因为算法精准，平台分发定位准确，误判率小，所以不用担心用户不喜欢当前视频，主打观看体验。</p>
<p>视频号：中间区域播放，不支持暂停，分割视频区域和评论区域，既可以评论互动又可以专注看视频。</p>
<p><strong>为什么不能暂停播放？</strong></p>
<p>1、<strong>从产品调性思考</strong>：因为内容短、精致、所以一分一秒都有干货，提醒用户节奏慢下来细细品味，提倡慢文化，与倍速对比，打造不同观看体验，也算是一个差异化特色。</p>
<p>2、<strong>从用户角度思考</strong>：若用户可以看完，说明他是感兴趣的，下次可以继续关注此类视频的动态，基于主动订阅的，用户有兴趣，所以不会影响体验，不会反感内容。假如不喜欢此类视频，可以取消关注，下次不再推送，所以更加精准了，很巧妙的办法。</p>
<p>3、<strong>从创作者思考</strong>：每一分每一秒都要高品质，否则用户取消关注，自己粉丝骤减，得不偿失。</p>
<p>4、<strong>从平台思考</strong>：无为而治，“看不见的手”，非常高明，让双方相互监管激励，可以说设计思维很缜密，很精心。</p>
<p>5、能不能结合VR打造立体观看体验呢？</p>
<p>6、横屏竖屏怎么设计？</p>
<p>7、基于中国人的生活规律和习惯，能否不同时间推荐不同视频？</p>
<p>“同城”和“附近的人”都是从空间角度思考，我们是不是可以从时间角度入手？</p>
<p>比如早上音乐类、中午美食类、晚上新闻资讯、职场干货类 。</p>
<p>以上是个人深入思考的想法，绞尽脑汁了，很喜欢头脑风暴，若有不足或疑虑，请大家多多交流指教。</p>
<p>视频号，<strong>未来可期，万物之上，希望至美！</strong></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E7%9F%AD%E8%A7%86%E9%A2%91%E6%80%8E%E4%B9%88%E5%81%9A/" rel="tag">短视频怎么做?</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E8%A7%86%E9%A2%91%E5%8F%B7%E6%80%9D%E8%80%83/" rel="tag">视频号思考</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-视频号—— 一部2020下凡人间的动态史记" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/04/02/%E8%A7%86%E9%A2%91%E5%8F%B7%E2%80%94%E2%80%94%20%E4%B8%80%E9%83%A82020%E4%B8%8B%E5%87%A1%E4%BA%BA%E9%97%B4%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%B2%E8%AE%B0/"
    >视频号——一部2020下凡人间的动态史记</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/04/02/%E8%A7%86%E9%A2%91%E5%8F%B7%E2%80%94%E2%80%94%20%E4%B8%80%E9%83%A82020%E4%B8%8B%E5%87%A1%E4%BA%BA%E9%97%B4%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%B2%E8%AE%B0/" class="article-date">
  <time datetime="2020-04-01T16:00:00.000Z" itemprop="datePublished">2020-04-02</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="categories/%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E8%A7%86%E9%A2%91%E5%8F%B7/">我眼中的视频号</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<blockquote>
<p>我一直由衷地崇拜张小龙老师，他是一片星辰大海，神圣而神秘。<br>这位华科电信系的“学长前辈”把善良、真理想到了极致，把简单、纯粹做到了极致。<br>他是上帝派落到凡间的天使，剖析犀利的视角，出谋划策、牵动宇宙。<br>他是时光洪流的掌舵人，引领标新立异的潮流，深挖特立独行的思考。<br>他是纷繁世态的独行侠，心怀普惠众生的悲悯，救济着每一个孤独的灵魂。<br>张小龙，传承中国龙人的基因、一颦一簇、一举一动、推动着时代的奇迹。</p>
</blockquote>
<h2 id="一、关于微信的个人思考"><a href="#一、关于微信的个人思考" class="headerlink" title="一、关于微信的个人思考"></a>一、关于微信的个人思考</h2><p>高山仰止,景行行止,虽不能至,心向往之。我知道，张小龙老师一直在路上思考，他的高度，我们无法抵达。<br>这篇文章构思了很久，其中可能有不太成熟的想法，但都是我深入思考的结晶。<br>这些文字就当做管窥蠡测一下我眼中的微信和视频号吧，我坚信微信的力量，坚信视频号的能量。<br>我始终认为，微信是一个艺术品。微信基于普惠理念发展出了工具、简单自然等产品哲学。<br>产品最深入人心的部分是认知，认知甚至可以扭曲现实，微信从真正意义上讲，改变了一个时代人的生活方式。<br>微信最初是为了提高通讯效率的一个工具，切入口足够垂直细分，从而很好的保护了自己，这为日后发展壮大，强大的地基和丰富的生态做足了铺垫。<br>白色象征干净、纯粹、人的出生就是一张白纸，白色泡泡象征每一个富有个性的人（因为每个人的DNA是不同的，人是基因、环境、角色的产物。）<br>绿色泡泡象征大自然的生态，它和谐、环保、包容、真实、承载着每一条人与人、人与物、物与物的连接。绿色泡泡的体积是更大的，因为人类征服不了自然，人类应该是大自然的敬畏者，白云飘飘，绿水青山，简单的意境，清新的格调，微信传达的是遥远山谷的一缕回音。<br>这轻轻的一声，敲响了十亿人沉沉的关系链。<br>微信的开屏首页，是苍茫星球中个体对万物的思考。时间不可逆，所有人类命运体最终都会走向必然，都将流向同一条河流。命运宿命论虽然悲哀却很真实。地心引力带着神秘的磁场运转着渺小的独立个体，构成庞大的社交网络。<br>熟人关系的朋友圈是一轮五彩斑斓的小圆圈，亲密无间的每分每秒循环播放，构成一个个闭环的圆圈广场。<br>陌生人关系的视频号，像极了蝶舞联翩的大蝴蝶，带着强IP属性的点点滴滴，散部在茫茫的星辰大海。<br>一强一弱，横纵交织，并驾齐驱，对立统一，这是多么和谐美好的设计。<br>微信，从盘古开天地的蛮荒时代降临，经历夸父逐日的兴衰荣辱，无数个十年后，它将直通浩瀚星海的宇宙。<br>个人设计的slogan提议：<br>微信视频号：拒绝蹉跎度日，记录朝花夕拾，人间贵在真实，你我载入历史。<br>微信支付：如影随形，安全经营，绿色贴心，福利降临。<br>微信读书：生活不止粗茶淡饭的琐碎，还有云淡风轻的诗和远方。<br>小程序：便捷生活的万花筒，疑难杂症的万金油。<br>搜一搜：世界日新月异，评论针尖利弊，掌舵风云资讯，天地与你同行。<br>附近的人：经纬交错，田园脉络，不用陌陌，桃花朵朵。<br>微信：日活十亿，记录最真实的你。<br>祝愿腾讯大树四季常青，蓬勃生长。<br>我眼中的产品：<br>你若盛开，清风自来；桃李不言，下自成蹊。<br>清风细雨，润物无声；上善若水，干净纯粹。<br>己所不欲，勿施于人；删繁就简，大智若愚。<br>从婴儿的视角观察，用哲人的大脑思考。<br>虚心求教，Stay  hungry，Stay  young。<br>从实践中总结的方法论：乔布斯Apple法则：<br>ambition–accumulation–persistence–prediction–learn–link–estimation–evaluation</p>
<h2 id="二、初识宇宙新物种——视频号大驾光临"><a href="#二、初识宇宙新物种——视频号大驾光临" class="headerlink" title="二、初识宇宙新物种——视频号大驾光临"></a>二、初识宇宙新物种——视频号大驾光临</h2><p><strong>产品定位：</strong><br>1、视频号定位于“<strong>人人皆可创作的平台</strong>”<br>2、微信作为一个基础的信息传递的工具或者说平台，任何一个不经意的动作，可能会引起信息洪流流向的变化。<br>3、微信的价值观是“再小的个体，也有自己的品牌”。<br>4、视频号是为了弥补当年短内容的失误。<br>5、微信是一个开放的平台，致力于提供给用户有价值的服务，来搭建一个动态的生态系统，从而消除中介、消除地理限制。<br>6、我们希望建造一个森林，而不是一座宫殿，而所有这一切实现的前提就是用户价值第一。<br><strong>表层现象</strong><br>1.仔细想想，我们是不是习惯了在朋友圈虚构好自己的人设？我们P图，精修，记录点滴美好，它是熟人社交中一张光鲜亮丽的名片，代表着我们的身份、地位和人设。<br>2.我们不敢轻易点赞，点在看，因为我们幻想着别人对我们的看法，“好看”文章的属性似乎反应了我们朋友圈人设的认知观，于是，我们变得小心翼翼了，害怕亲密的朋友发现了我们细腻的小心思，害怕隐私被揭开，害怕人设坍塌，形象受损，这一切的根源都是隐私风险和信任背书。不过，要知道任何表层需求上的驱动，剖析到底还是人性底层的驱动。<br><strong>深层需求分析：</strong><br>1.人作为一个社交动物，生而社交，但面对着如今充斥着焦虑和压力的社会，每个人都在极力逃避着那一颗社交压力的尘埃。<br>2.相对于社交产品或者IM工具的社交压力来说，陌生人社区产品逐渐成为了现代人缓解压力、寻找同好并获得兴趣满足的窗口。<br>3.根本渊源就是：马斯洛常说的，人性最底层的社交、尊重和自我实现的需求。<br><strong>人性角度：</strong><br>人性是两面的，一方面，我们贪婪，懒惰，迷恋舒适和稳定，基础物质的快乐来自规避风险，逃离现实。<br>另一方面，我们又渴望他人的赞赏和认可，为了荣誉和奖赏，我们诚惶诚恐，殚精竭虑，迫切打破舒适圈，刷新认知，走向新的台阶展现自己。<br><strong>精神层面：</strong><br>世界日新月异，如果不分年龄、性别、角色、人类最本质的需求是什么？<br>我认为，是恐惧。<br>世界太快了，它加速旋转，日夜不息，我们忙碌地从一座围城跳到另一座围城。<br>年轻时我们没有家室之累，无所畏惧，因为一无所有，所以能慷慨地舍弃一切。但我们恐惧被新鲜事物抛弃。到了中年，我们肩负老小，为谋生繁衍，奔波忙碌，劳耕累耘。我们恐惧贫穷、家庭破裂、事业风险。终于奋斗了很久，我们老了，然后被迫恐惧疾病和孤独。<br>总之，我们害怕自我更新的速度小于社会发展的速度，害怕被时代抛弃，害怕失去核心竞争力，于是我们产生了焦虑和恐惧 ，进而衍生了深层次的需求。它凌驾于安全、生理、社交、渴望被尊重、直接蹭升到自我实现的需求。<br><strong>现实层面：</strong><br>罗曼罗兰说：世界上只有一种英雄主义，那就是看清了生活的真相，但依然热爱它。<br>鲁迅说：真正的勇士敢于直面惨淡的人生，敢于正视淋漓的鲜血。<br>没错，人生本质上是不美好的，苦难是生命的常态，但我们依然可以在这个星球上猩猩相惜，肆意生长。<br>真正让我们快乐的，是克服重重险阻之后的喜悦，是破圈带给我们的蜕变。<br>基于上述人性角度的分析，人最珍贵的是清楚的认识自己，坦诚的记录自己，接受生活的真相和真实的自己，认清形势、珍惜当下。<br>所以，成长的酸甜苦辣，破圈的兴衰荣辱，都需要这样一个没有创作压力的平台。<br>以铜为镜，可以正衣冠；以史为镜，可以知兴替；以人为镜，可以知得失。<br>简单说，它就是一面干净的镜子，一把简单的工具，记录自己，记录世界，记录自己和世界的联系。它真实、便捷、随时可拍、触手可及。<br>对于每一个人来说，它好像我们的移动日记本，随时随地用视频记录自己的灵感和思考。从上帝视角观察，视频号就是一个个鲜活人物在茫茫星辰大海中一生的足迹呀，历史风云变幻，时代沧桑变迁，时代的巨轮承载了一代代人平凡又伟大的冒险，一代代鲜活的生命在这里上演人间的茶米油盐、爱恨情仇、辛酸苦辣、兴衰荣辱、这是一件多么美好、多少真实、多少有意义的流动数字资产啊！<br>我承认，这世上有数不完的艰辛、苦楚、失败与遗憾；总有平凡的人儿们喝着醍醐灌顶的烈酒，唱着声嘶力竭的热歌；偌大的星球上，形形色色，各行各业的人们穿梭在不同的轨道，企盼着平衡、探索着真理、追寻着真爱、万有引力很强大，生存法则很残酷，奋然前行，需要每一个平凡个体的勇气和信心！<br>肉体或精神的折磨，或许才是成熟的淬炼、成长的真相。<br>即使我们都是无名之辈，那又怎么样呢？世界很大，苦痛很大，但我们依然企盼着希望，带着茕茕孑立的孤独和猩猩相惜的点赞。<br>即使我们渺小如蝼蚁，那又如何呢？庞大的社交网络上，我们点头触碰，为千千万万平凡真实的VLOG热泪盈眶，为时空交错下心怀一致的赤诚与朝圣而欢呼雀跃！<br>多少年之后，我们的子孙后代，依然可以翻阅到我们的点点滴滴，它可能是简单平凡的日常琐事，也可能是阳春白雪的鸿篇巨著，但他们，都是我们曾经一分钟的感动啊，春夏秋冬，我们都曾真实记录过，年岁轮回，我们都曾认真体验过。<br>很多年之后，它们像罗马时代的墓碑一样，隐秘而神圣，这个大大的平台，跨越了岁月的交替和时空的变迁，多么伟大，多么难得。</p>
<p><strong>视频号的诞生原因：</strong><br><strong>行业背景：</strong><br>1.短视频产品在用户量和用户使用时长上的飞速增长。<br>2.弥补腾讯系在短视频领域的缺失，借助私域流量+公域流量弥补微视的遗憾。<br>虽然公众号本身，已是一个完整的内容生态，但其也存在明显的缺陷，它的属性，会带来一连串的诺米骨牌效应：<br><strong>强订阅关系—&gt;被动获取能力的缺失—&gt;低创作门槛的缺失—&gt;移动化创作方式的缺失—&gt;长尾内容的缺失—&gt;非人人可以创作的平台。</strong><br>因此，要依靠更大陌生人社交圈子的短视频，导流到公众号。<br>鼓励<strong>长尾作者</strong>去发挥创造力，提供视频号引流带来粉丝积淀和回馈变现，让有价值的服务普惠众生。<br>3、微信的理念其实是普惠，它重视的是人人都可用，而不是某个特定的群体。短视频降低了创作门槛，鼓励人人可创造有价值的内容。<br><strong>一句话定位视频号对微信生态的巨大意义：</strong><br>1.微信的破圈——长短互补，强弱交织，蝴蝶效应，生态闭环——避免微信不被新生的短视频文化需求边缘化。<br>2.唯一可以实现去中心化的、并且借助微信熟人社交链来打造电商基因 、金融科技、 闭环支付的短内容平台。<br><img src="https://img-blog.csdnimg.cn/20200402045437941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>视频号的分解单元</strong><br>基于特定文化或者主题来交流互动并持续产生内容的小标签话题<br><strong>视频号的整体框架：</strong><br>横向内容优质多元、百花齐放，兼顾高质量和正能量，垂直化领域足够深入，IP定位属性精准的陌生人社交网络<br><strong>与朋友圈相比，视频号的特点：</strong><br>1.位置于二级入口朋友圈下层，并驾齐驱，可见地址很重要！<br>2.打破熟人关系链，将交流的平台扩大到陌生人的领域。<br>3.实现强关系社交的转换，打开弱关系社交的大圈。<br>4.将微信的私域流量扩大到公域流量，完成微信生态的扩容。<br>5.降低创造长内容公众号的门槛，实现便捷、迅速记录当下生活点滴的机会。<br>6.打破过于隐秘的私人社交小圈，搭建社区大圈，增加模块的主题性、内容性、互动性。<br><strong>视频号的垂直化领域区分：</strong><br>1.<strong>基于哲学</strong>：一个基于特定文化或者主题来交流、互动并持续产生内容的空间，简称“同好互动空间”。<br>弱关系社区中，关键是你对和你建立联系的事物，是否产生了感应。比如点赞、评论、分享等互动操作。<br>类比视频版的知乎，缩略般的B站、去中心化版的微博。<br>意义：<br>一部基于物的生活知识的百科全书（好物推荐、种草合集、生活小常识）、一部基于人的经验分享和情感解惑（关乎学习、职场、恋爱）。<br>2.<strong>基于个人</strong>：记录自己，记录世界，记录自己与世界的联系。重要的是减小朋友圈发文的人设压力，在陌生人关系中大胆释放自己。<br>意义：<br>记下生活的灵感和感动，类比个人精炼的成长日记，关乎生活的辛酸苦辣，关乎个人成长历程、心路轨迹。<br>（游戏规则是带有个人简介，我们要清晰自己的定位，也是帮助我们找到自己的差异化优势和稀缺性特质）<br>3.<strong>基于品牌</strong>：记录中小型企业生产品牌的流程，全程拍摄品牌打造、精雕细琢的细节，传达企业的真诚和品牌的优质，让用户亲眼可见、增强对企业的关注度、对品牌的认知度。比如现有的内测的钻石、服装、无人机产业。<br>意义：<br>对于品牌，打通公众号宣传、小程序直播、实现商业化变现的通道。<br>对于用户，真实、快速、立体、全面感知产品的差异化优势，丰富知识面，扩展视野格局，更方便更快速买到更放心的优质产品。<br>4.<strong>基于媒体</strong>：记录时事热点、媒体资讯、关乎天下大事、家国情怀。<br>意义：<br>为社会热点留白，等待时机造势，当媒体活动宣发时，这是很好的流量入口 。<br>（说不定下一个微信红包的热点降临、健康码、出行公交码的热潮会借助视频号来引爆支付产业瓜分半壁江山)。</p>
<h2 id="三、对视频号的多维创新思考"><a href="#三、对视频号的多维创新思考" class="headerlink" title="三、对视频号的多维创新思考"></a>三、对视频号的多维创新思考</h2><p><strong>1、宣传视频号的小创意</strong><br>slogan: 拒绝蹉跎度日，记录朝花夕拾，人间贵在真实，你我载入历史。<br>1.还在抖音刷视频虚度光阴吗？临渊羡鱼，不如退而结网，来视频号提升自己吧！人生还有更独特的诗意和远方！<br>2.还在快手看直播吗？你想要的，视频号都有！精挑细选，有你好看~<br>3.还在知乎海淘干货、面经吗？视频版的浓缩精华，视频号等你来分享~<br>4.还在B站倍速播放卡槽点吗？慢一点，让我们享受一分钟的干货精华。<br>5.还在微博海量信息中大海捞针吗？这里有专属优质小圈，用料考究，视听盛宴等你来哦~<br>6.这是一部修身、齐家、治国、平天下的短视频版《资治通鉴》！<br>7.我们终将老去，来视频号沉淀您的即刻视频！。<br>8.沉淀前世今生的数字资产！<br>9.时光一去不复返，视频号里转一转。<br>10.人要怎么度过这一生？<br>当他回首往事的时候，他不会因为虚度年华刷抖音而悔恨，也不会因为碌碌无为逛淘宝而羞耻；<br>这样，在临死的时候，他就能够说：“我的整个生命和全部回忆都已经献给世界上最壮丽的事业———在视频号和陌生的你相遇。<br><strong>2、用户获取分析</strong><br>在国内内容类产品的发展史中，有两个产品在用户获取方面是异常彪悍的。<br>1、移动互联网初始萌芽的今日头条，在早期还享有移动互联网用户红利的时候，用性价比超高的大规模推广手段（手机厂商预装应用等）获取了大量用户，为整个头条系的产品积累了丰富的用户启动资源。<br>2、只用了27个月就成功上市的趣头条，主要针对的是下沉市场人群，通过金币激励体系疯狂地获取用户，硬生生地在巨头林立的内容资讯类产品中占据了一席之地。<br>事实上，绝大多数内容类产品在获取用户方面都是一个非常大的难题，毕竟现在获取一个用户的流量成本非常之高，从早期的1.5-2元／个，变成了现在20-50元／个。<br>如果一个产品本身的变现能力不行的话，它其实是没有办法大规模、可持续地去获取用户的。<br>但对视频号而言，用户获取却是相对而言简单许多的事情，毕竟这是一款坐拥10亿日活的产品，开了二级菜单给视频号导流，怕也是绝大多数互联网产品望尘莫及的一个数量级。<br>目前微信的策略：<br>1、将视频号的位置放置在「发现」中，紧随「朋友圈」之后，可以借助熟人朋友圈实现破圈。<br>2、内测阶段，微信的每一步都要稳扎稳打。上线方案，一起头脑风暴，集思广益。<br><strong>3、内容生态构建——差异性、稀缺性——与长内容公众号互补引流</strong><br>对于平台：<br>（1）微信是一个巨大的生态系统，我们只要提供一个平台，最基本的道具和框架，就是最好的方式，不要局限大家的认知、眼界、格局。<br>（2）把舞台留出来，灯光打上，让观众们激发无限创意和想象，交给观众去创造吧，我们要相信十亿中国人的发明创造。<br>（3）内容监管审核：关键在于保真、优质、定位精准、独特、新鲜、激发情感共鸣。<br>（4）社区建设注重具体场景，基于弱关系链、推荐生活VLOG、新闻热点资讯、科普知识、个人经验干货。<br>（5）减少娱乐、搞笑、剧情、走高端路线，打造温情故事、家国情怀、中国文化。<br><strong>（6）关注00后、10后Z世代文化和老年人喜闻乐见的生活视频，这是目前比较稀缺的两块内容区域。</strong><br>（个人建议，有待数据分析考量，出于重点打造差异化、空白区域切入的思路）</p>
<p><strong>4、内容生产模式</strong><br>（1）UGC用户群体庞大、真实记录生活VLOG、个人号定位精准简介、帮助用户更好认识自己、记录自我、世界、自我与世界的情感联系。UGC里有我们承受生活的苦难后获得的生长，有看清生活的本质但依然热爱生活的勇气，有不加滤镜、真实鲜活的自我。<br>（2）PGC里有专业精致的干货，有利用有限时间创造无限价值的方法，内容足够垂直化，优质化，涵盖了正能量明星背后的奋斗故事、优质行业博主光环背后的辛酸、自媒体创作者对于人生的深刻思考、中小企业品牌创造的精致打磨。这类视频用户粘性高，变现能力也最强。<br>（3）PUGC：优势互补、取其精华、去其糟粕。</p>
<p><strong>5、内容分发——筛选优质精准内容、提升用户体验</strong><br>内容类产品／平台的一个共同特点：<br>（1）首先平台本身必须是一个好的工具型产品，可低门槛地提供体验良好的工具供普通用户创作内容使用。<br>（2）平台要有一个<strong>良好的机制</strong>可以从海量的内容中筛选出优质的内容供用户消费。（真的很想来实习，自己主动研究了推荐算法，不过张小龙老师说不太推荐，主攻社交推荐，可能两者结合？应该要数据分析来解答）<br>（3）用户要有好的成长体验，能真正帮助用户在这里察看人生百态，获取有用资讯，实现自我价值转化和成长。<br>目前主流的内容分发模式有三个：算法推荐、社交推荐、用户订阅。<br><strong>张小龙老师的经典看法：</strong><br>几年前，我说过一句话，“推送改变世界，因为用户更懒了”。包括微信，也是基于推送的。<br>你收到的每一条消息，都被你把优先级排得比你要真正获取的信息的优先级更高一些。<br>那么，推送什么信息，决定了用户会看什么信息，决定了他在一个什么样的世界里。<br>这是一个我们要经常思考的问题，也是我们在努力的方向。所以，我很少说分发这个词，我觉得推荐可能更尊重一些。<br>“我们并不认为一个规则百分百确定的系统就好，相反，一个动态的、自我完善规则能够让系统获得动态稳定，整个系统可能是我们和第三方一起定义出来的。<br><strong>头条：算法推荐：协调过滤、召回排序</strong><br>优点:  全屏体验、精准分发。<br>缺点：马太效应、头部集中、中心化严重、社交关系难沉淀。<br>快手：均分算法推荐和社交推荐，基于同城构建社交。<br>优点：部分去中心化，关注下沉市场，从用户细分打造差异化。<br>缺点：内容上有质量风险，导致品牌调性下降。<br>微信：未知，我猜想通过<strong>用户自主关注、社交推荐、个性化推荐</strong>等多种方式，展示更丰富优质、用户更感兴趣的内容。<br>张小龙老师主张推荐，他主张技术的背后是人，更注重朋友之间的信任背书（比如微信读书）<br>优点：强社交属性、特有私域流量<br>我的一点小思考：<strong>快手有同城推荐，是基于地域的，我们可不可以基于时间域呢？给内容打标签，让算法在时间域上加一些权重分配？</strong><br>原理：中国人喜欢晚上看新闻、中午看娱乐缓解工作压力、英国人下午4点甜点喝茶、妈妈辈喜欢晚上广场舞、职场人喜欢晚上看看书<br><strong>从用户角度思考：</strong><br>1、视频号真好玩，不同时间知道我想做不同的事情，难道会读心术？<br>2、哎呀，六点了，视频号有没有我想看的新闻？<br>3、中午打开视频号，看看种草推荐吧，嘻嘻，视频号懂我。<br>4、晚上结束了一天的工作，来点鸡汤激励一下自己吧，我想看看视频号有没有牛人干货技巧分享。<br>5、我的好朋友最近在朋友圈分享了很多优质视频，我去看看吧，不然下次聚会就OUT啦。<br><strong>6、商业变现</strong><br>方式：广告、电商、直播、游戏、会员等等。<br>方式选择：是否贴合产品的使用和服务场景，平台自身的产品定位、用户属性。<br>优势：<br>1、公众号和短视频互相倒流。<br>2、发送到朋友圈或者朋友，通过分享来传播。<br>3、下一步可能打开小程序？<br>想象一下，视频号+公众号+小程序+微信群+朋友圈可能带来微信生态的大繁荣 。<br>张老师语录：<br>1、如果不慢慢来，只会使得第一波进来的人作为一个红利滥用它的流量。<br>2、作为流量红利来用的人并没有创造价值，对用户没有好处，还对平台造成损伤。<br><strong>自我思考：</strong><br>1、视频号目前打通小程序做商业化可能是不太好的，<strong>流量是用户信任的附属品</strong>，当我们初次将产品传给用户认知时，应该本着一切从用户出发的角度，视频号首先是一个真实记录生活的平台，产品的初次认知和定位很重要 。<br>2、商业化不让用户反感的前提是用户金钱付出的成本足够承担带给用户的价值，如果我们目前还做不到，那就慢慢打磨。<br>3、互联网时代争取的不应该是流量，而应该是信任，信任是互联网的稀缺资源。<br>4、注意力也是互联网的稀缺资源，当我们拥有了差异性和稀缺性，我们就拥有了良好稳健的生态和护城河。</p>
<h2 id="四、关于社区文化的思考：社区三基石（文化、角色、内容）"><a href="#四、关于社区文化的思考：社区三基石（文化、角色、内容）" class="headerlink" title="四、关于社区文化的思考：社区三基石（文化、角色、内容）"></a>四、关于社区文化的思考：社区三基石（文化、角色、内容）</h2><p>社区从社会学的角度来谈，本质上是一个社会群体组织单位。当个人进入群体之后，理性、独立、客观等个人意识会逐步地被弱化，藏在群体之中，无意识的情况之下，群体意识会逐渐占据着心智上的主导地位，这种群体意识即社区意识。<br>群体意识可以给社区带来更强的凝聚力、更强的归属感等积极意义，也可能使社区陷入混论、盲目和无序，因此需要通过社区文化来引导和管理社区意识。<br>由此可见，文化对于社区来说十分重要。所以要想打造一个好的社区，必须先要有一个好的且强有力的文化作支撑。<br><strong>底层闭环逻辑：</strong><br>1、社区的定位决定了社区的文化，而社区的文化影响着社区角色的行为以及它们所生产和消费的内容。<br>2、内容作为文化的载体吸引着认同社区文化的用户进入社区。<br>3、用户使用这个产品，愿意留在这个社区的前提是认同社区的文化和价值。<br><strong>收益（社交红利）=信息×关系链×互动</strong><br><strong>•信息像肉</strong><br><strong>•关系链似骨</strong><br><strong>•互动则像血液一样造成流动</strong><br>自我思考：<br>1、用户的社交帐号中，都有或多或少的好友，这就是对关系链的简单理解。<br>2、用户们的好友对于企业而言是弱关系，但对于用户自身则是强关系。<br>3、强弱之间的影响力截然不同，只有用户主动分享和推荐，信任依附在流动的信息之上，关系链的力量才会充分爆发。<br>4、“互动”（评论和转发）的发生本身取决于“信息”文案质量，以及用户好友数量多寡和紧密程度。<br>5、互动也是最简单、最直接的激励，推动有价值的信息在人群中口口相传流动开来，形成口碑效应和病毒式的传播。<br>6、这个公式也可以凝练成一句话：“让信息在关系链中流动”，或者“让人们讨论你”。<br>7、对于实操中的企业而言，谋求建立一套持续、稳定、有效的分享体系/文化，则是在这个理解上可以采取的策略。<br>换句话说，是从基础、从每个细节、环节、流程开始的优化，牢牢地和社交网络结合起来。<br>不管是“信息”“关系链”“互动”，都是构建这套体系的最基础构件。<br>在日常工作中，企业对“信息”“关系链”“互动”三个环节的不同分解与侧重，衍生出不同风格。<br>8、强调信息的企业与创业团队，以策划和活动见长；强调大号的价值，微博营销多云集于此。<br>实际上，这些着力点，都是致力于构建一套有别于社交平台之外的第三方付费分享体系。<br>9、朴素的情感（炫耀、爱心、利己利他等）是引发作用差别的根本因素。<br>热点事件因此而起，人们围观、参与令自己开心或愤怒的事情，也由此产生了许多无聊的“自娱现象”。<br>10、当信息纵横流动开来，会将一个个原本分割独立的社交网络连成整体，论坛与微博、微信、QQ空间，在某种意义上成为同一事物的不同映射。<br><strong>1、让团队来建立强有力的社区明文化</strong><br> 从字面意思很好理解，明文化这就是摆在台面上的，社区所倡导的文化和氛围。<br>通常大家都认为明文化是由社区运营人员通过白纸黑字的形式来制定一套符合社区文化的行为规范而建立起来的，例如什么社区公告、圈子规范等。其实并不是这么简单，包括UI风格、活动专题、推荐机制等等都是在想用户传递社区的文化、价值和底线，明文化是由团队的每个人一同打造的。<br>明文化就如同社区里的法律一般，所有社区成员的言行举止都要受到明文化的约束，不遵守甚至使违规就会收到惩罚，它确保了社区机制的正常运行。<br><strong>2、让用户来养成社区的暗文化</strong><br> 如果说明文化是社区的法律，那么暗文化就是社区的道德。它是没有强制约束的，是社区群体意识下自主形成的产物，同时它也是一个社区是否充满活力的象征，也正是它的存在将社区成员和网络路人彻底隔绝开来。<br>互联网上古时期D吧的屌丝文化、或者是最近几年兴起的B站的弹幕文化等等这些都是暗文化的代表，当然暗文化最直白最浅显最具体的表现就是社区黑话，比如一星护体、刚下飞机、下次一定之类的，懂得就是社区人，不懂就是社会人。<br>所以成功的社区，光有明文化是不够的，还需要重视暗文化的养成。但是暗文化不像是明文化那样可以在一朝一夕建立起来的，而是需要运营小伙伴持续地经营，通过头部用户去示范去引导去带动，在潜移默化中慢慢建立起来。<br><strong>2、角色</strong><br>角色的内核实际上就是社区的用户，是社区组织下最小的有机单位。<br>在群体意识和社区文化的作用下，用户会无意识地陷入角色化，而社区角色化最重要的意义就是让用户之间自主地产生协同分工，来维持社区的正常运作和活力。<br>一个成熟的社区里不可能只有一种角色，角色越多恰恰是证明社区分工越为成熟。<br>为生产者提供工具，为消费者提供内容<br>内容生产者和内容消费者其实是一个社区众多角色中抽象出来最简单的两个角色。<br>顾名思义，内容生产者就是在社区里生产内容的用户，他们通过生产内容进行自我展示，得到其他用户的反馈，获得尊重和自我价值的实现，甚至可以获得实质的收益；<br>而内容消费者则是大多数普通用户，通过消费社区里的内容，来满足自己的需求，获取价值。当然两者之间可不是一分为二的绝对划分，会有一定的重合，正是两者之间的互动，使得社区焕发出活力。<br>对于内容生产者，要要尽可能降低他们内容生产的门槛，提供便利的内容创作的工具，让他们可以更加快捷地进行内容创作；<br>对于内容消费者，首先通过算法推荐或者社交推荐，将感兴趣的内容展示给他们，其次是通过内容的整合和分发，保证他们内容消费的连贯性，最后就是要注重他们内容消费的体验。<br><strong>注重KOL，更要注重KOC</strong><br>决定一个社区能够走多快的是它的KOL，但决定一个社区能走多远的是它的KOC。<br>对于任何社区来说，KOL的重要性都不言而喻，尤其是在社区的启动阶段，KOL可以在短期内为社区带来一大批忠实的流量，即便是社区的成熟期，KOL也可以稳定住社区流量的基本盘。<br>但是太过于依赖KOL，很容易造成社区被KOL所裹挟的局面，包括我自己负责的产品里也有前车之鉴。社区与KOL的两方博弈最终受伤的还是社区，而KOC这些腰部用户却是一股第三力量，有助于打破这种“零和博弈”的局面。KOC对于社区来说，首先它的基数大，其次它的潜力大，最关键的是在于社区的博弈中，KOC属于一种弱势，欠搭把手的状态，社区会有更多的话语权。<br>社区加上KOC自然要大于KOL。所以一个健康且成功的社区里，服务好KOL大佬的同时，需要把更多的帮助给予到KOC的成长之路中去。<br><strong>打造角色等级体系的上升通道</strong><br>上瘾模型中说，用户对于一款产品上瘾基本分为“触发-行动-赏酬-投入”四个步骤。从中可以看出，如果想让用户对社区进行脑力和体力的投入之前，需要让他们获得多变的赏酬，而角色等级体系或者特权体系就是一种最常见的精神赏酬方式。</p>
<p>不论是内容生产者还是内容消费者，只要是做出符合社区价值的行为，就可以获得对应的虚拟收益，虚拟收益可以累计成对应等级，让角色之间自然而然的出现等级差异，这样促使他们相互进行攀比、炫耀，去持续创造符合社区价值的内容，这对于社区的发展是非常有必要的。</p>
<p><strong>3、内容</strong><br>内容毫无疑问的是社区最重要的资产。有句话说“花钱是门学问”，同样的花好内容资产对于任何一个社区都是一门学问。<br><strong>没有时效性的内容最珍贵</strong><br>热点内容在短期内会对社区带来巨大的瞬时流量，但是具有时效性的命门，也让他的价值会随着时间推移很快就流失掉。<br>经常混迹不同社区的话，你会发现很多让你感慨“‘大清亡了”的内容，仍然对于比你年纪小的用户群体们充满着吸引力，有着不错的阅读量和互动量。<br>对于没有时效性要求的、非资讯类的社区而言，没有时效性的内容经得起沉淀，也更显珍贵。<br><strong>做好内容分层，明确内容主体</strong><br>对于任何一个内容而言，它都是有层次的，我们不能一概而论。举个例子，我发了一个动态，这就是这个动态的一级内容，那么有人评论了我，这就属于二级内容了，接着又有人回复了这条评论，这就属于这条动态的三级内容了。就这么简单地划分了三级内容，但要说明的一点就是不是每个社区都有三级内容，也不是每个社区只有这三级内容。<br>最关键的是不同的社区对于内容侧重的层级也可能是不一样的，这就产生了他们的内容特点，例如最右注重的是二级内容也就是常说的神论，而小红书的核心内容是它的一级内容。<br>所以在积累社区内容之前，我们必须要明确我们社区内容的主体在哪。<br><strong>内容生产需要看不见的手</strong><br>如果说内容生产者（侧重用户部分）是内容生产看得见的手，那么平台侧的内容生产就是那只看不见的手，特别是社区发展的初期，这只看不见的手尤为重要。<br>发挥平台的力量，主要有三种方式：</p>
<p>①内容搬运</p>
<p>社区从0到1，真的不是缺人，而是缺内容。社区的逻辑就是内容为王，只要有了内容，就一定可以找到消费你内容的用户，然后再分化出再创作内容的用户。</p>
<p>但是没有内容呢？那就得靠平台通过爬虫也好，人工也罢，去从外站搬运符合社区文化的内容过来完成内容资本的原始积累。像是最右，70%以上的内容都是官方或者用户进行搬运的。</p>
<p>②官方生产</p>
<p>官方生产的内容就其数量而言，相比于搬运的内容一定是少之又少的，主要是对于搬运内容的一个有效补充，但是就其内容价值而言，那就可能远高于搬运内容。</p>
<p>要注意的是，官方生产的内容不一定是要用官方账号去发表，更多地通过普通用户账号去发表，具有真实性、原创性、优质性，打造社区核心内容。</p>
<p>③活动引导</p>
<p>平台通过活动来引导、征集用户原创内容，这也是一个比较常见的社区内容生产方式。</p>
<p><strong>内容筛选“取精华弃糟粕”</strong><br>好了，基础的内容有了，那我们面对“河量”或者海量的内容，就要进行到下一步筛选内容了。<br>筛选的过程大致分为三个步骤：<br>首先可以通过机器过滤，把一些涉及到违法、色情、有害的内容过滤掉；<br>接着就是需要把不符合我们社区文化和价值的内容刨除掉；<br>最后就是要在剩余的内容里，通过智能算法或者人工筛选，把优质内容和普通内容区分开来分发，因此它们将会得到不同的流量灌溉。</p>
<p><strong>找到适合的节点去综合分发内容</strong><br>社区的内容分发要结合自身的特点，找到并设置合理的节点进行有效的内容分发，常见的节点有用户节点、关系节点、话题节点等等。<br>比如说你在外卖平台经常点炸鸡，就会给你推很多炸鸡的店铺，这就是基于用户行为的内容分发。再比如你关注了A，A点赞了某个内容，就将这个内容也推给你，这就是基于用户关系的分发。这里由于篇幅的关系也不展开来讲了。<br>除了分发的节点外，按照分发机制来划分的话，市面上最常见的就是算法分发和社交分发这两种。算法分发的好处不必多说，可能比你自己更了解自己，但坏处就是很容易形成信息茧房，而社交推荐因为基于社交关系，你和你的朋友之间的偏好有一定的差异，所以会让你看到很多新的差异化的内容，但弊端就是让你觉得推荐的不精准。<br>所以综合之下，算法分发与社交分发相结合，找到适合社区信息架构的节点去进行有效的内容分发是关键。</p>
<p><strong>根据内容价值进行合理排序</strong><br>内容排序的前提是内容价值的判断，通过价值来进行展示上的排序，就跟产品需求排优先级一样，价值越高越靠前。而社区内容的价值判断往往是基于用户的互动行为，比如说微博的转评赞，B站的一键三连，这都是基于用户行为对内容的价值和热度进行评判。<br>但是也不能只把价值高的放在前面，这样容易导致社区内容的马太效应严重，打击中小内容生产者的积极性，所以一般的内容排序规则是多个维度穿插在一起的，以此来降低单一维度的权重，实现一种合理排序。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E8%A7%86%E9%A2%91%E5%8F%B7/" rel="tag">视频号</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-做好视频号的三点建议" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/04/02/%E5%81%9A%E5%A5%BD%E8%A7%86%E9%A2%91%E5%8F%B7%E7%9A%84%E4%B8%89%E7%82%B9%E5%BB%BA%E8%AE%AE/"
    >做好视频号的三点建议</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/04/02/%E5%81%9A%E5%A5%BD%E8%A7%86%E9%A2%91%E5%8F%B7%E7%9A%84%E4%B8%89%E7%82%B9%E5%BB%BA%E8%AE%AE/" class="article-date">
  <time datetime="2020-04-01T16:00:00.000Z" itemprop="datePublished">2020-04-02</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="一、推荐算法上主攻空白区——增加时间维度"><a href="#一、推荐算法上主攻空白区——增加时间维度" class="headerlink" title="一、推荐算法上主攻空白区——增加时间维度"></a>一、推荐算法上主攻空白区——增加时间维度</h2><p>原因：快手中有一个同城模块，是利用了基于地域的空间差异性。<br>分析：现有的短视频推荐算法可以按照发布时间排序推荐，这是从发布者的角度出发。<br>反思：能不能从<strong>用户者的角度出发？</strong><br>1、因为视频号足够短，信息浓缩度高，只要可以精准分发，<strong>就能戳中痛点快速帮助用户解析眼前问题。</strong><br>2、用户会把着当作碎片化时代的心理咨询师、贴心小帮手、<strong>微信本质是工具。</strong><br>3、用户心理：视频号真懂我，每时每刻和我同行，<strong>它是我的魔法师，懂猜心术，</strong>不让我沉迷娱乐浪费时间，它是在<strong>帮我随时随地解决需求、让我过好正能量的每一天，</strong>有了它，我生活更加方便、舒心了，<strong>抖音看再多，都是别人的狂欢，还是要回到现实生活调整好自己的节奏、用心打理自己的生活。</strong><br><strong>场景：用户在一天的不同时间场景下需求是不同的，我们只要一分钟，用高效优质内容帮您快速解决紧急需求！</strong><br>1、比如早上想听比较<strong>欢快的音乐、搞笑的闹钟铃声</strong>开启一天新生活。<br>2、从视频中选择优质、用户好友喜欢、或者用户曾经点赞的<strong>温情励志鸡汤类</strong>的一分钟短视频，激发用户开启努力工作的每一天。<br>3、我们还可以选取关于<strong>早餐美食、早茶文化、日出、闹钟、出门穿搭、化妆干货经验</strong>的优质短视频。助力美美出门！<br>4、到了十点左右，学生用户推荐<strong>学习加油站、学生广播体操、课间文化、智力游戏、学习标兵PK</strong>视频。点燃学习激情。<br>5、十点职场达人：外卖最新单品种草分享帮助您优化午餐选择、工作日程管理干货祝您解决业务难题、只要一分钟，可能给您带来意想不到的优质体验。<br>6、午饭时间：农民伯伯种田视频、舌尖上的中国、美食点评、优质吃播（为了传播中国饮食文化而不是空洞的表演）。<br>7、下午四点：英国人喜欢下午茶，可以推荐一些缓解压力的风景短片、主要为了调节工作气氛，帮助用户更好的复盘一天的工作。<br>8、晚饭时间：家人其乐融融的场景短片，万家灯火的车水马龙，给用户一种要回家的归属感。<br>9、7点：中国人的标配：准时新闻联播，通过短视频一分钟提炼，可以快速获取最新资讯和点评。<br>10、睡眠：轻音乐、书评、助力生活解惑，关注内心成长，因为人们喜欢在安静的夜晚深入思考，白天过于喧嚣。<br><strong>预想结果：<br>   消费者层面：</strong><br>1、视频号真懂我，每时每刻和我同行，<strong>它是我的魔法师，懂猜心术，</strong>不让我沉迷娱乐浪费时间，它是在<strong>帮我随时随地解决需求、让我过好正能量的每一天。<br>2、</strong>有了它，我生活更加方便、舒心了，<strong>抖音看再多，都是别人的狂欢，还是要回到现实生活调整好自己的节奏、用心打理自己的生活。</strong><br><strong>生产者层面：</strong><br>1、我的粉丝<strong>每时每刻都需要我</strong>，<strong>因为他们在和我相同的时间维度上</strong> ，明天我的粉丝在讨论什么新鲜话题呢？我主打中国饮食，要时常更新才能让粉丝<strong>每一天都可以在固定的时间和我见面呀</strong>，虽然我们是粉丝弱关系，但是我每天都要和朋友们约会，作为饮食达人，我要努力打磨自己的视频号。<br>2、时间是不可逆的，珍惜时间，努力做出好产品。<br><strong>平台层面的战术考量：</strong><br>1、我们的初心是为了提升用户体验，和其他短视频拉开差距的，虽然其他短视频每天都是推送用户感兴趣的话题，但是它们只是内容上切分，没有从时间维度考虑，但是，<strong>短视频的体验效果和时间场景是有很大联系的！</strong><br>2、用户来看这个视频，其他平台是无聊打发时间，图个乐子，一天之内啥时候看都行，每天看不看无所谓，看心情咯，今天工作忙就不娱乐了。<br>3、用户来视频号，不仅仅是为了娱乐，更是为了多和陌生人互动，我为什么要天天来看呢？<br>  <strong>因为它很短，但是很有料<br>  能根据每天的不同时间点给我推荐不同类型的我感兴趣的话题<br>  很能帮助我快速解决不同时间和场景下的视频需求。<br>  视频号不是消磨我的时间，它是我的猜心小帮手，了解我现在想看啥，真有趣，还能根据早中晚区别我的想法，真智能。<br>  视频号不仅仅是别人的世界，这里也有我的生活思考和点滴记录<br>  打开视频号，看这热络鲜活的世界，最新鲜最懂我。</strong></p>
<p> <strong>差异化优势：</strong><br> 1、用户众多，相比抖音一二线，快手三四线、B站二次元、视频号是一个全中国人都在用的记录平台。<br> 2、<strong>每天定点推送我想要的视频 ：</strong>它就像个小闹钟，聪明精确的了解我每时每刻的需求和偏好，更智能更高效。抖音消磨我的时间，每时每刻都是同类型的视频，我想在不同时间尝鲜，晚上适合思考，白天适合娱乐，我是地道中国人！<br> 3、我的朋友、我的粉丝、我的偶像都在这里，<strong>真实简单，这是更接地气的社区平台</strong>，不仅可以和陌生人社交，还可以和同圈子的人交流，<strong>真是一呼百应，就像小蝴蝶，说不定一不小心，我闪动了小小的蝴蝶效应，改变了世界的认知呢</strong>，我要好好打磨作品，给世界留下点我的思考印记，<strong>这个平台传作简单、气氛又好，每时每刻都很热闹，我就粘在这里啦</strong>。<br> <strong>推荐方式机制</strong><br>1、按照内容发布时间倒序为主、点赞量、评论量、转发量和收藏量为辅的排序方式。<br>发布时间倒序：按照内容发布时间新旧排序，新发布的内容用户先看到；<br>点赞量、评论量、转发量和收藏量为辅：如果存在发布时间相同的内容，先按照用户点赞量递减排序；点赞量相同，按照评论量递减；评论量相同按照转发量递减；转发量相同按照收藏量递减。如果收藏量相同则按照后台获取的优先顺序排序。<br>2、做好内容池排序标签后，推送上按照一天24小时，分四段时间区域切分，在不同时间块，根据行为习惯，加入基于用户角度的时间权重。<br>3、其余权重采用人以类聚，物以群分的规则，划分关键词，提取特征向量，做双向维度匹配。<br>4、迭代用户历史记录行为和内容标签，优化算法方案。<br>5、列举上述4条的优先级排序，设置不同权重，然后按照由强及弱进行推荐。<br>6、做此类推荐首先需要有内容数据支撑和用户行为支撑作为冷启动。<br><strong>数据分析迭代：</strong><br>观察类型：<br>1、不同类型间的内容播放数据（平均浏览量环比前日增长）<br>可能原因分析：<br>有的类型是正增长，而较多类型处于负增长主要原因有两个：<br>A: 用户基数较小，探究的样本空间就相对较小，所以分化比较严重；<br>B:这段时间为内容创作适应阶段，需要长期对标用户，调整创作方案和创作类型。<br>2、用户次日留存，平均看视频时长、视频号板块使用时间。</p>
<h2 id="二、内容筛选上主攻垂直化——正向激励（知识性）、Z时代文化（趣味性）、新闻资讯（时效性）、中国文化（时空交错性"><a href="#二、内容筛选上主攻垂直化——正向激励（知识性）、Z时代文化（趣味性）、新闻资讯（时效性）、中国文化（时空交错性" class="headerlink" title="二、内容筛选上主攻垂直化——正向激励（知识性）、Z时代文化（趣味性）、新闻资讯（时效性）、中国文化（时空交错性)"></a>二、内容筛选上主攻垂直化——正向激励（知识性）、Z时代文化（趣味性）、新闻资讯（时效性）、中国文化（时空交错性)</h2><p>   创作者要清晰定位、优质输出。优秀，是会传染的，做好闭环激励，一切皆有可能。<br>   创作者需要根据的用户反馈，快速调整创作方案，再迅速投到产品中等待再次反馈最新的内容。<br>   强关系社区，更强调娱乐性、生活化分享以及存在区域性特征。<br>   弱关系社区，则更强调信息的价值、快捷，媒体属性更强。<br>   弱关系平台可能是我们展示自己的一个公平的舞台，你可以把才华在这里无障碍的表现出来。<br>   弱关系平台获得自己人生中的很多以前不会有的机会和认同。<br>   我个人认为，新浪微博这样的东西，更多的是要做自己的个人品牌。<br>   而对于强关系的社区来说，则要注意保护自己的隐私和形象，以免成为别人的谈资和笑柄，影响你在圈子内的形象。</p>
<p> <strong>1、基于哲学：</strong>一个基于特定文化或者主题来交流、互动并持续产生内容的空间，简称“同好互动空间”。<br>弱关系社区中，关键是你对和你建立联系的事物，是否产生了感应。比如点赞、评论、分享等互动操作。<br>类比视频版的知乎，缩略般的B站、去中心化版的微博。<br>意义：<br>一部基于物的生活知识的百科全书（好物推荐、种草合集、生活小常识）、一部基于人的经验分享和情感解惑（关乎学习、职场、恋爱）。<br>  2.<strong>基于个人</strong>：记录自己，记录世界，记录自己与世界的联系。重要的是减小朋友圈发文的人设压力，在陌生人关系中大胆释放自己。<br>意义：<br>我们只有不断地与各类人员进行交往和信息沟通，才能不断地丰富自己、发展自己、扩充自己。<br>记下生活的灵感和感动，类比个人精炼的成长日记，关乎生活的辛酸苦辣，关乎个人成长历程、心路轨迹。<br>（游戏规则是带有个人简介，我们要清晰自己的定位，也是帮助我们找到自己的差异化优势和稀缺性特质）<br>  3.<strong>基于品牌</strong>：记录中小型企业生产品牌的流程，全程拍摄品牌打造、精雕细琢的细节，传达企业的真诚和品牌的优质，让用户亲眼可见、增强对企业的关注度、对品牌的认知度。比如现有的内测的钻石、服装、无人机产业。<br>意义：<br>对于品牌，打通公众号宣传、小程序直播、实现商业化变现的通道。<br>对于用户，真实、快速、立体、全面感知产品的差异化优势，丰富知识面，扩展视野格局，更方便更快速买到更放心的优质产品。<br>  4.<strong>基于媒体</strong>：记录时事热点、媒体资讯、关乎天下大事、家国情怀。<br>意义：<br>为社会热点留白，等待时机造势，当媒体活动宣发时，这是很好的流量入口 。<br>（说不定下一个微信红包的热点降临、健康码、出行公交码的热潮会借助视频号来引爆支付产业瓜分半壁江山)。<br><strong>平台内容过滤机制：</strong><br>通过平台用户对内容打分，过滤出优质内容和劣质内容，将优质内容推送给其他更多用户，劣质内容则淘汰不在推送。<br>初步设想实现方式如下：<br>1、制定随机种子：内容随机推送给100个用户（数量根据平台用户规模和库内内容存量定），然后通过100个用户对内容的行为操作统计分数。<br>2、优劣判断：设定优劣分数判定标准，150分以上为优质。（每个平台不一样，根据用户规模、内容情况和历史数据判定）。<br>3、优质推送规则：100个随机用户完成打分后，将优质内容按照分数高低推送给其他用户，同时优质内容每天也会再次进行重计分和重排序。<br>4、打分规则：内容得分=是否分享<em>分数+是否关注</em>分数+是否评论<em>分数+是否点赞</em>分数+是否收藏<em>分数。<br>分数：指的是每个行为占比，这里，设定所有行为总分=10，其余各项分别=1；<br>这里没有考虑完播率：*</em>目前视频号不支持跳播，提倡慢文化，细细品味优质内容，个人认为设计很棒，有差异性。带来不一样的用户体验，要培养快餐文化下的细品习惯。**<br>功能上线后，保证优质内容持续产生；研究用户平均使用时长；研究用户留存情况；优化运营推广的方案。</p>
<h2 id="三、宣传产品的策略"><a href="#三、宣传产品的策略" class="headerlink" title="三、宣传产品的策略"></a>三、宣传产品的策略</h2><p>1、好的产品会说话，定位要精准、犀利、用户对产品的第一认知非常重要，产品最深入人心的是认知，认知可扭曲现实。<br>2、针对不同用户画像，深挖痛点、精准投放。<br>3、好的宣传，是真诚大于套路，但本质还是套路。<br>4、把精准的人设，通过合适的渠道，合适的时间，投放到合适的人群，参考直播策略 人、货、场的饥饿营销模式。</p>
<p><strong>1、宣传视频号的小创意</strong><br><strong>slogan: 拒绝蹉跎度日，记录朝花夕拾，人间贵在真实，你我载入历史。</strong><br>以上四句话对应区别抖音、鼓舞用户创造、产品定位、时代意义。<br>快抖是可乐，快感中少了营养，<strong>微信是青山悠悠，蝴蝶翩翩，带你飞向未知的诗和远方。</strong><br>哲学版：<br>1、我们要追求那真实的功业，要追求对宇宙人生更深远的了解；要追求永远超过狭小生活圈子之外的更有用的东西。<br>2、让整个一生都在追求中度过吧。那么在这一生中必定会有许许多多美好的时刻。<br>3、看清这个世界，然后爱它。<br>4、人类经常把一个生涯发生的事，撰写成历史，在从那里看人生。其实，那不过是隐，人生是内在的。<br>5、与其花许多时间和精力去凿许多浅井，不如花同样的时间和精力去凿一口深井。<br>6、一个人的痛苦，无非来自两个方面，一是没有个性，另一个是个性太强。<br>7、累累的创伤，就是生命给你的最好东西，因为在每个创伤上面都标志着前进的一步。<br>8、什么是生命？它并不是象冷酷的理智和我们的肉眼所见到的那个模样，而是我们幻想中的那个模样。生命的节奏是爱。<br>9、给时间以岁月，给岁月以文明。<br>10、有趣是个开放的空间，一直伸往未知的领域。<br>11、有趣和生活与年龄无关，你选择什么样的生活由你决定，从何时开始改变由你做主。<br>12、世界是美好与未知的，世界也是无趣与必然的。在这个认识的过程中去创造美，去获取快乐。<br>13、当信息足够公开，话语权足够平等，并且时间足够长，最终的结果一定是最好的。<br>14、区块链，更是一个美好的技术理念，但它所建构的基础，却诚然是我们“肮脏”的物理世界，“腐朽”的人性社会。<br>15、产品是技术和艺术的结合。<br>16、微信一直坚守君子之交淡若水的社交原则，从未改变。<br><strong>喜闻乐见版：</strong><br>1.还在抖音刷视频虚度光阴吗？临渊羡鱼，不如退而结网，来视频号提升自己吧！人生还有更独特的诗意和远方！<br>2.还在快手看直播吗？你想要的，视频号都有！精挑细选，有你好看~<br>3.还在知乎海淘干货、面经吗？视频版的浓缩精华，视频号等你来分享~<br>4.还在B站倍速播放卡槽点吗？慢一点，让我们享受一分钟的干货精华。<br>5.还在微博海量信息中大海捞针吗？这里有专属优质小圈，用料考究，视听盛宴等你来哦~<br>6.这是一部修身、齐家、治国、平天下的短视频版《资治通鉴》！<br>7.我们终将老去，来视频号沉淀您的即刻视频！。<br>8.沉淀前世今生的数字资产！<br>9.时光一去不复返，视频号里转一转。<br>10.人要怎么度过这一生？<br>当他回首往事的时候，他不会因为虚度年华刷抖音而悔恨，也不会因为碌碌无为逛淘宝而羞耻；<br>这样，在临死的时候，他就能够说：“我的整个生命和全部回忆都已经献给世界上最壮丽的事业———在视频号和陌生的你相遇。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E8%A7%86%E9%A2%91%E5%8F%B7%E6%80%9D%E8%80%83/" rel="tag">视频号思考</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E8%A7%86%E9%A2%91%E5%8F%B7%E6%98%AF%E4%BC%9F%E5%A4%A7%E7%9A%84/" rel="tag">视频号是伟大的</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-服务器端性能优化(一)之SSR" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/03/11/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(%E4%B8%80)%E4%B9%8BSSR/"
    >服务器端性能优化(一)之SSR</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/03/11/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(%E4%B8%80)%E4%B9%8BSSR/" class="article-date">
  <time datetime="2020-03-11T15:59:21.553Z" itemprop="datePublished">2020-03-11</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>前端框架带来了大改变，但是前端业务逻辑变的庞大时，给开发带来了很好的效果，但是！开发效率提升之后，带来的首屏渲染问题也需要我们思考怎么在框架的层面上去提升性能？<br>解决思路：多层次的优化方案：<br>1.构建层模板编译。<br>2.数据无关的页面进行prerender，这种方式适用于用户集群的场景，就是说呢，用户访问的页面时没有太多区别的，对ID和特性定制要求很低，比如某个广告运营页面。<br>3.服务端渲染，涉及到用户特性选择时的方案。</p>
<h2 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h2><p>概括一下流程就是将组件或页面通过服务器生成html字符串，再发送到浏览器，最后将静态标记”混合”为客户端上完全交互的应用程序，此篇笔记以 vue为例，后面做了React的项目再记录补充一下~<br>原理：靠vue-server-renderer这个库的createRenderer()，然后调用rendererToString()。</p>
<h2 id="SSR渲染和客户端渲染的区别"><a href="#SSR渲染和客户端渲染的区别" class="headerlink" title="SSR渲染和客户端渲染的区别"></a>SSR渲染和客户端渲染的区别</h2><p>1、SSR渲染的优势：</p>
<p>（1）更利于SEO；</p>
<p>（2）更利于首屏渲染（特别是对于缓慢的网络情况或运行缓慢的设备，内容更快到达）</p>
<p>2、SSR渲染的缺点：</p>
<p>（1）服务器压力大，考虑服务器端负载。</p>
<p>（2）开发条件受限，只会执行到ComponentMount之前的生命周期钩子，引用第三方库不可用其他生命周期钩子，引用库选择产生很大的限制。</p>
<p>（3）学习成本增大，需要学习构建设置和部署的更多要求。</p>
<h2 id="从流程角度比较性能"><a href="#从流程角度比较性能" class="headerlink" title="从流程角度比较性能"></a>从流程角度比较性能</h2><p>1.SSR服务端渲染是先向后端服务器请求数据，然后生成完整首屏html返回给浏览器，<br>2.而<strong>客户端渲染是等js代码下载、加载、解析完成后再请求数据渲染</strong>，等待的过程页面是什么都没有的，就是用户看到的白屏！<br>2.服务端<strong>不需要等待js代码下载完成并请求数据</strong>，就可以返回一个已有完整数据的首屏页面<br>2.由服务端请求首屏数据，而不是客户端请求首屏数据，这是“快”的一个主要原因。<br>3.<strong>服务端在内网进行请求，数据响应速度快</strong>。<br>4.客户端在不同网络环境进行数据请求，<strong>外网http请求开销大，导致时间差</strong>。</p>
<h2 id="构建vue-demo"><a href="#构建vue-demo" class="headerlink" title="构建vue  demo"></a>构建vue  demo</h2><p>具体实现：</p>
<p>1、创建一个空项目 mkdir vuessr &amp;&amp; cd vuessr</p>
<p>2、运行 npm init 进行初始化</p>
<p>3、安装我们需要的依赖 cnpm install vue vue-server-renderer –save</p>
<p>4、创建index.js代码如下：</p>
<p>5、运行 node index.js 可以看到在控制台输出了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第 1 步：创建一个 Vue 实例</span></span><br><span class="line"><span class="keyword">const</span> Vue = <span class="built_in">require</span>(<span class="string">'vue'</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;Hello World&lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第 2 步：创建一个 renderer</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="built_in">require</span>(<span class="string">'vue-server-renderer'</span>).createRenderer()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第 3 步：将 Vue 实例渲染为 HTML</span></span><br><span class="line">renderer.renderToString(app, (err, html) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">  <span class="built_in">console</span>.log(html)</span><br><span class="line">  <span class="comment">// =&gt; &lt;div data-server-rendered="true"&gt;Hello World&lt;/div&gt;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="我理解的原理"><a href="#我理解的原理" class="headerlink" title="我理解的原理"></a>我理解的原理</h2><p>1.利用服务端Node.js去执行VUE框架的构建逻辑，可以在服务端直接从接口拿到用户的信息，作为首屏渲染的数据源，直接当地解决好渲染，返回一个HTML，在浏览器端和VUE混入。<br>2.不在客户端执行JS逻辑，利用好服务端的运算能力，同时减少了客户端等待VUE框架加载和VUE 代码运行的时间，相当于平衡了两者的算力!<br>3.要考虑服务端的运算能力和压力，集群完备能力，还有内存泄漏问题！</p>
<h2 id="官方原理图"><a href="#官方原理图" class="headerlink" title="官方原理图"></a>官方原理图</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczIuYmRzdGF0aWMuY29tLzcwY0Z2blNoX1ExWW54R2twb1dLMUhGNmhoeS9pdC91PTQwNTU5MDYyNjgsMTMyNDg1NDI3MCZmbT0yNiZncD0wLmpwZw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>这是尤大牛老师在发布时的讲解图~<br>1.关键是编写针对VUE SSR渲染的组件（UAC）！其实生命周期是不一样的，VUE SSR时没有mounted阶段，因为SSR不存在DOM节点的真实渲染情况。<br>2.APP.JS有两个构建入口，Webpack 会分别构建用于S和C的两个bundle,分别在S和C端用到，首屏的渲染问题已经在Bundle Renderer中解决了！这时HTML包含了首屏的DOM结构和数据，HTML由BR生成，到浏览器之后，还是要通过客户端的VUE框架进行管理，怎么决定混入之后的关联？ <del>由Client Bundle 解决吗？</del> 还是利用serverBundle和clientManifest进行优化<br>？这里还不太明白。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cubXdjeHMudG9wL3N0YXRpYy91cGxvYWQvcGljcy8yMDE5LzMvMU9iYWVUeHdzc2JEYnhXSnBZSXVUVWptay5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cubXdjeHMudG9wL3N0YXRpYy91cGxvYWQvcGljcy8yMDE5LzMvMVJnZXUySU1QQ1pJRFY0dDlZRGtNSkVBeS5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cubXdjeHMudG9wL3N0YXRpYy91cGxvYWQvcGljcy8yMDE5LzMvMWhGUHQxUHhVRDhHOHhhR25QNDFiY08tTy5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<h2 id="深入思考"><a href="#深入思考" class="headerlink" title="深入思考"></a>深入思考</h2><blockquote>
<p>是否可以使用vuex？<br>我也没有准确答案~<br>是否使用SSR就一定好？<br>这个不一定，任何技术都有使用场景。<br>SSR可以帮助提升首页加载速度，优化搜索引擎SEO。<br>但同时它需要在node中渲染整套Vue的模板，会占用服务器负载。<br>并且只会执行beforeCreate和created两个生命周期，对于一些外部扩展库需要做一定处理才可以在SSR中运行。</p>
</blockquote>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-JS异步解决方案的发展历程以及优缺点" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/03/11/JS%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9/"
    >JS异步解决方案的发展历程以及优缺点</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/03/11/JS%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9/" class="article-date">
  <time datetime="2020-03-11T15:59:00.342Z" itemprop="datePublished">2020-03-11</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>JS 异步已经告一段落了，这里来一波小总结~</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 回调函数（callback）</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// callback 函数体</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>缺点：回调地狱，不能用 try catch 捕获错误，不能 return<br>回调地狱的根本问题在于：<br>缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符<br>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（控制反转）<br>嵌套函数过多的多话，很难处理错误</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">'XXX1'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// callback 函数体</span></span><br><span class="line">    ajax(<span class="string">'XXX2'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// callback 函数体</span></span><br><span class="line">        ajax(<span class="string">'XXX3'</span>, () =&gt; &#123;</span><br><span class="line">            <span class="comment">// callback 函数体</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）</p>
<ol start="2">
<li>Promise<br>Promise就是为了解决callback的问题而产生的。<br>Promise 实现了链式调用，也就是说每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装<br>优点：解决了回调地狱的问题</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">'XXX1'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 操作逻辑</span></span><br><span class="line">      <span class="keyword">return</span> ajax(<span class="string">'XXX2'</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 操作逻辑</span></span><br><span class="line">      <span class="keyword">return</span> ajax(<span class="string">'XXX3'</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 操作逻辑</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>缺点：无法取消 Promise ，错误需要通过回调函数来捕获</p>
<ol start="3">
<li>Generator<br>特点：可以控制函数的执行，可以配合 co 函数库使用</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">fetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> ajax(<span class="string">'XXX1'</span>, () =&gt; &#123;&#125;)</span><br><span class="line">    <span class="keyword">yield</span> ajax(<span class="string">'XXX2'</span>, () =&gt; &#123;&#125;)</span><br><span class="line">    <span class="keyword">yield</span> ajax(<span class="string">'XXX3'</span>, () =&gt; &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = fetch()</span><br><span class="line"><span class="keyword">let</span> result1 = it.next()</span><br><span class="line"><span class="keyword">let</span> result2 = it.next()</span><br><span class="line"><span class="keyword">let</span> result3 = it.next()</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>Async/await<br>async、await 是异步的终极解决方案</li>
</ol>
<p>优点是：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题<br>缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式</span></span><br><span class="line">  <span class="comment">// 如果有依赖性的话，其实就是解决回调地狱的例子了</span></span><br><span class="line">  <span class="keyword">await</span> fetch(<span class="string">'XXX1'</span>)</span><br><span class="line">  <span class="keyword">await</span> fetch(<span class="string">'XXX2'</span>)</span><br><span class="line">  <span class="keyword">await</span> fetch(<span class="string">'XXX3'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来看一个使用 await 的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  a = a + <span class="keyword">await</span> <span class="number">10</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>, a) <span class="comment">// -&gt; '2' 10</span></span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line">a++</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>, a) <span class="comment">// -&gt; '1' 1</span></span><br></pre></td></tr></table></figure>
<p>对于以上代码你可能会有疑惑，让我来解释下原因</p>
<p>首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为 await 内部实现了 generator ，generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来<br>因为 await 是异步操作，后来的表达式不返回 Promise 的话，就会包装成 Promise.reslove(返回值)，然后会去执行函数外的同步代码<br>同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 0 + 10<br>上述解释中提到了 await 内部实现了 generator，其实 await 就是 generator 加上 Promise的语法糖，且内部实现了自动执行 generator。<br>在最新的ES7（ES2017）中提出的前端异步特性：async、await。</p>
<p>什么是async、await？<br>async顾名思义是“异步”的意思，async用于声明一个函数是异步的。而await从字面意思上是“等待”的意思，就是用于等待异步完成。并且await只能在async函数中使用</p>
<p>通常async、await都是跟随Promise一起使用的。为什么这么说呢？因为async返回的都是一个Promise对象同时async适用于任何类型的函数上。这样await得到的就是一个Promise对象(如果不是Promise对象的话那async返回的是什么 就是什么)；</p>
<p>await得到Promise对象之后就等待Promise接下来的resolve或者reject。</p>
<p>来看一段简单的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testSync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">         setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">             resolve(<span class="string">"async await test..."</span>);</span><br><span class="line">          &#125;, <span class="number">1000</span>);</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;</span><br><span class="line">testSync();<span class="comment">//async await test...</span></span><br></pre></td></tr></table></figure>

<p>就这样一个简单的async、await异步就完成了。使用async、await完成异步操作代码可读与写法上更像是同步的，也更容易让人理解。相对于es6的generator函数，更直观理解。</p>
<p><strong>async、await串行并行处理<br>串行：等待前面一个await执行后接着执行下一个await，以此类推</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncAwaitFn</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(str)</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> serialFn = <span class="keyword">async</span> () =&gt; &#123; <span class="comment">//串行执行</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">'serialFn'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> asyncAwaitFn(<span class="string">'string 1'</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> asyncAwaitFn(<span class="string">'string 2'</span>));</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'serialFn'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>serialFn();<br><strong>并行：将多个promise直接发起请求（先执行async所在函数），然后再进行await操作。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncAwaitFn</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(str)</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> parallel = <span class="keyword">async</span> () =&gt; &#123; <span class="comment">//并行执行</span></span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">'parallel'</span>)</span><br><span class="line">    <span class="keyword">const</span> parallelOne = asyncAwaitFn(<span class="string">'string 1'</span>);</span><br><span class="line">    <span class="keyword">const</span> parallelTwo = asyncAwaitFn(<span class="string">'string 2'</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//直接打印</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> parallelOne)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> parallelTwo)</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'parallel'</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">parallel()</span><br></pre></td></tr></table></figure>

<p>async、await错误处理<br>JavaScript异步请求肯定会有请求失败的情况，上面也说到了async返回的是一个Promise对象。既然是返回一个Promise对象的话那处理当异步请求发生错误的时候我们就要处理reject的状态了。<br>在Promise中当请求reject的时候我们可以使用catch。为了保持代码的健壮性使用async、await的时候我们使用try catch来处理错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">catchErr</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> errRes = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    reject(<span class="string">"http error..."</span>);</span><br><span class="line">                 &#125;, <span class="number">1000</span>);</span><br><span class="line">           );</span><br><span class="line">                <span class="comment">//平常我们也可以在await请求成功后通过判断当前status是不是200来判断请求是否成功</span></span><br><span class="line">                <span class="comment">// console.log(errRes.status, errRes.statusText);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">             <span class="built_in">console</span>.log(err);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">catchErr(); <span class="comment">//http error...</span></span><br></pre></td></tr></table></figure>
<p>以上就是async、await使用try catch 处理错误的方式。<br>async/await的使用使得 Promise操作更加方便了！</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-css的优先级和权重问题 以及!important优先级 (1)" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/03/11/css%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E6%9D%83%E9%87%8D%E9%97%AE%E9%A2%98%20%E4%BB%A5%E5%8F%8A!important%E4%BC%98%E5%85%88%E7%BA%A7%20(1)/"
    >css的优先级和权重问题 以及!important优先级 (1)</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/03/11/css%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E6%9D%83%E9%87%8D%E9%97%AE%E9%A2%98%20%E4%BB%A5%E5%8F%8A!important%E4%BC%98%E5%85%88%E7%BA%A7%20(1)/" class="article-date">
  <time datetime="2020-03-11T15:59:00.294Z" itemprop="datePublished">2020-03-11</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>问：有多少种css选择器可以对</p><p>标签样式产生影响呢？</p>
<p>如果详细的进行分析，排列组合有太多种了，太过麻烦。今天学习到一个好方法。</p>
<p>行内样式：        即  style = “font-size: 12px”；<br>id选择器：  　   即  #thisId {font-size: 12px;}<br>class选择器：   即 .thisClass {font-size: 12px;}<br>元素选择器：    即  p {font-size: 12px;}<br>如上四种类别都可以对</p><p>标签的样式产生影响，那么谁先谁后，谁打谁小呢？<br>有如下两种解释：</p>
<p>1.一个selector的权重表示方式：0.0.0.0，按照计算规则给每位填充数字，对应位置相等，则比较下一位；<br>2.分别以1000、100、10、1四个权值系数对CSS选择器进行权重计算。</p>
<p><img src="https://img-blog.csdnimg.cn/20200303212631153.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>1.!important 表示强制应用该样式，例如：button{ width: 150px !important;}，与以上的选择器相遇时，强制使用此样式；<br>2.如果比较后权重相同，那么后者覆盖前者，后渲染的胜出；<br>3.内联样式  &gt; id选择器样式 &gt; 类选择器样式 &gt; 元素选择器样式；<br>4.CSS选择器的使用，应该尽量避免使用 !important 和 内联样式；id通常也是与class区分开使用，前者多用于JS中的结点定位，后者多用于CSS选择器。<br>5.重中之重，1000/100/10/1这种权值系数的比较方式只是便于理解，真实情况下10个class并不能逆转1个id。</p>
</blockquote>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-趣谈HTTPS协议_" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/03/07/%E8%B6%A3%E8%B0%88HTTPS%E5%8D%8F%E8%AE%AE_/"
    >趣谈HTTPS协议_</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/03/07/%E8%B6%A3%E8%B0%88HTTPS%E5%8D%8F%E8%AE%AE_/" class="article-date">
  <time datetime="2020-03-07T02:14:51.527Z" itemprop="datePublished">2020-03-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h1 id="HTTP传输数据存在的问题"><a href="#HTTP传输数据存在的问题" class="headerlink" title="HTTP传输数据存在的问题"></a>HTTP传输数据存在的问题</h1><h1 id="HTTPS与HTTP的区别"><a href="#HTTPS与HTTP的区别" class="headerlink" title="HTTPS与HTTP的区别"></a>HTTPS与HTTP的区别</h1><h1 id="SSL的加密方式"><a href="#SSL的加密方式" class="headerlink" title="SSL的加密方式"></a>SSL的加密方式</h1><h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><h1 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h1><p>HTTP采用明文传输。明文传输在一些需要保护个人隐私的场景是大忌，比如银行卡卡号和密码的输入，个</p>
<p>人信息的录入等。才用明文传输分分钟钟被不法分子截取下来。</p>
<p>HTTP不验证通信双方的身份。HTTP的状态是无请求的，优点在于解放了服务器，每一次请求“点到为止”不会造成不必要连接占用，缺点在于每次请求会传输大量重复的内容信息。</p>
<p>详细解析一下：无状态指的是任意一个Web请求必须完全与其他请求隔离，当请求端提出请求时，请求本身包含了相应端为相应这一请求所需的全部信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 Http协议不像建立了socket连接的两个终端，双方是可以互相通信的，http的客户端只能通过请求服务器来获取相关内容或文件信息。这也是后来为什么后来HTTP2有了服务器推送的原因！</p>
<p>至于为什么无状态，后面在Cookie和Session中详细分析一下~</p>
<p>HTTP无法验证报文的完整性，报文可能被篡改。</p>
<p>升级版！HTTPS：加密算法</p>
<p>对称加密原理：加密的算法是公开的，密钥来加密数据，对称加密使用一个密钥加密，还要使用相同的密钥才能解密！</p>
<p>常用的算法有：DES,3DES,AES</p>
<p>现在用的比较多的是AES，破解难度大，国外用的比较多。</p>
<p>//使用对称加密，AES加密的时候，密钥长度必须是16个字节，arg0表示要加密的数据，arg1表示要加密的密钥。<br>//解密也是两个参数，arg0和arg1，arg0是要解密的数据，arg1是解密的密钥<br>//方法：AES.decryptFromBase64()</p>
<p>加密之后是一个字符串，服务器解密，这时用户和服务器都有一把一样的钥匙！</p>
<p>优点：</p>
<p>1.计算量较小，加密和解密的速度比较快，适合加密比较大的数据</p>
<p>2.缺点:在传输数据之前，要先传输公钥，可能被中间人劫持，可能会被泄密。</p>
<p>3.当用户很多时，一个用户必须要有唯一的密钥，所以管理起来很麻烦，造成服务器压力巨大。</p>
<p>非对称加密：</p>
<p> 1.算法是公开的，公钥和私钥是配对的，公钥加密只能私钥解密，私钥加密只能公钥解密，简单理解就是用不同的钥匙去开锁，打开和关闭的钥匙是不一样的，所以称非对称~服务器会保存公钥 和私钥 </p>
<p>2.公钥和私钥是通过算法生成的，不能随意乱写！</p>
<p>3.典型方法：RSA  有两个方法   RSA.encrypt     RSA.decrypt  </p>
<p>流程：</p>
<p>服务器发送公钥给用户——&gt;用户采用公钥进行加密——&gt;加密之后传输给服务器——&gt;服务器用私钥进行解密</p>
<p>上述流程中，黑客可能同时拿到公钥和数据，但是公钥是解不了密的！所以黑客解不开这时的数据！</p>
<p>非对称加密的算法RSA</p>
<p>优点:   加密和解密采用不同的钥匙，公钥是可以传输的，但不能解开数据</p>
<p>缺点：计算量比较大，加密和解密的速度比较慢。</p>
<p>那么HTTPS是怎么结合的呢？</p>
<p>对称加密+非对称加密(HTTPS采用这种方式)</p>
<p>使用对称密钥的好处是解密的效率比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解，因为就算你拦截到了数据，但是没有对应的私钥，也是不能破解内容的。</p>
<p>举个例子：你抢到了一个保险柜，但是没有保险柜的钥匙也不能打开保险柜。那我们就将对称加密与非对称加密结合起来,充分利用两者各自的优势，在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式。</p>
<p>具体做法是：发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信。所以，HTTPS采用对称加密和非对称加密两者并用的混合加密机制。</p>
<p>但是这样还不够哦！我们聪明的密码学家考虑问题是非常周全的，在实际场景中，会有很多bug~</p>
<p>比如：网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，那如何校验数据的完整性呢？</p>
<p>画押！—–&gt;校验数字签名。</p>
<p>数字签名有两种功效：</p>
<p>1.能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。</p>
<p>2.数字签名能确定消息的完整性,证明数据是否未被篡改过。</p>
<p>HTTPS工作原理：</p>
<p>1.服务器有公钥和私钥，公钥是传给客户端的，但是不是直接传输，而是先通过SSL数字证书，证书上标注了公钥和服务器的身份标志信息，客户端收到SSL证书之后，拆包，解析出公钥，这时呢，客户端会检查一下服务器的身份，是不是我想要去请求的那个服务器呢？是不是过期了呢？如果没有问题的话，客户端会生成一个随机码，使用公钥进行加密！传输加密之后的数据</p>
<p>2.服务器拿到随机码之后（这时已经被公钥加密了！），这个随机码就可以作为对称加密的密钥，这时服务器就有了数据和私钥 </p>
<p>服务器用私钥进行解密之后，拿到随机码， 这时两端都有了相同的数据，这样的话，双方采用相同的随机码作为对称加密的钥匙！就可以对称的拿到解析之后的数据了，为什么这样？因为传输的时候采用对称加密可以提高速度！</p>
<p>3.详细说明一下：</p>
<p>SSL证书包裹这公钥和服务器的身份标志，为什么带上服务器的标志呢？哈哈，这就是为了防止中间人的劫持，如果你不是正规服务器的话，我就不要你的冒牌货的钥匙！这样客户端就可以防止黑客坑骗拐骗拿到我们的信息啦，不过这只是开始~</p>
<p>假设随机码6666是采用公钥AA加密的，采用对称算法，加密之后生成<strong>***</strong>这种字符串，对称加密保证了传输的速度，但是我们又不想让黑客劫持，所以要引入SSL证书来告诉双方，验证真假美猴王~防止双方都不知道对方身份的情况下，被双向迷惑！猜想一下，黑客是很聪明的，他可能伪装成任何一个角色，如果在客户端这里，他伪装成服务端，采用不正规的钥匙和我们通信，那么我们并不知道身份，会被盗取信息，而在服务端，黑客会假冒成客户端，黑客就是双重身份的冒充人！这样，他获取了双方的信息，随意篡改就很危险！而这个时候我们双方是不知情的，所以SSL很重要！必要要带上身份标志才能辨别好。</p>
<p>随机码就是对陈加密的密钥，客户端采用随机码6666进行对称加密，传输<strong><strong>，服务端拿到</strong></strong>，使用私钥BB解密，拿到随机码6666，再用随机码解密用户的信息，这样就保证了双方的通信。细想这样安全吗？</p>
<p>设想一下，刚开始发送SSL的时候，黑客是可以获取公钥AA的，后来传输加密之后的数据时黑客也可以劫持，拿到*****但是这时，公钥是解不开数据的，因为黑客没有私钥BB。</p>
<p>先发公钥AA给用户—-&gt;用户生成一个随机码6666—–&gt;使用AA加密6666生成<strong><strong>—–&gt;传输</strong></strong>给服务器——&gt;服务器使用私钥BB解密<strong><strong>—–&gt;拿到随机码6666，这个随机码的破解是采用的非对称加密哦，因为都是在双方本地完成解析的，所以相对不用考虑解析算法耗时的问题—–&gt;服务器采用6666随机码解密</strong></strong>，到这里我就明白了，为什么要用随机码来作为对称加密的密钥，这一招厉害了哈哈，这个密钥不仅保证了黑客解不开****，还保证了双方解析用户ID时采用对称算法，减少解密时间的效果~</p>
<p>配置密钥库</p>
<p>1.genkey-alias  生成证书别名</p>
<p>2.keyalg   指定密钥算法，默认RSA</p>
<p>3.keysize  默认1024位。</p>
<p>上面就是我的通俗讲解了~密码学家真的很聪明</p>
<p>官方流程参考：</p>
<p>首先看看组成HTTPS的协议：HTTP协议和SSL/TLS协议。HTTP协议就不用讲了，而SSL/TLS就是负责加密解密等安全处理的模块，所以HTTPS的核心在SSL/TLS上面。整个通信如下：</p>
<p>1、浏览器发起往服务器的443端口发起请求，请求携带了浏览器支持的加密算法和哈希算法。</p>
<p>2、服务器收到请求，选择浏览器支持的加密算法和哈希算法。</p>
<p>3、服务器下将数字证书返回给浏览器，这里的数字证书可以是向某个可靠机构申请的，也可以是自制的。</p>
<p>4、浏览器进入数字证书认证环节，这一部分是浏览器内置的TLS完成的：</p>
<p>4.1 首先浏览器会从内置的证书列表中索引，找到服务器下发证书对应的机构，如果没有找到，此时就会提示用户该证书是不是由权威机构颁发，是不可信任的。如果查到了对应的机构，则取出该机构颁发的公钥。</p>
<p>4.2 用机构的证书公钥解密得到证书的内容和证书签名，内容包括网站的网址、网站的公钥、证书的有效期等。浏览器会先验证证书签名的合法性（验证过程类似上面Bob和Susan的通信）。签名通过后，浏览器验证证书记录的网址是否和当前网址是一致的，不一致会提示用户。如果网址一致会检查证书有效期，证书过期了也会提示用户。这些都通过认证时，浏览器就可以安全使用证书中的网站公钥了。</p>
<p>4.3 浏览器生成一个随机数R，并使用网站公钥对R进行加密。</p>
<p>5、浏览器将加密的R传送给服务器。</p>
<p>6、服务器用自己的私钥解密得到R。</p>
<p>7、服务器以R为密钥使用了对称加密算法加密网页内容并传输给浏览器。 </p>
<p>8、浏览器以R为密钥使用之前约定好的解密算法获取网页内容。</p>
<p>附上SHA算法供大家有兴趣研究~可以脑补一下著名的哈希冲突</p>
<p>安全哈希算法（Secure Hash Algorithm）主要适用于数字签名标准（Digital Signature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。对于长度小于2^64位的消息，SHA1会产生一个160位的消息摘要。该算法经过加密专家多年来的发展和改进已日益完善，并被广泛使用。该算法的思想是接收一段明文，然后以一种不可逆的方式将它转换成一段（通常更小）密文，也可以简单的理解为取一串输入码（称为预映射或信息），并把它们转化为长度较短、位数固定的输出序列即散列值（也称为信息摘要或信息认证代码）的过程。散列函数值可以说是对明文的一种”指纹”或是”摘要”所以对散列值的数字签名就可以视为对此明文的数字签名。</p>
<p>最后补充一下：SSL协议并不是一个应用层协议，它是介于应用层和传输层协议之间的一个安全协议。</p>
<p>枯燥但科学的总结一下：HTTPS=HTTP+加密+身份认证+完整性保护。HTTPS并不是一种新的协议，在通信接口使用了SSL和TLS协议而已。HTTP通常直接和TCP通信，而HTTPS中HTTP先和SSL通信，再由SSL和TCP进行通信。模型如下</p>
<p>HTTPS使用两种加密方式的混合加密<br>对称密钥加密方式的优缺点：</p>
<p>优点：处理速度快<br>缺点：但是容易被第三方盗取<br>非对称密钥加密方式的优缺点：</p>
<p>优点：更加安全，不容易被盗取<br>缺点：处理效率相比对称密钥加密要慢，如果在通信时用这种方式加密，效率很低<br>于是HTTPS采用了两者的优点，使用了混合加密的方式</p>
<p>使用非对称密钥加密的方式安全地交换再稍后对称密钥加密中要使用的密钥<br>确保交换的密钥是安全的之后，放弃非对称密钥加密，使用对称密钥加密来进行通信，保证传输效率<br>HTTPS是怎么解决HTTP协议的三大缺点的？<br>防监听：采用对称加密对数据进行加密，采用非对称加密对对称加密的密钥进行加密<br>防伪装：通信双方携带证书，证书有第三方颁发，很难伪造<br>防篡改：采用摘要算法（MD5或是SHA-1），同样的数据由同样的摘要，而只要有一点不同的数据，它的摘要往往不同，只要数据做了篡改，就会被感知到。</p>
<p>HTTP与HTTPS的区别<br>HTTPS更加安全，因为它有加密，身份认证，验证数据完整性等环节<br>HTTPS需要申请证书，要付费（要钱！一年大概600元）<br>加密通信需要消耗更多的cpu和内存资源，如果每次通信都加密，会消耗很多的资源，当访问量很多的那些网站在进行加密处理时，它们所承担着的负载就很多了，这个时候就需要服务器端实现负载均衡。（有专用的https加解密硬件服务器）<br>使用端口不同，HTTP使用的是80端口，HTTPS使用的是443端口<br>所在层次不同，HTTP运行在TCP之上，HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS运行在TCP之上</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-谈谈Ajax" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/03/07/%E8%B0%88%E8%B0%88Ajax/"
    >谈谈Ajax</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/03/07/%E8%B0%88%E8%B0%88Ajax/" class="article-date">
  <time datetime="2020-03-07T02:14:51.518Z" itemprop="datePublished">2020-03-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Asynchronous JavaScript and XML，意思是异步JS和XML。<br>解释下异步，异步是相对于同步来说的，同步即同时进行（累积多了就排队，一个一个执行，必须等上一个结束，才能到下一个），而异步就是执行到我了，我去旁边继续执行等结果，后面排队的不用等我结果出来再执行。<br>这是对于ajax的特点来设计的，<strong>因为ajax对后端数据的请求需要时间，</strong>而这个时间不利用起来就是浪费。当然，如果必须要等前一个的结果怎么办，这就使用到JS中的重要部分——回调函数了，其实回调在JS中应用很多，像点击事件执行的就是回调（先绑定事件，只有在点击发生时，才会执行）。那么ajax也一样，先请求数据，只有在状态改变时才会执行接下来的（这个状态包括请求成功和请求失败）。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>AJAX 是一种用于创建快速动态网页的技术，对网页的某部分进行更新，不用刷新整个网页。<br>它可以通过在后台与服务器进行少量数据交换，使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个页面。</p>
<h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><p>ajax实现的就是浏览器和服务器之间的数据交互。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTM4MzQ4OC8yMDE4MDUvMTM4MzQ4OC0yMDE4MDUxMzIzMDQwMTE1NS0xOTMyNDMyMDgzLnBuZw?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>　 XMLHTTPRequest对象，（是对象，就有属性和方法）</p>
<p>　常用的方法：<br>　open(“method”, “url”, “async”)，</p>
<p>　method表示通过什么方式进行服务器访问，包括get和post；</p>
<p>　url表示访问服务器的地址；</p>
<p>　async表示是否异步，包括true和false（注意：true表示异步）。</p>
<pre><code>send(content)，</code></pre><p>　content表示向服务器发送的数据。
　</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHTTPRequest();</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> xhr.open(<span class="string">"method"</span>, <span class="string">"url"</span>, <span class="string">"async"</span>);</span><br><span class="line"> <span class="number">4</span> </span><br><span class="line"> <span class="number">5</span> xhr.send(<span class="literal">null</span>);</span><br><span class="line"> <span class="number">6</span> </span><br><span class="line"> <span class="number">7</span> xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="number">8</span> </span><br><span class="line"> <span class="number">9</span>     <span class="keyword">if</span>(xhr.readystate == <span class="number">4</span>)&#123;</span><br><span class="line"><span class="number">10</span> </span><br><span class="line"><span class="number">11</span> 　　　<span class="keyword">if</span>(xhr.status == <span class="number">200</span>)&#123;</span><br><span class="line"><span class="number">12</span> </span><br><span class="line"><span class="number">13</span> 　　　　　<span class="built_in">console</span>.log(xhr.responseText)</span><br><span class="line"><span class="number">14</span> </span><br><span class="line"><span class="number">15</span> 　　　&#125;</span><br><span class="line"><span class="number">16</span> </span><br><span class="line"><span class="number">17</span> 　　&#125;</span><br><span class="line"><span class="number">18</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="向服务器请求状态的阶段："><a href="#向服务器请求状态的阶段：" class="headerlink" title="向服务器请求状态的阶段："></a>向服务器请求状态的阶段：</h2><p>　　　onreadystatechange表示请求状态改变的事件触发器，</p>
<p>　　　readystate表示请求状态，4表示完成，具体如下表：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTM4MzQ4OC8yMDE4MDUvMTM4MzQ4OC0yMDE4MDUxMzIzMTk0NDc1Mi0xMzA4MzA2MzU3LnBuZw?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<h2 id="服务器反馈阶段："><a href="#服务器反馈阶段：" class="headerlink" title="服务器反馈阶段："></a>服务器反馈阶段：</h2><p>　　　status表示http请求状态码，200表示成功，具体如下表：<br>　　　<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTM4MzQ4OC8yMDE4MDUvMTM4MzQ4OC0yMDE4MDUxMzIzMzY1NTI1NC0yMTM2ODM3MDA2LnBuZw?x-oss-process=image/format,png" alt="在这里插入图片描述">
　　</p>
<h2 id="避坑"><a href="#避坑" class="headerlink" title="避坑"></a>避坑</h2><p>IE7及其以上版本中支持原生的 XHR 对象，因此可以直接用： var oAjax = new XMLHttpRequest();<br>IE6及其之前的版本中，XHR对象是通过MSXML库中的一个ActiveX对象实现的。使用下面的语句创建： var oAjax=new ActiveXObject(’Microsoft.XMLHTTP’);<br>GET 请求方式是通过<strong>URL参数</strong>将数据提交到服务器的，POST则是通过将数据作为 <strong>send 的参数</strong>提交到服务器；POST 请求中，在发送数据之前，要设置表单提<strong>交的内容类型</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以以下步骤代替上面的open、setRequestHeader、send三行，此处对GET和POST做了很好的区分</span></span><br><span class="line">    <span class="keyword">var</span> params = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> ajaxData.data)&#123;</span><br><span class="line">         params.push(key + <span class="string">"="</span> + ajaxData.data[key]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> sendData = params.join(<span class="string">"&amp;"</span>);</span><br><span class="line">    <span class="keyword">if</span>(ajaxData.type.toUpperCase() == <span class="string">"GET"</span>)&#123;</span><br><span class="line">         xhr.open(ajaxData.type, ajaxData.url + <span class="string">"?"</span> + sendData, ajaxData.async);</span><br><span class="line">         xhr.send(<span class="literal">null</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         xhr.open(ajaxData.type, ajaxData.url, ajaxData.async);</span><br><span class="line">         xhr.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded; charset=utf-8"</span>);</span><br><span class="line">         xhr.send(sendData);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="JQuery中的封装方法"><a href="#JQuery中的封装方法" class="headerlink" title="JQuery中的封装方法"></a>JQuery中的封装方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    type: <span class="string">"GET"</span>,            　　<span class="comment">//访问服务器的方式，GET/POST</span></span><br><span class="line">    url: <span class="string">"test.json"</span>,       　　<span class="comment">//url表示访问的服务器地址</span></span><br><span class="line">    data: &#123;<span class="attr">username</span>: <span class="string">""</span>,     </span><br><span class="line">           content: <span class="string">""</span>&#125;, 　　　 <span class="comment">//data表示传递到后台的数据，使用键值对形式传递</span></span><br><span class="line">    <span class="keyword">async</span>: <span class="literal">true</span>,            　 <span class="comment">//true表示异步，false表示同步</span></span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="封装成JQuery的形式"><a href="#封装成JQuery的形式" class="headerlink" title="封装成JQuery的形式"></a>封装成JQuery的形式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$Ajax</span>(<span class="params">opt</span>)</span>&#123;</span><br><span class="line">    opt = opt || &#123;&#125;;</span><br><span class="line">    opt.type = opt.type || <span class="string">"post"</span>;</span><br><span class="line">    opt.url = opt.url || <span class="string">""</span>;</span><br><span class="line">    opt.async = opt.async || <span class="literal">true</span>;</span><br><span class="line">    opt.data = opt.data || <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    opt.success = opt.success || <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    opt.error = opt.error || <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHTTPRequest();</span><br><span class="line">    <span class="keyword">var</span> params = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> opt.data)&#123;</span><br><span class="line">         params.push(key + <span class="string">"="</span> + opt.data[key]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> sendData = params.join(<span class="string">"&amp;"</span>);</span><br><span class="line">    <span class="keyword">if</span>(opt.type.toUpperCase() == <span class="string">"GET"</span>)&#123;</span><br><span class="line">         xhr.open(opt.type, opt.url + <span class="string">"?"</span> + sendData, opt.async);</span><br><span class="line">         xhr.send(<span class="literal">null</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         xhr.open(opt.type, opt.url, opt.async);</span><br><span class="line">         xhr.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded; charset=utf-8"</span>);</span><br><span class="line">         xhr.send(sendData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(xhr.readystate == <span class="number">4</span>)&#123;</span><br><span class="line">              <span class="keyword">if</span>(xhr.status == <span class="number">200</span>)&#123;</span><br><span class="line">                    opt.success &amp;&amp; opt.success(xhr.responseText);  </span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    opt.error &amp;&amp; xhr.error(xhr.status);</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-数组技巧总结" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/03/07/%E6%95%B0%E7%BB%84%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"
    >数组技巧总结</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/03/07/%E6%95%B0%E7%BB%84%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2020-03-07T02:14:51.491Z" itemprop="datePublished">2020-03-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h2 id="map与for-each"><a href="#map与for-each" class="headerlink" title="map与for each"></a>map与for each</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">			<span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">			<span class="comment">//for each 对数组直接进行循环，相当于直接for循环,没有返回值</span></span><br><span class="line">			<span class="comment">//三个参数是item  index arr不是必须的</span></span><br><span class="line">			<span class="comment">// let result = arr.forEach((item,index,arr)=&gt;&#123;</span></span><br><span class="line">			<span class="comment">// 	console.log(item)</span></span><br><span class="line">			<span class="comment">// 	console.log(index)</span></span><br><span class="line">			<span class="comment">// 	console.log(arr)</span></span><br><span class="line">			<span class="comment">// 	return item</span></span><br><span class="line">			<span class="comment">// &#125;)</span></span><br><span class="line">			<span class="comment">//console.log(result)</span></span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">let</span> arr2 = [<span class="string">'香蕉'</span>,<span class="string">"苹果"</span>,<span class="string">"雪梨"</span>]</span><br><span class="line">			<span class="comment">//map,对数组每一项进行加工，加工完成之后返回1个新的数组！</span></span><br><span class="line">			<span class="comment">// let result2 = arr2.map((item,index,arr)=&gt;&#123;</span></span><br><span class="line">			<span class="comment">// 	let str = index + item + index</span></span><br><span class="line">			<span class="comment">// 	return str</span></span><br><span class="line">			<span class="comment">// &#125;)</span></span><br><span class="line">			<span class="comment">// console.log(result2)</span></span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">let</span> arr3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line">			<span class="comment">//filter过滤，就是将想要的内容进行筛选，不要内容去除，最终返回想要的内容的数组。</span></span><br><span class="line">			<span class="comment">// let result3 = arr3.filter((item,index)=&gt;&#123;</span></span><br><span class="line">			<span class="comment">// 	if(item%2==0)&#123;</span></span><br><span class="line">			<span class="comment">// 		//通过返回true还是false进行选择，true就是想要，false就是去除。</span></span><br><span class="line">			<span class="comment">// 		return true;</span></span><br><span class="line">			<span class="comment">// 	&#125;else&#123;</span></span><br><span class="line">			<span class="comment">// 		return false;</span></span><br><span class="line">			<span class="comment">// 	&#125;</span></span><br><span class="line">			<span class="comment">// &#125;)</span></span><br><span class="line">			<span class="comment">// console.log(result3)</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">//reduce,是对整个数组进行整合，比如要将数组里所有的数字进行相加</span></span><br><span class="line">			<span class="comment">//将数组每一项内容整合后，返回1个内容</span></span><br><span class="line">			<span class="keyword">let</span> arr4 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line">			<span class="keyword">let</span> result4 =arr4.reduce(<span class="function">(<span class="params">pre,next,index</span>)=&gt;</span>&#123;</span><br><span class="line">				<span class="built_in">console</span>.log(pre);</span><br><span class="line">				<span class="built_in">console</span>.log(next);</span><br><span class="line">				<span class="built_in">console</span>.log(index)</span><br><span class="line">				<span class="keyword">return</span> pre+next</span><br><span class="line">			&#125;,<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">console</span>.log(result4)</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//for...in...主要用于遍历对象的，不适用于遍历数组,for(key in obj),里面的每项是key</span></span><br><span class="line">			<span class="comment">//for...of...可以用来遍历数组，类数组的对象，字符串，set/map,generator。</span></span><br><span class="line">			<span class="comment">//for(item of arr),里面的是每一项</span></span><br><span class="line">			<span class="comment">//map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</span></span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">let</span> obj = &#123;</span><br><span class="line">				name:<span class="string">"老陈"</span>,</span><br><span class="line">				type:<span class="string">"帅"</span>,</span><br><span class="line">				content:<span class="string">"前端"</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span>(key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">				<span class="built_in">console</span>.log(<span class="string">"key："</span>+key+<span class="string">";value:"</span>+obj[key])</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">let</span> arr5 = [<span class="string">"范冰冰"</span>,<span class="string">"李晨"</span>,<span class="string">"鹿晗"</span>]</span><br><span class="line">			<span class="comment">//for of循环的是每一项的内容</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr5)&#123;</span><br><span class="line">				<span class="built_in">console</span>.log(item)</span><br><span class="line">			&#125;</span><br><span class="line">		&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p>这是一个非常流行的关于Javascript数组的采访问题，数组去重。这里有一个快速简单的解决方案，可以使用一个新的Set()。我想向您展示两种可能的方法，一种是使用.from()方法，另一种是使用spread操作符(…)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"banana"</span>, <span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"watermelon"</span>, <span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"grape"</span>, <span class="string">"apple"</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// First method</span></span><br><span class="line"><span class="keyword">var</span> uniqueFruits = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(fruits));</span><br><span class="line"><span class="built_in">console</span>.log(uniqueFruits); </span><br><span class="line"><span class="comment">// returns ["banana", "apple", "orange", "watermelon", "grape"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Second method</span></span><br><span class="line"><span class="keyword">var</span> uniqueFruits2 = […<span class="keyword">new</span> <span class="built_in">Set</span>(fruits)];</span><br><span class="line"><span class="built_in">console</span>.log(uniqueFruits2); </span><br><span class="line"><span class="comment">// returns ["banana", "apple", "orange", "watermelon", "grape"]</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>替换数组中的特定值<br>有时在创建代码时需要替换数组中的特定值，有一种很好的简单的方法可以做到这一点，我们可以使用.splice(start、valueToRemove、valueToAdd)，并将所有三个参数传递给它，这些参数可以指定我们希望从哪里开始修改、希望修改多少值和新值。</li>
</ol>
<p>var fruits = [“banana”, “apple”, “orange”, “watermelon”, “apple”, “orange”, “grape”, “apple”];<br>fruits.splice(0, 2, “potato”, “tomato”);<br>console.log(fruits);<br>// returns [“potato”, “tomato”, “orange”, “watermelon”, “apple”, “orange”, “grape”, “apple”]<br>3. 没有map()的映射数组<br>也许每个人都知道数组的map()方法，但是有一个不同的解决方案，它可以用来获得类似的效果和非常干净的代码。我们可以使用.from()方法。</p>
<p>var friends = [<br>    { name: “John”, age: 22 },<br>    { name: “Peter”, age: 23 },<br>    { name: “Mark”, age: 24 },<br>    { name: “Maria”, age: 22 },<br>    { name: “Monica”, age: 21 },<br>    { name: “Martha”, age: 19 },<br>]</p>
<p>var friendsNames = Array.from(friends, ({name}) =&gt; name);<br>console.log(friendsNames);<br>// returns [“John”, “Peter”, “Mark”, “Maria”, “Monica”, “Martha”]<br>4. 空数组<br>您是否有一个满是元素的数组，但是您需要出于任何目的对其进行清理，并且您不想逐个删除项? 很容易就可以在一行代码中完成。要清空一个数组，您需要将数组的长度设置为0，就是这样!</p>
<p>var fruits = [“banana”, “apple”, “orange”, “watermelon”, “apple”, “orange”, “grape”, “apple”];</p>
<p>fruits.length = 0;<br>console.log(fruits);<br> // returns []</p>
<h2 id="将数组转换为对象"><a href="#将数组转换为对象" class="headerlink" title="将数组转换为对象"></a>将数组转换为对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spread运算符(…)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"banana"</span>, <span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"watermelon"</span>];</span><br><span class="line"><span class="keyword">var</span> fruitsObj = &#123; …fruits &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(fruitsObj);</span><br><span class="line"><span class="comment">// returns &#123;0: "banana", 1: "apple", 2: "orange", 3: "watermelon", 4: "apple", 5: "orange", 6: "grape", 7: "apple"&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="用数据填充数组"><a href="#用数据填充数组" class="headerlink" title="用数据填充数组"></a>用数据填充数组</h2><p>在某些情况下，当创建一个数组时，希望用一些数据来填充它，或者需要一个具有相同值的数组，在这种情况下使用fill()方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>).fill(<span class="string">"1"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newArray); </span><br><span class="line"><span class="comment">// returns ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1"]</span></span><br></pre></td></tr></table></figure>

<h2 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h2><p>.concat()方法或spread操作符(…)在处理数组时非常有用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>];</span><br><span class="line"><span class="keyword">var</span> meat = [<span class="string">"poultry"</span>, <span class="string">"beef"</span>, <span class="string">"fish"</span>];</span><br><span class="line"><span class="keyword">var</span> vegetables = [<span class="string">"potato"</span>, <span class="string">"tomato"</span>, <span class="string">"cucumber"</span>];</span><br><span class="line"><span class="keyword">var</span> food = […fruits, …meat, …vegetables];</span><br><span class="line"><span class="built_in">console</span>.log(food); </span><br><span class="line"><span class="comment">// ["apple", "banana", "orange", "poultry", "beef", "fish", "potato", "tomato", "cucumber"]</span></span><br></pre></td></tr></table></figure>

<h2 id="求两个数组的交集"><a href="#求两个数组的交集" class="headerlink" title="求两个数组的交集"></a>求两个数组的交集</h2><blockquote>
<p>为了找到两个数组的交集，以确保数组中的值不重复，使用.filter方法和.include方法。最后，将得到两个数组的交集。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numOne = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> numTwo = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> duplicatedValues = […<span class="keyword">new</span> <span class="built_in">Set</span>(numOne)].filter(<span class="function"><span class="params">item</span> =&gt;</span> numTwo.includes(item));</span><br><span class="line"><span class="built_in">console</span>.log(duplicatedValues); </span><br><span class="line"><span class="comment">// returns [2, 4, 6]</span></span><br></pre></td></tr></table></figure>

<h2 id="从数组中删除假值"><a href="#从数组中删除假值" class="headerlink" title="从数组中删除假值"></a>从数组中删除假值</h2><blockquote>
<p>在Javascript中，假值是false, 0， “ “， null, NaN, undefined  使用.filter()方法。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mixedArr = [<span class="number">0</span>, <span class="string">"blue"</span>, <span class="string">""</span>, <span class="literal">NaN</span>, <span class="number">9</span>, <span class="literal">true</span>, <span class="literal">undefined</span>, <span class="string">"white"</span>, <span class="literal">false</span>];</span><br><span class="line"><span class="keyword">var</span> trueArr = mixedArr.filter(<span class="built_in">Boolean</span>);</span><br><span class="line"><span class="built_in">console</span>.log(trueArr); </span><br><span class="line"><span class="comment">// returns ["blue", 9, true, "white"]</span></span><br></pre></td></tr></table></figure>

<h2 id="从数组中获取随机值"><a href="#从数组中获取随机值" class="headerlink" title="从数组中获取随机值"></a>从数组中获取随机值</h2><blockquote>
<p>有时需要从数组中随机选择一个值。要以一种简单、快速、简短的方式创建它，并保持代码整洁，可以根据数组长度获得一个随机索引号。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"blue"</span>, <span class="string">"white"</span>, <span class="string">"green"</span>, <span class="string">"navy"</span>, <span class="string">"pink"</span>, <span class="string">"purple"</span>, <span class="string">"orange"</span>, <span class="string">"yellow"</span>, <span class="string">"black"</span>, <span class="string">"brown"</span>];</span><br><span class="line"><span class="keyword">var</span> randomColor = colors[(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (colors.length + <span class="number">1</span>)))]</span><br></pre></td></tr></table></figure>

<h2 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a>数组反转</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"blue"</span>, <span class="string">"white"</span>, <span class="string">"green"</span>, <span class="string">"navy"</span>, <span class="string">"pink"</span>, <span class="string">"purple"</span>, <span class="string">"orange"</span>, <span class="string">"yellow"</span>, <span class="string">"black"</span>, <span class="string">"brown"</span>];</span><br><span class="line"><span class="keyword">var</span> reversedColors = colors.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(reversedColors); </span><br><span class="line"><span class="comment">// returns ["brown", "black", "yellow", "orange", "purple", "pink", "navy", "green", "white", "blue"]</span></span><br></pre></td></tr></table></figure>

<h2 id="lastIndexOf-方法"><a href="#lastIndexOf-方法" class="headerlink" title="lastIndexOf()方法"></a>lastIndexOf()方法</h2><blockquote>
<p>允许查找给定元素的最后一次出现的索引。例如，数组有重复的值，可以找到它最后一次出现的位置。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">var</span> lastIndex = nums.lastIndexOf(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(lastIndex); </span><br><span class="line"><span class="comment">// returns 9</span></span><br></pre></td></tr></table></figure>

<h2 id="将数组中的所有值相加"><a href="#将数组中的所有值相加" class="headerlink" title="将数组中的所有值相加"></a>将数组中的所有值相加</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> sum = nums.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y);</span><br><span class="line"><span class="built_in">console</span>.log(sum); </span><br><span class="line"><span class="comment">// returns 14</span></span><br></pre></td></tr></table></figure>

<h2 id="易混辨析"><a href="#易混辨析" class="headerlink" title="易混辨析"></a>易混辨析</h2><p>比如有一个数组a=[1,2,3,4]，还有一个对象a={0:1,1:2,2:3,3:4}，然后运行alert(a[1])，两种情况下的运行结果是相同的！这就是说，数据集合既可以用数组表示，也可以用对象表示，那么我到底该用哪一种呢？<br><strong>数组表示有序数据的集合，而对象表示无序数据的集合。如果数据的顺序很重要，就用数组，否则就用对象。</strong><br>当然，数组和对象的另一个区别是，数组的数据没有”名称”（name），对象的数据有”名称”（name）。<br>但是问题是，很多编程语言中，都有一种叫做”关联数组”（associative array）的东西。这种数组中的数据是有名称的。<br>但是在《javascript DOM》中，不推荐我们使用 关联数组！</p>
<blockquote>
<p><strong>判断一个对象是不是数组类型最可靠的方法是这两种:<br>Object. prototype.toString.call(obj)===[ object Array]和Array. isArray(obj)。</strong></p>
</blockquote>
<p>原因：typeof 检查基本数据类型是可以的，但不准确。<br>Array.isArray() 用于确定传递的值是否是一个 Array。如果对象是 Array，则为true; 否则为false.这个是可以的！<br> <strong>所有 函数的原型对象默认是OBJECT的实例，但OBJECT除外。Function 函数是new自己产生的。</strong><br>但是！bug问题就是研究不深入啊啊啊啊啊啊，作为程序媛，我有点难~<br>A  instance of   B不准确！因为原型链可以改变，只要B构造函数的显示原型对象protptype在左边A的原型链上可以找到就返回TRUE。只要在A 的原型链上找到了B的prototype,，就可以,任何一个就可以说明A是B的一个实例。<br>这种方法有一个问题，就是验证不够严格。 如果对象创建时不是使用数组创建的，但是只要原型链上有数组类型，也认为是数组，如下面一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Test.prototype = <span class="built_in">Array</span>.prototype;</span><br><span class="line"><span class="keyword">let</span> test = <span class="keyword">new</span> Test();</span><br><span class="line">test <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Object. prototype.toString.call(obj)===[ object Array]原理是根据对象的class属性(类属性)，跨原型链调用toString()方法。<br><code>Object.prototype.toString.call(new Date());   //&quot;[object Date]&quot;
Object.prototype.toString.call(Window);       //&quot;[object window]&quot;
Object.prototype.toString.call(/./);          //&quot;[object RegExp]&quot;</code></p>
</blockquote>
<p>解释一下，在js中一个对象一旦被创建，在内部会携带创建对象的类型名，一旦创建就不能被修改了。那么怎么获取这个对象的类型名呢？所谓”纯粹的对象”，就是说该对象是通过”{}“或”new Object”创建的。<br>js中提供了调用对象原型中的toString方法， Object.prototype.toString.call(obj)。因为很多对象继承的toString（）方法被重写了，为了能够调用正确的toString（）版本，也就是最原始的版本。可以使用Function.call()的方法。<br>其中call可以这么理解，相当于obj去借用这个 Object.prototype.toString()<br><strong>举个栗子~</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;,</span><br><span class="line">arr = [];</span><br><span class="line"></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>	<span class="comment">//false</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>	<span class="comment">//true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>	<span class="comment">//true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Object</span>	<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span></span><br><span class="line">var obj = &#123;&#125;,</span><br><span class="line">arr = [];</span><br><span class="line"></span><br><span class="line">obj.constructor === <span class="built_in">Object</span>	<span class="comment">//true</span></span><br><span class="line">arr.constructor === <span class="built_in">Object</span>	<span class="comment">//false</span></span><br><span class="line">obj.constructor === <span class="built_in">Array</span>	<span class="comment">//true！</span></span><br><span class="line">arr.constructor === <span class="built_in">Array</span>	<span class="comment">//false</span></span><br></pre></td></tr></table></figure>



      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-前端的单页面模式和多页面模式" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/03/07/%E5%89%8D%E7%AB%AF%E7%9A%84%E5%8D%95%E9%A1%B5%E9%9D%A2%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%9A%E9%A1%B5%E9%9D%A2%E6%A8%A1%E5%BC%8F/"
    >前端的单页面模式和多页面模式</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/03/07/%E5%89%8D%E7%AB%AF%E7%9A%84%E5%8D%95%E9%A1%B5%E9%9D%A2%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%9A%E9%A1%B5%E9%9D%A2%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-03-07T02:14:51.481Z" itemprop="datePublished">2020-03-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h2 id="思考动机"><a href="#思考动机" class="headerlink" title="思考动机"></a>思考动机</h2><p>前端部分的搭建，需要考虑使用哪种模式进行页面之间的跳转交互，<br>而项目内的页面交互，不可避免的需要相互之间的数据共享。</p>
<h2 id="模式选择"><a href="#模式选择" class="headerlink" title="模式选择"></a>模式选择</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTM4MzQ4OC8yMDE4MDcvMTM4MzQ4OC0yMDE4MDcxMjE3NDAwNTA3NS0xMjA1MTA1OTMzLnBuZw?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<blockquote>
<p>单页面模式（SPA  Single-page Application）：<br>只有一张Web页面的应用，是一种从Web服务器加载的富客户端，单页面跳转仅刷新局部资源 ，公共资源(js、css等)仅需加载一次<br>页面跳转：使用js中的append/remove或者show/hide的方式来进行页面内容的更换,或者使用框架。<br>数据传递：可通过全局变量或者参数传递，进行相关数据交互<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTM4MzQ4OC8yMDE4MDcvMTM4MzQ4OC0yMDE4MDcxMjE3NDAwNTA3NS0xMjA1MTA1OTMzLnBuZw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>多页面模式（MPA  Multi-page Application）：<br>多页面跳转需要刷新所有资源，每个公共资源(js、css等)需选择性重新加载<br>页面跳转：使用window.location.href = “./index.html”进行页面间的跳转；<br>数据传递：可以使用path?account=”123”&amp;password=””路径携带数据传递的方式，或者localstorage、cookie等存储方式</p>
</blockquote>
<blockquote>
<p>总结：<br>单页面模式：相对比较有优势，无论在用户体验还是页面切换的数据传递、页面切换动画，都可以有比较大的操作空间<br>多页面模式：比较适用于页面跳转较少，数据传递较少的项目中开发，否则使用cookie，localstorage进行数据传递，性能很不好。</p>
</blockquote>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="page/2/">2</a><a class="page-number" href="page/3/">3</a><a class="page-number" href="page/4/">4</a><a class="extend next" rel="next" href="page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2020
        Wangqiuxia
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    <aside class="sidebar">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="index.html"><img src="/images/ayer-side.svg" alt="爱产品，爱前端！"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="index.html">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%8A%80%E6%9C%AF/">小程序</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://shenyu-vip.lofter.com/" target="_blank" rel="noopener">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="https://v.xiumi.us/stage/v5/4IeLH/197507179" target="_blank" rel="noopener">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<script src="/js/share.js"></script>



<script src="fancybox/jquery.fancybox.min.js"></script>




<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['做一个有情怀懂产品的程序媛！','业精于勤荒于嬉！行成于思毁于随！','越努力越幸运'],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script>
  var ayerConfig = {
    mathjax: false
  }
</script>


<script src="js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=518895142&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>