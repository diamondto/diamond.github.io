<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     爱产品，爱前端！
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="css/style.css">

  
<script src="/js/pace.min.js"></script>


  

  

<link rel="alternate" href="atom.xml" title="爱产品，爱前端！" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/diamondto.github.io"
        target="_blank"><img width="149" height="149" src="images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="index.html">爱产品，爱前端！</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-React源码阅读笔记+链接分享" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/04/27/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0+%E9%93%BE%E6%8E%A5%E5%88%86%E4%BA%AB/"
    >阿里面试总结（十）——React源码阅读笔记+链接分享</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/04/27/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0+%E9%93%BE%E6%8E%A5%E5%88%86%E4%BA%AB/" class="article-date">
  <time datetime="2020-04-26T16:00:00.000Z" itemprop="datePublished">2020-04-27</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="categories/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">React源码阅读笔记</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>昨天晚上突然接到面试电话，是一个很有礼貌、很有趣的面试官哥哥，很耐心的听我balabala，小霞也要学会多多耐心倾听！<br>问题很全面啦，面完也翻了翻笔记，回顾了一些知识点，查漏补缺！<br>CSS部分是去年冬天学习的，纸质笔记，等有空了也来个博客整理！<br>小霞今天写一个很经典的问题，顺便宣传下阿里团队（此处有掌声！）出品的神奇小程序开发工具~<br>是我在阿里演讲中看到的~小伙伴们有兴趣可以去Github上研究研究！<br>小霞也加油学习，传承开源精神，小程序，大未来！</p>
<blockquote>
<p><strong>本文以setState同步异步的不同场景出发—&gt;<br>总结一下原生事件（同步）和合成事件（异步）的区别、用法—&gt;<br>如何搭配解决典型业务场景？—&gt;<br>要注意哪些坑？<br>福利：伟大的阿里团队出品Remax开发小程序啦！激不激动？开不开心？hhh!!!<br>小霞放上链接和官方文档，大家一起去最新的科技海洋遨游吧！</strong></p>
</blockquote>
<p><a href="https://remaxjs.org" target="_blank" rel="noopener">使用真正的React构建跨平台小程序！！</a></p>
<h2 id="一、setState异步？同步？"><a href="#一、setState异步？同步？" class="headerlink" title="一、setState异步？同步？"></a>一、setState异步？同步？</h2><p>1、 setState 只在合成事件和钩子函数中是“异步”的，<strong>相同的状态属性（不同的状态属性不会影响）多次更新会合并成一次，只保留最后一次。</strong></p>
<p> 2、<strong>在原生事件和setTimeout 中都是同步的，会依次更新。</strong></p>
<p>3、 setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩⼦函数中没法立马拿到更新后的值，形成了所谓的“异步”。<br>当然可以通过第二个参数 setState(partialState, callback) 中的 callback拿到更新后的结果。 </p>
<ul>
<li>通过setState去更新this.state，<strong>不要直接操作this.state</strong>，<strong>请把它当成不可变的。</strong></li>
<li>调用setState更新this.state不是马上生效的，它是异步哒，执行完setState后this.state不是最新的值哦。</li>
<li>多个<strong>顺序执行的setState不是同步地一个一个执行</strong>，而是会一个一个加入队列，然后最后一起执行，即<strong>批处理</strong>！</li>
</ul>
<p>4、setState 的<strong>批量更新优化</strong>也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新。</p>
<p>5、<strong>在“异步”中如果对同⼀个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200427233100321.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>setState之后发生的事情？</strong></p>
</blockquote>
<p>1、在官方的描述中，setState操作并不保证是同步的，也可以认为是异步的。<br>2、React在setState之后，<strong>会经对state进行diff，判断是否有改变</strong>，然后去<strong>diff dom决定是否要更新UI。</strong><br>3、如果这一系列过程立刻发生在每一个setState之后，就可能会有性能问题。<br>4、在短时间内频繁setState，React会将<strong>state的改变压入栈中，在合适的时机，批量更新state和视图</strong>，达到提高性能的效果。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为什么直接修改<span class="selector-tag">this</span><span class="selector-class">.state</span>无效？</span><br></pre></td></tr></table></figure>

<p>1、setState本质是通过一个<strong>队列机制实现state更新的。</strong><br>2、执行setState时，<strong>会将需要更新的state合并后放入状态队列，而不会立刻更新state</strong>，<strong>队列机制</strong>可以批量更新state。<br>3、<strong>如果不通过setState而直接修改this.state，那么这个state不会放入状态队列中，</strong>下次调用setState时对状态队列进行合并时，<strong>会忽略之前直接被修改的state</strong>，这样我们就无法合并了，也就是说没有把我们想要的state更新上去！</p>
<blockquote>
<p><strong>什么是批量更新 Batch Update？</strong></p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一些<span class="selector-tag">mv</span>*框架中，就是将一段时间内对**<span class="selector-tag">model</span>的修改批量更新到<span class="selector-tag">view</span>的机制**。</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/2020042723311197.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="批量更新！"></p>
<blockquote>
<p>两个Demo测试setState异步的小秘密</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// demo1</span><br><span class="line"><span class="selector-tag">class</span> <span class="selector-tag">App</span> <span class="selector-tag">extends</span> <span class="selector-tag">React</span><span class="selector-class">.Component</span> &#123;</span><br><span class="line">       state = &#123;</span><br><span class="line">         <span class="selector-tag">num</span>: 0</span><br><span class="line">      &#125;;</span><br><span class="line">       <span class="selector-tag">componentDidMount</span>() &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">          <span class="selector-tag">num</span>: <span class="selector-tag">this</span><span class="selector-class">.state</span><span class="selector-class">.num</span> + 1</span><br><span class="line">          &#125;);</span><br><span class="line">      <span class="selector-tag">this</span><span class="selector-class">.setState</span>(&#123;</span><br><span class="line">          <span class="attribute">num</span>: this.state.num + <span class="number">2</span></span><br><span class="line">        &#125;);</span><br><span class="line">         <span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">this</span><span class="selector-class">.state</span><span class="selector-class">.num</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="selector-tag">render</span>() &#123;</span><br><span class="line">         const &#123; num &#125; = this.state;</span><br><span class="line">         return &lt;div&gt;&#123; num &#125;&lt;/div&gt;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">控制台打印0，界面显示2</span><br><span class="line">由上面的例子得出结论1：</span><br><span class="line"></span><br><span class="line">在<span class="selector-tag">componentDidMount</span>这个生命周期函数的场景下，<span class="selector-tag">setState</span>是异步的，界面显示2表示对于相同的状态属性，界面显示会合并成一次，并且只有最后一次会生效，显示到界面上就是加了两次的2。</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// demo2</span><br><span class="line"><span class="selector-tag">class</span> <span class="selector-tag">App</span> <span class="selector-tag">extends</span> <span class="selector-tag">React</span><span class="selector-class">.Component</span> &#123;</span><br><span class="line">       state = &#123;</span><br><span class="line">         <span class="selector-tag">num</span>: 0</span><br><span class="line">      &#125;;</span><br><span class="line">     handleClick = () =&gt; &#123;</span><br><span class="line">         <span class="selector-tag">this</span><span class="selector-class">.setState</span>(&#123;</span><br><span class="line">           <span class="attribute">num</span>: this.state.num + <span class="number">1</span></span><br><span class="line">        &#125;);</span><br><span class="line">         <span class="selector-tag">this</span><span class="selector-class">.setState</span>(&#123;</span><br><span class="line">           <span class="attribute">num</span>: this.state.num + <span class="number">2</span></span><br><span class="line">        &#125;);</span><br><span class="line">         console.log(this.state.num); // 点击num控制台打印0,界面显示2</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="selector-tag">render</span>() &#123;</span><br><span class="line">        const &#123; num &#125; = this.state;</span><br><span class="line">        return &lt;div onClick=&#123;this.handleClick&#125;&gt;&#123; num &#125;&lt;/div&gt;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第二个例子我给<span class="selector-tag">div</span>注册了一个<span class="selector-tag">click</span>事件，界面渲染之后，<span class="selector-tag">num</span>显示为0，点击之后显示是2，控制台打印是0。</span><br><span class="line"></span><br><span class="line">结论2：这里的<span class="selector-tag">onClick</span>事件并不是<span class="selector-tag">JS</span>原生的事件，而是<span class="selector-tag">React</span>的合成事件，合成事件就是通过<span class="selector-tag">JSX</span>绑定的事件，合成事件中<span class="selector-tag">React</span>的<span class="selector-tag">setState</span>也是异步的。</span><br></pre></td></tr></table></figure>


<h2 id="二、合成事件的机制！"><a href="#二、合成事件的机制！" class="headerlink" title="二、合成事件的机制！"></a>二、合成事件的机制！</h2><p><strong>合成事件的绑定：</strong></p>
<p>1、React基于虚拟DOM实现了一个<strong>合成事件层</strong>，我们所定义的事件处理器会接收到一个合成事件对象的实例，它完全符合 W3C 标准，不会存在任何IE标准的兼容问题。并且与原生浏览器具有一样的接口，<strong>同样支持事件冒泡机制，可用 stopPropagation() 和 preventDefault() 来中断它。</strong></p>
<p>2、<strong>所有事件都自动绑定在最外层上。</strong>如果需要访问原生事件对象，可以使用nativeEvent属性。也就是说—&gt;React并不是将click事件直接绑定到div的真实DOM上面。<strong>（因为DOM上面绑定了太多的事件处理函数，整个页面的响应和内存占用都可能受到影响）</strong></p>
<p>3、在document处监听所有支持的事件，<strong>当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。</strong></p>
<p>4、冒泡机制的流程就是从触发事件的对象开始，向父元素回溯，<strong>依次调用它们注册事件的callback。</strong></p>
<p>5、这种绑定方式和与原生HTML事件监听很相似。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div onClick=&#123;this.handleClick&#125;&gt;点我呀！&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">但有以下区别：</span><br><span class="line"></span><br><span class="line">(1)事件处理函数是一个函数，而不是像原生事件那样的函数名称。</span><br><span class="line"></span><br><span class="line">(2) <span class="selector-tag">JSX</span>中采用驼峰式属性命名方式，<span class="selector-tag">HTML</span>事件则是全部小写：<span class="selector-tag">onclick</span>。</span><br><span class="line"></span><br><span class="line">(3) JSX中props的值可以是任意类型，但HTML 中只能是字符串：onclick="handleClick()"</span><br><span class="line"></span><br><span class="line">(4) <span class="selector-tag">React</span>事件没有直接绑定在 <span class="selector-tag">HTML</span> 元素上只是借鉴了这种写法。<span class="selector-tag">React</span>中所有事件使用了事件委托方式自动绑定在最外层的。</span><br></pre></td></tr></table></figure>


<p><strong>合成事件的实现机制：</strong></p>
<p>1、<strong>为了避免DOM事件滥用—&gt;React实现了一个中间层SyntheticEvent。</strong></p>
<p>SyntheticEvent对象是通过<strong>合并</strong>得到的，在事件回调被调用之后，<strong>SyntheticEvent对象将被重用、并且所有属性都会被取消。这时候，我们是没有办法以异步的方式访问该事件的。</strong></p>
<p>(也就是说event对象是复用的，事件处理函数执行完后，属性会被清空，所以event的属性无法被异步访问，详情请查阅event-pooling。)</p>
<blockquote>
<p>解决办法：官方指出–&gt;如果想要以异步的方式访问事件属性，应该对事件调用event.persist()，这将从池中删除合成事件，并允许用户代码保留对事件的引用。</p>
</blockquote>
<p>2、当用户在为onClick添加函数时，React并没有将Click事件直接绑定到真实的DOM节点上，<strong>而是在document监听所有支持的事件，</strong>当事件发生并冒泡到document处，完成了事件委派的任务。</p>
<p>3、<strong>React将事件内容封装交给中间层SyntheticEvent，这个中间层就负责所有事件合成</strong>，它维持了一个<strong>映射来保存所有组件内部的事件监听和处理。</strong></p>
<p>4、当组件在<strong>挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象；</strong>当事件发生时，首先被这个统一的事件监听器处理，然后在<strong>映射里找到真正的事件处理函数并调用</strong>。这样<strong>简化了事件处理和回收机制，提升了效率</strong>。<br><strong>事件触发的时候，会使用统一的分发函数dispatchEvent将指定函数执行。</strong></p>
<p><strong>简单梳理一下就是：</strong></p>
<blockquote>
<p>事件注册：</p>
<p>（1）将事件注册到 document 这个原生DOM上</p>
<p>（2）将注册的事件采用事务队列的形式存储起来，以便事件触发时回调。</p>
<p>事件分发：通过 ReactEventListener.dispatchEvent 回调函数实现。</p>
<p>事件触发：</p>
<p>（1）document上 addEventListener 注册的 callback 会被回调。</p>
<p>（2）回调函数就是ReactEventListener.dispatchEvent。</p>
<p>（3）dispatchEvent会找到事件触发的 DOM 及其对应的 React 组件。</p>
</blockquote>
<h2 id="三、-React中原生事件是什么？"><a href="#三、-React中原生事件是什么？" class="headerlink" title="三、 React中原生事件是什么？"></a>三、 React中原生事件是什么？</h2><p>首先，要明白！流是一种有方向的数据；事件流，是页面接受事件的顺序。</p>
<p><strong>一、DOM事件流的三个阶段</strong></p>
<p><strong>1、事件捕获阶段</strong></p>
<p>当某个事件触发时—&gt;文档根节点最先接受到事件—&gt;然后根据DOM树结构向具体绑定事件的元素传递—&gt;该阶段为父元素截获事件提供了机会。</p>
<p>事件传递路径为：</p>
<p><strong>window —&gt; document —&gt; boy —&gt; button</strong></p>
<p><strong>2、目标阶段</strong></p>
<p> 具体元素已经捕获事件—&gt;之后事件开始向<strong>根节点</strong>冒泡。</p>
<p><strong>3、事件冒泡阶段</strong></p>
<p>该阶段的开始即是事件的开始—&gt;根据<strong>DOM树结构由具体触发事件的元素向根节点传递。</strong>    </p>
<p><strong>事件传递路径：</strong></p>
<p>button —&gt; body —&gt; document —&gt; window</p>
<p><strong>4、选择监听事件的阶段</strong></p>
<p>使用addEventListener函数在<strong>事件流的的不同阶段监听事件。</strong></p>
<p>DOMEle.addEventListener(‘事件名称’,handleFn,Boolean)。</p>
<p>此处第三个参数Boolean即代表监听事件的阶段。</p>
<p><strong>为true时，在在捕获阶段监听事件，执行逻辑处理。<br>为false时，在冒泡阶段监听事件，执行逻辑处理。</strong></p>
<blockquote>
<p><strong>什么场景使用原生事件？</strong></p>
</blockquote>
<p>虽然React封装了几乎所有的原生事件，但诸如：</p>
<p>谈话框开启以后点其他空白区域需要关闭谈话框。</p>
<p><strong>引入了一些以原生事件实现的第三方库，并且相互之间需要有交互。</strong></p>
<p>等等场景时，不得不使用原生事件来进行业务逻辑处理。</p>
<p><strong>由于原生事件需要绑定在真实DOM上！</strong></p>
<p>**</p>
<blockquote>
<p>所以一般是在componentDidMount阶段/ref的函数执行阶段进行绑定操作，在componentWillUnmount阶段进行解绑操作以避免内存泄漏。</p>
</blockquote>
<p>**</p>
<p>使用如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">class</span> <span class="selector-tag">Demo</span> <span class="selector-tag">extends</span> <span class="selector-tag">React</span><span class="selector-class">.PureComponent</span> &#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        const $this = ReactDOM.findDOMNode(this)</span><br><span class="line">        $this.addEventListener('click', this.onDOMClick, false)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    onDOMClick = evt =&gt; &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="selector-tag">render</span>() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;Demo&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开发项目总结：混合使用要注意什么？</p>
<p>注意!!!</p>
<p>1、合成事件的监听器是统一注册在document上的，<strong>且仅有冒泡阶段。</strong></p>
<p>所以原生事件的监听器响应总是比合成事件的监听器早。</p>
<p>2、阻<strong>止 React 合成事件冒泡，并不能阻止原生事件的冒泡，就算使用 stopPropagation 也无法阻止原生事件的冒泡。</strong></p>
<p><strong>React 自身实现了一套事件冒泡机制，所以这也就是为什么我们 event.stopPropagation() 无效的原因。</strong></p>
<p>3、<strong>阻止原生事件的冒泡后，会阻止合成事件的监听器执行。</strong></p>
<p>也就是说，取消原生事件的冒泡也会同时取消 React 事件，并且原生事件的冒泡在 React 事件的触发和冒泡之前。</p>
<p>4、对于原生事件，一定要手动移除，否则很可能出现内存泄漏的问题。</p>
<p><strong>5、一般在componentDidMount() 方法中注册原生事件。<br>  6、一般在componentWillUnmount() 方法中移除事件。</strong></p>
<blockquote>
<p>典型需求分析：</p>
</blockquote>
<p>功能：页面弹出对话框，点击页面其他位置需要隐藏该对话框，点击对话框本身不隐藏。</p>
<p>分析：我们会在document上加上addEventListener，在触发的页面框时，使用stopPropagation。</p>
<p>但是！将事件添加到document对象，未达预期<br>原因：阻止 React 合成事件冒泡，并不能阻止原生事件的冒泡。</p>
<p>当我们点击其他空白区域时，移除监听器隐藏对话框，<strong>但是点击对话框时，如果不阻止冒泡，会导致父级触发监听器，隐藏对话框。</strong></p>
<p><strong>把事件添加到document对象时，是React的合成事件，并不能阻止原生的冒泡行为。</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">export default () =&gt; &#123;</span><br><span class="line">    const clickListener = e =&gt; &#123;</span><br><span class="line">        <span class="selector-tag">console</span><span class="selector-class">.log</span>("<span class="selector-tag">clickListener</span>")</span><br><span class="line">    &#125;</span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">              //使用事件冒泡模型</span><br><span class="line">        <span class="selector-tag">document</span><span class="selector-class">.addEventListener</span>("<span class="selector-tag">click</span>", <span class="selector-tag">clickListener</span>, <span class="selector-tag">false</span>)</span><br><span class="line">        return () =&gt; document.removeEventListener("click", clickListener, false)</span><br><span class="line">    &#125;, <span class="selector-attr">[]</span>)</span><br><span class="line"></span><br><span class="line">    const handleClick = e =&gt; &#123;</span><br><span class="line">        <span class="selector-tag">e</span><span class="selector-class">.stopPropagation</span>()</span><br><span class="line">        <span class="selector-tag">console</span><span class="selector-class">.log</span>("<span class="selector-tag">click</span>")</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;button onClick=&#123;e =&gt; handleClick(e)&#125;&gt;test click&lt;/button&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将事件添加到window对象上，达到预期</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">export default () =&gt; &#123;</span><br><span class="line">    const clickListener = e =&gt; &#123;</span><br><span class="line">        <span class="selector-tag">console</span><span class="selector-class">.log</span>("<span class="selector-tag">clickListener</span>")</span><br><span class="line">    &#125;</span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">              //使用事件冒泡模型</span><br><span class="line">        <span class="selector-tag">window</span><span class="selector-class">.addEventListener</span>("<span class="selector-tag">click</span>", <span class="selector-tag">clickListener</span>, <span class="selector-tag">false</span>)</span><br><span class="line">        return () =&gt; window.removeEventListener("click", clickListener, false)</span><br><span class="line">    &#125;, <span class="selector-attr">[]</span>)</span><br><span class="line"></span><br><span class="line">    const handleClick = e =&gt; &#123;</span><br><span class="line">        <span class="selector-tag">e</span><span class="selector-class">.stopPropagation</span>()</span><br><span class="line">        <span class="selector-tag">console</span><span class="selector-class">.log</span>("<span class="selector-tag">click</span>")</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;button onClick=&#123;e =&gt; handleClick(e)&#125;&gt;test click&lt;/button&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因：<strong>取消原生事件的冒泡也会同时取消 React 事件，并且原生事件的冒泡在 React 事件的触发和冒泡之前。</strong></p>
<p>代码分析：使用原生事件冒泡模型，最终事件会冒泡到window对象上，我们在window对象上添加事件监听，button的click事件会代理到document上执行，因为添加了stopPropagation，因此不会再向上冒泡到window了，也就不会触发window的的click事件。</p>
<p>响应顺序的典型例子<br>下面例子中点击Demo以后，控制台输出会是怎样的？</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">class</span> <span class="selector-tag">Demo</span> <span class="selector-tag">extends</span> <span class="selector-tag">React</span><span class="selector-class">.PureComponent</span> &#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        const $this = ReactDOM.findDOMNode(this)</span><br><span class="line">        $this.addEventListener('click', this.onDOMClick, false)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    onDOMClick = evt =&gt; &#123;</span><br><span class="line">        console.log('dom event')</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    onClick = evt =&gt; &#123;</span><br><span class="line">        console.log('react event')</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="selector-tag">render</span>() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div onClick=&#123;this.onClick&#125;&gt;Demo&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先DOM事件监听器被执行—&gt;然后事件继续冒泡至document—&gt;合成事件监听器再被执行。最终控制台输出为：</p>
<p>dom event<br>react event<br>如果在onDOMClick中调用evt.stopPropagtion()呢？</p>
<p>由于DOM事件被阻止冒泡了—&gt;无法到达document—&gt;所以合成事件自然不会被触发，控制台输出就变成了：dom event</p>
<p>来一个复杂例子！</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">class</span> <span class="selector-tag">Demo</span> <span class="selector-tag">extends</span> <span class="selector-tag">React</span><span class="selector-class">.PureComponent</span> &#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        const $parent = ReactDOM.findDOMNode(this)</span><br><span class="line">        const $child = $parent.querySelector('.child')</span><br><span class="line"> </span><br><span class="line">        $parent.addEventListener('click', this.onParentDOMClick, false)</span><br><span class="line">        $child.addEventListener('click', this.onChildDOMClick, false)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    onParentDOMClick = evt =&gt; &#123;</span><br><span class="line">        console.log('parent dom event')</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    onChildDOMClick = evt =&gt; &#123;</span><br><span class="line">        console.log('child dom event')</span><br><span class="line">    &#125;    </span><br><span class="line"> </span><br><span class="line">    onParentClick = evt =&gt; &#123;</span><br><span class="line">        console.log('parent react event')</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    onChildClick = evt =&gt; &#123;</span><br><span class="line">        console.log('child react event')</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="selector-tag">render</span>() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div onClick=&#123;this.onParentClick&#125;&gt;</span><br><span class="line">                &lt;div className="child" onClick=&#123;this.onChildClick&#125;&gt;</span><br><span class="line">                    <span class="selector-tag">Demo</span></span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在onChildClick中调用evt.stopPropagtion()，则控制台输出变为：</p>
<p>child dom event<br>parent dom event<br>child react event</p>
<p>这样的结果是因为React给合成事件封装的stopPropagtion函数在调用时：</p>
<p>给自己加了个isPropagationStopped标记位来确定后续监听器是否执行！</p>
<p>上源码！！</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// https://github.com/facebook/react/blob/src/renderers/shared/stack/event/EventPluginUtils.js</span><br><span class="line">for (var i = 0; i &lt; dispatchListeners.length; i++) &#123;</span><br><span class="line">  <span class="selector-tag">if</span> (<span class="selector-tag">event</span><span class="selector-class">.isPropagationStopped</span>()) &#123;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">  // Listeners and Instances are two parallel arrays that are always in sync.</span><br><span class="line">  <span class="selector-tag">if</span> (<span class="selector-tag">dispatchListeners</span><span class="selector-attr">[i]</span>(<span class="selector-tag">event</span>, <span class="selector-tag">dispatchInstances</span><span class="selector-attr">[i]</span>)) &#123;</span><br><span class="line">    return dispatchInstances[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">stopImmediatePropagation</span></span><br></pre></td></tr></table></figure>

<p>1、stopImmediatePropagation常常在多个第三方库混用时，<strong>用来阻止多个事件监听器中的非必要执行。</strong></p>
<p>2、但React体系中，<strong>一个组件只能绑定一个同类型的事件监听器。</strong><br>（重复定义时，后面的监听器会覆盖之前的)，所以合成事件甚至都不去封装stopImmediatePropagation。</p>
<p>3、事实上nativeEvent的stopImmediatePropagation<strong>只能阻止绑定在document上的事件监听器。</strong></p>
<p>有点累了，明天继续！</p>
<p>程序媛像个妈妈，管着一群调皮的小朋友，既要顾全大局还有考虑边界条件</p>
<p>程序媛是啥？上帝角色！运筹帷幄，操控芸芸众生~</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E5%8D%87%E7%BA%A7%E6%89%93%E6%80%AAReact/" rel="tag">升级打怪React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E5%BC%80%E6%BA%90%E6%96%B0%E6%8A%80%E6%9C%AF%E3%80%81%E6%96%B0%E5%8F%91%E7%8E%B0%EF%BC%81/" rel="tag">开源新技术、新发现！</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-朝花夕拾集 (1)" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/04/26/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE%E9%9B%86%20(1)/"
    >阿里面试总结（九）——朝花夕拾集</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/04/26/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE%E9%9B%86%20(1)/" class="article-date">
  <time datetime="2020-04-25T16:00:00.000Z" itemprop="datePublished">2020-04-26</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE%E9%9B%86/">朝花夕拾集</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>周末抽空重温一下马云大大的演讲！<br>看完演讲，小霞明白了一个道理~<br>为什么阿里巴巴每个人都要有一个花名呢？<br>因为花名让阿里人充满了<strong>修身、齐家、治国、平天下</strong>的责任感！<br>我们每一个人都要有武侠情怀！<br><strong>武侠情怀是一种舍我其谁的勇敢担当；</strong><br><strong>武侠情怀是一种普渡众生的大气胸襟；</strong><br><strong>武侠情怀是一种大义凌然的淡定决绝；</strong><br>人生短暂，带上花名和武侠情怀，有梦就勇敢去追！<br>如果可以，小霞想取名花木兰！ 巾帼不让须眉~<br>小霞周末收集了一些看书时感动的句子，整理如下文，希望您有所共鸣~</p>
<p><a href="https://www.bilibili.com/video/BV1cb411q7hw?p=25" target="_blank" rel="noopener">马云大大的演讲集合！周末回看，莫名感动！希望您有所收获！25岁之前小霞和您一起敢想敢做！点链接可以播放哦，空闲时间听听演讲，获益匪浅哦~</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200427231104526.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="一、影响力"><a href="#一、影响力" class="headerlink" title="一、影响力"></a>一、影响力</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上鲜活例证——名人谈影响力！</span><br></pre></td></tr></table></figure>

<p>1、我没有太多优势，我会利用影响力。 —— 李湘</p>
<p>2、成名之后，马云爸爸在回答记者“迄今对你影响最大的人是谁？”的提问时，这样回答：“我觉得影响我的人挺多的，在不同阶段有不同的人影响我。</p>
<p>  路遥的《人生》影响过我，</p>
<p>  金庸的《笑傲江湖》影响过我，</p>
<p>《阿甘正传》里面简单的阿甘影响过我，</p>
<p>《排球女将》中的小鹿纯子影响过我，</p>
<p>  还有我的父母、我的老师、我的朋友，他们都影响过我。</p>
<p><strong>但是，我认为在这个世界上，没有一个人能完全影响你，重要的是你能从每一个影响过你的人身上找到各种机会，然后不断学习，从而反过来影响别人。</strong>”</p>
<p>3、如果你有行动力，你就会成功；如果你有创造力，你就会卓越；<strong>如果你有影响力，你就会有成就。</strong> —— 牛根生</p>
<p>4、<strong>人际关系最重要最重要的方法就是真正的、诚恳地去关心别人。这个影响力是很大的。</strong> —— 陈安之</p>
<p>5、权力（power），定位（positioning），表现（performance）和礼貌（politeness），认知（perception）。<br>     五个P可以帮助你提高说服别人的能力。</p>
<blockquote>
<p><strong>精选触动小霞的101条影响力管理语录，希望您有收获！</strong> </p>
</blockquote>
<pre><code>1、每一分每一秒做最有生命力的事情。
2、一日之计在于昨天。
3、一开始就冲刺。</code></pre><p>　　4、一次性就将事情做对。<br>　　5、<strong>做对的事情，而不仅仅把事情做好。</strong><br>　　6、客户就是裁判。<br>　　7、我们不用语言教学，用心灵撞击心灵。<br>　　8、先处理心情，再处理事情。<br>　　9、<strong>立场要坚定、态度要热情。</strong><br>　　10、节约一块钱比赚一块钱来的容易。<br>　　11、成功一定有办法，失败一定有原因。<br>　　12、思路决定出路。<br>　　13、持续改善。<br>　　14、无限接近缺陷。<br>　　15、希望别人怎样对待自己，就怎么对待别人。<br>　　16、完成本职工作，就是对队友最大的支持。<br>　　17、坚持到底，永不放弃。<br>　　18、<strong>简单的工作练到极致，就是绝招。</strong><br>　　19、说到听者想听，听到说者想说。<br>　　20、高明的领导者领导员工的思维，不高明的领导看管员工的行为。<br>　　21、培训很贵，不培训更贵。<br>　　22、人是企业竞争致胜的第一资本。<br>　　23、学习是企业的第二生产力。<br>　　24、<strong>学习是最赚钱的投资。</strong><br>　　25、小公司做事，大公司“做”人。<br>　　26、<strong>行动力来源：追求快乐，逃离痛苦。</strong><br>　　27、<strong>事物本身并不影响人，人们只受对事物看法的影响。</strong><br>　　28、不是失败，只是暂时没有成功。<br>　　29、命运在自己的手里，而不是在别人的嘴里。<br>　　30、我一定要，我一定能。<br>　　31、爱是一切动力的源泉。<br>　　32、<strong>自由代价是自律。</strong><br>　　33、自信不一定成功，但不自信铁定离成功更远。<br>　　34、目标决定现实，而不是现实决定目标。<br>　　35、<strong>“为何”比“如何”更重要。</strong><br>　　36、<strong>大目标是小目标的结果，小目标是大目标的条件。</strong><br>　　37、<strong>修订计划，而不是改变目标。</strong><br>　　38、<strong>成功者的第一反应：找方法，而不是找借口。</strong><br>　　39、所有的限制，一开始来源于自我设限。<br>　　40、人与人之间的差别，一开始在于思考问题的方式不同。<br>　　41、21天改变命运。<br>　　42、我们不改变坏习惯，坏习惯将控制我们一生。<br>　　43、将练习当成比赛。<br>　　44、将汗水流在练习场上，而不要将泪水流在竞技场上。<br>　　45、比裁判更加严格的要求你的队员。<br>　　46、你越努力，你的运气越好。<br>　　47、跟什么人在一起，就将成为什么人。<br>　　48、<strong>只要不服输，失败就不会是定局。</strong><br>　　49、目标就是你未来的现实。<br>　　50、成功就是简单的事情重复去做。<br>　　51、成功是因为态度。<br>　　52、我是我认为的我。<br>　　53、我是一切的根源。<br>　　54、不是不可能。<br>　　55、山不过来我就过去。<br>　　56、<strong>每天进步一点点。</strong><br>　　57、决心决定成功。<br>　　58、天助自助者。<br>　　59、太棒了。<br>　　60、成功的捷径就是按最有效的成功策略行驶，用错方法就是走弯路。<br>　　61、<strong>活在当下，把握今天。</strong><br>　　62、把眼前的事情做到最好。<br>　　63、<strong>动作对了，结果迟早会对。</strong><br>　　64、不是成功太慢，而是放弃太快。<br>　　65、劳心者治人，劳力者治于人。<br>　　66、<strong>用心做人，用脑做事。</strong><br>　　67、做你所写，写你所做。<br>　　68、按劳动的结果分配，而不是劳累的程度分配。<br>　　69、<strong>学者的任务把简单问题复杂化；管理者的任务把复杂的问题简单化。</strong><br>　　70、好的制度让坏人变好；不好的制度让好人变坏。<br>　　71、教不会徒弟，饿死师傅。<br>　　72、沟通要充分，决定要服从。<br>　　73、解决问题，不要放大问题。<br>　　74、<strong>好消息向下传，坏消息向上传。</strong><br>　　75、当面说，不要背后说；会上说，不要会后乱说。<br>　　76、量大，一定有质优。<br>　　77、<strong>不是没有伯乐，而是我们是不是一匹真正的千里马。</strong><br>　　78、员工可以跳槽，老板只是跳楼。<br>　　79、为自己留后路，你十有八九走后路。<br>　　80、经常走后路，一定是绝路。<br>　　81、进一步海阔天空。<br>　　82、贫者因学习而富，富者因学习而强。<br>　　83、<strong>如果事情无法改变，就改变自己。</strong><br>　　84、做手心向下的人。<br>　　85、与强者竞争，更容易成为强者。<br>　　86、只能授出任务，无法授出责任。责任由授权者承担。<br>　　87、管理者的核心任务：修路，而不是“修”人。<br>　　88、管理，“消灭”形容词。（以量词来计量工作）<br>　　89、让“傻瓜”都能做对。<br>　　90、缺少任何一个人，都能保证组织正常运转。<br>　　91、不是收入太少，而是贡献不够。<br>　　92、<strong>我们需要英雄，因为英雄可以带动团队；我们更需要团队，因为团队可以创造更多英雄。</strong><br>　　93、在运动中改变。<br>　　94、管理者就是培训者。<br>　　95、只问问题，不“给”答案。<br>　　96、延迟评判。<br>　　97、以事实为依据，不要“想当然”。<br>　　98、<strong>制定目标，从未来到现在；达成目标，从现在到未来。</strong><br>　　99、路径很明确，路途很漫长。<br>　　100、100%成功=100%意愿<em>100%方法</em>100%行动<br>　　101、<strong>有梦想就会实现！</strong><br>　　<img src="https://img-blog.csdnimg.cn/20200427231127145.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="二、《千与千寻》"><a href="#二、《千与千寻》" class="headerlink" title="二、《千与千寻》"></a>二、《千与千寻》</h2><p>1、<strong>不管前方的路有多苦，只要走的方向正确，不管多么崎岖不平，都比站在原地更接近幸福。</strong><br>2、我不知道将去何方，但我已在路上。<br>3、人们常常会欺骗你，是为了让你明白，有时候，你唯一应该相信的人就是你自己。<br>4、这个世界真的很现实，每个人都在为着同一个目的，不惜一切代价努力着，心甘情愿的成为金钱的奴隶，死心蹋地的付出。<br>5、<strong>请记得那些对你好的人，因为他本可以不这样。</strong><br>6、这世上有一条路无论如何也不能走，那就是歧途，只要走错一步结果都会是粉身碎骨。<br>7、人生就是一列开往坟墓的列车，路途上会有很多站，很难有人可以自始至终陪着走完。当陪你的人要下车时，即使不舍也该心存感激，然后挥手道别。<br>8、<strong>再辛苦也要忍耐等待时机。</strong><br>9、再漫长的故事，也有完结的时候，行驶的再慢的列车，也有一个又一个的站台；再亲密无间的旅伴，也有分开的时候。旅途上经历的事情 ，可能会被我们遗忘；旅途上学到的东西，我们却会将它记在心间。因为遇见你，我才知道我也能拥有美丽的记忆。<strong>所以，无论你怎么对待我，我都会用心去宽恕你的恨，用心去铭记你的好。</strong><br>10、<strong>有一天那个人走进了你的生命，你就会发现，真爱总是值得等待。</strong><br>11、<strong>人总要走在路上，才能扶着自己成长。</strong><br>12、要好好珍惜自己的名字：<strong>记得自己是谁，便知道自己要做什么，要走什么样的路。</strong><br>13、<strong>幸福是靠自己争取的，或许这个过程会很艰辛很艰难，但总比站在原地等待要好。</strong><br><img src="https://img-blog.csdnimg.cn/20200427231144561.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="三、《哈尔的移动城堡》"><a href="#三、《哈尔的移动城堡》" class="headerlink" title="三、《哈尔的移动城堡》"></a>三、《哈尔的移动城堡》</h2><p>1、<strong>世界这么大，人生这么长，总会有这么一个人，让你想要温柔地对待。</strong><br>2、人哪有好的 只是坏的程度不一样而已。<br>3、人老了的好处，就是可失去的东西越来越少了.<br>4、<strong>被一个人深深地爱著将给你力量；深深地爱著一个人将给你勇气。</strong><br>5、<strong>爱，不是寻找一个完美的人，而是学会用完美的眼光，欣赏那个并不完美的人。</strong><br><img src="https://img-blog.csdnimg.cn/20200427231158166.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="四、《悬崖上的金鱼姬》"><a href="#四、《悬崖上的金鱼姬》" class="headerlink" title="四、《悬崖上的金鱼姬》"></a>四、《悬崖上的金鱼姬》</h2><p>1、成长，是每个孩子的权力，也是他们必经的征程，或平坦、或崎岖，有悲欢，有离合。<br>2、<strong>信仰到底是什么呢？就是纵身一跃，就是我们跟神之间一个永远的约定，是舍弃旧的去开始新的生活。</strong><br>3、现在这个家就像暴风雨中的灯塔，黑暗中的人们都依靠着这个光芒，为他们指引方向。<br>4、<strong>爱是需要付出代价，爱是需要担当，爱是需要努力争取，爱是需要你为了对方而放弃一些事情，并改变自己。</strong><br><img src="https://img-blog.csdnimg.cn/20200427231212612.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="五、《魔女宅急便》"><a href="#五、《魔女宅急便》" class="headerlink" title="五、《魔女宅急便》"></a>五、《魔女宅急便》</h2><p>1、<strong>只有一个人在旅行时，才听得到自己的声音，它会告诉你，这世界比想象中的宽阔。</strong><br>2、<strong>成长是一笔交易，我们都是用朴素的童真与未经人事的洁白交换长大的勇气。</strong><br>3、在这个世界上别太依赖任何人，因为当你在黑暗中挣扎时，连你的影子都会离开你。<br>4、不要对外表过分在意，心灵才是最重要的。<br>5、<strong>学会承受，学会长大，学会哭过以后，还能微笑地拥抱爸爸妈妈。</strong><br>6、大部分人随着年纪变大，身上的担子也变强壮了，能负担起更多的事：埋怨啊、不安啊、失落啊…这些东西不是说不痛了、不难过了。只是担子大了就能装下，然后就默默地挑走。<br><img src="https://img-blog.csdnimg.cn/20200427231227241.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="六、《幽灵公主》"><a href="#六、《幽灵公主》" class="headerlink" title="六、《幽灵公主》"></a>六、《幽灵公主》</h2><p>1、我想以没有仇恨的眼睛看世界。不管你曾经被伤害得有多深，总会有一个人的出现，让你原谅之前生活对你所有的刁难。<br>2、<strong>到不了的地方都叫做远方，回不去的世界都叫做家乡，我一直向往的却是比远方更远的地方。</strong><br>3、想要拥有天地间所有的东西，是人类的天性也就是罪孽。<br>4、命运是任何人也无法改变的，但他可以决定是等死还是面对。<br>5、<strong>我想用澄净的眼光，看清楚事实真相再做决定。</strong><br><img src="https://img-blog.csdnimg.cn/20200427231243181.jpg#pic_center" alt="在这里插入图片描述"></p>
<h2 id="七、《龙猫》"><a href="#七、《龙猫》" class="headerlink" title="七、《龙猫》"></a>七、《龙猫》</h2><p>1、<strong>生活坏到一定程度就会好起来，因为它无法更坏。努力过后，才知道许多事情，坚持坚持，就过来了。</strong><br>2、认清这个世界，然后爱它。就这么一辈子，下一世你可能就不在这个世界了。有些烦恼，丢掉了，才有风轻云淡的机会。<br>3、<strong>当你无法再拥有时，你唯一能做的就是不要再忘记</strong><br>4、<strong>没问题的，别担心，一切都会好的.</strong><br>5、<strong>人生的某些障碍，你是逃不掉的。与其费尽周折绕过去，不如勇敢的地攀越，或许这会铸就你人生的高点。</strong><br>6、<strong>不要害怕孤独。因为这个世界上，肯定有一个人，正努力的走向你。</strong><br>7、<strong>不要着急，最好的总在不经意之间出现。</strong><br>8、<strong>拥抱是世界上最美的语言。</strong><br>9、<strong>大声的笑出来，就不害怕了。</strong><br><img src="https://img-blog.csdnimg.cn/20200427231258850.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="八、《天空之城》"><a href="#八、《天空之城》" class="headerlink" title="八、《天空之城》"></a>八、《天空之城》</h2><p>1、越是试着忘记，越是记得深刻。<br>2、<strong>有时候，坚持了你最不想干的事情之后，便可得到你最想要的东西。</strong><br>3、我们的孤独，就像天空中的一座城市，仿佛是一个秘密，却无从诉说。<br><img src="https://img-blog.csdnimg.cn/20200427231311570.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="九、《风之谷》"><a href="#九、《风之谷》" class="headerlink" title="九、《风之谷》"></a>九、《风之谷》</h2><p>1、<strong>最远的旅行，是从自己的身体到自己的心，是从一个人的心到另一个人的心。</strong><br>2、人类，就是一直在重复过去的道路。每个人都认为自己是对的，然后就由罪恶衍生出更多的罪恶，悲哀衍生出更多的悲哀，永远找不到出路。<br>3、坚强，不是面对悲伤不流一滴泪，而是擦乾眼泪后微笑著面对以后的生活。<br>4、<strong>生命是黑暗中闪烁的光。</strong><br>5、只要活着，就有希望。<br><img src="https://img-blog.csdnimg.cn/20200427231326628.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="十、写在最后"><a href="#十、写在最后" class="headerlink" title="十、写在最后"></a>十、写在最后</h2><p>“朝花夕拾”语录，简约而不简单，<strong>世事纷繁，收集点点滴滴的感动！</strong><br><strong>小霞愿和您一起穿越人潮拥挤、改变自己、影响他人、未来可期，定会遇见更好的自己、更美的明天！</strong></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E4%BF%AE%E8%BA%AB%E3%80%81%E9%BD%90%E5%AE%B6%E3%80%81%E6%B2%BB%E5%9B%BD%E3%80%81%E5%B9%B3%E5%A4%A9%E4%B8%8B/" rel="tag">修身、齐家、治国、平天下</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E5%B0%8F%E9%9C%9E%E6%84%9F%E5%8A%A8%E7%9A%84%E4%BA%8B/" rel="tag">小霞感动的事</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-每日十题系列（一）" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/04/25/%E6%AF%8F%E6%97%A5%E5%8D%81%E9%A2%98%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/"
    >经典算法系列（一）</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/04/25/%E6%AF%8F%E6%97%A5%E5%8D%81%E9%A2%98%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/" class="article-date">
  <time datetime="2020-04-24T16:00:00.000Z" itemprop="datePublished">2020-04-25</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>记录一下二刷数据结构与算法的回顾梳理，经典的东西是解决问题的根本呀<br>每天收集好十题并手撸一下，时常回顾。<br>二刷时多看看别人的思路，寻找最优的解法。<br>计划每天十题，第一天写了三个多小时，enenen后面动态规划地去调整hhh!<br>扶朕起来，朕还能学。。。</p>
<h4 id="一、请把俩个数组-A1-A2-B1-B2-C1-C2-D1-D2-和-A-B-C-D-，合并为-A1-A2-A-B1-B2-B-C1-C2-C-D1-D2-D-。"><a href="#一、请把俩个数组-A1-A2-B1-B2-C1-C2-D1-D2-和-A-B-C-D-，合并为-A1-A2-A-B1-B2-B-C1-C2-C-D1-D2-D-。" class="headerlink" title="一、请把俩个数组 [A1, A2, B1, B2, C1, C2, D1, D2] 和 [A, B, C, D]，合并为 [A1, A2, A, B1, B2, B, C1, C2, C, D1, D2, D]。"></a>一、请把俩个数组 [A1, A2, B1, B2, C1, C2, D1, D2] 和 [A, B, C, D]，合并为 [A1, A2, A, B1, B2, B, C1, C2, C, D1, D2, D]。</h4><p>1、采用双指针的方法，i 指向第一个数组开头，j 指向第二个数组开头。<br>2、K是数组长度比值的取整，比如此题，K是2，每次跳两步。这个方法挺好的，比我原来的标记法更省空间!<br>3、循环遍历，每次截取前i到i+k个，再拼上数组2中的目标元素。<br>4、最后变成一维数组。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">function</span> <span class="selector-tag">concatArr</span>(<span class="selector-tag">arr1</span>,<span class="selector-tag">arr2</span>) &#123;</span><br><span class="line">let temp=[];</span><br><span class="line">let len2=arr2.length;</span><br><span class="line">let len1=arr1.length;</span><br><span class="line">let k=len1/len2;</span><br><span class="line">for(let i=0,j=0;i&lt;len1;i+=k,j++)&#123;</span><br><span class="line"><span class="selector-tag">temp</span><span class="selector-class">.push</span>(<span class="selector-tag">arr1</span><span class="selector-class">.slice</span>(<span class="selector-tag">i</span>,<span class="selector-tag">i</span>+<span class="selector-tag">k</span>)<span class="selector-class">.concat</span>(<span class="selector-tag">arr2</span><span class="selector-attr">[j]</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">return</span> <span class="selector-tag">temp</span><span class="selector-class">.flat</span>(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>多维数组=&gt;一维数组</p>
</blockquote>
<p>第0种处理:直接的调用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; arr_flat = arr.flat(Infinity);</span><br></pre></td></tr></table></figure>

<p>第一种处理</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ary = str.replace(/(\[\]))/g, '').split(',');</span><br></pre></td></tr></table></figure>

<p>第二种处理</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = str.replace(/(\[\]))/g, '');</span><br><span class="line">str = '[' + str + ']';</span><br><span class="line">ary = JSON.parse(str);</span><br></pre></td></tr></table></figure>

<p>第三种处理：递归处理</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let result = [];</span><br><span class="line">let fn = function(ary) &#123;</span><br><span class="line">for(let i = 0; i &lt; ary.length; i++) &#125;&#123;</span><br><span class="line">let item = ary[i];</span><br><span class="line"><span class="selector-tag">if</span> (<span class="selector-tag">Array</span><span class="selector-class">.isArray</span>(<span class="selector-tag">ary</span><span class="selector-attr">[i]</span>))&#123;</span><br><span class="line">fn(item);</span><br><span class="line">&#125; <span class="selector-tag">else</span> &#123;</span><br><span class="line">result.push(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四种处理：用 reduce 实现数组的 flat 方法</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">function</span> <span class="selector-tag">flatten</span>(<span class="selector-tag">ary</span>) &#123;</span><br><span class="line">return ary.reduce((pre, cur) =&gt; &#123;</span><br><span class="line"><span class="selector-tag">return</span> <span class="selector-tag">pre</span><span class="selector-class">.concat</span>(<span class="selector-tag">Array</span><span class="selector-class">.isArray</span>(<span class="selector-tag">cur</span>) ? <span class="selector-tag">flatten</span>(<span class="selector-tag">cur</span>) : <span class="selector-tag">cur</span>);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let ary = [1, 2, [3, 4], [5, [6, 7]]]</span><br><span class="line"><span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">ary</span><span class="selector-class">.MyFlat</span>(<span class="selector-tag">Infinity</span>))</span><br></pre></td></tr></table></figure>

<p>第五种处理：扩展运算符</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">while</span> (<span class="selector-tag">ary</span><span class="selector-class">.some</span>(<span class="selector-tag">Array</span><span class="selector-class">.isArray</span>)) &#123;</span><br><span class="line">ary = [].concat(...ary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二、算法题「移动零」，给定一个数组-nums，编写一个函数将所有-0-移动到数组的末尾，同时保持非零元素的相对顺序。"><a href="#二、算法题「移动零」，给定一个数组-nums，编写一个函数将所有-0-移动到数组的末尾，同时保持非零元素的相对顺序。" class="headerlink" title="二、算法题「移动零」，给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。"></a>二、算法题「移动零」，给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</h4><p>1、先从前面找，每次记录下当前遍历的元素。判断是不是0<br>2、找到一个0，就将这个0放到数组最后。<br>3、并在数组中将这个0删除，为了避免数组塌陷，先在后面加入一个0<br>4、将角标-1，这个因为splice方法造成的，NUM加1.<br>5、这个方法，可以在原地删除。<br>PS:注意splice的数组塌陷！！坑！</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> let num = 0;</span><br><span class="line">	for (let index = 0; index &lt; arr.length - num; index++) &#123;</span><br><span class="line">    const element = arr[index];</span><br><span class="line">		if (element === 0) &#123;</span><br><span class="line">			<span class="selector-tag">arr</span><span class="selector-class">.push</span>(<span class="selector-tag">element</span>);</span><br><span class="line">      <span class="selector-tag">arr</span><span class="selector-class">.splice</span>(<span class="selector-tag">index</span>, 1);</span><br><span class="line">      index -= 1</span><br><span class="line">      num +=1</span><br><span class="line">		&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">return</span> <span class="selector-tag">arr</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="三、已知数据格式，实现一个函数-fn-找出链条中所有的父级-id"><a href="#三、已知数据格式，实现一个函数-fn-找出链条中所有的父级-id" class="headerlink" title="三、已知数据格式，实现一个函数 fn 找出链条中所有的父级 id"></a>三、已知数据格式，实现一个函数 fn 找出链条中所有的父级 id</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const obj = [&#123;</span><br><span class="line">id: '1',</span><br><span class="line">name: '广东省',</span><br><span class="line">children: [&#123;</span><br><span class="line">id: '11',</span><br><span class="line">name: '深圳市',</span><br><span class="line">children: [&#123;</span><br><span class="line">id: '111',</span><br><span class="line">name: '南山区'</span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attribute">id</span>: <span class="string">'112'</span>,</span><br><span class="line">name: <span class="string">'福田区'</span></span><br><span class="line">&#125;]</span><br><span class="line">&#125;]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>1、用深度优先遍历的方法，先用一个栈把数组中的对象存储起来<br>2、判断这个对象的属性ID，如果相等，返回结果。<br>3、没有的话，就去深层比较，DFS找到孩子里面的ID，注意条件的孩子数组的长度不为0！！！这是递归终止的条件之一<br>4、本质还是递归，用map返回新的数组，放上最后的结果。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const getIds = (obj, id) =&gt; &#123;</span><br><span class="line">    const dfs = (obj, stack = []) =&gt; &#123;</span><br><span class="line">        <span class="selector-tag">for</span>(<span class="selector-tag">let</span> <span class="selector-tag">item</span> <span class="selector-tag">of</span> <span class="selector-tag">obj</span>) &#123;</span><br><span class="line">            stack.push(item);</span><br><span class="line">            if (item.id === id) &#123;</span><br><span class="line">                <span class="selector-tag">return</span> <span class="selector-tag">stack</span>;</span><br><span class="line">            &#125; <span class="selector-tag">else</span> &#123;</span><br><span class="line">                if (item.children &amp;&amp; item.children.length) &#123;</span><br><span class="line">                    <span class="selector-tag">return</span> <span class="selector-tag">dfs</span>(<span class="selector-tag">item</span><span class="selector-class">.children</span>, <span class="selector-tag">stack</span>);</span><br><span class="line">                &#125; <span class="selector-tag">else</span> &#123;</span><br><span class="line">                    stack.pop(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dfs(obj).map(item =&gt; item.id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(getIds(obj, '112'));</span><br></pre></td></tr></table></figure>
<h4 id="四、实现模糊搜索结果的关键词高亮显示"><a href="#四、实现模糊搜索结果的关键词高亮显示" class="headerlink" title="四、实现模糊搜索结果的关键词高亮显示"></a>四、实现模糊搜索结果的关键词高亮显示</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">let list = [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">id</span>: <span class="number">1</span>,</span><br><span class="line">address: <span class="string">'上海野生动物园'</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">id</span>: <span class="number">2</span>,</span><br><span class="line">address: <span class="string">'上饶野生动物园'</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">id</span>: <span class="number">3</span>,</span><br><span class="line">address: <span class="string">'北京巷子'</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">id</span>: <span class="number">4</span>,</span><br><span class="line">address: <span class="string">'上海中心'</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">id</span>: <span class="number">5</span>,</span><br><span class="line">address: <span class="string">'上海黄埔江'</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">id</span>: <span class="number">6</span>,</span><br><span class="line">address: <span class="string">'迪士尼上海'</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">id</span>: <span class="number">7</span>,</span><br><span class="line">address: <span class="string">'陆家嘴上海中心'</span></span><br><span class="line">&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>1、先写一个防抖，性能优化！！只取最后一次输入，直到用户不再输入时，根据最后的结果去显示。<br>2、再找到关键词，用filter方法，筛选出，也没那么难，注意读题~<br>3、最后再渲染到页面上。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">function</span> <span class="selector-tag">debounceFunc</span> (<span class="selector-tag">fn</span>, <span class="selector-tag">delay</span>) &#123;</span><br><span class="line">    let lastTime = 0;</span><br><span class="line">    let timer = null;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">function</span> (<span class="selector-tag">event</span>) &#123;</span><br><span class="line">        let now = +(new Date());</span><br><span class="line">        <span class="selector-tag">clearTimeout</span>(<span class="selector-tag">timer</span>)</span><br><span class="line">        timer = setTimeout(function () &#123;</span><br><span class="line">            <span class="selector-tag">fn</span><span class="selector-class">.call</span>(<span class="selector-tag">event</span>);</span><br><span class="line">        &#125;, <span class="selector-tag">delay</span>);</span><br><span class="line">        <span class="selector-tag">if</span> (<span class="selector-tag">now</span> <span class="selector-tag">-</span> <span class="selector-tag">lastTime</span> &lt; <span class="selector-tag">delay</span>) &#123;</span><br><span class="line">            lastTime = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">function</span> <span class="selector-tag">getResult</span>(<span class="selector-tag">str</span>) &#123;</span><br><span class="line">    return str.trim() ? list.filter(item =&gt; item.address.includes(str))</span><br><span class="line">                .map(item =&gt; &#123;</span><br><span class="line">                    <span class="selector-tag">return</span> &#123;</span><br><span class="line">                        ...item,</span><br><span class="line">                        address: item.address.replace(str, `&lt;span style="color:#31b0d5"&gt;$&#123;str&#125;&lt;/span&gt;`)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;) : <span class="selector-attr">[]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">function</span> <span class="selector-tag">renderUl</span>(<span class="selector-tag">lis</span>) &#123;</span><br><span class="line">    ul.innerHTML = lis.map(item =&gt; `&lt;li&gt;$&#123;item.address&#125;&lt;/li&gt;`).join('')</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="五、旋转数组算法题"><a href="#五、旋转数组算法题" class="headerlink" title="五、旋转数组算法题"></a>五、旋转数组算法题</h4><p>1、二分查找法的变形。<br>2、优化方案是先找到旋转的那个节点，也就是那个扰乱顺序的子元素，展开运算符…真香啊！哈哈哈<br>3、最后把它从头部插入！</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">function</span> <span class="selector-tag">reversalArr</span>(<span class="selector-tag">arr</span>, <span class="selector-tag">frequency</span>) &#123;</span><br><span class="line">  const newReversalArr = arr</span><br><span class="line">  for (let index = 0; index &lt; frequency; index++) &#123;</span><br><span class="line">    var first = newReversalArr.splice(newReversalArr.length - 1,1)</span><br><span class="line">    <span class="selector-tag">newReversalArr</span><span class="selector-class">.unshift</span>(..<span class="selector-class">.first</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">return</span> <span class="selector-tag">newReversalArr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="六、运用你所掌握的数据结构，设计和实现一个-LRU-最近最少使用-缓存机制。"><a href="#六、运用你所掌握的数据结构，设计和实现一个-LRU-最近最少使用-缓存机制。" class="headerlink" title="六、运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。"></a>六、运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。</h4><p>它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>
<p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。<br>当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">cache</span><span class="selector-class">.put</span>(1, 1);</span><br><span class="line"><span class="selector-tag">cache</span><span class="selector-class">.put</span>(2, 2);</span><br><span class="line">cache.get(1);       // 返回  1</span><br><span class="line">cache.put(3, 3);    // 该操作会使得密钥 2 作废</span><br><span class="line">cache.get(2);       // 返回 -1 (未找到)</span><br><span class="line">cache.put(4, 4);    // 该操作会使得密钥 1 作废</span><br><span class="line">cache.get(1);       // 返回 -1 (未找到)</span><br><span class="line">cache.get(3);       // 返回  3</span><br><span class="line">cache.get(4);       // 返回  4</span><br></pre></td></tr></table></figure>


<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">LRU</span> （<span class="selector-tag">Least</span> <span class="selector-tag">Recently</span> <span class="selector-tag">Used</span>）缓存机制</span><br><span class="line">在缓存满的时候，删除缓存里最久未使用的数据，然后再放入新元素；</span><br><span class="line">数据的访问时间很重要，访问时间距离现在最近，就最不容易被删除。</span><br><span class="line">核心思想：在删除元素的时候，只看在缓存里的存在时间。</span><br></pre></td></tr></table></figure>


<p>1、利用 Map 既能保存键值对，并且能够记住键的原始插入顺序。<br>2、Map 中的键值是有序的，而添加到对象中的键不是。<br>3、因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值<br>4、Map.prototype.keys()返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。<br>5、尾部元素一直是最新set的，对应于LRU的最近使用原则Map.set()<br>6、头部元素是最远使用的，用于LRU容量满载时删除最远使用的元素，可获取其keyMap.keys().next().value<br>7、貌似这个题还有个变种，是另外一种删除策略，不过今天没有找到题目，明天去github上面逛一逛看看有啥好方法~<br>解题步骤：</p>
<blockquote>
<p>一个Map对象在迭代时会根据对象中元素的插入顺序来进行！</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">get</span>操作：</span><br><span class="line">1、如果元素存在，先<span class="selector-tag">delete</span>再<span class="selector-tag">set</span>, 元素便会置为最新使用；如果不存在，返回<span class="selector-tag">-1</span></span><br><span class="line"><span class="selector-tag">put</span>操作:</span><br><span class="line">1、如果元素存在，先<span class="selector-tag">delete</span>再<span class="selector-tag">set</span>, 元素便会置为最新使用。</span><br><span class="line">2、如果容器超限，进行删除末尾元素操作。</span><br><span class="line">3、使用 <span class="selector-tag">Map</span>&#123;&#125;<span class="selector-class">.keys</span>()<span class="selector-class">.next</span>()得到迭代器的第一个元素，为使用时间最远的元素，进行删除。</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var LRUCache = function(capacity) &#123;</span><br><span class="line">    this.cache = new Map()</span><br><span class="line">    this.capacity = capacity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LRUCache.prototype.get = function(key) &#123;</span><br><span class="line">    <span class="selector-tag">if</span> (<span class="selector-tag">this</span><span class="selector-class">.cache</span><span class="selector-class">.has</span>(<span class="selector-tag">key</span>)) &#123;</span><br><span class="line">        // 存在即更新</span><br><span class="line">        let temp = this.cache.get(key)</span><br><span class="line">        <span class="selector-tag">this</span><span class="selector-class">.cache</span><span class="selector-class">.delete</span>(<span class="selector-tag">key</span>)</span><br><span class="line">        <span class="selector-tag">this</span><span class="selector-class">.cache</span><span class="selector-class">.set</span>(<span class="selector-tag">key</span>, <span class="selector-tag">temp</span>)</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">temp</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LRUCache.prototype.put = function(key, value) &#123;</span><br><span class="line">    <span class="selector-tag">if</span> (<span class="selector-tag">this</span><span class="selector-class">.cache</span><span class="selector-class">.has</span>(<span class="selector-tag">key</span>)) &#123;</span><br><span class="line">        // 存在即更新（删除后加入）</span><br><span class="line">        <span class="selector-tag">this</span><span class="selector-class">.cache</span><span class="selector-class">.delete</span>(<span class="selector-tag">key</span>)</span><br><span class="line">    &#125; else if (this.cache.size &gt;= this.capacity) &#123;</span><br><span class="line">        // 不存在即加入</span><br><span class="line">        // 缓存超过最大值，则移除最近没有使用的</span><br><span class="line">        <span class="selector-tag">this</span><span class="selector-class">.cache</span><span class="selector-class">.delete</span>(<span class="selector-tag">this</span><span class="selector-class">.cache</span><span class="selector-class">.keys</span>()<span class="selector-class">.next</span>()<span class="selector-class">.value</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">this</span><span class="selector-class">.cache</span><span class="selector-class">.set</span>(<span class="selector-tag">key</span>, <span class="selector-tag">value</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="七、假设你正在爬楼梯。需要-n-阶你才能到达楼顶。"><a href="#七、假设你正在爬楼梯。需要-n-阶你才能到达楼顶。" class="headerlink" title="七、假设你正在爬楼梯。需要 n 阶你才能到达楼顶。"></a>七、假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</h4><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line"> <span class="selector-tag">-</span>  1 阶 + 1 阶 + 1 阶</span><br><span class="line"> <span class="selector-tag">-</span>  1 阶 + 2 阶</span><br><span class="line"> <span class="selector-tag">-</span>  2 阶 + 1 阶</span><br></pre></td></tr></table></figure>
<p>解题一：<br>1、可以用动态规划来做。<br>2、常规解法可以分成多个子问题，爬第n阶楼梯的方法数量，等于 2 部分之和</p>
<ul>
<li>爬上 n-1 阶楼梯的方法数量。因为再爬1阶就能到第n阶 </li>
<li>爬上 n-2阶楼梯的方法数量，因为再爬2阶就能到第n阶<br>3、所以小霞得到公式 dp[n] = dp[n-1] + dp[n-2]<br>同时需要初始化 ！！！dp[0]=1和 dp[1]=1，怎么老忘记初始化。。。<br>时间复杂度：O(n)</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">Solution</span> &#123;</span><br><span class="line">    public int climbStairs(int n) &#123;</span><br><span class="line">        if (n == 1) &#123;</span><br><span class="line">            <span class="selector-tag">return</span> 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] dp = new int[n + 1];</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        dp[2] = 2;</span><br><span class="line">        for (int i = 3; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - 1] + dp[i - 2];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">dp</span><span class="selector-attr">[n]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解题二：<br>JavaScript递归解法(缓存中间步骤)，又是中间件的思想，缓存很多时候就是空间换时间！<br>有木有！！宇宙是恒定的，没有两全其美，只好交换时间和空间了，总要牺牲一个！</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//使用一个缓存对象保存计算中间值</span><br><span class="line">var cache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var climbStairs = function(n) &#123;</span><br><span class="line">//非法输入</span><br><span class="line">if (n &lt;= 0) &#123;</span><br><span class="line"><span class="selector-tag">return</span> <span class="selector-tag">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">//当爬1个台阶时,只有一种方法;</span><br><span class="line">//当爬2个台阶时,有两种方法,迈两步或迈一步</span><br><span class="line">if (n &lt;= 2) &#123;</span><br><span class="line"><span class="selector-tag">return</span> <span class="selector-tag">n</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 要爬到第n个台阶,可选的方法</span></span><br><span class="line"><span class="comment">* 1.在n-1个方法迈一步</span></span><br><span class="line"><span class="comment">* 2.在n-2个台阶上迈两步</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">prevStep</span>, <span class="selector-tag">prevPrevStep</span>;</span><br><span class="line">//递归计算爬n-1个台阶的方法,并利用缓存</span><br><span class="line">if (cache[n - 1] !== undefined) &#123;</span><br><span class="line">prevStep = cache[n - 1];</span><br><span class="line">&#125; <span class="selector-tag">else</span> &#123;</span><br><span class="line">prevStep = climbStairs(n - 1);</span><br><span class="line">cache[n - 1] = prevStep;</span><br><span class="line">&#125;</span><br><span class="line">//递归计算爬n-2个台阶的方法,并利用缓存</span><br><span class="line">if (cache[n - 2] !== undefined) &#123;</span><br><span class="line">prevPrevStep = cache[n - 2];</span><br><span class="line">&#125; <span class="selector-tag">else</span> &#123;</span><br><span class="line">prevPrevStep = climbStairs(n - 2);</span><br><span class="line">cache[n - 2] = prevPrevStep;</span><br><span class="line">&#125;</span><br><span class="line">//将这两种方法的可能性相加得到最终结果</span><br><span class="line"><span class="selector-tag">return</span> <span class="selector-tag">prevStep</span> + <span class="selector-tag">prevPrevStep</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="八、在未排序的数组中找到第-k-个最大的元素。"><a href="#八、在未排序的数组中找到第-k-个最大的元素。" class="headerlink" title="八、在未排序的数组中找到第 k 个最大的元素。"></a>八、在未排序的数组中找到第 k 个最大的元素。</h4><p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="line">输出: 5</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</span><br><span class="line">输出: 4</span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">你可以假设 <span class="selector-tag">k</span> 总是有效的，且 1 ≤ <span class="selector-tag">k</span> ≤ 数组的长度。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>js构造最小堆 堆中最后保存的最大的k个元素！！<br>这个题，有点难度，主要是健堆和调整。主要的角标公式要刻到脑子里！</p>
</blockquote>
<p><strong>解题思路：</strong><br>1、在小根堆中，堆顶的元素是最小的，如果堆顶的元素都比其他元素大，<br>2、那么堆里面的元素都比其他元素大，所以堆顶就是第k大元素<br><strong>步骤：</strong><br>1、从n个元素中截取前k个元素构造一个小根堆<br>2、for循环，依次从剩余n-k个元素中取出元素和堆顶比较，如果大于堆顶，则把值赋给堆顶，然后调整堆<br><strong>用到的算法：</strong><br>构造小根堆：<br>1、数组保存堆中元素，从0开始，最后一个元素下标是n = arr.length-1<br>2、从最后一个非叶子结点开始(第一个非叶子结点 Math.floor((n-1)/2))，从右至左，从下至上进行调整。<br><strong>调整方法：</strong><br>1、比较arr[2i+1],arr[2i+2],将最小的与arr[i]交换，<br>2、交换后需要重新调整结构(把大的元素沉到底部)<br>3、将剩余元素与堆顶比较</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; k</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">var findKthLargest = function(nums, k) &#123;</span><br><span class="line">    var kHeap = nums.slice(0,k);</span><br><span class="line">    <span class="selector-tag">makeHeap</span>(<span class="selector-tag">kHeap</span>);</span><br><span class="line">    for(let i=k;k&lt;nums.length;k++)&#123;</span><br><span class="line">        <span class="selector-tag">updateHeap</span>(<span class="selector-tag">kHeap</span>,<span class="selector-tag">nums</span><span class="selector-attr">[k]</span>);</span><br><span class="line">    &#125;;   </span><br><span class="line">    //取k个元素构造小顶堆</span><br><span class="line">    <span class="selector-tag">function</span> <span class="selector-tag">makeHeap</span>(<span class="selector-tag">arr</span>)&#123;</span><br><span class="line">        var temp;</span><br><span class="line">        for(let i = Math.floor((arr.length-2)/2);i&gt;=0;i--)&#123;</span><br><span class="line">            if(arr.length % 2==0 &amp;&amp; 2*i+1 == arr.length-1)&#123;</span><br><span class="line">                <span class="selector-tag">if</span>(<span class="selector-tag">arr</span><span class="selector-attr">[2*i+1]</span>&lt;<span class="selector-tag">arr</span><span class="selector-attr">[i]</span>)&#123;</span><br><span class="line">                    temp = arr[i];</span><br><span class="line">                    arr[i] = arr[2*i+1];</span><br><span class="line">                    arr[2*i+1] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="selector-tag">else</span>&#123;</span><br><span class="line">                if(arr[2*i+1]&lt;=arr[2*i+2] &amp;&amp; arr[2*i+1]&lt;arr[i])&#123;</span><br><span class="line">                    temp = arr[2*i+1];</span><br><span class="line">                    arr[2*i+1] = arr[i];</span><br><span class="line">                    arr[i] = temp;</span><br><span class="line">                    <span class="selector-tag">downHeap</span>(<span class="selector-tag">arr</span>,2*<span class="selector-tag">i</span>+1,<span class="selector-tag">arr</span><span class="selector-class">.length-1</span>);</span><br><span class="line">                &#125;<span class="selector-tag">else</span> <span class="selector-tag">if</span>(<span class="selector-tag">arr</span><span class="selector-attr">[2*i+2]</span>&lt;<span class="selector-tag">arr</span><span class="selector-attr">[2*i+1]</span> &amp;&amp; <span class="selector-tag">arr</span><span class="selector-attr">[2*i+2]</span>&lt;<span class="selector-tag">arr</span><span class="selector-attr">[i]</span>)&#123;</span><br><span class="line">                    temp = arr[2*i+2];</span><br><span class="line">                    arr[2*i+2] = arr[i];</span><br><span class="line">                    arr[i] = temp;</span><br><span class="line">                    <span class="selector-tag">downHeap</span>(<span class="selector-tag">arr</span>,2*<span class="selector-tag">i</span>+2,<span class="selector-tag">arr</span><span class="selector-class">.length-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;          </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //第i个元素向下 比较 下降</span><br><span class="line">    <span class="selector-tag">function</span> <span class="selector-tag">downHeap</span>(<span class="selector-tag">arr</span>,<span class="selector-tag">i</span>,<span class="selector-tag">n</span>)&#123;</span><br><span class="line">        if(2*i+1&gt;n)&#123;</span><br><span class="line">            <span class="selector-tag">return</span>;</span><br><span class="line">        &#125;<span class="selector-tag">else</span> <span class="selector-tag">if</span>(2*<span class="selector-tag">i</span>+2 &gt; <span class="selector-tag">n</span>)&#123;</span><br><span class="line">            if(arr[2*i+1]&lt;arr[i])&#123;</span><br><span class="line">                temp = arr[i];</span><br><span class="line">                arr[i] = arr[2*i+1];</span><br><span class="line">                arr[2*i+1] = temp;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="selector-tag">else</span>&#123;</span><br><span class="line">            if(arr[2*i+1]&lt;=arr[2*i+2] &amp;&amp; arr[2*i+1]&lt;arr[i])&#123;</span><br><span class="line">                temp = arr[2*i+1];</span><br><span class="line">                arr[2*i+1] = arr[i];</span><br><span class="line">                arr[i] = temp;</span><br><span class="line">                <span class="selector-tag">downHeap</span>(<span class="selector-tag">arr</span>,2*<span class="selector-tag">i</span>+1,<span class="selector-tag">arr</span><span class="selector-class">.length-1</span>);</span><br><span class="line">            &#125;<span class="selector-tag">else</span> <span class="selector-tag">if</span>(<span class="selector-tag">arr</span><span class="selector-attr">[2*i+2]</span>&lt;<span class="selector-tag">arr</span><span class="selector-attr">[2*i+1]</span> &amp;&amp; <span class="selector-tag">arr</span><span class="selector-attr">[2*i+2]</span>&lt;<span class="selector-tag">arr</span><span class="selector-attr">[i]</span>)&#123;</span><br><span class="line">                temp = arr[2*i+2];</span><br><span class="line">                arr[2*i+2] = arr[i];</span><br><span class="line">                arr[i] = temp;</span><br><span class="line">                <span class="selector-tag">downHeap</span>(<span class="selector-tag">arr</span>,2*<span class="selector-tag">i</span>+2,<span class="selector-tag">arr</span><span class="selector-class">.length-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">function</span> <span class="selector-tag">updateHeap</span>(<span class="selector-tag">heap</span>, <span class="selector-tag">item</span>)&#123;</span><br><span class="line">        if(heap[0]&lt;item)&#123;</span><br><span class="line">            heap[0] = item;</span><br><span class="line">            <span class="selector-tag">downHeap</span>(<span class="selector-tag">heap</span>,0,<span class="selector-tag">heap</span><span class="selector-class">.length-1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">kHeap</span><span class="selector-attr">[0]</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="九、给你一个字符串-s-和一个字符规律-p，请你来实现一个支持-‘-’-和-‘-’-的正则表达式匹配。"><a href="#九、给你一个字符串-s-和一个字符规律-p，请你来实现一个支持-‘-’-和-‘-’-的正则表达式匹配。" class="headerlink" title="九、给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。"></a>九、给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">'.' 匹配任意单个字符</span><br><span class="line">'*' 匹配零个或多个前面的那一个元素</span><br><span class="line">所谓匹配，是要涵盖 整个 字符串 <span class="selector-tag">s</span>的，而不是部分字符串。</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">说明:</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">s</span> 可能为空，且只包含从 <span class="selector-tag">a-z</span> 的小写字母。</span><br><span class="line"><span class="selector-tag">p</span> 可能为空，且只包含从 <span class="selector-tag">a-z</span> 的小写字母，以及字符 . 和 *。</span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s = "aa"</span><br><span class="line">p = "a"</span><br><span class="line">输出: <span class="selector-tag">false</span></span><br><span class="line">解释: "<span class="selector-tag">a</span>" 无法匹配 "<span class="selector-tag">aa</span>" 整个字符串。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s = "aa"</span><br><span class="line">p = "a*"</span><br><span class="line">输出: <span class="selector-tag">true</span></span><br><span class="line">解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s = "ab"</span><br><span class="line">p = ".*"</span><br><span class="line">输出: <span class="selector-tag">true</span></span><br><span class="line">解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。</span><br><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s = "aab"</span><br><span class="line">p = "c*a*b"</span><br><span class="line">输出: <span class="selector-tag">true</span></span><br><span class="line">解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。</span><br><span class="line">示例 5:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s = "mississippi"</span><br><span class="line">p = "mis*is*p*."</span><br><span class="line">输出: <span class="selector-tag">false</span></span><br></pre></td></tr></table></figure>
<p>enenen，貌似可以一行搞定。<br>思路:<br>先把p变为正则的形式，然后创建正则规则，再去匹配s<br>先把原p中的.变为任意字符，但注意要想用”[\s\S]”代替时，里面的反斜杠要写两个才行，记得转义！<br>一定要加开始、结束符。<br>不需要在”g”(全局模式下)匹配s。<br>PS：看到有社区用动态规划的，有点复杂，锻炼思路很好。<br>今天写不完了，先这样做吧，比较方便。<br>我已经写了3个小时了，还有一题，扶我起来，我还行！enennen……..</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var isMatch = function(s, p) &#123;</span><br><span class="line">    p = "^" + p.replace(/\./g,"[\\s\\S]") + "$";</span><br><span class="line">    var reg = new RegExp(p);</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">reg</span><span class="selector-class">.test</span>(<span class="selector-tag">s</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="十、编写一个-SQL-查询，获取-Employee-表中第二高的薪水（Salary）-。"><a href="#十、编写一个-SQL-查询，获取-Employee-表中第二高的薪水（Salary）-。" class="headerlink" title="十、编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。"></a>十、编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。</h4><p>+—-+——–+<br>| Id | Salary |<br>+—-+——–+<br>| 1  | 100    |<br>| 2  | 200    |<br>| 3  | 300    |<br>+—-+——–+<br>例如上述 Employee 表，SQL查询应该返回 200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。</p>
<p>+———————+<br>| SecondHighestSalary |<br>+———————+<br>| 200                 |<br>+———————+<br>PS:这题我不太会，记录一下大佬的答案。思路如下：</p>
<p>1、首先先将数据去重：SELECT DISTINCT Salary FROM Employee<br>2、再将是数据按薪水降序排除：SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC<br>3、分页的思想是一页一条数据，<br>4、第二高的薪水则在第二页：SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1, 1<br>5、考虑到极端情况：没有第二薪水则为空，使用ifnull判断：<br>SELECT IFNULL( (SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1, 1),null) AS SecondHighestSalary<br>貌似也不难，只是SQL好久没有复习了，手撸一个，顺便记下两个知识点。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">select</span> <span class="selector-tag">ifNull</span>(</span><br><span class="line">(<span class="selector-tag">select</span> <span class="selector-tag">distinct</span> <span class="selector-tag">salary</span></span><br><span class="line"><span class="selector-tag">from</span> <span class="selector-tag">Employee</span> </span><br><span class="line"><span class="selector-tag">order</span> <span class="selector-tag">by</span> <span class="selector-tag">Salary</span> <span class="selector-tag">Desc</span></span><br><span class="line"><span class="selector-tag">limit</span> 1,1),<span class="selector-tag">null</span></span><br><span class="line">) <span class="selector-tag">as</span> <span class="selector-tag">SecondHighestSalary</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">分页的其他使用：<span class="selector-tag">offset</span></span><br><span class="line"><span class="selector-tag">SQL</span>查询语句中的 <span class="selector-tag">limit</span> 与 <span class="selector-tag">offset</span> 的区别：</span><br><span class="line"><span class="selector-tag">limit</span> <span class="selector-tag">y</span> 分句表示: 读取 <span class="selector-tag">y</span> 条数据</span><br><span class="line"><span class="selector-tag">limit</span> <span class="selector-tag">x</span>, <span class="selector-tag">y</span> 分句表示: 跳过 <span class="selector-tag">x</span> 条数据，读取 <span class="selector-tag">y</span> 条数据</span><br><span class="line"><span class="selector-tag">limit</span> <span class="selector-tag">y</span> <span class="selector-tag">offset</span> <span class="selector-tag">x</span> 分句表示: 跳过 <span class="selector-tag">x</span> 条数据，读取 <span class="selector-tag">y</span> 条数据</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">题解一：使用 <span class="selector-tag">limit</span></span><br><span class="line">回忆一下 <span class="selector-tag">limit</span> 的用法</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">limit</span> <span class="selector-tag">N</span>     # 返回 <span class="selector-tag">N</span> 条记录</span><br><span class="line"><span class="selector-tag">offset</span> <span class="selector-tag">M</span>    # 跳过 <span class="selector-tag">M</span> 条记录，<span class="selector-tag">M</span> 默认为 0</span><br><span class="line"><span class="selector-tag">limit</span> <span class="selector-tag">M</span>,<span class="selector-tag">N</span>   # 相当于 <span class="selector-tag">limit</span> <span class="selector-tag">N</span> <span class="selector-tag">offset</span> <span class="selector-tag">M</span>，从第 <span class="selector-tag">M</span> 条记录开始，返回 <span class="selector-tag">N</span> 条记录</span><br><span class="line">将 <span class="selector-tag">Salary</span> 去重后降序排列，再返回第二条记录可得第二大的值</span><br><span class="line">也许只有一个 <span class="selector-tag">Salary</span> 值，将返回 <span class="selector-tag">null</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">select</span> (</span><br><span class="line">	<span class="selector-tag">select</span> <span class="selector-tag">DISTINCT</span> <span class="selector-tag">Salary</span></span><br><span class="line">	<span class="selector-tag">from</span> <span class="selector-tag">Employee</span></span><br><span class="line">	<span class="selector-tag">order</span> <span class="selector-tag">by</span> <span class="selector-tag">Salary</span> <span class="selector-tag">DESC</span></span><br><span class="line">	<span class="selector-tag">limit</span> 1,1) </span><br><span class="line"><span class="selector-tag">as</span> <span class="selector-tag">SecondHighestSalary</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题解二：使用 <span class="selector-tag">max</span> 函数</span><br><span class="line">回忆一下 <span class="selector-tag">max</span> 的用法</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">max</span>(字段名)  # 返回该字段的最大值</span><br><span class="line">找出小于该字段最大值的最大值，即为第二大值</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">select</span> <span class="selector-tag">max</span>(<span class="selector-tag">Salary</span>) <span class="selector-tag">as</span> <span class="selector-tag">SecondHighestSalary</span> </span><br><span class="line"><span class="selector-tag">from</span> <span class="selector-tag">Employee</span></span><br><span class="line"><span class="selector-tag">where</span> <span class="selector-tag">Salary</span> &lt; (</span><br><span class="line">    <span class="selector-tag">select</span> <span class="selector-tag">max</span>(<span class="selector-tag">Salary</span>) <span class="selector-tag">from</span> <span class="selector-tag">Employee</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>





      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E6%AF%8F%E6%97%A5%E5%8D%81%E9%A2%98%E7%B3%BB%E5%88%97/" rel="tag">每日十题系列</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E8%AE%B0%E5%BD%95%E7%BB%8F%E5%85%B8%E7%9A%84%E7%AE%97%E6%B3%95-%E5%AF%BB%E6%89%BE%E4%BC%98%E5%8C%96%E7%9A%84%E8%A7%A3%E6%B3%95/" rel="tag">记录经典的算法  寻找优化的解法</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-商场血雨腥风，小程序如何攀登珠穆朗玛峰？" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/04/24/%E5%95%86%E5%9C%BA%E8%A1%80%E9%9B%A8%E8%85%A5%E9%A3%8E%EF%BC%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E6%94%80%E7%99%BB%E7%8F%A0%E7%A9%86%E6%9C%97%E7%8E%9B%E5%B3%B0%EF%BC%9F/"
    >阿里面试总结（八）——小程序是便捷生活的万花筒，疑难杂症的万金油</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/04/24/%E5%95%86%E5%9C%BA%E8%A1%80%E9%9B%A8%E8%85%A5%E9%A3%8E%EF%BC%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E6%94%80%E7%99%BB%E7%8F%A0%E7%A9%86%E6%9C%97%E7%8E%9B%E5%B3%B0%EF%BC%9F/" class="article-date">
  <time datetime="2020-04-23T16:00:00.000Z" itemprop="datePublished">2020-04-24</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%98%AF%E4%BE%BF%E6%8D%B7%E7%94%9F%E6%B4%BB%E7%9A%84%E4%B8%87%E8%8A%B1%E7%AD%92%EF%BC%8C%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E7%9A%84%E4%B8%87%E9%87%91%E6%B2%B9/">小程序是便捷生活的万花筒，疑难杂症的万金油</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>小程序，大未来！<br>小程序是便捷生活的万花筒，疑难杂症的万金油！<br>这篇总结来自商业背景调研和梳理，服务业数字化是支付宝小程序的年度战略!<br>小霞搜集了好久，自己手绘了一些典型案例。重在了解时事、商业模式、业务逻辑~<br>程序媛想改变世界，第一步就是了解世界，hhh，先搞明白背后的商业模式和价值链条！<br>Welcome to share creative thoughts!创新未完待续！</p>
<h2 id="一、认清形势、找准定位。"><a href="#一、认清形势、找准定位。" class="headerlink" title="一、认清形势、找准定位。"></a>一、认清形势、找准定位。</h2><blockquote>
<p><strong>微信小程序：</strong></p>
</blockquote>
<p><strong>商业优势</strong>：朋友圈引流、<strong>社交裂变</strong>、线下场景少。<br><strong>引流方式</strong>：打通公众号、搜索入口路径短、<strong>浮窗设计</strong>、卡包、等可触发二次消费、打通自家APP生态。<br><strong>特色</strong>：基因是<strong>社交</strong>、侧重游戏、电商、知识付费、商家可通过<strong>公众号长内容、视频号短内容</strong>实现<strong>消息推送。</strong><br><strong>开发</strong>：放任自由、设置底线，提供工具框架，激发开发者自主创造。<br><strong>关键词</strong>：<strong>社交、好玩、游戏、内容、流量</strong>、线上玩的嗨。<br><strong>使命</strong>：帮助开发者建立留存途径、<strong>公众号短视频实现消息推送。</strong><br><strong>思路</strong>：<strong>野蛮式开放生长，无数开发者创造的小程序在社交大树上生根发芽。</strong></p>
<blockquote>
<p><strong>支付宝小程序：</strong></p>
</blockquote>
<p><strong>商业优势</strong>：消费信贷（比如花呗、芝麻信用）、支付业务、线下场景丰富。<br><strong>引流方式：</strong>叠加流量、支付、信贷能力、<strong>“轻会员”策略 、”共享经济”、</strong>打通微博破圈社交关系链、”718+X玩法”<br><strong>特色</strong>：基因是<strong>交易</strong>、主打购物、娱乐、本地生活服务、数字化云计算、安全性高、质量放心、服务便利、”新零售”经营效能强大。<br><strong>开发</strong>：一条龙服务、<strong>助力数字化工具</strong>、帮商家设计好、阿里云推出小程序云，让开发者<strong>一云多端</strong>。<br><strong>关键词</strong>：<strong>支付、信用、大数据、安全、医疗、出行等公共服务、便利生活、线下场景丰富。</strong><br><strong>使命</strong>：<strong>帮助开发者更方便、安全、快速、贴心的触达用户。</strong><br><strong>对用户：侧重什么场景怎么快速解决痛点需求。<br>   对商家：助力商家零（低）门槛实现数字化转型。</strong><br><strong>思路</strong>：<strong>聚拢式收敛汇聚、每个消费节点扩散出去的商家和服务聚集成一张紧密联系的消费网络。</strong><br><img src="https://img-blog.csdnimg.cn/20200425164937621.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="二、做好从应用商店—-gt-操作系统的破圈"><a href="#二、做好从应用商店—-gt-操作系统的破圈" class="headerlink" title="二、做好从应用商店—&gt;操作系统的破圈"></a>二、做好从应用商店—&gt;操作系统的破圈</h2><blockquote>
<p><strong>小程序一点也不小！小程序作为”中间件”，是打造数字经济体、商业帝国操作系统的API接口！</strong></p>
</blockquote>
<p>让我们把目光转移到最新的进展！<br>百万支付宝小程序如雨后春笋般繁茂生长，它们将助力支付宝破圈，实现<strong>应用商店</strong>到<strong>操作系统</strong>的改革开放！<br><strong>如何打通连接，四通八达，打造支付闭环，实现数字转型，帮助B端和C端客户更好地享受云端服务，是支付宝的愿景和使命，也是数字化平台发展的核心！</strong><br><img src="https://img-blog.csdnimg.cn/20200425163853333.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>过去的一年，支付宝小程序先后跟<strong>阿里系体系内的淘宝、天猫、UC、高德、钉钉、饿了么、天猫精灵等各大应用打通。</strong>服务阿里内部生态过程中，支付宝小程序在<strong>下沉市场的表现</strong>尤其不错。<br>目前在支付宝小程序的排行榜上，排名第一和第五的正是由聚划算和阿里妈妈团队运营的<strong>“每日必抢”、“一淘特卖”小程序。</strong>据新闻报道，过去一年支付宝小程序<strong>为淘宝带来了1亿的新增用户</strong>（但来自下沉市场的比例并未透露）。截至目前，支付宝APP全球用户已经达到10亿，全国的用户已经突破8.5亿。<br><strong>掌握如此巨大的流量入口，如何才能更好的聚焦“服务”？</strong>管仲前辈给出的答案是<strong>向B端输出。</strong><br>2020年4月24日，支付宝、上汽集团、斑马网络宣布将联手打造<strong>5G时代数字出行样板车，百万支付宝小程序将从手机被搬上汽车，用户通过语音操控，就能享受到支付宝的一系列生活服务。</strong><br>据悉，将于5月发布的上汽荣威RX5 PLUS 会实现这一功能体验，首期上车的35款支付宝小程序，<strong>涵盖了交通出行、影音娱乐和休闲购物等方面。</strong><br>车主通过<strong>触控、语音或手势等方式，就可以唤醒相应的支付宝小程序。</strong><br>与此同时，<strong>支付宝小程序与车载系统场景、地图也做了深度融合，小程序可以通过场景识别主动触发服务。</strong></p>
<p>跟据调研，<strong>服务业数字化是支付宝的年度战略。</strong>今年3月，<strong>支付宝全面升级为数字生活开放平台</strong>，宣布将通过<strong>开放平台战略、数字经营赋能，全力帮助服务业实现数字化升级。</strong><br><strong>“数字出行”是继“数字景区”、“数字市民中心”后的又一个数字化样板。</strong><br>目前支付宝数字生活平台上已经汇集了超过170万个小程序，除了车载系统，支付宝小程序已经打通了天猫、淘宝、钉钉、高德、新浪微博等多端场景。<br>收集这么多报道，不如图文并茂！看下面这些图就明白啦！<br>小霞搜集了好久，自己手绘了一些典型案例。<br><strong>程序媛想改变世界，就先了解世界，hhh，先搞明白背后的商业模式和价值链条！</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200425164357899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200425165435352.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>让我们从用户的角度分析一个场景：<br>1、用户通过手机支付宝小程序<strong>预订了</strong>一个餐厅的晚餐—》<br>2、当用户上车时，汽车就会为用户<strong>自动导航前往目的地</strong>，同时<strong>车载小程序就会主动预约排号</strong>—》<br>3、如果遇到交通拥堵，小程序还会根据到达时间<strong>主动提醒用户</strong>是否需要把订座时间延后半小时—》<br>4、到达餐厅附近，系统会<strong>自动唤醒小程序，为用户推荐就近的停车场</strong>—》<br>5、下车后，车载小程序会<strong>无缝连接</strong>到手机端，用户可以在手机小程序上<strong>查看餐厅的预约信息</strong>！</p>
<p><img src="https://img-blog.csdnimg.cn/20200425162500118.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200425162510472.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200425162522604.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>怎么样？是不是非常贴心呢？<strong>科技真的改变生活、改变世界！</strong><br><strong>作为程序媛，这个支付场景的逻辑必须要先搞明白！再去敲代码！</strong><br>再来几个案例吧，大家一起感受一下小程序的魅力~<br>下次写代码的时候，<strong>是不是觉得自己像上帝在创作一个精美的艺术品，一壶解决疑难杂症的万金油，在普渡众生呢？hhh！</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200425164744325.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200425164844791.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200425165103884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="三、借力云端、创新未完待续！"><a href="#三、借力云端、创新未完待续！" class="headerlink" title="三、借力云端、创新未完待续！"></a>三、借力云端、创新未完待续！</h2><blockquote>
<p>这一节让我们一起去看看小程序的创新落地，小霞决定下一步从<strong>技术角度</strong>做个调研，<strong>探探小程序背后的架构之美！</strong></p>
</blockquote>
<p>让我们一起去往下一站吧，下一站是什么呢？Remax让小霞拭目以待！</p>
<p><img src="https://img-blog.csdnimg.cn/20200425170135121.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200425170719402.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%8C%E5%A4%A7%E6%9C%AA%E6%9D%A5/" rel="tag">小程序，大未来</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E6%95%B0%E5%AD%97%E5%8C%96%E7%BB%8F%E6%B5%8E/" rel="tag">数字化经济</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-技能叠加+视野破圈+删繁就简+独立思考+保持初心" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/04/23/%E6%8A%80%E8%83%BD%E5%8F%A0%E5%8A%A0+%E8%A7%86%E9%87%8E%E7%A0%B4%E5%9C%88+%E5%88%A0%E7%B9%81%E5%B0%B1%E7%AE%80+%E7%8B%AC%E7%AB%8B%E6%80%9D%E8%80%83+%E4%BF%9D%E6%8C%81%E5%88%9D%E5%BF%83/"
    >阿里面试总结（七）——技能叠加+视野破圈+删繁就简+独立思考+保持初心</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/04/23/%E6%8A%80%E8%83%BD%E5%8F%A0%E5%8A%A0+%E8%A7%86%E9%87%8E%E7%A0%B4%E5%9C%88+%E5%88%A0%E7%B9%81%E5%B0%B1%E7%AE%80+%E7%8B%AC%E7%AB%8B%E6%80%9D%E8%80%83+%E4%BF%9D%E6%8C%81%E5%88%9D%E5%BF%83/" class="article-date">
  <time datetime="2020-04-22T16:00:00.000Z" itemprop="datePublished">2020-04-23</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="categories/%E4%B8%AA%E4%BA%BA%E7%BB%8F%E5%8E%86%E4%B8%8E%E7%94%9F%E6%B4%BB%E6%80%9D%E8%80%83/">个人经历与生活思考</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>记录一下这段时间的回顾梳理，每天收集好关于个人成长、职业规划的一些想法。<br>月结一下hhh，希望能给找实习的朋友们带来一些帮助！小霞也要及时反馈、复盘反思！<br>朋友们，让我们一起加油！实现从0到1到X的突破！<br>offer会有的，不要焦虑、保持初心、你若盛开，清风自来，桃李不言、下自成蹊！<br>接下来小霞从<strong>技能叠加+视野破圈+删繁就简+独立思考+保持初心</strong>五个维度分享一些感受，希望对阅读的您有所帮助！<br>您的收获和支持是小霞最大的动力！</p>
<h2 id="1、技能叠加"><a href="#1、技能叠加" class="headerlink" title="1、技能叠加"></a>1、技能叠加</h2><blockquote>
<p><strong>面试就是对自身知识掌握程度的一次搜索：分为宽搜、深搜 。<br>我们常常要考虑企业为什么招我？<br>我的独特之处是什么？<br>我有哪些不可替代性？<br>或者核心竞争力？说的简单一些：别人没有，只有我独有。<br>记得三月份有一次面试，对方说：你的简历为什么要写产品思考？我面的是前端。<br>我下来思考了很久，有一句话叫：人人都是产品经理。<br>可能它更好的表达是：人人都要有产品思维。（个人思考，请勿喷）<br>可能每个人都要想想STAR法则。<br>可能每个人多问一下自己：为什么？是什么？怎么办？好不好？</strong> </p>
</blockquote>
<p>1、JobDescription就是我们查漏补缺的<strong>映射表。</strong><br>2、T型模式重点还是在于<strong>垂直领域深耕，一直挖、挖到底。</strong><br>3、毕竟技术的关键是<strong>按时落地、多做多想、拿出实实在在的成绩。</strong><br>4、作为应届生、我们很难接触到亿万流量的项目，所以多想想前后端的业务逻辑是什么。<br>5、仔细思考一下、项目需求千变万化，难道做一个Demo就能带给企业价值吗？<br>6、<strong>技术沉淀可以靠时间、靠现有的模型；但技术突破只能靠思考、靠破圈、靠独创。</strong><br>7、我时常在想，为什么分社招？校招？实习生？<br>从这半个月的经历来看，总结可能是以下三点：<br>根本原因是：</p>
<ul>
<li>人是DNA基因、角色、环境的综合产物，带有个性化标签，<strong>是组件</strong>。</li>
<li>而企业需要不同角色的分工、协调、团结合作、<strong>需要兼容并蓄、汇集河流，是容器</strong>。 </li>
<li>打个比方：<strong>招聘就是古代招兵买马、带兵打仗、攻城略地。</strong></li>
<li>社招要的是<strong>身经百战、经常带兵打仗</strong>的将士、团长。比如关羽、张飞、林冲。</li>
<li>优点：经验丰富、业务熟练。</li>
<li>缺点：限于商业化气氛、思维可能局限、<strong>长期专攻某一项技术、可能视野不够广。</strong></li>
<li>校招要的是<strong>上知天文、下知地理、韬光养晦、运筹帷幄</strong>的军师。比如诸葛亮、周瑜。</li>
<li>优点：<strong>校园气氛单纯、科技感浓厚、善于思辨、创新、是源头活水、新鲜血液。</strong></li>
<li>缺点：缺乏大项目的经验、缺乏商业思维、业务理解。</li>
<li>实习生就是<strong>中间件，起承转合，最后留下的，是上述两者的取长补短。</strong></li>
<li>所以作为应届生，<strong>核心竞争力是创新的思维模式、反思总结的习惯。</strong></li>
<li>积极投入实习，<strong>找到自己稀缺的品质和特长、对个人、对企业，都有利于长远发展。</strong></li>
</ul>
<p>8、马云爸爸非常成功，我很崇拜他。他说自己不懂计算机，<strong>但他是一位高瞻远瞩的策划家、激情飞扬的演说家。</strong><br>9、<strong>所以说，没有人万能，但总有突破垂直领域的可能。</strong><br>10、<strong>现在很多企业，起步都是从非常小的入口划开一道口子（垂直深挖），然后横向扩展企业的生态圈。（横向延申）</strong><br>11、<strong>比如微信开始只做社交、支付宝开始只做交易、微博开始只做资讯、爱奇艺开始只做娱乐。</strong><br>12、<strong>后来都慢慢建立自己的用户圈、横向发展相关联的业务，发展一站式闭环联合生态。</strong><br>13、<strong>企业拆分一下，就是个人，都要用好T性思维，建立自己稳固的护城河。</strong><br>14、<strong>个人先垂直深挖发展成某一个行业的专家、接着打败所有人、然后去横向发展其他能力、最后谁都代替不了你，但要永远记住团队力量才是世界上最美的力量！如果每个个体都是某个领域的专家，那么这个团结、和谐、有共同价值观、使命感的团队一定可以流芳百世、做出世界级的大技术，大改革！</strong><br>15、<strong>这个时代，合作、共享是伟大的，走的最长远的一定是开源的、宽容的、普渡众生的，先成就他人、再成就自己。永远记住换位思考、关心他人。</strong><br>16、<strong>古语云：己所不欲，勿施于人！永远记住换个角度思考世界、思考未来、思考万物互联。</strong><br>17、<strong>技术+人文会有超乎平凡世界的想象力和创造力、伟大的技术需要跨界、需要交融、需要精心灌溉、需要兼容并蓄。</strong><br>18、<strong>永远走在路上，永远仰望星空、脚踏实地!   纸上得来终觉浅、觉知此事要躬行！</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200423140109380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt></p>
<h2 id="2、视野破圈"><a href="#2、视野破圈" class="headerlink" title="2、视野破圈"></a>2、视野破圈</h2><blockquote>
<p><strong>昨天我的闺蜜和我诉苦，她说，一场视频面试，好多问题不会，心态很崩，但是面试官一直引导。<br>我们聊了聊菜鸟到大牛的进阶之路，也分享了很多面试体验，这让我很感动。<br>越是Leader面，越能感受到视野和胸襟的魅力。<br>可能大牛就是：一颗心在流血、一颗心在宽容吧。<br>整理了以下八条总结：现阶段搭了个骨头框架，希望实习时填上丰富的血肉之躯！<br>毕竟嘛，中国人喜欢听故事。</strong></p>
</blockquote>
<p>1、前端领域、对照现有的书本、互联网资源<strong>查漏补缺</strong>是必备的环节、可是做到一本<strong>活字典</strong>却很难。<br>2、<strong>没有最标准的答案、只有特定场景下最合适的解法。</strong><br>3、术业有专攻、涉及未知领域时、<strong>最好的办法就是用自己的方法论快速掌握核心要点。</strong><br>4、<strong>大牛=天赋+方法论+时间管理+情怀+眼光</strong><br>5、很多时候、不是我们知识不渊博、能力不优秀、只是信息不匹配、视野不够广。<br>6、所以、世界级的技术很难、成功的个人、成功的团队、成功的企业、需要<strong>破圈。</strong><br>7、<strong>视野、格局、情怀</strong>在某种程度上决定了一个个体、团队、企业的调性。<br>8、<strong>调性影响文化、文化催生品牌、品牌决定影响力、影响力成就世界级的技术成果。</strong><br><img src="https://img-blog.csdnimg.cn/20200423140334408.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="3、删繁就简"><a href="#3、删繁就简" class="headerlink" title="3、删繁就简"></a>3、删繁就简</h2><blockquote>
<p><strong>有次面试我balabala了一大堆，但对方没有回应，尴尬了10秒，我当时也懵了，下来反思之后明白：<br>我们的信息不对称，更精准的说法就是：我没有满足对方的迫切需要。<br>沟通效率的提升对双方都很重要，所以我要常常反思，做到结构化表达、准确、高效输出。<br>这一点很难，我的路很长。<br>所以现在锻炼写博客、日记、迅速理好逻辑、金字塔原理、结构化表达。<br>所以简单点、再简单点、浓缩、再浓缩、突出重点、一针见血。<br>想做好真的很难，小霞加油！<br>陌生人冷启动可以话多、但是快节奏生活里、删繁就简！</strong></p>
</blockquote>
<p>1、知道的多（输入多）、说明的少（输出少）、在某些场景下，是一种明智。<br>2、这是我还要努力完善的地方，我应该学会精简化表达，让自己的想法更准确的输出、更高效的表达。<br>3、<strong>很多名人演讲非常通俗、简单。简单是一种美。</strong><br>4、浓缩就是精华。<br>5、<strong>世界上最解渴的是水、最昂贵的是免费、最难得的是精华。</strong><br>6、说到点子上。<br>7、交流是相互的，<strong>学会倾听</strong>、学会揣摩、想好了再说，输出要有价值。<br>8、<strong>加快沟通的办法：同步精神认知、保障信息对称。</strong><br>9、<strong>耐心、细心、不要轻易对一个人下结论，性格没有好坏之分。</strong><br>10、个体差异性的最大因素是环境，<strong>多站在对方的角度换位思考</strong>，Leader想要的是什么？我怎么做可以优化？</p>
<h2 id="4、深入思考"><a href="#4、深入思考" class="headerlink" title="4、深入思考"></a>4、深入思考</h2><blockquote>
<p><strong>为什么网上出现这么多面经？为什么我们只想要标准答案？面试是我拿着题库，你来背吗？<br>好像我挑着水，你拿着担耶，写到这里，莫名有点喜感，哈哈哈。<br>记得有一次面试，我说了HTTPS的通信流程：它的历史、发展、优缺点、存在的问题、怎么解决、优缺点、设计思想balabala。。。。。。<br>小哥哥听完，顿了一下：同学你记性太好了，故事情节生动（当时听到实在控制不住，笑出了鼻涕enenen）你是咋记住这么多稀奇古怪的名词的？<br>面试官哥哥独白：同学啊，我也好难，我选哪个题考你呢？这题我好像也不太会啊，哈哈哈。(面试官哥哥太可爱了吧hhh)<br>后面就感觉面试像聊聊天，聊聊学校和公司的区别，聊到了前端埋点，我觉得这样就很好啊，因为我们突破围城，看到了不同环境下的技术追求。<br>只要我们获得了超越成见的信息、丰富了固有的认知、看见了圈外的另一面、就是有效的交流。<br>因为它突破了信息茧房，消除了信息不对称，这就是改变、升华呀。<br>比起选题、背题、交流想法和认知，更加难能可贵。<br>我们呆在不同的环境、不同的圈子、不同的围城、难免忘记了，多看看更深远、广大、有差异化的另一边。<br>我们要多一些独立思考，思考是进步、升华、破圈的源泉。</strong></p>
</blockquote>
<p>1、一切问题都有标准答案吗？<br>2、答案是什么？<br>3、<strong>答案是主观人类对客观物质的解读和思考。</strong><br>4、答案是一成不变的吗？<br>5、<strong>当然不是，就算客观物质没有发生Change、主观人类的进化每分每秒都在Update。</strong><br>6、<strong>大概这个世界上99%的东西都Etag吧。</strong><br>7、<strong>基础JS知识、数据结构堆、栈、树、链表、图、框架设计Vue、React、Node、Koa、O(N)最小的算法</strong><br>   <strong>分治、归并、快排、深广遍历、层次遍历二叉树、链表成环、贪心算法、动态规划、设计模式、框架思想、前端行业发展等等等等…</strong><br>   <strong>基础知识是分散的血肉、框架搭建是连接的骨架、我们需要去深入思考组件化、模块化、工程化的发展意义、因为发展史是血液！</strong><br>   <strong>血液是流动、变化的，我们要思考、把控、检测、优化前端血液、所流向的方向、速度和频率。</strong><br>   <strong>有了坚硬的骨头、丰富的血肉、动态的血液、才有健康、完整、生动、蓬勃向上的前端，才能破圈、做出世界级的技术。</strong><br>   <strong>所有的一切、都需要技术改革、破圈。像我们的国家一样、改革开放是第一生产力。</strong><br>   <strong>要让技术有情怀、要让科技向善、人文向美。这是品牌的生命力、是企业的美好愿景和希望。</strong><br>8、本质上也是由物质组成的、物质由原子组成。<strong>而原子是时刻运动、变化的。</strong><br>9、<strong>性能优化的本质是：<br>**时间上：让技术创新的速度Match上原子运动的速度。</strong><br><strong>空间上：让容器承受的数据Contain上人类信息的爆发。</strong><br><strong>这是低频—》同频—》高频的进化，也是破圈的关键。</strong><br><strong>D2前端技术的日程里，我们看到了前端的巨大能量！</strong><br><strong>AI智能化、机器学习弄潮于技术之巅，怎能不让人期待和心动？如何结合小程序真正落地、解决痛点是我们要深入思考的角度。</strong><br><strong>Severless体系的不断完善，让上云变得充满了诗情画意的想象，新链路怎么样才能构建各大厂商线下线上业务的有效闭环？</strong><br><strong>工程化的巨变要怎么样监控、优化、才能重构业务形态？风险和收益并存，我们要怎么样衡量成本和获利？保留抑或抛弃过去的框架？</strong><br><strong>微前端的价值是什么？迁移是否存在生物学中的排异反应？是否能带来化学中的催化剂效力？要怎么模型匹配，才能共生共存，和谐并进？</strong><br><strong>技术的背后暗藏了深厚的中国哲学。哲学是打造世界级技术的根本。</strong><br><strong>质对量、快对慢、新对旧、多对少，如何把控？</strong><br><strong>思考“度”的破圈。</strong><br><strong>思考《老子》的中庸之道。</strong><br><strong>小霞相信历史的判断力、经典著作的权威力。</strong><br><strong>以史为镜，真的，可以做决策。</strong><br>（可能不成熟，小霞缺乏亿万流量级别的实习经验、但小霞相信技术与人文的强大爆发力）<br>（很多时候，不是我们经历了什么，而是我们从大大小小的经历中总结了什么，反思了什么，决定了我们的定位。）<br>记得初中那会上历史课时，恩师神采飞扬的说：<strong>人类最大的差异化优势就是懂得思考，思考是与其他动物的最大区别。</strong><br>未来充满了挑战和期待！真正能帮助我们勇敢接受、直面困难、解决问题的：<strong>是无所畏惧的激情、是磨练的底气、是总结的方法论。</strong><br>而这一切、都来自思考！<br>思考的造字、意境很美！</p>
<ul>
<li><p>思：</p>
</li>
<li><p>田:</p>
</li>
<li><p>代表方圆之中的规律之美，没有规矩，不成方圆。</p>
</li>
<li><p>田是全包围结构。</p>
</li>
<li><p>古往今来、规矩是本、社会、企业需要规章制度、这是和谐、不乱套的基本原则。</p>
</li>
<li><p>心：</p>
</li>
<li><p>心代表方圆之中的想象之美，海阔天空、有容乃大。</p>
</li>
<li><p>心是半包围结构。</p>
</li>
<li><p>沧海桑田、夸父逐日、社会、<strong>企业需要心心相印、齐心协力，这是突破、不流俗的升华破圈。</strong></p>
</li>
<li><p>考：</p>
</li>
<li><p><strong>土:土代表萌芽、原生、质朴、抗压、浪里淘沙、亘古不变、土承载了韧性的基因、父辈的传承。</strong></p>
</li>
<li><p><strong>丐:丐代表空无、白纸、困境、窘迫、白手起家、从0到1，丐象征了DNA的钙铁锌硒、破圈的坚韧。</strong></p>
</li>
<li><p>至于这一丿，<strong>小霞就理解为时代的风向吧，象征着机遇和挑战，怎么把握、怎么挖掘、怎么价值最大化是我们思考的结晶！</strong></p>
</li>
<li><p>就如雷军先生所说：学会机智、及时的站在风口上。（小霞改编一下，原话很接地气，嘿嘿，这里的意境偏古风~）</p>
</li>
</ul>
<blockquote>
<p>谈谈如何选择？如何刷新？</p>
</blockquote>
<p><strong>没有最标准的答案、只有特定场景下最合适的解法。</strong></p>
<blockquote>
<p>我们呆在不同的环境、不同的圈子、不同的围城。<br>难免忘记了，多看看更深远、广大、有差异化的另一边。<br>我们要多一些独立思考，思考是进步、升华、破圈的源泉。<br>进程、线程、协程需要想办法通信。人与人、人与物、物与物之间是一个道理，破圈第一步就是通信！<br>10、<strong>我们总是试图在随机事件中寻找规律，但这种倾向很有可能会使我们误入歧途。</strong><br>    <strong>对错评判的标准需要更多复杂的维度、创新的角度、突破信息茧房的深度。</strong><br>11、<strong>机器学习为什么梯度下降？为什么要修改损失函数？</strong><br>12、<strong>根本原因就是调整方向、扭转局势、悬崖勒马。</strong><br>13、我们避免不了误判、所以要经常检测、如果<strong>不及时止损、后果不堪设想。</strong><br>14、一个坑不解决、后面<strong>会有很多很多坑、连累很多很多人。</strong><br>15、当做出重要决策以后，我们经常会<strong>过高地评价自己的选择</strong>而<strong>贬低放弃的选择。</strong><br>16、所以<strong>当局者迷、旁观者清，我们需要第三方的公正评价。</strong><br>17、人类大部分的<strong>冲突和争论</strong>都源于人们过于关注自己的意见而<strong>并非去寻找问题的真正答案。 -</strong><br>18、<strong>信息爆炸的时代，独立思考真的，难能可贵。</strong><br>19、<strong>每天需要半个小时，思考一下，我今天做的事情，有价值吗？</strong><br>20、<strong>多照镜子、多从他人眼中，看到自己的影子。</strong><br>21、<strong>学的越多、越发现、知识海洋的深广、信息迭代的神速。</strong><br>22、<strong>你的兴趣很大程度上决定了你钻研的深度。认清自己、找准定位、T型发展。</strong><br>23、总有不会、不懂的，不要焦虑，不要烦躁，<strong>控制情绪是成功的第一步。</strong><br>24、世界这么大，社会需要不同领域的专家。<strong>每个人做好USB接口，能正常通信、汲取借鉴，就非常棒了。</strong><br>25、保持孩子般天真的求知欲，总之，活到老，学到老。学习是投资最低、收益最大的生意。<br>26、伟大的诗人歌德说：我没有一天是闲下来的。<br>27、<strong>跳出舒适圈、信息茧房、越早越好。</strong><br>28、21世纪的字典里，<strong>没有稳定</strong>，真的没有骗你。<br>29、<strong>所谓岁月静好，是有人为你遮风挡雨、负重前行，但总有一天，我们要独立面对狂风暴雨、晴天霹雳。</strong><br>30、<strong>我们可以有潦倒的困境，但不能有潦草的内心。</strong><br><img src="https://img-blog.csdnimg.cn/20200423140222712.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<h2 id="5、保持初心"><a href="#5、保持初心" class="headerlink" title="5、保持初心"></a>5、保持初心</h2><blockquote>
<p><strong>世界很大，小霞不能迷失了自己。<br>追梦路上、初心一直，与我同在。<br>退缩很愚蠢、灾难来临，总有人要挺身而出。<br>困难降临、不被认可只是说明：<br>天将降大任于斯人也，上帝要苦我心志、让我涅槃重生。<br>他选了我，说明我有潜质成为与众不同的人！<br>坦然接受，勇敢面对，拥抱变化、保持激情和乐观！<br>别忘了！你还有家人和朋友，你还有明天的朝霞、明天的起飞。<br>总有一天，会找到光亮、它在美丽的远方闪闪发光。</strong></p>
</blockquote>
<p>1、<strong>时常看看镜子里的自己：眼神是否还清澈？</strong><br>2、时常摸摸自己的心脏：是否还有激情？<br>3、时常和父母谈心：我是不是当初那个单纯的孩子？<br>4、<strong>时常回顾日记：我的赤诚、坦率、热心、良善、还在吗？还有温度吗？</strong><br>5、初心让我们回归<strong>简单、质朴、简单是一种力量，强大的力量。</strong><br>6、初心可以省去很多烦恼。<br>7、<strong>海纳百川、有容乃大；壁破千仞，无欲则刚。</strong><br>8、<strong>初心里承载着正直、良善、宽容。</strong><br>9、<strong>企业有了初心，会更有温度和情怀，会走的长远、稳健。</strong><br>10 <strong>企业做前端、做产品，根本是解决人的真需求，要带上初心、情怀、灵魂。</strong><br>11 <strong>初心带来心心相印，用户喜欢和我们相似的人。</strong><br>12、<strong>水能载舟、亦能覆舟。得民心者得天下，古往今来、无一例外。阿里的信念是用户第一！</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200423140046512.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200423140411854.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200423142800156.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200423142846387.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200423142941467.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E4%B8%AA%E4%BA%BA%E6%97%A5%E8%AE%B0%E6%80%BB%E7%BB%93/" rel="tag">个人日记总结</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E5%B1%95%E6%9C%9B%E6%9C%AA%E6%9D%A5%E5%8D%81%E5%B9%B4/" rel="tag">展望未来十年</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-深入总结Leader对小霞的终极灵魂十问！附上小霞名字解析_" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/04/21/%E6%B7%B1%E5%85%A5%E6%80%BB%E7%BB%93Leader%E5%AF%B9%E5%B0%8F%E9%9C%9E%E7%9A%84%E7%BB%88%E6%9E%81%E7%81%B5%E9%AD%82%E5%8D%81%E9%97%AE%EF%BC%81%E9%99%84%E4%B8%8A%E5%B0%8F%E9%9C%9E%E5%90%8D%E5%AD%97%E8%A7%A3%E6%9E%90_/"
    >阿里面试总结（六）——深入总结Leader对小霞的终极灵魂十问！附上小霞生活思考~</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/04/21/%E6%B7%B1%E5%85%A5%E6%80%BB%E7%BB%93Leader%E5%AF%B9%E5%B0%8F%E9%9C%9E%E7%9A%84%E7%BB%88%E6%9E%81%E7%81%B5%E9%AD%82%E5%8D%81%E9%97%AE%EF%BC%81%E9%99%84%E4%B8%8A%E5%B0%8F%E9%9C%9E%E5%90%8D%E5%AD%97%E8%A7%A3%E6%9E%90_/" class="article-date">
  <time datetime="2020-04-20T16:00:00.000Z" itemprop="datePublished">2020-04-21</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="categories/%E4%B8%AA%E4%BA%BA%E7%BB%8F%E5%8E%86%E4%B8%8E%E7%94%9F%E6%B4%BB%E6%80%9D%E8%80%83/">个人经历与生活思考</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>突如其来的一个电话让小霞创作了这篇文章，记录很有深度的Leader问，感谢这次机会，也算是一次自己对过往生活和学习的深入思考。<br>吾日三省吾身，为人谋而不忠乎？与朋友交而不信乎?传不习乎？<br>夫以铜为镜，可以正衣冠；以史为镜，可以知兴替；以人为镜，可以明得失！<br>Welcome to share creative thoughts!<br>第七部分的技术思考欢迎大家多多交流指教！</p>
<h2 id="一、为什么学产品？"><a href="#一、为什么学产品？" class="headerlink" title="一、为什么学产品？"></a>一、为什么学产品？</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 小霞复盘思考</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>做产品的初衷？</strong></p>
</blockquote>
<ul>
<li>本科参加很多社团活动、喜欢和不同角色的人打交道。</li>
<li>本科双学位是英语、享受演讲的过程、希望自己有一天可以站在讲台上、普及自己的产品思维和理念。</li>
<li>看了很多心理学和哲学的书、想挖掘产品背后的人性层面的原理。</li>
<li>做产品可以进一步提高思辨能力、抽象能力、逻辑能力。</li>
</ul>
<blockquote>
<p><strong>实习干了什么？</strong></p>
</blockquote>
<p>1、实践出真知，大三实习时我撰写需求文档—》设计流程图—》沟通前端、后台、UI、运维—》加快产品上线。<br>2、实习总结后，我幡然大悟：<strong>产品思维</strong>是一种<strong>挖掘问题—》拆分问题—》解决问题—》优化产出</strong>的能力。</p>
<blockquote>
<p><strong>产品实习的收获？</strong></p>
</blockquote>
<ul>
<li>更长远的<strong>大局观</strong></li>
<li>更专业的<strong>商业思维</strong></li>
<li>更敏锐的<strong>洞察力</strong></li>
<li>更准确的<strong>判断力</strong></li>
<li>更有温度的<strong>同理心</strong></li>
<li>更有效的<strong>沟通力</strong></li>
</ul>
<blockquote>
<p> <strong>B\C端有什么区别？</strong></p>
</blockquote>
<ul>
<li>C端产品服务于用户，成功的关键是根据<strong>马斯洛法则</strong>分辨需求真伪、从人性角度深入挖掘。</li>
<li>C端产品要考虑怎么样让用户在最短路径，最快时间满足自己的需求，<strong>提升用户体验</strong>。</li>
<li>B端产品服务于组织，组织的需求不是从单个用户需求点出发，而是一种<strong>生产关系的连接和延伸</strong>。</li>
<li>B端产品的重点是基本信息流的传递，梳理<strong>业务流和逻辑链条</strong>、关注商业模式、企业文化、沟通效率、平台盈利。</li>
</ul>
<blockquote>
<p> <strong>我总结了哪些解决问题的办法？</strong><br> <strong>这一部分从宏观角度阐述、在研究生方法论中以科研经历为例子具体展开谈。</strong></p>
</blockquote>
<ul>
<li>分治法：拆分大问题—》解决子问题—》<strong>各个击破</strong>—》合并归一。   </li>
<li>破冰法：<strong>千里之堤、溃于蚁穴</strong>。有些问题只是窗户纸（表面很难、本质很容易）一针见血便可迎刃而解。   </li>
<li>二轴四象限法：二轴是<strong>时间和空间</strong>、四象限根据具体问题去设计、<strong>规划优先级、先解决最迫切的问题</strong>。   </li>
<li>经验借鉴法：问渠那得清如许，为有源头活水来？<strong>从企业、团队、个人成功或者失败的例子中找到答案</strong>。   </li>
<li>头脑风暴法：开会、交流、集思广益、<strong>群谋划策</strong>、借助团队的力量。</li>
<li><strong>Apple法则： 取首英文字母串联起流程，小霞的Apple法则来自实践—实践出真知</strong></li>
<li>确定产品定位、项目目标、针对哪些<strong>场景优化</strong>到什么数量级？(Ambition）</li>
<li>收集用户需求、<strong>辨别真伪、确定优先级</strong>、做好项目排期（Accumulation)</li>
<li>预测方案A/B/C哪个性能更好？哪个框架更优？<strong>技术选型比较</strong>（Prediction)</li>
<li>确定方案后、团队合作、<strong>深耕细耘</strong>、一万小时的努力成就辉煌(Persistence)</li>
<li>前端科技日新月异、保持热情、终身学习、<strong>T型发展</strong>（Learn）</li>
<li>提高<strong>沟通表达效率</strong>、把自己打磨成<strong>USB一个接口</strong>，适配不同角色的人群、对接后台、UI、产品（Link）</li>
<li>及时复盘、定期总结、<strong>虚心求教、自我评估</strong>（Evaluation）</li>
<li>产品上线、<strong>数据分析</strong>、预测商业价值、<strong>盘活商业模式</strong>（Estimation）</li>
</ul>
<blockquote>
<p><strong>这些方法论的原理是什么？</strong></p>
</blockquote>
<ul>
<li><strong>知己知彼，百战不殆</strong>。</li>
<li>旁观者清、身居者迷。 </li>
<li>一千个人眼中有一千个哈姆雷特。</li>
<li>横看成岭侧成峰、远近高低各不同。 </li>
<li><strong>不做什么，比做什么更重要</strong>。</li>
<li>富人思维是一种多变量思维。 </li>
<li><strong>以铜为镜，可以正衣冠；以史为镜，可以知兴替；以人为镜，可以知得失</strong>。</li>
<li>沟通失败的本质有两点：<strong>一是精神层面的认知不同，二是物质层面的信息不对称。</strong></li>
</ul>
<blockquote>
<p><strong>什么样的产品是好产品？</strong></p>
</blockquote>
<p><strong>微观层面：</strong><br>你若盛开，清风自来；桃李不言，下自成蹊。<br>清风细雨，润物无声；上善若水，干净纯粹。<br>己所不欲，勿施于人；删繁就简，大智若愚。<br><strong>宏观层面：</strong></p>
<ul>
<li>有使命：解决用户痛点、提高企业效率、扩大平台盈利  </li>
<li>美好愿景：用户个性化定制、企业品牌化策略 </li>
<li>价值观：<strong>互联网最稀缺的是信任和注意力、好的产品一定是普惠众生的、免费的产品本质上是最贵的</strong> </li>
<li>（价值观的原理很深，日后展开谈背后的真相）</li>
</ul>
<blockquote>
<p> 举例说明？<br> 请见博客实习总结，爱奇艺实习总结社区文化的规律、视频号源自社区建设的思考。<br> 不成熟之处小霞虚心求教，写博客的目的是记录当下22岁的思考，等我长大了细细回顾。<br> 小霞想记录不同年龄、不同阅历、不同人生阶段的自我成长、并乐意和阅读的您分享，愿每一个人都珍惜成长的记录！</p>
</blockquote>
<h2 id="二、为什么做前端？"><a href="#二、为什么做前端？" class="headerlink" title="二、为什么做前端？"></a>二、为什么做前端？</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 小霞复盘思考</span><br></pre></td></tr></table></figure>
<p>1、做产品时很注重<strong>用户体验</strong>，经常和前端打交道、页面的效果让我感到<strong>神奇和惊叹</strong>、激发了学习欲望。<br>2、本身是工科出身、有技术基础、<strong>学好技术是个人学业的必备要求，也让我有底气和踏实感</strong>。<br>3、从去年开始学习HTML、CSS、JS、VUE、React，写了很多笔记看了很多书籍、小霞要<strong>做好职业规划和成长目标</strong>。<br>4、前端专家是<strong>综合性人才</strong>，高屋建瓴，兼顾<strong>商业背景、技术架构、产品体验</strong>。<br>5、<strong>企业理念是导向，用户体验是目标、技术框架是基石，技术与人文结合才有巨大的蝴蝶效应。</strong><br>6、<strong>读研</strong>的深入学习让我对前端有了更大的热情和动力，<strong>AI的研究经历</strong>让我产生很多关于前端的思考。<br>7、未来十年、前端拥有无限的发展空间、<strong>聪明的选择要紧密契合时代发展、独到的眼光决定个人成长路线的走向。</strong><br>8、<strong>学习热情的高低决定职业发展瓶颈的大小、持续的动力来自内心真正的热爱，它决定我们到底能走多远。</strong><br>9、<strong>没有任何一份职业是轻松的，生活的本质是苦难，成长的真相是蜕变、快乐来自自我的破圈、认知的进化。</strong><br>10、这个博客是自己搭建的、申请域名、Github账号、设计博客页面、插入小音乐、小程序、喜欢的摄影家、个人相册、搭建时很有成就感，也激发了学习前端、做好设计的强烈欲望。<strong>它让我快乐、踏实、持续高产、精神充实。</strong></p>
<h2 id="三、你在团队项目中是一个什么样的角色？"><a href="#三、你在团队项目中是一个什么样的角色？" class="headerlink" title="三、你在团队项目中是一个什么样的角色？"></a>三、你在团队项目中是一个什么样的角色？</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本科阶段</span><br></pre></td></tr></table></figure>
<blockquote>
<p>商务英语方面：”点亮英语” 社团—我的角色是<strong>社团Leader</strong>，专注于策划活动方案、社团招新、管理</p>
</blockquote>
<p><strong>项目背景</strong>：刚入大学的萌新们学习有些放松、没有了早读、首课八点半才开始、大把时间浪费在寝室睡懒觉。<br><strong>项目策划：</strong></p>
<ul>
<li>点亮社团推出”朝花夕拾”活动。 </li>
<li>引导大家早起晨读英语、模拟对话练习。 </li>
<li>与留学生社团合作举办英语角、英语演讲比赛。</li>
</ul>
<p> <strong>我的角色是Leader，做了以下三点：</strong><br> 1、做为项目策划人、我设计了以上三点策划方案、借教室、借场地、<strong>招新纳才、和校方沟通联合</strong>、全校宣传社团活动。<br> 2、邀请留学生作客演讲、解决<strong>活动冷启动</strong>的问题、通过大型宣传<strong>打破同学认知、跳出被窝舒适圈、激发学习热情。</strong><br> 3、做好团队文化管理，定期开会<strong>集思广益、处理反馈建议、迭代优化</strong>团队的活动方案、在校内做到社团活跃度TOP1。</p>
<blockquote>
<p>大学生kmust “飞思卡尔”  智能机器人大赛</p>
</blockquote>
<p><strong>项目背景</strong> ：选取任意一组、团队合作完成机器人赛道流程、包含自动循迹、弯道减速、绕过障碍物、定点踢球功能。</p>
<ul>
<li>基础四轮组 </li>
<li>双车组 </li>
<li>AI电磁组</li>
<li>摄像头循迹组 （我们选了这个组别，难度比较大）</li>
</ul>
<p><strong>我的角色：USB接口</strong>（我分为对内和对外两个角度）</p>
<blockquote>
<p>对内： 个人专攻于<strong>路径循迹模块</strong>：</p>
</blockquote>
<p>1、我采用了八个红外线传感器，安装在机器人的头部电机，采用<strong>并排的方式</strong>扩大视野范围。<br>2、设计程序、控制机器人及时检测对面路况信息、及时接受反馈回来的信号、将传感器的数据送到CPU主核处理器。<br>3、看论文、看官方文档、创新提出<strong>优化PID算法，进行积分、加权、微分</strong>、得出下一步路劲的方向、速度、转角大小。<br>4、优化程序设计<strong>不断调试参数</strong>、历经两个月、每天坚持在实验室测试、最终保证机器人正常检测路况自动跑完”S”赛道。</p>
<blockquote>
<p>对外：<strong>对接其他模块接口、团队完成一整套流程：</strong></p>
</blockquote>
<p>1、其他同学不太精通的地方，我凭借自己的专业能力帮助他人：<br>比如有同学英语不太好，我帮助他完成<strong>翻译、解析、让他获取更多有效的资源和解决方案。</strong><br>（因为有一些资源是英文版的，比较复杂，涉及很多专业名词，有一些同学存在阅读和理解上的困难）<br>2、及时和大家沟通交流，接口对不上的话，整个流程的效率都会降低，所以经常开会讨论方案、优化机器人的跑步速度，同时还要<strong>减小路线判断的失误、提高检查路况的准确度。</strong></p>
<h2 id="四、研究生做了哪些项目，有哪些学习方法？"><a href="#四、研究生做了哪些项目，有哪些学习方法？" class="headerlink" title="四、研究生做了哪些项目，有哪些学习方法？"></a>四、研究生做了哪些项目，有哪些学习方法？</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">研究生阶段：医疗图像处理、人体姿态估计</span><br></pre></td></tr></table></figure>

<blockquote>
<p>医疗图像处理：对接华科同济医学院，利用深度学习帮助医生诊断脑血栓、脑瘤的病历。</p>
</blockquote>
<p>项目需求：解决诊断周期长、设备成本高、医疗人才短缺、诊断效率低的问题。<br>项目成员：两位同济医生、一位博士、两位研究生（包括我）、一位本科生<br><strong>我的角色：</strong><br><strong>沟通层面</strong>：和医生对接、每周去三次医院、拷贝病人电子病历、和医生交流待解决的诊断难题。<br><strong>技术层面</strong>：利用Pytorch框架做数据集的筛选、清洗、预处理、数据标注、数据集训练等技术问题。<br><strong>克服的困难：</strong><br><strong>医疗方面</strong>：<strong>短时间内</strong>要学习大量脑部结构的依赖关系、学习各种诊断病历的医院专用软件。<br>我的方案：<strong>勤学多问</strong>、牺牲娱乐和休息时间、因为资料比较多、所以采用了<strong>时间压缩法，缩小间隙、排挡比较满。</strong><br><strong>算法方面</strong>：学习各种深度学习的<strong>复杂</strong>计算公式、框架应用、网络模型。<br>我的方案：<strong>多听学术分享会、多看前人的经验总结、要从历史规律中找寻答案</strong>、多看视频网课、看精华分享。</p>
<h2 id="五、当下的研究生技术困难，怎么解决，为什么这样做？"><a href="#五、当下的研究生技术困难，怎么解决，为什么这样做？" class="headerlink" title="五、当下的研究生技术困难，怎么解决，为什么这样做？"></a>五、当下的研究生技术困难，怎么解决，为什么这样做？</h2><blockquote>
<p>人体姿态估计：华科新兴领域、很多技术层面的体系不太完善、技术突破需要有新思路、新灵感、破功难。</p>
</blockquote>
<p><strong>项目目标：</strong></p>
<ol>
<li><p>基于<strong>自底向上</strong>的多人人体姿态估计方案，设计系统并实现<strong>功能需求。</strong></p>
</li>
<li><p>结合<strong>新科研成果</strong>对卷积神经网络结构进行改造，使得网络中的<strong>参数量得以大幅缩减</strong>，<strong>计算复杂度得以大幅降低。</strong></p>
</li>
<li><p>在卷积神经网络的参数量和计算量都大幅减小情况下，对方案进行改进以<strong>接近原始网络结构的精度。</strong></p>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为什么选择自底向上的方案？</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200421222036296.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>项目难点：</strong></p>
<ol>
<li>网络的<strong>计算量太大</strong>，硬件计算资源难以支持。在实验室的计算资源丰富的环境下训练出来的网络，一旦部署到计算资源紧缺的移动终端上就会导致<strong>运行时间太长而难以接受</strong>。</li>
<li>网络的<strong>参数量太大</strong>，部署在硬件上会占用大量的内存，对于内存较小的移动终端来说，很容易出现<strong>内存溢出</strong>问题。</li>
</ol>
<p><strong>解决思路：</strong></p>
<p>最直观的做法：训练出一种<strong>计算复杂度更低、参数量更少</strong>的网络以满足实际的生产环境部署的要求。</p>
<p>以下是详细流程：来自日常汇报的部分截图，流程比较复杂，选取一部分代表</p>
<blockquote>
<p>实验部分偏技术，下面板块会总结方法论！</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200421222725727.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200421222931608.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200421223151262.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200421223401718.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200421223452391.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200421223633782.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200421223940958.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200421223807609.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="六、你总结了哪些科研方法论？"><a href="#六、你总结了哪些科研方法论？" class="headerlink" title="六、你总结了哪些科研方法论？"></a>六、你总结了哪些科研方法论？</h2><blockquote>
<p>这里举了一些实验方案和例子，在《小霞看前端》中也有很多最新成果的展示。<br>第一板块的Apple法则是从宏观角度，下面的方法是从微观角度 。</p>
<p> <strong>我总结一下，科研的方法论就是：<br>  调研最新论文、开源项目、多看论文，</strong>找到还可以优化的点**<br>     汲取历史经验、<strong>判断未来发展方向**</strong><br><strong>做实验前先把以下问题搞明白、搞透彻再去部署实践。</strong></p>
</blockquote>
<p><strong>预判断部分：好的方向和起点是成功的一半！</strong></p>
<blockquote>
<p> <strong>我们要解决什么问题？<br> 这个问题是真需求还是伪需求？<br> 如果解决了，它真的能带来很多性能优化吗？<br> 能发出创新论文吗？</strong></p>
</blockquote>
<p><strong>调研部分：</strong>      <strong>知己知彼、百战不殆+认清形势、抛弃不切实际的幻想！</strong></p>
<blockquote>
<p><strong>这些问题前人做过没有？<br> 其他实验室做过没有？<br> 或者说竞争对手做过没有？<br> 他们做的怎么样？<br> 有一定成果吗？<br> 我们的服务器资源能支持吗？<br>导师支持吗？<br>投入产出比是多少？<br>现阶段的技术水平能否完成？<br>实验周期能否加快？</strong></p>
</blockquote>
<p><strong>落实部分：协调沟通+定期分享！</strong></p>
<blockquote>
<p><strong>团队人员是否意见一致？<br> 团队合作是否高效、协调？<br> 每个人的价值是否充分发挥？<br> 每个人是不是在做自己擅长的领域？<br>大家有没有互相借鉴的思想？<br>多久安排一次分享会来集思广益？<br>项目排期是否合理？<br>导师的任务是否高效运转？<br>能否完成导师的预期目标？</strong></p>
</blockquote>
<p><strong>优化部分：循环迭代+持之以恒！</strong></p>
<p> <strong>没有人随随便便成功，实验问题是不可避免的，保持乐观和热情。<br>及时和导师交流，经验这个东西，和年纪、阅历有关，不能急于求成。<br>不论成功、失败、都有可以挖掘的价值，关键是如何思考、如何复盘总结。<br>规律是个很神奇的东西、多看、多听、多想、就有思路和灵感了。<br>经过切分、拆解、大问题就是你经常遇到的小问题。<br>创新的前提的有一定的理论基础、天马行空并不能实时落地。<br>真正打败自己的是没有热情和信心。<br>如果你真的花光了所有力气，你要相信，这时候，全世界都会为你助力。真的。<br>万物之上、希望之美，我们应该对未来有所期待。<br>真正的勇士、是看清了生活的真相、但依然热爱它。<br>天下没有绝境、除非自己放弃了自己。<br>要相信一万小时成功定律、没有成绩是因为还不够专业、努力。</strong></p>
<h2 id="七、谈谈你对研究生的技术思考？"><a href="#七、谈谈你对研究生的技术思考？" class="headerlink" title="七、谈谈你对研究生的技术思考？"></a>七、谈谈你对研究生的技术思考？</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 综合前端技术和<span class="selector-tag">AI</span>技术、我有以下理解，纯属个人观点，毕竟年纪有限，不到位之处请点评指教~</span><br></pre></td></tr></table></figure>
<p>1、<strong>计算机世界是二进制的、离散型的。人类世界是多进制的、连续型的。</strong><br>2、深度学习是在模拟现实世界，神经网络就是模拟人的原生大脑。<br>3、<strong>科技的溯源是生活、一切科技、艺术的底层来源于丰富、细微的生活场景！</strong><br>4、好的科技人员应该是个<strong>艺术家。</strong><br>5、<strong>工具</strong>推动了人类历史的发展。从蛮荒时代到21世纪，没有例外！<br>6、Webpack的Tree-Shaking可能来自一场突然的倾盆大雨。<br>7、VUE的发布订阅模式可能起源于生活中的订购牛奶、报纸。<br>8、Node中的单线程模式可能来自于早餐店中的点钞员，点钞员一直接待客人、客人拿号就走、异步处理单个客户的需求！<br>9、<strong>前后端分离、数据与视图的分离</strong>可能来自于美国的联邦制度、<strong>下放集权、划分州市、分块统治。</strong><br>10、<strong>组件划分、Loader单一职责</strong>可能来自于社会演变中<strong>角色的划分、职场上职业的分类、评级等思想！</strong><br>11、React的<strong>单一数据流思想</strong>可能来自于一江春水向东流、大声吼啊！不回头。<br>12、<strong>可逆与不可逆是我们常要思考的问题。（哈希算法）</strong>还有DOM事件流，冒泡还是捕捉，下还是下，是否回流，怎么调度才好、都要思考、设计。<br>13、HTTPS的CA证书、洋葱模型的中间件、Redux的中间件都体现着<strong>第三方（代理）的魅力。</strong><br>14、当我们手足无措、绞尽脑汁时、多想想代理，代理就是你的帮手、秘书！<br>15、<strong>代理的本质有三类：缓存（保留状态）、公正（安全认证）、传递（消息同步异步）。</strong><br>16、分久必合、合久必分是历史的规律、也是科技的回流。<br>17、<strong>拆分、解耦、归并、融合、归并排序很好的阐释了上述原理。</strong><br>18、<strong>比如React中Fiber数据结构用到的时间分片（拆分）、划分reconciler和commit阶段；setstate中异步操作、批量更新（合并）。</strong><br>19、<strong>setState 只在合成事件和钩⼦函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。</strong><br>20、时间和空间同样是很好的两个维度。<br>21、<strong>我们常常在其中做平衡、做选择、牺牲时间换取空间、或者逆向操作。</strong><br>22、比如Token的加密解密耗费了时间、但是解决了Session存储压力大的空间问题。<br>23、0和1是两个很奇妙的数字，它代表了选择和抛弃，<strong>工程师要敢于舍弃、有舍才有得。</strong><br>24、做权衡的时候我们可以想一想0-1的蜕变，<strong>多思考0-1之间的权重分配。</strong><br>25、前端发展就是一部<strong>性能优化的历史。</strong><br>26、优化来自两部分：减少计算的框架和工具（Webpack、Flutter）、加快传输的通信协议。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 再谈谈深度学习方向的思考：</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p>1、卷积网络CNN的起源来自于模拟人类的大脑神经元。<br>2、RNN网络的思想有点像人类的<strong>七天记忆遗忘曲线。</strong><br>3、Attention（注意力）机制就是模拟了人类的<strong>视野感受差。</strong><br>4、人类总喜欢关注中心化的、有差异的、有视觉冲击力的。<br>5、<strong>整体与局部、分支与合并、权重分配</strong>、是优化神经网络的三大角度。</p>
<h2 id="八、你怎么看前端？"><a href="#八、你怎么看前端？" class="headerlink" title="八、你怎么看前端？"></a>八、你怎么看前端？</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">今天简单划分一下方向，还有很多科研任务要完成，日后小霞来细细剖析！</span><br><span class="line">这个话题很深远、广大、小霞还需要默默沉淀、积累！</span><br><span class="line">目前输出是《小霞看前端》——从研究生生活与科研的视角</span><br></pre></td></tr></table></figure>

<h2 id="九、有哪些习惯和生活思考？"><a href="#九、有哪些习惯和生活思考？" class="headerlink" title="九、有哪些习惯和生活思考？"></a>九、有哪些习惯和生活思考？</h2><p>1、吾日三省吾身<strong>为人谋而不忠乎，与朋友交而不信乎，传不习乎?</strong><br>（搞笑版的三反省：看脸看体重秤看余额宝，哈哈小霞都会反省啦~）<br>2、背单词！这是小霞从小学一年级开始的习惯（在次艾特我亲爱的老妈，感谢她老人家的严格要求）<br>3、写日记或者博客，原因很简单：<strong>反思自己、记录自己和世界的变化、联系。</strong><br>4、我相信这是宝贵的数字资产、我也相信时间不可逆、灵感不可逆。<br>5、好习惯成就不平凡的人生。<strong>平凡人要有不平凡的精神寄托。</strong><br>6、<strong>人最难的是认清自己、很多进步和优化来自梳理、复盘、总结。</strong><br>7、<strong>每个独立个体都需要性能优化。</strong><br>8、写日记就是照镜子、不带滤镜的那种，<strong>你需要时刻倾听内心真实的想法。</strong><br>9、临渊羡鱼、不如退而结网。<strong>在每个人的坐标差里、你从未静止。</strong><br>10、<strong>很多东西都有保质期、但我们总贪恋持久化。</strong><br>11、<strong>认清这个真实的世界、然后微笑着用尽全力去爱她。</strong></p>
<h2 id="十、小霞名字的渊源？"><a href="#十、小霞名字的渊源？" class="headerlink" title="十、小霞名字的渊源？"></a>十、小霞名字的渊源？</h2><blockquote>
<p>落霞与孤鹜齐飞、秋水共长天一色！</p>
</blockquote>
<p>这有什么深厚的秘密和涵义吗？<br>当然有！来自文化人姥爷的精雕细琢！<br>欲知后事如何，请听小霞下次分解~</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E4%B8%AA%E4%BA%BA%E6%97%A5%E8%AE%B0%E6%80%BB%E7%BB%93/" rel="tag">个人日记总结</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E5%B1%95%E6%9C%9B%E6%9C%AA%E6%9D%A5%E5%8D%81%E5%B9%B4/" rel="tag">展望未来十年</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-React学习小结（一）" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/04/20/React%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"
    >阿里面试总结（五）——React学习小结（一）</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/04/20/React%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/" class="article-date">
  <time datetime="2020-04-19T16:00:00.000Z" itemprop="datePublished">2020-04-20</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="categories/React%E6%80%9D%E6%83%B3%E8%AE%BE%E8%AE%A1/">React思想设计</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>本文旨在以精简、通俗的语言传达React的思想<br>来自阅读源码、《深入浅出React》的一些提炼！<br>来自个人梳理总结，重在设计思想的探索，新版迭代快，可能有某些API的细微差别，欢迎指出不到位的地方。<br>欢迎大家一起讨论学习，集思广益！<br>Welcome to share creative thoughts!</p>
<h2 id="1-React独特思想"><a href="#1-React独特思想" class="headerlink" title="1.React独特思想"></a>1.React独特思想</h2><pre><code>1.UI =render(data)
纯函数：最终的用户界面，在 render 函数确定的情况下完全取决于输入数据。
2.函数式编程、响应式展示、拆分数据data和视图render。</code></pre><h2 id="2-虚拟DOM"><a href="#2-虚拟DOM" class="headerlink" title="2.虚拟DOM"></a>2.虚拟DOM</h2><pre><code>1.DOM 是结构化文本（HTML文本）的抽象表达形式，HTML中的每个元素都对应 DOM中某个节点，树状关系，层级嵌套。
2.虚拟DOM不涉及浏览器、本质是JS对象，存在于JS内存中的树形结构。
3.每次比较，Diff算法，找出真假差异，批量更新（Fiber的创新之处后期更新）</code></pre><h2 id="3-框架流程"><a href="#3-框架流程" class="headerlink" title="3.框架流程"></a>3.框架流程</h2><pre><code>1.单向数据流思想：数据驱动---&gt;N个事件触发render函数---&gt;虚拟DOM改变---&gt;Diff差异---&gt;更新视图（真实DOM）。
2.充分解耦、组件拆分。
3.关注输入、输出、有点面向对象编程的思想。
4.借助虚拟DOM，重复渲染来实现动态更新效果，实际上减少了DOM操作，渲染效率高。
5.（React花了很多心思来解决渲染问题，后期一一剖析）</code></pre><h2 id="4-React中的容器组件和傻瓜（展示）组件"><a href="#4-React中的容器组件和傻瓜（展示）组件" class="headerlink" title="4.React中的容器组件和傻瓜（展示）组件"></a>4.React中的容器组件和傻瓜（展示）组件</h2><pre><code>1.拆分业务、一个组件专注做一件事。
2.外层（父聪明）容器组件负责和 Redux Store 打交道的组件。容器组件监听商店状态、通过props告知展示组件重新渲染。
3.内层（子傻瓜）组件只专心负责渲染界面，傻瓜组件是纯函数，只需要根据props来渲染结果，不需要state，state都交给容器组件去打理
4.傻瓜组件没有状态，不需要用对象表示，所以连类都不需要了，对于一个只有 render法的组件，缩略为一个函数就OK，性能优化！</code></pre><p> <img src="https://img-blog.csdnimg.cn/20200420104708974.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="5-props"><a href="#5-props" class="headerlink" title="5.props"></a>5.props</h2><pre><code>1.prop外部传入的数据，对外接口，支持任意数据类型，不是字符串类型必须要用花括号｛｝把 prop 值包住。
2.style两层花括号，外层花括号代表是JSX语法，内层花括号代表这是一个对象常量。
3.函数类型的 prop 就是让父组件交给了子组件一个回调函数。
4.子组件可以恰当的调用函数类型的prop，带上必要的参数，反过来把信息传递给外部世界。
4.组件定义自己的构造函数，必须加上super(props),才可以后续通过this.props访问到父组件传递过来的 props 值。</code></pre><h2 id="6-state"><a href="#6-state" class="headerlink" title="6.state"></a>6.state</h2><pre><code>1.prop不能修改，记录自己的状态只能用state，state存在的意义是被修改。
2.比如计数器初始值是prop传递，加减之后的状态变化由state存储。
3.state 必须是一个 JavaScript 对象，不能是 string 或者 number 这样的简单数据类型。
4.当我们需要存储的只是一个数字类型的数据时，应该把它存作 state 某个字段对应的值。
5.this.state 可以读取到组件的当前 state，this.setState 函数才可以修改数据。</code></pre><h2 id="7-React组件间通信方式"><a href="#7-React组件间通信方式" class="headerlink" title="7.React组件间通信方式"></a>7.React组件间通信方式</h2><pre><code>1.父组件向子组件通讯: 父组件可以向⼦组件通过传 props 的⽅式，向子组件进⾏通讯 。
2.子组件向父组件通讯: props+回调的方式，父组件向子组件传递props进行通讯，此props的作用域为父组件自身的函数。
子组件调用该函数，将子组件想要传递的信息，作为参数，传递到父组件的作用域中 。
3.兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信息进行通信。
4.跨层级通信: Context 设计目的是为了共享那些对于⼀个组件树而言是“全局”的数据。
例如当前认证的用户、主题或首选语⾔,对于跨越多层的全局数据可以通过 Context 通信。
5.发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应。
我们可以通过引⼊event模块进行通信全局状态管理工具: 
借助Redux或者Mobx等全局状态管理⼯具进行通信---&gt;这种工具会维护⼀个全局状态中心Store---&gt;Store根据不同的事件产生新的状态。</code></pre><h2 id="8-React中的context"><a href="#8-React中的context" class="headerlink" title="8.React中的context"></a>8.React中的context</h2><p><strong>为什么有context?</strong><br>1、React 组件是用 props 来传递父子组件之间的数据的。<br>2、在一个嵌套多层的组件结构中，如果只有最里层的组件才需要使用 store，但是为了把store从外面传到最里面，所有的中间组件都要支持store prop，层级太深时用 prop 传递 store 不是一个好方法。<br><strong>context做了什么？</strong><br>1、context让一个树状组件上所有组件都能访问一个共同的对象。<br>2、上级组件要宣称自己支持 context ，并且提供一个函数来返回代表 Context的对象。<br>3、这个上级组件之下的所有子孙组件，只要宣称自己需要这个 context ，然后通过 this.context 访问到这个共同的环境对象<br><strong>使用context要注意什么？</strong><br>1、Context 相当于提供了一个全局可以访问的对象，但是只要有一个地方改变了全局对象的值，应用中其他部分就会受影响<br>2、只有对那些每个组件都可能使用，但是中间组件又可能不使用的对象才有必要使用Context 。</p>
<p><img src="https://img-blog.csdnimg.cn/20200420105841440.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="9-设计好Store-属性，是规划好-Redux流程的基础"><a href="#9-设计好Store-属性，是规划好-Redux流程的基础" class="headerlink" title="9. 设计好Store 属性，是规划好 Redux流程的基础"></a>9. 设计好Store 属性，是规划好 Redux流程的基础</h2><p>生动的说就是：<br>你想看到最新的报纸消息（信息同步），Flux是一个快递员(Dispatcher)送货，你必须要记住快递员的电话（注册订阅），由快递员来通知你，给你送最新的报纸。<br>但是！在Redux中,设置了一个信息中心store，全世界只有一个Onlyone！<br>没有快递员，但是你有自己的手机（dispatch）你想信息同步，直接打开手机，刷刷每日最新就OK！<br>由一部手机（这个手机就是store绑定在自己身上的函数dispatch）来实现信息同步。<br>这个函数帮你完成了一切复杂的分发信息流程！（函数式编程思想的体现）</p>
<p>   1.数据不一致怎么办？—&gt;靠Redux中的store来解决，全局状态就是唯一可靠的数据源。<br>    Redux Store 状态设计的一个主要原则：唯一数据源<br>    2.仅仅在构造组件时根据 store 来初始化 this.state 远远不够，还要保持 store 上状态和 this .state 的同步。<br>    3.在Flux中有多个store，分发功能由一个Dispatcher 对象完成（这个Dispatcher对象把一个 action 对象分发给多个注册了的 Store)。<br>    4.但是！Redux 全局只有一个Store，废弃了Dispatcher对象，在全局Store上绑定自己的函数dispatch，调用这个函数就可以拿到新的数据。<br>    5.通过 store.getState （）能够获得 store 上存储的所有状态，但是当我们只想获取组件的某一部分数据时，要在getOwnState函数中设计好逻   辑，以后任何关联 Store 状态的地方都可以重用getOwnState这个函数。<br>     6.在componentDidMount设计监听函数，通过 Store subscribe 监听其变化，只要 Store状态发生变化，就会调用这个组件的 onChange 方法。<br>     7.在 componentWillUnmount函数中，我们必须把这个监听注销掉，这个清理动作和 componentDidMount 中的动作对应。<br>     8.除了从 store 同步状态，视图中可能会想要改变 store 中的状态，但是改变store 中状态的唯一方法就是派发action。<br>     9.在 Redux 中，action 构造函数只负责创建对象，要派发 action需要调用 store.dispatch 函数。</p>
<h2 id="10-redux的工作流程？"><a href="#10-redux的工作流程？" class="headerlink" title="10.redux的工作流程？"></a>10.redux的工作流程？</h2><p>源码版：建议配合源码食用，比较复杂但是可以啃下来<br><img src="https://img-blog.csdnimg.cn/20200420124530161.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200420113519742.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">核心概念：</span><br><span class="line">    <span class="selector-tag">Store</span>：保存数据的地方，可以把它看成一个容器，整个应用只能有⼀个<span class="selector-tag">Store</span>。</span><br><span class="line">    <span class="selector-tag">State</span>：<span class="selector-tag">Store</span>对象包含的所有数据，如果想得到某个时点的数据，就要对<span class="selector-tag">Store</span>生成快照，某一时间的数据集合就是<span class="selector-tag">state</span> </span><br><span class="line">    <span class="selector-tag">Action</span>：<span class="selector-tag">State</span>的变化，会导致<span class="selector-tag">View</span>的变化。</span><br><span class="line">    注意！用户接触不到<span class="selector-tag">State</span>，只能接触到<span class="selector-tag">View</span>。所以<span class="selector-tag">State</span>的变化必须 是<span class="selector-tag">View</span>导致的。</span><br><span class="line">    <span class="selector-tag">Action</span>就是<span class="selector-tag">View</span>发出的通知，表示<span class="selector-tag">State</span>应该要发生变化了。</span><br></pre></td></tr></table></figure>

<p>梳理简洁版：思想是通用的</p>
<blockquote>
<p>Action Creator：View要发送多少种消息，就会有多少种Action。我们定义⼀个函数Action Creator来生成Action。<br>Reducer：一个函数，它接受Action和当前State作为参数，返回⼀个新的State。<br>当Store收到Action以后，必须返回⼀个新的State，这样View才会发生变化。这种State的计算过程就是Reducer。<br>dispatch：是View发出Action的唯⼀方法。<br>    然后我们对照上图梳理一下整个工作流程：<br>    1. 首先，⽤户（通过View）发出Action，触发store.dispatch(action)方法，将状态变化通知到中间件。<br>    2. 然后，Store自动调用Reducer函数，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State<br>    3. State⼀旦有变化，Store就会调用监听函数，来更新View。<br>    4. 到此回到View层，⼀次用户交互流程结束。<br>   总结：在整个流程中数据都是单向流动的，这种方式保证了流程的清晰。</p>
</blockquote>
<p>**</p>
<h2 id="11-redux中如何进行异步操作"><a href="#11-redux中如何进行异步操作" class="headerlink" title="11.redux中如何进行异步操作?"></a>11.redux中如何进行异步操作?</h2><blockquote>
<p>借助redux的异步中间件进行异步处理.  redux异步流中间件分类：<br>redux-thunk<br>redux-saga<br> redux-effects<br> redux-side-effects<br> redux-loop<br> redux-observable</p>
</blockquote>
<h2 id="12-redux异步中间件之间的优劣对比"><a href="#12-redux异步中间件之间的优劣对比" class="headerlink" title="12.redux异步中间件之间的优劣对比"></a>12.redux异步中间件之间的优劣对比</h2><p> <strong>redux-thunk</strong><br> 优点:<br> 1、体积小<br> 2、实现方式很简单<br> 3、 redux-thunk没有引入像redux-saga或者redux-observable额外的范式，上手简单<br> 缺陷:<br> 1、样板代码过多、与redux本身一样，通常一个请求需要大量的代码，而且很多都是重复性质的、耦合严重<br> 2、异步操作与redux的action偶合在⼀起，不方便管理 ，功能孱弱</p>
<p> <strong>redux-saga</strong><br> 优点:<br> 1、异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js 中<br> 2、action摆脱thunk function: dispatch 的参数依然是⼀个纯粹的 action (FSA)<br> 3、function 异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败都可以直接通过 try/catch 语法直接捕获    4、redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用，封装方便<br> 5、redux-saga可以将多个Saga可以串行/并行组合起来,形成⼀个非常实用的异步flow<br> 6、易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等<br>  缺陷:<br>  1、额外的学习成本: 反正我还没有学完，API好多，上手有一定困难<br>   redux-observable<br>   优点:<br>   1、功能最强，背靠rxjs这个强大的响应式编程库<br>   2、借助rxjs的操作符，几乎可以完成异步处理的需求<br>   剩下的还没有了解到，暂不介绍，一入前端深似海。。。</p>
<h2 id="13-Redux-终极小结"><a href="#13-Redux-终极小结" class="headerlink" title="13.Redux 终极小结"></a>13.Redux 终极小结</h2><pre><code>1. 唯一数据源：状态数据应该只存储在唯一的一个 Store上，这个store是一个树形的对象，每个组件往往只是用树形对象上一部
    分的数据。
2. 保持状态只读：不能去直接修改状态，要修改 Store 的状态，必须要通过派发action 对象完成。UI =render( state )
    改变状态的方法不是去修改状态上值，而是创建一个新的状态对象返回给 Redux ，由 Redux 完成新的状态的组装。
3. 数据改变只能通过纯函数完成：reducer(state , action)，函数的返回结果必须完全由参数 state action 决定，而且不产生任何副
   作用，也绝对不能修改参数 state action 对象，改变store中状态的方法就是派发action。
4. Redux中，action 构造函数只负责创建对象，要派发 action，需要调用 store.dispatch 函数。
5. 每个 action 构造函数都返回一个action 对象。
6. 组件的 render 函数所显示的动态内容，要么来自于 props ，要么来自于自身状态。
7. Redux中的reducer 只负责计算状态，却并不负责存储状态，在 reducer 中，绝对不能去修改数中的 state，它是纯函数，是一个计算公式。
8. React Redux 本质上是两个独立的产品， 一个应用可以使用React而不使用Redux，也可以使用 Redux 而不使用 React。
9. 在 Redux 中，很多函数都是不做产生副作用的动作，而是返回一个对象，把如何处理这个对象的工作交给调用者。
10.Redux 中把 state 作抽取出交给 Redux 框架本身， reducer 只用关心如何更新 state 而不要管 state 怎么存。</code></pre><h2 id="14-react-redux是如何工作的"><a href="#14-react-redux是如何工作的" class="headerlink" title="14.react-redux是如何工作的?"></a>14.react-redux是如何工作的?</h2><p><img src="https://img-blog.csdnimg.cn/20200420120213681.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>react-redux将所有的组件分成两大类：</strong></p>
<p><strong>UI组件：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">只负责<span class="selector-tag">UI</span>的呈现，不带有任何业务逻辑</span><br><span class="line">通过<span class="selector-tag">props</span>接受属性（非函数属性）</span><br><span class="line">不使用任何<span class="selector-tag">redux</span>的<span class="selector-tag">API</span></span><br><span class="line">一般保存在<span class="selector-tag">components</span>文件夹下</span><br></pre></td></tr></table></figure>

<p><strong>容器组件:</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">负责管理数据和业务逻辑，不负责<span class="selector-tag">UI</span>的呈现</span><br><span class="line">使用<span class="selector-tag">redux</span>的<span class="selector-tag">API</span></span><br><span class="line">一般保存在<span class="selector-tag">containers</span>文件夹下</span><br></pre></td></tr></table></figure>

<p><strong>mapStateToProps</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">基本语法：<span class="selector-tag">mapStateToProps</span>(<span class="selector-tag">state</span>, <span class="selector-tag">ownProps</span>)</span><br><span class="line"></span><br><span class="line">参数含义：<span class="selector-tag">state</span> 全局状态 、 <span class="selector-tag">ownProps</span>代表组件本身的<span class="selector-tag">props</span>。</span><br><span class="line">（如果写了第二个参数<span class="selector-tag">ownProps</span>，那么当<span class="selector-tag">prop</span>发生变化的时候，<span class="selector-tag">mapStateToProps</span>也会被调用）。</span><br><span class="line"></span><br><span class="line">作用：将<span class="selector-tag">store</span>中的数据作为<span class="selector-tag">props</span>绑定到组件中。</span><br><span class="line"></span><br><span class="line">调用：只要<span class="selector-tag">store</span>更新了就会调用<span class="selector-tag">mapStateToProps</span>方法。</span><br><span class="line"></span><br><span class="line">返回结果：<span class="selector-tag">mapStateToProps</span>返回的结果必须是<span class="selector-tag">object</span>对象，该对象中的值将会更新到组件中。</span><br></pre></td></tr></table></figure>
<p><strong>mapDispatchToProps</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">基本语法：<span class="selector-tag">mapDispatchToProps</span>(<span class="selector-tag">dispatch</span>, <span class="selector-attr">[ownProps]</span>)</span><br><span class="line"></span><br><span class="line">参数：<span class="selector-tag">dispatch</span>  <span class="selector-tag">store</span><span class="selector-class">.dispatch</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ownProps</span>代表组件本身的<span class="selector-tag">props</span>，如果写了第二个参数<span class="selector-tag">ownProps</span>，那么当<span class="selector-tag">prop</span>发生变化的时候，<span class="selector-tag">mapDispatchToProps</span>也会被调用。</span><br><span class="line"></span><br><span class="line">作用：定义<span class="selector-tag">UI</span>组件如何发出<span class="selector-tag">action</span>，实际上就是要调用<span class="selector-tag">dispatch</span>这个方法。</span><br><span class="line">调用：<span class="selector-tag">props</span>改变。</span><br><span class="line"></span><br><span class="line">返回结果：返回包含对应<span class="selector-tag">action</span>的<span class="selector-tag">object</span>对象。</span><br></pre></td></tr></table></figure>

<p><strong>Provider</strong>：让所有组件都可以使用state数据</p>
<p><strong>Connect: 负责连接React和Redux</strong> </p>
<p>1、获取state：<br>Connect通过context获取Provider中的store，通过store.getState()获取整个store tree 上所有state  。</p>
<p>2、包装原组件:<br>将state和action通过props的方式传入到原组件内部—&gt;<br>WrapWithConnect返回⼀个ReactComponent对象Connect—&gt;<br>Connect重新render外部传入的原组件WrappedComponent—&gt;<br>把connect中传入的mapStateToProps、mapDispatchToProps与组件上原有的props合并—&gt;<br>合并之后通过props的方式一起传给WrappedComponent </p>
<p>3、监听store tree变化:<br>connect缓存了store tree中state的状态—&gt;<br>通过当前state状态和变更前state状态进行比较—&gt;<br>从而确定是否调用this.setState()方法触发Connect及其子组件的重新渲染。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/React/" rel="tag">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E7%90%86%E8%A7%A3%E2%80%94%E2%80%94%E6%8F%90%E7%82%BC%E7%89%88/" rel="tag">源码分析与理解——提炼版</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-前端发展：一云多端、智能化、AI+" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/04/19/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%EF%BC%9A%E4%B8%80%E4%BA%91%E5%A4%9A%E7%AB%AF%E3%80%81%E6%99%BA%E8%83%BD%E5%8C%96%E3%80%81AI+/"
    >阿里面试总结（四）——小霞看前端——一云多端、智能化、AI+</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/04/19/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%EF%BC%9A%E4%B8%80%E4%BA%91%E5%A4%9A%E7%AB%AF%E3%80%81%E6%99%BA%E8%83%BD%E5%8C%96%E3%80%81AI+/" class="article-date">
  <time datetime="2020-04-18T16:00:00.000Z" itemprop="datePublished">2020-04-19</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="categories/%E5%B1%95%E6%9C%9B%E5%89%8D%E7%AB%AF/">展望前端</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="思考背景："><a href="#思考背景：" class="headerlink" title="思考背景："></a>思考背景：</h2><p>面试官哥哥(亲切、帅气、耐心倾听)延申的健康码、小程序、校园生活应用。</p>
<h2 id="面试总结："><a href="#面试总结：" class="headerlink" title="面试总结："></a>面试总结：</h2><p>1、技术的背后是人文，好的技术专注用户体验、性能优化、AI创新。</p>
<p>2、前端专家是综合性人才，高屋建瓴，兼顾商业背景、技术架构、产品体验</p>
<p>3、挖掘需求、解决痛点。</p>
<p>健康码：疫情下保障安全出行。（时代背景）</p>
<p>校园生活：打通支付闭环、热点引流、用户留存、丰富平台生态。</p>
<p>小程序：前端智能化、生活化、数字化。（移动时代碎片化、数字化）</p>
<p>4、企业理念是导向，用户体验是目标、技术框架是基石。缺一不可！~</p>
<p>6、反思：背了四年主持稿，英语演讲、辩论赛思维不适合面试场景</p>
<p>7、面试的语速要减慢、精简复杂流程、结构化表达、放轻松。</p>
<p>TIPS：企业和学校不同，工作之后汇报时要精炼、简洁</p>
<p>学校教育喜欢刨根问底追究细节，工作要注重高效率、高产出、浓缩精华。</p>
<p>8、解决问题的方法论、团队协作能力要从点线面的角度举例说明。</p>
<p>9、关注支付宝小程序，从商业环境、技术架构升级思考前端发展。</p>
<p>10、关注前沿技术、多比较JS、TS、Dart的异同，沉淀技术实力。</p>
<p>11、关注移动端发展曲线、想想怎么做好小程序，打造自己的差异化优势。</p>
<p>12、关于Node.js底层原理、Koa中间件、JS内存管理、V8引擎、性能优化、VUE、React设计思想我都有私下做过功课</p>
<p>以后把纸质笔记本的内容输出到公众号奈何公众号一天只能发一次</p>
<p>附上小霞22岁方法论：<br><img src="https://img-blog.csdnimg.cn/20200419132255688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>Apple法则：  取首英文字母串联起流程像乔布斯一样做前端</p>
<p>确定产品定位、项目目标、针对哪些场景优化到什么数量级？(Ambition）</p>
<p>收集用户需求、辨别真伪、确定优先级、做好项目排期（Accumulation)</p>
<p>预测方案A/B/C哪个性能更好？哪个框架更优？技术选型比较（Prediction)</p>
<p>确定方案后、团队合作、深耕细耘、一万小时的努力成就辉煌(Persistence)</p>
<p>前端科技日新月异、保持热情、终身学习、T型发展（Learn）</p>
<p>提高沟通表达效率、把自己打磨成一个接口，对接后台、UI、产品（Link）</p>
<p>及时复盘、定期总结、虚心求教、自我评估（Evaluation）</p>
<p>产品上线、数据分析、预测商业价值、盘活商业模式（Estimation）</p>
</blockquote>
<p>因为面试官哥哥提到了小程序的前端发展。所以有了下文~</p>
<h2 id="今日目标：调研资料、梳理逻辑、提炼总结"><a href="#今日目标：调研资料、梳理逻辑、提炼总结" class="headerlink" title="今日目标：调研资料、梳理逻辑、提炼总结"></a>今日目标：调研资料、梳理逻辑、提炼总结</h2><p>调研资源来自搜索引擎、阿里云，经过逻辑思考之后输出如下</p>
<p>以小程序为主题，从业务逻辑、技术架构、学习成果、前端思考上写个总结！</p>
<p>主要是帮助自己梳理业务逻辑，做好前端要和后台、运营、产品紧密对接</p>
<p>毕竟团队合作，众人拾柴才能提高企业发展的效率</p>
<p>小程序架构图先存储起来，后面好好梳理，阿里技术团队真的厉害</p>
<p>借助目前的知识沉淀能大概理解其中的原理，不过精细之处还要多多学习、细细研究</p>
<p>前端智能化发展一个很棒的例证！  链接如下：</p>
<p>商家应用 + AR : 助力虚拟试妆引擎落地手淘（2019/12/19)</p>
<p>最后附上研究生AI人体姿态估计成果</p>
<p>（流程复杂，面试难以讲好，不过面试官哥哥很耐心听我balabala）</p>
<p>（最后还鼓励了我，感动只要被肯定，就要坚持不懈）</p>
<p>总之，AI+前端让未来充满了希望和可能！</p>
<p>OK，吾日三省吾身，欲知细节，请看下文~</p>
<h2 id="一、业务逻辑"><a href="#一、业务逻辑" class="headerlink" title="一、业务逻辑:"></a>一、业务逻辑:</h2><p>718+X 模式打通线上线下场景 + 助力中小商家+  全球最佳B2B服务</p>
<p><img src="https://img-blog.csdnimg.cn/20200419132321364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200419132333400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p> 七大入口为小程序引流：</p>
<p>扫一扫、搜索、朋友tab主入口、支付成功页、小程序收藏、生活号、卡包</p>
<p>一个闭环构造商业生态：</p>
<p>构成服务、拉新、留存、促活的完整闭环。</p>
<p>八大API接口激活冷启动：</p>
<p>芝麻信用、资金管理、金融服务、高德定位、导航、路线规划、菜鸟和1688的配送、溯源、供应链。</p>
<p>X场景提升用户体验：</p>
<p>助力小程序一次开发，在阿里app中多端透出、多端运行。</p>
<p>企业核心：建立一套交易和信用机制    </p>
<p>小程序特点：高可用、性能优化、多端输出</p>
<p>阿里商业要素：信任+口碑+体验</p>
<p><img src="https://img-blog.csdnimg.cn/20200419132351900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>二、技术架构：</p>
<p>一云多端、借助AI、AR、VR、5G构建丰富场景</p>
<p>一云多端<br><img src="https://img-blog.csdnimg.cn/20200419132406969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>系统架构<br><img src="https://img-blog.csdnimg.cn/20200419132424100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>开发者：编程模型简洁、官方文档详细、学习门槛低、快速开发。</p>
<p>渲染引擎：</p>
<p>JavaScript+Webview 的方式</p>
<p>JavaScript+Native 的方式</p>
<p>研发支撑、运维支撑服务：提升开发者效率、上线管理等等。</p>
<p>运行架构<br><img src="https://img-blog.csdnimg.cn/20200419132442297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>浏览器内核<br><img src="https://img-blog.csdnimg.cn/20200419132449168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>离线缓存优化流程图<br><img src="https://img-blog.csdnimg.cn/20200419132459154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>虚拟DOM优化流程图<br><img src="https://img-blog.csdnimg.cn/20200419132513975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>技术架构部分的图片来自支付宝小程序首席架构师白招拒老师的分享</p>
<p>在次表示感谢，我会在后续日记中仔细梳理细节、输出自己的独立思考</p>
<p>今天先揭开小程序的面纱，后面再庖丁解牛、条分缕析</p>
<p>放上我的前端笔记：我取名叫四库全书、葵花宝典</p>
<p>涵盖了前端的汪洋知识星海，纯手写画图够真诚<br><img src="https://img-blog.csdnimg.cn/20200419132529800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>前端小程序怎么做？：</p>
<blockquote>
<p>现阶段我的理解：先记录五点，随着不断学习补充提升，请大家多多指教</p>
<p>1、业务流程场景化、优化渲染效果、打造极致体验（AR   VR   WebGL） </p>
<p>2、针对需求做好性能优化(技术框架、打包工具、CDN加速、5G、云端计算）</p>
<p>3、每一点都很不容易，扩大视野的同时要关注细节。</p>
<p>4、前端人要心有猛虎、细嗅蔷薇。</p>
<p>5、水能载舟、亦能覆舟。企业是舟、用户是水，打造企业品牌、追求极致体验</p>
<p>是前端人的目标和初心！</p>
</blockquote>
<p>三、学习成果   AI姿态估计（我的毕业设计方案）</p>
<p>研究生团队目前成果：<br><img src="https://img-blog.csdnimg.cn/20200419132557989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>（我们实验室的团队~第一排右2是小霞）</p>
<pre><code>华科女子军最多的团队</code></pre><p><img src="https://img-blog.csdnimg.cn/20200419132607972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>多人上肢关键点识别：<br><img src="https://img-blog.csdnimg.cn/20200419132616214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200419132628629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/2020041913264017.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们还能做什么？</p>
<p>人脸检测、手势识别、手势交互、目标追踪</p>
<p>四、前端行业未来思考 ：AI智能、图形学、云计算、蓬勃生态<br><img src="https://img-blog.csdnimg.cn/20200419132656608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>前端发展行情？</p>
<p>Webpack推陈出新Module Federation</p>
<p>Severless函数应用架构升级</p>
<p>基于FAAS实现NPM CDN同步</p>
<p>电商直播+AR技能应用升级</p>
<p>支付宝新春活动3D特效</p>
</blockquote>
<p>引领时代潮流、打造极致体验、开源助力分享、智能重构升级！</p>
<p>理科生眼中的前端情怀：</p>
<blockquote>
<p>舍我其谁、无惧挑战是每一个前端人的Map</p>
<p>心有猛虎、细嗅蔷薇是每一个前端人的Key</p>
<p>拥抱变化、精雕细琢是每一个前端人的Value</p>
<p>前端是一汪浩瀚星海，一片神奇星空！</p>
<p>一切皆有可能万物之上、希望至美 !</p>
</blockquote>
<p>我眼中的阿里内涵：</p>
<p><strong>左耳旁是太阳：原子碰撞、光芒万丈、阿里蒸蒸日上！（阿）</strong></p>
<p><strong>右部首是可能：创造时机、人才济济、阿里充满希冀 !（阿）</strong></p>
<p><strong>一横一竖、刚正坚挺、阿里用信任建设芊芊江山 !（里）</strong></p>
<p><strong>一田一土、返璞归真、阿里用赤诚打动亿万客户!（里）</strong></p>
<p>为了平仄相生、韵脚别致</p>
<p>本研究僧深度优先、广度优先搜了N遍残留的文学细胞</p>
<p><strong>亲爱的阿里</strong></p>
<p><strong>我愿赴汤蹈火、在所不辞</strong></p>
<p><strong>永葆热情、虚心求教</strong></p>
<p><strong>遇见前端，我想遇见更好的自己 !</strong></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E4%B8%AA%E4%BA%BA%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/" rel="tag">个人职业规划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E6%9C%AA%E6%9D%A5%E5%8D%81%E5%B9%B4/" rel="tag">未来十年</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-阿里面试总结" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/04/17/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"
    >阿里面试复盘总结（三）——动画方案+秒杀系统+项目难题</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/04/17/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2020-04-16T16:00:00.000Z" itemprop="datePublished">2020-04-17</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/">经验总结</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="一、动画方案"><a href="#一、动画方案" class="headerlink" title="一、动画方案"></a>一、动画方案</h2><p>如何设置一个节日动画，推陈出新，提升用户体验？<strong>（技术选型）</strong></p>
<p>1.requestAnimationFrame<br>本质：传入的回调函数执行异步任务、属于宏任务队列、由系统刷新率决定回调函数的时间间隔。</p>
<p><strong>优点：</strong></p>
<p>系统决定回调函数执行时机，动画更流畅，不掉帧。</p>
<p>窗口没激活时，动画将停止，节省计算资源。</p>
<p>存在兼容性问题，自己可以封装。</p>
<p>按帧对网页动画进行重绘，可以并发渲染。</p>
<p><strong>动画方案：</strong></p>
<p>1.大图动画性能消耗大，使用translate3D实现GPU加速。</p>
<p>2.动画结束、暂停时，切换回2D，取消加速。</p>
<p>3.按需加载，必要时卸载。</p>
<p>4.简化函数计算，减少回流、重绘。</p>
<p>5.采用Web  Workers 开启多线程，提供更好的动画效果。</p>
<p><strong>用户体验优化：</strong></p>
<p>1.首屏优先加载，所以图片loaded以后，再启动主动画资源加载。</p>
<p>2.图片优化：雪碧图、压缩、Base64。</p>
<p>3.存储DOM变量，减少DOM tree的查找。</p>
<p>4.限频。</p>
<p><strong>场景应用：</strong></p>
<p>1.Three.js+requestAnimationFrame实现3D动态效果。</p>
<p>2.WebGL+Webpack 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var globalID;</span><br><span class="line"><span class="function">function <span class="title">animate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Do whatever</span></span><br><span class="line">  globalID=requestAnimationFrame(animate);</span><br><span class="line">  <span class="comment">// Do something animate，返回一个ID</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//when ot start</span></span><br><span class="line">  globalID=requestAnimationFrame(animate);</span><br><span class="line"><span class="comment">//when to stop</span></span><br><span class="line">  cancelAnimationFrame(globalID);<span class="comment">//取消回调函数</span></span><br></pre></td></tr></table></figure>

<p>2.setTimeout</p>
<p>本质：异步任务、宏任务队列、有最小执行时间。</p>
<p><strong>缺点：</strong></p>
<p>1.H5标准规定：setTimeout()的第二个参数的最小值（）最短间隔不得低于4毫秒，当我们把延迟时间设置为0，实际上会4毫秒后才把事件推入任务队列。</p>
<p>2.时间不精准，误差与代码执行时间有关。</p>
<p>3.队列中所有的代码都要等到JS进程空闲后才能执行，不论它们是如何添加到队列的。</p>
<p>3.setInterval</p>
<p>本质：以指定周期调用函数，隔一段时间推入一个事件。异步循环任务。</p>
<p><strong>缺点：</strong></p>
<p>事件执行时间不一定准确，有可能当前事件还没有执行完毕，下一个事件来临。</p>
<p>某些间隔被跳过。</p>
<p>多个定时器的代码执行之间的间隔可能比预期小。</p>
<p><strong>解决方案：</strong>使用setTimeout构造轮询可以保证每次轮询的间隔。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function  fn()&#123;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"我被调用了"</span>);</span><br><span class="line">setTimeout(fn,<span class="number">100</span>);</span><br><span class="line">&#125;,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>这个模式链式调用了setTimeout()，每次函数执行的时候都会创建一个新的定时器。第二个setTimeout()调用当前执行的函数，并为其设置另外一个定时器。</p>
<p>这样做的好处是，在前一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。而且，它可以保证在下一次定时器代码执行前，至少要等待指定的间隔，避免了连续的运行。</p>
<p><strong>我的延申思考：</strong></p>
<p>requestIdleCallback()</p>
<p>1、MDN解释：该方法在浏览器的空闲阶段内调用函数排队。使开发者在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，比如动画和输入响应。</p>
<p>2、利用这个特性做性能优化：在每帧的空闲时间进行数据发送操作，或者低优先级的工作，不会影响动画的性能。</p>
<p>3、想到的应用：React  Fiber 架构思想：切割长任务，利用空闲时间执行，避免主线程长时间阻塞。</p>
<p>4、Fiber核心：树的深度遍历变成链表遍历+时间分片+任务调度。</p>
<p>其他实现方案：</p>
<p>GSAP:</p>
<p>优点：</p>
<p>1、运行速度快，多个动画可以同时执行。</p>
<p>2、轻量、模块化、按需使用、无需依赖。</p>
<p>3、零插件依赖。</p>
<p>4、灵活控制，代码量少，可以设置精确时间控制。</p>
<p>5、任何对象都可以实现动画。</p>
<p>6、实现重复：repeat设为-1就OK。</p>
<h2 id="二、Promise的理解"><a href="#二、Promise的理解" class="headerlink" title="二、Promise的理解"></a>二、Promise的理解</h2><p><strong>优点：</strong></p>
<p>1、对象状态不受外界影响。状态一旦改变，就不会再变。</p>
<p>2、解决了回调地狱。</p>
<p>3、提供统一接口，方便异步操作。</p>
<p><strong>缺点：</strong></p>
<p>1、无法中途取消。</p>
<p>2、处于pending无法知道进展到了哪一个阶段。（刚开始还是要完成）</p>
<p><strong>流程：观察者模式</strong></p>
<p>Promise的构造方法接收一个executor()，在new Promise()时就立刻执行这个executor回调</p>
<p>executor()内部的异步任务被放入宏/微任务队列，等待执行</p>
<p>then()被执行，收集成功/失败回调，放入成功/失败队列</p>
<p>executor()的异步任务被执行，触发resolve/reject，从成功/失败队列中取出回调依次执行</p>
<p>细节问题：</p>
<p>promise的then()放入了微任务队列。</p>
<p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获。</p>
<p>如果没有使用 catch 方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。</p>
<p>Node 有一个 unhandledRejection 事件，专门监听未捕获的 reject 错误。</p>
<p>Catch 方法返回的还是一个 Promise 对象，因此后面还可以接着调用 then 方法。</p>
<blockquote>
<p>then 方法</p>
</blockquote>
<ul>
<li><p>1、可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 resolved 时调用，第二个回调函数是<br>Promise 对象的状态变为 rejected 时调用。</p>
<p>2、第二个函数是可选的，不一定要提供。这两个函数都接受 Promise 对象传出的值作为参数。</p>
<p>3、采用链式的 then ，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个 Promise<br>对象（即有异步操作），这时后一个回调函数，就会等待该 Promise 对象的状态发生变化，才会被调用。</p>
<p>（异步变同步的思路）</p>
<p>4、then(）回调不是函数时要忽略，否则会导致链式调用中断。</p>
<p>5、一个Promise依赖于另外一个Promise，异步变同步。简化3的说法</p>
</li>
</ul>
<blockquote>
<p>异步加载图片：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">loadImageAsync</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> Promise(function(resolve, reject) &#123; </span><br><span class="line"> var image = <span class="keyword">new</span> Image();</span><br><span class="line">  image.onload = function() &#123;</span><br><span class="line">   resolve(image); </span><br><span class="line">   &#125;;</span><br><span class="line">   image.onerror = function() &#123; </span><br><span class="line">   reject(new Error('Could not load image at ' + url)); </span><br><span class="line">   &#125;;</span><br><span class="line">   image.src = url; </span><br><span class="line">   &#125;); </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>All方法</p>
</blockquote>
<p>1、接受的参数是数组（里面有多个Promise实例）或者具有iterable接口的对象，但必须使返回的成员是promise的实例。</p>
<p>2、数组中每一项都执行成功才会成功，有一个失败就失败。</p>
<p>3、可以用到前后端加载数据、解决乱序渲染的问题。</p>
<p>（数组下标迭代保证了顺序）</p>
<p>4、异步处理的好帮手，比如ajax请求多个数据，在此之前显示loading图标，使加载全部完成再显示页面，区分懒加载和预加载，看具体场景需求。</p>
<p>5、即使响应时间不同，也可以保证接受到的数据与原始数据顺序一致。</p>
<p>6、一个操作需要所有的Promise一起运行才能解决问题。</p>
<p>Race方法</p>
<p>1、不管结果成功还是失败，数组中哪一个结果最先执行完成就返回哪个结果。</p>
<p>2、具体场景还没有想到，业务里有这种需求吗？后续脑补。</p>
<p>我的延申思考：</p>
<p>1、Promise解决了异步编程的一些问题，但是链式调用不能取消执行，无法获取执行进度怎么办？</p>
<p>2、实际开发，我们如何做好状态管理，兼顾好同步和异步的切换？</p>
<p>3、上述解答可以从其他的框架中挖掘答案。</p>
<p>方案对比和思考：</p>
<p>Generator:</p>
<p>1、generator函数返回一个遍历器对象，是函数的内部指针。</p>
<p>2、每次调用遍历器对象的next方法，就会返回有value和done两个属性的对象。</p>
<p>3、value属性表示当前内部状态的值，等于yield语句后面的值。</p>
<p>4、done属性是布尔值，表示是否遍历结束。</p>
<p>优点：控制函数的暂停和继续，向外输出结果，下次继续执行可以传入参数。</p>
<p>缺点：不能自动执行，遇到yield暂停，要手动控制。</p>
<p>控制Generator函数流程的关键：</p>
<p>是接受传入的值，并且可以把执行的权力还给程序。</p>
<blockquote>
<p>yield*</p>
</blockquote>
<p>yield委托，让出迭代控制。</p>
<p>co:</p>
<p>返回一个Promise对象，让generator自动执行，类比执行器。</p>
<p>thunk函数</p>
<p>自动执行Generator函数。</p>
<blockquote>
<p>for  of :</p>
</blockquote>
<p>遍历Generator函数运行生成的Iterator对象。</p>
<p>不用调用next 方法，可以通过break return 暂停遍历。</p>
<p>实战应用：</p>
<p>1、购物车每订购一件商品就调用next()实现库存的减一，记录库存状态。</p>
<p>2、三次抽奖活动，点击按钮调用next()实现次数减一，转动转盘的时候，让按钮禁止点击，转盘结束之后再调用next()进行下一次的抽奖，然后打开按钮的开关，记录按钮状态。</p>
<p>3、支付场景：付款之后通过定时器询问接口，是否处理完成订单流程。</p>
<p>4、总结一下就是在中断某一个操作时，要保留当时的状态，下次执行时回到当初的状态，比如我们做饭中途取了一个快递，然后保持菜的状态不改变，取完快递回来，接着做饭。</p>
<p>由Generator引发的协程原理思考：</p>
<blockquote>
<p>协程：</p>
</blockquote>
<p>1、协程有自己的上下文和栈，当任务切换时，会将当前的上下文和栈保存到其他地方，再被切回来的时候，恢复之前保存的上下文和栈。</p>
<p>2、我的理解就是：保留上一次的状态，重新进入时恢复到上次离开的状态。</p>
<p>3、按需生成返回结果，而不是一次性的return所有的结果。</p>
<blockquote>
<p>场景应用：</p>
</blockquote>
<p>1、用户登录状态，切换某个页面之后，再次回来，保留上一次的状态。</p>
<p>2、按需读取大文件，一段段的读取，不用一次遍历整个列表。</p>
<p>3、类比流的思想，这里还要多学习一下stream的知识。</p>
<p>4、直接读取大文件容易造成内存溢出，Generator不会造成内存溢出。</p>
<p>5、使用中还可以向yield中传入值。</p>
<p>6、协程开销远小于线程，yield让协程暂停，和线程的阻塞有本质的区别。</p>
<p>7、协程的暂停由程序控制、线程的阻塞状态由操作系统的内核来进行切换。</p>
<blockquote>
<p>由Generator引发的Koa中的原理思考：</p>
</blockquote>
<p>1、首先执行一次 dispatch(0) 也就是默认返回第一个 app.use 传入的函数， 使用 Promise 函数封装返回。</p>
<p>2、其中第一个参数是 ctx，第二个参数就是 next 参数，next 每次执行之后都会等于下一个中间件函数，如果下一个中间件函数不为真则返回一个成功的 Promise。</p>
<p>3、Koa V1  基于Generator   Koa V2 利用async函数。</p>
<p>4、洋葱模型的执行顺序类似捕获和冒泡的过程。</p>
<p>5、由堆栈这种先进后出的模型可以类比Koa框架自外到内的Request和由里到外的Response的数据流。</p>
<p>6、context的保存和传递、中间件的管理、next的实现要深入理解。</p>
<p>7、源码中调用App.use（）把一个中间件push到一个列表中，每次执行use函数，就在函数数组中添加了一个函数，然后通过compose来遍历整个中间件，最终将context和dispatch(i+1)传给了middleware。</p>
<p>8、一个中间件不能调用两次next()，调用时类比async函数，此时并不是表示中间件函数执行完毕了，调用了next()之后主程序还可以执行其他代码，类似于让next函数异步处理。（我对源码是这样理解的，有错误请大家指教）</p>
<p>9、compose将多个中间件函数合并成一个大的中间件函数，然后依次调用单独的每一层。</p>
<p>10、由compose处理中间件想到了redux，redux是利用数组的reducer对数组参数进行迭代。</p>
<p>11、Koa的思想是不是继承了Emitter？为了在任意时间处理抛出的异常，订阅了error事件，Koa有一个app-onerror事件输出错误的日志。</p>
<p>12、error处理有两个层面：APP层面负责log，一次响应过程中的error处理负责排查每次响应的结果。</p>
<h2 id="三、秒杀活动设计的思考方案"><a href="#三、秒杀活动设计的思考方案" class="headerlink" title="三、秒杀活动设计的思考方案"></a>三、秒杀活动设计的思考方案</h2><blockquote>
<p>背景：疫情枪口罩</p>
</blockquote>
<p>前端设计：防抖、节流减少请求次数、降低服务器压力</p>
<p>后端设计：Node玩法高级，开启Master+Worker模式</p>
<p>优点：</p>
<p>Node本身的特性是单线程、事件驱动、异步非阻塞。</p>
<p>没有多线程的切换上下文、加锁、销毁等复杂操作，之前博客也接触学习过。</p>
<p>线程安全、数据读写一致性好。</p>
<p>缺点：</p>
<p>单线程无法利用多核CPU</p>
<p>当时面试想到的方案：</p>
<p>1、<strong>首先进程通信在本科学过有信号量、共享内存、消息队列、管道、套接字等，不过Node是基于管道实现的。</strong></p>
<p>2、Node可以跨平台，libuv会针对不同的平台，采用不同的方式实现进程的通信。</p>
<p>3、开启child_process模块，利用child_process模块直接创建子进程。</p>
<p>暂时取名叫单线程+多进程模式吧</p>
<p>（这和H5提出的Web  Worker有异曲同工之妙，相当于另辟蹊径，解决了JS主线程和UI渲染共用一个线程所引发的相互阻塞问题）。</p>
<p>4、fork线程的开销还是比较大的，是为了利用CPU的资源。</p>
<p>5、口罩请求打到主进程上面，主进程进行代理，转发到不同端口的子进程上。</p>
<p>下来思考复盘之后可能出现的问题：</p>
<p>代理请求转发不友好</p>
<p>1、操作系统的文件描述符是有限的，维护需要成本。</p>
<p>2、比如：当客户端连接到主进程的时候，用完了一个操作符，当主进程连接到子进程时，又用掉了一个，从数量上看，代理方案不节省资源。</p>
<p>解决办法：（办法是查阅Node.js  9.2.3得出的）</p>
<blockquote>
<p>句柄传递-去除代理</p>
</blockquote>
<p>句柄传递可以代替代理的方案，原理是主进程收到客户端的请求之后，将这个请求直接发送到工作进程，而不是重新与子进程之间建立新的连接来转发数据。（又好像发布订阅模式）<br><img src="https://img-blog.csdnimg.cn/20200419125338865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200419125357754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>问题来了</p>
<p>为何通过发送句柄之后，多个进程可以监听到相同的端口而不引起异常？</p>
<p>官方解答：</p>
<p>1、因为独立启动的进程中，TCP服务器端socket套接字的文件描述符并不相同，导致监听到相同的端口时会抛出异常。</p>
<p>2、Node底层对每个端口监听设置了SO_REUSEADDR选项，不同进程可以对相同的网卡和端口进行监听，服务器套接字可以被不同的进程复用。</p>
<p>3、对于send(）发送的句柄还原出来的服务而言，文件描述符是相同的，所以监听相同的端口不会引起异常。</p>
<p>4、网络请求向服务器发送时，只有一个幸运的进程可以抢到连接，本质上一个请求的进程对应服务是抢占式的。</p>
<p>好了，这个问题终于解决啦</p>
<p>还有可能出现的问题：（简单给出思路和方案，日后再深入分析~）</p>
<p>1、数据共享？</p>
<p>答：Node本身不支持数据共享，所以我们要引入第三方Redis缓存，写一个定时脚本，在秒杀还没有开始之前，把口罩的库存数量写到Redis，从Redis拿数据处理。</p>
<p>2、多人抢一只口罩，库存来不及更新？</p>
<p>答：使用check-and-set实现乐观锁操作。（这个下去再仔细研究一下）</p>
<h2 id="四、项目梳理：每个项目选了一个点来切入"><a href="#四、项目梳理：每个项目选了一个点来切入" class="headerlink" title="四、项目梳理：每个项目选了一个点来切入"></a>四、项目梳理：每个项目选了一个点来切入</h2><h2 id="项目一"><a href="#项目一" class="headerlink" title="项目一"></a>项目一</h2><p>问题：给学校水果商店做的小程序，计算金额的时候，浮点数的精度问题。</p>
<p>举例子： 源自浮点数误差</p>
<p>0.1+0.2   //0.30000000000000004<br>1-0.9     //0.09999999999999998<br>9007199254740993-9007199254740992  //0<br>Math.pow(2,1023) //8.98846567431158e+307<br>//但是<br>Math.pow(2,1024)  //Infinity<br>0.1 &gt;&gt; 0.0001 1001 1001 1001…（1001无限循环）<br>0.2 &gt;&gt; 0.0011 0011 0011 0011…（0011无限循环）<br>原因分析：</p>
<p>JavaScript 里的数字是采用 IEEE 754 标准的 64 位双精度浮点数。</p>
<p>这个规范定义了浮点数的格式，对于64位的浮点数在内存中的表示：</p>
<p>最高的1位是符号位，接着的11位是指数，剩下的52位为有效数字。</p>
<p>第0位：符号位， s 表示 ，0表示正数，1表示负数；</p>
<p>第1位到第11位：储存指数部分， e 表示 ；</p>
<p>第12位到第63位：储存小数部分（即有效数字），f 表示；</p>
<p>根本原因：计算机底层只能二进制存储，所有的语言都存在这个问题。</p>
<blockquote>
<p>解决办法：</p>
</blockquote>
<p>1、引入两个库</p>
<p>Math.js<br> 适用于JavaScript 和 Node.js </p>
<p>具有灵活的表达式解析器，支持符号计算。</p>
<p>配有大量内置函数和常量</p>
<p>支持大数字(超出安全数的数字)，复数，分数，单位和矩阵的运算。</p>
<p>decimal.js<br>可以方便 JavaScript 进行十进制类型的任意精度数值计算。</p>
<p>2调用误差检查函数number.epsilon（）  兼容方法：math.abs(2，-52)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">withinErrorMargin</span> <span class="params">(left, right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.<span class="built_in">abs</span>(left - right) &lt; Number.EPSILON</span><br><span class="line">&#125;</span><br><span class="line">withinErrorMargin(<span class="number">0.1</span>+<span class="number">0.2</span>, <span class="number">0.3</span>)</span><br></pre></td></tr></table></figure>

<p>3、自己封装</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 核心方法，实现加减乘除运算，确保不丢失精度</span></span><br><span class="line"><span class="comment">     * 思路：把小数放大为整数（乘），进行算术运算，再缩小为小数（除）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param a &#123;number&#125; 运算数1</span></span><br><span class="line"><span class="comment">     * @param b &#123;number&#125; 运算数2</span></span><br><span class="line"><span class="comment">     * @param op &#123;string&#125; 运算类型，有加减乘除（add/subtract/multiply/divide）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">function <span class="title">operation</span><span class="params">(a, b, op)</span> </span>&#123;</span><br><span class="line">        var o1 = toInteger(a);</span><br><span class="line">        var o2 = toInteger(b);</span><br><span class="line">        var n1 = o1.num;</span><br><span class="line">        var n2 = o2.num;</span><br><span class="line">        var t1 = o1.times;</span><br><span class="line">        var t2 = o2.times;</span><br><span class="line">        var max = t1 &gt; t2 ? t1 : t2;</span><br><span class="line">        var result = null;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            case 'add':</span><br><span class="line">                <span class="keyword">if</span> (t1 === t2) &#123; <span class="comment">// 两个小数位数相同</span></span><br><span class="line">                    result = n1 + n2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t1 &gt; t2) &#123; <span class="comment">// o1 小数位 大于 o2</span></span><br><span class="line">                    result = n1 + n2 * (t1 / t2);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// o1 小数位 小于 o2</span></span><br><span class="line">                    result = n1 * (t2 / t1) + n2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result / max</span><br><span class="line">            case 'subtract':</span><br><span class="line">                <span class="keyword">if</span> (t1 === t2) &#123;</span><br><span class="line">                    result = n1 - n2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t1 &gt; t2) &#123;</span><br><span class="line">                    result = n1 - n2 * (t1 / t2);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = n1 * (t2 / t1) - n2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result / max;</span><br><span class="line">            case 'multiply':</span><br><span class="line">                result = (n1 * n2) / (t1 * t2);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            case 'divide':</span><br><span class="line">                result = (n1 / n2) * (t2 / t1);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加减乘除的四个接口</span></span><br><span class="line">    <span class="function">function <span class="title">add</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">        return operation(a, b, 'add');</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">function <span class="title">subtract</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">        return operation(a, b, 'subtract');</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">function <span class="title">multiply</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">        return operation(a, b, 'multiply');</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">function <span class="title">divide</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">        return operation(a, b, 'divide');</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exports</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        add: add, <span class="comment">// 加</span></span><br><span class="line">        subtract: subtract, <span class="comment">// 减</span></span><br><span class="line">        multiply: multiply, <span class="comment">// 乘</span></span><br><span class="line">        divide: divide <span class="comment">// 除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p>学习反思：</p>
<p>1、下去学习了千位分隔符（用正则可以解决）的解决办法。</p>
<p>2、学习了大数相加的办法：转换成字符串进行操作，按位遍历，执行加减乘除，使用变量来保存进位。</p>
<p>3、了解了底层数据的存储方式。</p>
<p>4、涉及到金额要格外细心铭感。</p>
<h2 id="项目二："><a href="#项目二：" class="headerlink" title="项目二："></a>项目二：</h2><p>学习了VUE的框架原理，通过项目有了一些框架体会和思考。</p>
<p>问题：坑挺多，一般查阅MDN和stackoverflow和社区可以解决bug。</p>
<p>收获：VUE-Router的源码学习。</p>
<p>导航守卫的执行过程。</p>
<p>URL变化逻辑切换不同页面的原理。（出栈入栈）</p>
<blockquote>
<p>原理概括分析：</p>
</blockquote>
<p>1当点击router-link时，最终会执行router.push(this.history.push）入栈。</p>
<p>2通过transitionTo做路劲切换，成功的回调会执行pushHash(roote.fullPath</p>
<p>方法，后面根据路劲变化去做入栈出栈操作，完成pop,place,replace功能。</p>
<p>3在 history 的初始化中，会设置一个监听器，监听历史栈的变化。</p>
<p>4当点击浏览器返回按钮的时候，如果已经有 url 被压入历史栈，则会触发 popstate 事件，然后拿到当前要跳转的 hash，执行 transtionTo 方法做一次路径转换。</p>
<blockquote>
<p>阅读源码笔记：</p>
</blockquote>
<p>1、导航守卫就是发生在路由路径切换时，执行的一系列钩子函数。</p>
<p>2、这些钩子函数执行的逻辑：首先构造一个队列 queue，这个队列实际上是一个数组。</p>
<p>3、然后再定义一个迭代器函数 iterator；最后再执行 runQueue 方法执行这个队列。</p>
<p>4、一个非常经典的异步函数队列化执行的模式，queue 是一个NavigationGuard 类型的数组，源码定义了 step 函数，每次根据 index 从 queue 中取一个 guard，然后执行 fn 函数，并且把 guard 作为参数传入，第二个参数是一个函数，当这个函数执行的时候再递归执行 step 函数，前进到下一个，其实这里的 fn 就是非常经典的 iterator 函数</p>
<p>5、iterator 函数逻辑就是去执行每一个导航守卫 hook，并传入 route、current 和匿名函数，这些参数对应源码中的 to、from、next。</p>
<p>6、当执行了匿名函数，会根据一些条件执行 abort 或 next，只有执行 next 的时候，才会前进到下一个导航守卫钩子函数中，这也就是为什么官方文档会说只有执行 next 方法才 resolve 这个钩子函数。</p>
<p>下面举例一个比较经典的，其他就不上图啦</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 经典的同步执行异步函数</span></span><br><span class="line">  runQueue(<span class="built_in">queue</span>, iterator, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> postEnterCbs = []</span><br><span class="line">    <span class="keyword">const</span> isValid = () =&gt; <span class="keyword">this</span>.current === route</span><br><span class="line">    <span class="comment">// 当所有异步组件加载完成后，会执行这里的回调，也就是 runQueue 中的 cb()</span></span><br><span class="line">    <span class="comment">// 接下来执行 需要渲染组件的导航守卫钩子</span></span><br><span class="line">    <span class="keyword">const</span> enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">queue</span> = enterGuards.concat(<span class="keyword">this</span>.router.resolveHooks)</span><br><span class="line">    runQueue(<span class="built_in">queue</span>, iterator, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 跳转完成</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.pending !== route) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abort</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.pending = null</span><br><span class="line">      onComplete(route)</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.router.app) &#123;</span><br><span class="line">        <span class="keyword">this</span>.router.app.$nextTick(() =&gt; &#123;</span><br><span class="line">          postEnterCbs.forEach(cb =&gt; &#123;</span><br><span class="line">            cb()</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">export</span> function <span class="title">runQueue</span> <span class="params">(<span class="built_in">queue</span>: Array&lt;?NavigationGuard&gt;, fn: Function, cb: Function)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> step = index =&gt; &#123;</span><br><span class="line">  <span class="comment">// 队列中的函数都执行完毕，就执行回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="built_in">queue</span>.length) &#123;</span><br><span class="line">      cb()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">queue</span>[index]) &#123;</span><br><span class="line">      <span class="comment">// 执行迭代器，用户在钩子函数中执行 next() 回调</span></span><br><span class="line">      <span class="comment">// 回调中判断传参，没有问题就执行 next()，也就是 fn 函数中的第二个参数</span></span><br><span class="line">        fn(<span class="built_in">queue</span>[index], () =&gt; &#123;</span><br><span class="line">          step(index + <span class="number">1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        step(index + <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取出队列中第一个钩子函数</span></span><br></pre></td></tr></table></figure>

<h2 id="项目三：还在完善中"><a href="#项目三：还在完善中" class="headerlink" title="项目三：还在完善中"></a>项目三：还在完善中</h2><blockquote>
<p>优化一：封装函数</p>
</blockquote>
<p>/*<br>封装的能发ajax请求的函数, 向外暴露的本质是axios</p>
<ol>
<li>解决post请求携带参数的问题: 默认是json, 需要转换成urlencode格式</li>
<li>让请求成功的结果不再是response, 而是response.data的值</li>
<li>统一处理所有请求的异常错误</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">*/</span><br><span class="line">import axios from 'axios'</span><br><span class="line">import qs from 'qs'</span><br><span class="line">import &#123;message&#125; from 'antd'</span><br><span class="line"><span class="comment">// 添加请求拦截器: 让post请求的请求体格式为urlencoded格式 a=1&amp;b2</span></span><br><span class="line"><span class="comment">// 在真正发请求前执行</span></span><br><span class="line">axios.interceptors.request.use(function (config) &#123;</span><br><span class="line">  <span class="comment">// 得到请求方式和请求体数据</span></span><br><span class="line">  <span class="keyword">const</span> &#123;method, data&#125; = config</span><br><span class="line">  <span class="comment">// 处理post请求, 将data对象转换成query参数格式字符串</span></span><br><span class="line">  if (method.toLowerCase() === 'post' &amp;&amp; typeof data==='object') &#123;</span><br><span class="line">    config.data = qs.stringify(data) <span class="comment">// username=admin&amp;password=admin</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">  <span class="comment">// 功能1: 让请求成功的结果不再是response, 而是response.data的值</span></span><br><span class="line">  <span class="comment">// 功能2: 统一处理所有请求的异常错误</span></span><br><span class="line"><span class="comment">// 在请求返回之后且在我们指定的请求响应回调函数之前</span></span><br><span class="line">axios.interceptors.response.use(function (response) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response.data <span class="comment">// 返回的结果就会交给我们指定的请求响应的回调</span></span><br><span class="line">  <span class="comment">// return response // 返回的结果就会交给我们指定的请求响应的回调</span></span><br><span class="line">&#125;, function (error) &#123; <span class="comment">// 统一处理所有请求的异常错误</span></span><br><span class="line">  message.error('请求出错 ' + error.message)</span><br><span class="line">  <span class="comment">// return Promise.reject(error);</span></span><br><span class="line">  <span class="comment">// 返回一个pending状态的promise, 中断promise链</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(() =&gt; &#123;&#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> axios</span><br></pre></td></tr></table></figure>

<blockquote>
<p>优化二：减少Render次数</p>
</blockquote>
<p>Component与PureComponent</p>
<p> 原因分析：Component存在的问题?</p>
<p> 父组件重新render(), 子组件也会重新执行render(), 即使没有任何变化</p>
<p> 解决Component存在的问题</p>
<p> 原因: 组件的shouldComponentUpdate()默认返回true, 即使数据没有变化render()都会重新执行</p>
<p> 办法1: 重写shouldComponentUpdate(), 判断如果数据有变化返回true, 否则返回false</p>
<p> 办法2: 使用PureComponent代替Component</p>
<p> 办法3：使用React.memo()高阶函数</p>
<p>PureComponent的基本原理：</p>
<p>（1）重写实现shouldComponentUpdate()</p>
<p>（2）对组件的新/旧state和props中的数据进行浅比较, 如果都没有变化, 返回false, 否则返回true</p>
<p>（3）一旦ShouldComponentUpdate()返回false，就不再执行用于更新的render()</p>
<blockquote>
<p>优化三：缓存HTTP请求和数据</p>
</blockquote>
<p>原因：</p>
<p>当用户再次请求相同的搜索内容时，可以不必发送网络请求，从缓存中取。</p>
<p>思路：</p>
<p>创建一个资源对象来缓存结果，当每次向网络发出新请求时，检查缓存中有没有上次的相同查询结果，存在就直接返回，不存在再发送网络请求，并将最新的请求数据保存到缓存中。</p>
<blockquote>
<p>优化四：用好Key</p>
</blockquote>
<p>虚拟DOM的key的地位:</p>
<p>1、其实key就是一个是虚拟DOM对象的标识, Key把页面上的DOM和虚拟DOM做了一层关联映射。</p>
<p>2、虚拟DOM是真实DOM在内存中的一个表示。在更新显示时key是一个唯一的标签，就像我们现实生活中的身份证，在生命周期中如果变化了，React会销毁原来的真实DOM，创建新的真实DOM。</p>
<p>3、当列表数组中的数据发生变化生成新的虚拟DOM后, React会逐层做Diff算法，分为TreeDiff  Component Diff  Element Diff </p>
<p>（1）key没有变</p>
<pre><code>item数据没变, 直接使用原来的真实DOM。

item数据变了, 对原来的真实DOM进行数据更新。</code></pre><p>（2）key变了：</p>
<p>销毁原来的真实DOM, 根据item数据创建新的真实DOM显示。</p>
<p>(即使item数据没有变)</p>
<p>4、key为index存在的问题</p>
<p>（1）添加/删除/排序 =&gt; 产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低</p>
<p>（2）如果item界面还有输入框 =&gt; 产生错误的真实DOM更新 ==&gt; 界面有问题</p>
<p>5、使用总结：问题的关键就是一定要用唯一属性作为Key</p>
<p>（1）如果不存在添加/删除/排序/过滤操作, 用index作为keys是可以的。</p>
<p>（2）列表不可以变动时，可以用index作为key。</p>
<p>（3）列表添加删除时，可能导致某一部分的商品下标（key）改变被销毁，导致数据错乱或者不必要的重复渲染。</p>
<p>（4）用唯一属性作为key，比如商品的出厂号码等，在生命周期中唯一不变</p>
<blockquote>
<p>优化小细节总结五：</p>
</blockquote>
<p>1、JS事件中节流。</p>
<p>比如即时搜索功能，节流到输入字段结束之后再去请求数据。</p>
<p>2、避免在map 方法中使用index作为组件的Key。</p>
<p>3、采用记忆化的React组件：存储复杂函数的计算结果，比如优化三中的缓存组件。</p>
<p>4、使用Web  Workers扩展任务。</p>
<p>5、根据需要采用服务端渲染。</p>
<p>6、在服务器启动Gzip压缩，在Node端安装Compression并调用。</p>
<blockquote>
<p>目前计划和挑战：</p>
</blockquote>
<p>1、学习移动消息推送中一键免密登录、第三方登录的原理，尝试实现这个功能。</p>
<p>2、深化前端模块化、工程化的理念和实践，关注智能化的新方向。</p>
<p>3、学习Flutter技术，做好研究生的深度学习毕设。</p>
<p>4、关注前端领域、做好T型学习模式，视野要广，对于某方向的技术要好好沉淀，多思考，多锻炼，坚持不懈，做到精益求精。</p>
<p>5、保持热情和动力、科技改变美丽人生、打造极致体验</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E4%B8%AA%E4%BA%BA%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/" rel="tag">个人职业规划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E6%80%9D%E8%80%83%E5%A4%8D%E7%9B%98/" rel="tag">思考复盘</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-认真剖析Promise" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/04/14/%E8%AE%A4%E7%9C%9F%E5%89%96%E6%9E%90Promise/"
    >阿里面试总结（二）——认真剖析Promise</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/04/14/%E8%AE%A4%E7%9C%9F%E5%89%96%E6%9E%90Promise/" class="article-date">
  <time datetime="2020-04-13T16:00:00.000Z" itemprop="datePublished">2020-04-14</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="categories/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">阿里面试总结</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>今天面试官小姐姐问了一个很好的问题，Promise怎么异步转同步？<br>当时有点紧张想复杂了，下来好好梳理一下，小姐姐人很好，激发了小霞打下坚实基础，投身大前端的激情和动力，hhh，话不多说，<strong>追根溯源，脚踏实地，勤恳思辨就是学习最好的方法</strong>，路漫漫，加油干！</p>
<h2 id="一、同步异步场景需求剖析："><a href="#一、同步异步场景需求剖析：" class="headerlink" title="一、同步异步场景需求剖析："></a>一、同步异步场景需求剖析：</h2><p>1、RunAsync.add(new Task())//task1<br>    .add(new Task())//task2<br>    .add(new Task())//task3<br>    .start();<br>我们希望task1完成之后task2再启动，task2完成后task3再启动，也即异步串联。<br>2、把异步变成同步。<br>3、页面倒计时，10、9、8、7、6依次输出。<br>首先拆解一下题意，不能曲解了嘿嘿嘿，我当时就是紧张了，想到了Promise.all和Promise.race去解决多个并行任务，设计逻辑，判断返回函数的顺序的场景。其实我们要解决的是异步串联问题，也就是把异步变成同步，注意这里不要曲解字面意思哦。<br>让我娓娓道来！后来我又想了一个方法，除了.then异步串联，好像还可以用自动迭代去next()。目前想到这两种解决方案。<br>首先，什么是同步？什么是异步？</p>
<blockquote>
<p>字面误区：1、js单线程，同步操作任务，并非一起操作之意，而是你执行完了我再去执行；2、js异步操作任务，也并非是指在不同线程里做不同的事情。</p>
</blockquote>
<p><strong>本质理解：</strong>首页js的语言执行环境是单线程的，也就是一次只能完成一个任务，多个任务就必须按照时间先后排队，前面完成后才能完成后一个任务。这个是js的常规模式，也就也是同步操作任务。</p>
<p><strong>弊端：</strong>同步操作任务带来的问题是，只要一个任务执行时间过程，后面的任务都会排队等待，拖延整个程序的执行。<br>如：常见的浏览器假死很可能就是js任务执行时间太长导致。</p>
<p>为了解决同步操作带来的弊端，js语言增加了异步任务的操作模式：<br>1、当前任务可以携带回一个回调函数（当前任务执行时间过长，把需要提前执行的任务放在回掉中）。<br>2、可以利用setTimeout构建异步任务，让主逻辑优先执行，对于耗时间长的任务可以放在setTimeout中异步执行。<br>3、所以异步操作任务主要是改变了程序的正常执行操作顺序。<br>举个栗子吧！<br>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"1"</span>)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"2"</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"3"</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"4"</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"5"</span>)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>执行结果为：</p>
<p>1<br>5<br>2<br>3<br>4</p>
<p>那么大致的运行机制如下：<br>（1）在js主程序（单线程）上的同步任务形成了一个主任务执行栈。<br>（2）主线程之外还存在一个任务队列，这个队列存在一些按时间顺序存放的事件，<strong>如鼠标点击、计时触发等，主线程中每出现一个异步任务，任务队列就会增加一个异步任务的事件。</strong><br>（3）一般执行栈中的同步任务执行完毕，系统就会读取任务队列，看看哪些事件是可以执行的，一旦可以执行将进入执行栈开始执行，后面分析Generator再区别微任务和宏任务。<br>（4）不断重复以上动作。<br>严肃剖析一下：</p>
<p><strong>同步</strong>：百度的名词解释是： 同步指两个或两个以上随时间变化的量在变化过程中保持一定的相对关系。<br> 例如：你去饭店去吃饭。当你叫服务员点餐时，服务员正在别的桌服务，这时你要等待服务员，把别人的事情处理完成以后，才可以到你这服务。不能同时进行，是要有排队顺序的，所以会阻塞进程，简单的说，只有一条主任务工作。<br>总结：就是一个任务完成之后，才能执行下一个任务。我们可以将同步看成是单线的执行，即要么执行成功，要么执行失败，反正就是要返回一个结果，在没有得到这个结果之前什么都不干，就傻傻的等着。任务提交后不向系统交出控制权，持续等待。<br><strong>异步</strong>：执行一个任务的同时，中间去执行其它的事件，最终在回来执行这个任务，不连续，node最大的特点就是支持异步，例如：node虽然是单线程，但是CPU利用率非常高，它就是一个日夜不息的接单员，一直在流水线工作。其实这样好处也很多，不用处理开辟线程、销毁线程的任务，而且不用设计资源抢占、读写锁的问题，对I/O密集友好。<br>总结：异步则是当你的任务提交了之后，不用管任务的结果是什么，可以继续执行别的任务，任务提交后将控制权交予系统，系统可以进行其他任务的执行。<br>两者比较<br>1、同步的执行效率会比较低，耗费时间，但有利于我们对流程进行控制，避免很多不可掌控的意外情况。<br>2、异步的执行效率高，节省时间，但是会占用更多的资源，也不利于我们对进程进行控制。<br><strong>优缺点及使用场景</strong><br>异步优点<br>1、异步流程可以立即给调用方返回初步的结果。</p>
<p>2、异步流程可以延迟给调用方最终的结果数据，在此期间可以做更多额外的工作，例如结果记录等等。</p>
<p>3、异步流程在执行的过程中，可以释放占用的线程等资源，避免阻塞，等到结果产生再重新获取线程处理。</p>
<p>4、异步流程可以等多次调用的结果出来后，再统一返回一次结果集合，提高响应效率。</p>
<p><strong>异步使用场景：</strong></p>
<p>1、不涉及共享资源，或对共享资源只读，即非互斥操作。</p>
<p>2、没有时序上的严格关系。</p>
<p>3、不需要原子操作，或可以通过其他方式控制原子性。</p>
<p>4、常用于IO操作等耗时操作，因为比较影响客户体验和使用性能。</p>
<p>5、不影响主线程逻辑。</p>
<p><strong>同步优点：</strong></p>
<p>1、同步流程对结果处理通常更为简单，可以就近处理。</p>
<p>2、同步流程对结果的处理始终和前文保持在一个上下文内。同步是一步一步来操作，等待请求返回的数据，再执行下一步，那么一定会有一些情况，只有这一步执行完，拿到数据，通过获取到这一步的数据来执行下一步的操作。</p>
<p>3、同步流程可以很容易捕获、处理异常。</p>
<p>4、同步流程是最天然的控制过程顺序执行的方式。</p>
<h2 id="二、异步串联"><a href="#二、异步串联" class="headerlink" title="二、异步串联"></a>二、异步串联</h2><p>其实面试官小姐姐的答案就是：.then()来异步串联。<br>下面是我的思考和解答：<br>首先是一个简单版的手撸Promise:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">Promise</span><span class="params">(executor)</span></span>&#123; <span class="comment">//executor执行器</span></span><br><span class="line">    let self = <span class="keyword">this</span>;</span><br><span class="line">    self.status = 'pending'; //等待态</span><br><span class="line">    self.value  = undefined; <span class="comment">// 表示当前成功的值</span></span><br><span class="line">    self.reason = undefined; <span class="comment">// 表示是失败的值</span></span><br><span class="line">    <span class="function">function <span class="title">resolve</span><span class="params">(value)</span></span>&#123; <span class="comment">// 成功的方法</span></span><br><span class="line">        if(self.status === 'pending')&#123;</span><br><span class="line">            self.status = 'resolved';</span><br><span class="line">            self.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">function <span class="title">reject</span><span class="params">(reason)</span></span>&#123; <span class="comment">//失败的方法</span></span><br><span class="line">        if(self.status === 'pending')&#123;</span><br><span class="line">            self.status = 'rejected';</span><br><span class="line">            self.reason = reason;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    executor(resolve,reject);</span><br><span class="line">&#125;</span><br><span class="line">Promise.prototype.then = function(onFufiled,onRejected)&#123;</span><br><span class="line">    let self = <span class="keyword">this</span>;</span><br><span class="line">    if(self.status === 'resolved')&#123;</span><br><span class="line">        onFufiled(self.value);</span><br><span class="line">    &#125;</span><br><span class="line">    if(self.status === 'rejected')&#123;</span><br><span class="line">        onRejected(self.reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">module</span>.exports = Promise;</span><br></pre></td></tr></table></figure>
<p>使用方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let Promise = require('./m2.Promise');</span><br><span class="line">let p = <span class="keyword">new</span> Promise((resolve, reject) =&gt;&#123;</span><br><span class="line">          setTimeout(()=&#123;</span><br><span class="line">    resolve('zfpx')</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.then(function(data)&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"data"</span>,data)</span><br><span class="line">&#125;,function(err)&#123;</span><br><span class="line">  console.log('err',err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200413232504760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200413232526253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>观察这个例子，我来分析 一下Promise 的调用流程：</p>
<ul>
<li>Promise的构造方法接收一个executor()，在new Promise()时就立刻执行这个 executor 回调   </li>
<li>executor()内部的异步任务被放入宏/微任务队列，等待执行 then()被执行，收集成功/失败回调，放入成功/失败队列   </li>
<li>executor()的异步任务被执行，触发resolve/reject，从成功/失败队列中取出回调依次执行</li>
</ul>
<p>我理解这是个观察者模式，是一种收集依赖=》触发通知 =》取出依赖执行 的方式。<br>new Promise时（）会立即执行executor，并传入resolve和reject，由于他们是在executor内部被调用，所以要使用箭头函数去固定this指向，否则会找不到成功resolve之后的this.resolveQueue。<br>在 Promise 里，执行顺序是then收集依赖 ，异步触发resolve ， resolve执行依赖。then方法的回调里取到异步操作的返回值，then返回一个新的promise，分别对应状态改变的时候触发的回调，到了时间我们就返回Promise的结果，类似于依赖执行完毕。then方法可以被同一个promise调用多次，要实现这个功能，我们可以用一个队列来存储回调。<br>依此，我们可以勾勒出 Promise 的大致形状：其实就是一个单向变更的状态机，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">Promise</span><span class="params">(executor)</span> </span>&#123; <span class="comment">// executor是一个执行函数</span></span><br><span class="line">    let self = <span class="keyword">this</span>;</span><br><span class="line">    self.status = 'pending';</span><br><span class="line">    self.value = undefined; <span class="comment">// 默认成功的值</span></span><br><span class="line">    self.reason = undefined; <span class="comment">// 默认失败的原因</span></span><br><span class="line">    self.onResolvedCallbacks = []; <span class="comment">// 存放then成功的回调</span></span><br><span class="line">    self.onRejectedCallbacks = []; <span class="comment">// 存放then失败的回调</span></span><br><span class="line">    <span class="function">function <span class="title">resolve</span><span class="params">(value)</span> </span>&#123; <span class="comment">// 成功状态</span></span><br><span class="line">        if (self.status === 'pending') &#123;</span><br><span class="line">            self.status = 'resolved';</span><br><span class="line">            self.value = value;</span><br><span class="line">            self.onResolvedCallbacks.forEach(function (fn) &#123;</span><br><span class="line">                fn();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">function <span class="title">reject</span><span class="params">(reason)</span> </span>&#123; <span class="comment">// 失败状态</span></span><br><span class="line">        if (self.status === 'pending') &#123;</span><br><span class="line">            self.status = 'rejected';</span><br><span class="line">            self.reason = reason;</span><br><span class="line">            self.onRejectedCallbacks.forEach(function (fn) &#123;</span><br><span class="line">                fn();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executor(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123; <span class="comment">// 捕获的时候发生异常,就直接失败了</span></span><br><span class="line">        reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">resolvePromise</span><span class="params">(promise2, x, resolve, reject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有可能这里返回的x是别人的promise</span></span><br><span class="line">    <span class="comment">// 尽可能允许其他乱写</span></span><br><span class="line">    <span class="keyword">if</span> (promise2 === x) &#123; <span class="comment">//这里应该报一个类型错误，有问题</span></span><br><span class="line">        return reject(new TypeError('循环引用了'))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 看x是不是一个promise,promise应该是一个对象</span></span><br><span class="line">    let called; <span class="comment">// 表示是否调用过成功或者失败</span></span><br><span class="line">    if (x !== null &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123;</span><br><span class="line">        <span class="comment">// 可能是promise &#123;&#125;,看这个对象中是否有then方法，如果有then我就认为他是promise了</span></span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">// &#123;then:1&#125;</span></span><br><span class="line">            let then = x.then;</span><br><span class="line">            if (typeof then === 'function') &#123;</span><br><span class="line">                <span class="comment">// 成功</span></span><br><span class="line">                then.call(x, function (y) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">                    called = <span class="literal">true</span></span><br><span class="line">                    <span class="comment">// y可能还是一个promise，在去解析直到返回的是一个普通值</span></span><br><span class="line">                    resolvePromise(promise2, y, resolve, reject)</span><br><span class="line">                &#125;, function (err) &#123; <span class="comment">//失败</span></span><br><span class="line">                    <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">                    called = <span class="literal">true</span></span><br><span class="line">                    reject(err);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(x)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 说明是一个普通值1</span></span><br><span class="line">        resolve(x); <span class="comment">// 表示成功了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Promise.prototype.then = function (onFulfilled, onRjected) &#123;</span><br><span class="line">    <span class="comment">//成功和失败默认不传一个函数</span></span><br><span class="line">    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : function (value) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    onRjected = typeof onRjected === 'function' ? onRjected : function (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    let self = <span class="keyword">this</span>;</span><br><span class="line">    let promise2; <span class="comment">//返回的promise</span></span><br><span class="line">    if (self.status === 'resolved') &#123;</span><br><span class="line">        promise2 = <span class="keyword">new</span> Promise(function (resolve, reject) &#123;</span><br><span class="line">            <span class="comment">// 当成功或者失败执行时有异常那么返回的promise应该处于失败状态</span></span><br><span class="line">            <span class="comment">// x可能是一个promise 也有可能是一个普通的值</span></span><br><span class="line">            setTimeout(function () &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    let x = onFulfilled(self.value);</span><br><span class="line">                    <span class="comment">// x可能是别人promise，写一个方法统一处理</span></span><br><span class="line">                    resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.status === 'rejected') &#123;</span><br><span class="line">        promise2 = <span class="keyword">new</span> Promise(function (resolve, reject) &#123;</span><br><span class="line">            setTimeout(function () &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    let x = onRjected(self.reason);</span><br><span class="line">                    resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"> </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当调用then时可能没成功 也没失败</span></span><br><span class="line">    if (self.status === 'pending') &#123;</span><br><span class="line">        promise2 = <span class="keyword">new</span> Promise(function (resolve, reject) &#123;</span><br><span class="line">            <span class="comment">// 此时没有resolve 也没有reject</span></span><br><span class="line">            self.onResolvedCallbacks.push(function () &#123;</span><br><span class="line">                setTimeout(function () &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        let x = onFulfilled(self.value);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">            self.onRejectedCallbacks.push(function () &#123;</span><br><span class="line">                setTimeout(function () &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        let x = onRjected(self.reason);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 捕获错误的方法</span></span><br><span class="line">Promise.prototype.<span class="keyword">catch</span> = function (callback) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(null, callback)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解析全部方法</span></span><br><span class="line"><span class="comment">// let arr = [];</span></span><br><span class="line"><span class="comment">// arr[1] = 100;</span></span><br><span class="line"><span class="comment">// console.log(arr.length)</span></span><br><span class="line">Promise.all = function (promises) &#123;</span><br><span class="line">    <span class="comment">//promises是一个promise的数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise(function (resolve, reject) &#123;</span><br><span class="line">        let arr = []; <span class="comment">//arr是最终返回值的结果</span></span><br><span class="line">        let i = <span class="number">0</span>; <span class="comment">// 表示成功了多少次</span></span><br><span class="line">        function processData(index, y) &#123;</span><br><span class="line">            arr[index] = y;</span><br><span class="line">            <span class="keyword">if</span> (++i === promises.length) &#123;</span><br><span class="line">                resolve(arr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">            promises[i].then(function (y) &#123;</span><br><span class="line">                processData(i, y)</span><br><span class="line">            &#125;, reject)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只要有一个promise成功了 就算成功。如果第一个失败了就失败了</span></span><br><span class="line">Promise.race = function (promises) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise(function (resolve, reject) &#123;</span><br><span class="line">        <span class="keyword">for</span> (var i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">            promises[i].then(resolve,reject)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成一个成功的promise</span></span><br><span class="line">Promise.resolve = function(value)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise(function(resolve,reject)&#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成一个失败的promise</span></span><br><span class="line">Promise.reject = function(reason)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise(function(resolve,reject)&#123;</span><br><span class="line">        reject(reason);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">Promise.defer = Promise.deferred = function () &#123;</span><br><span class="line">    let dfd = &#123;&#125;;</span><br><span class="line">    dfd.promise = <span class="keyword">new</span> Promise(function (resolve, reject) &#123;</span><br><span class="line">        dfd.resolve = resolve;</span><br><span class="line">        dfd.reject = reject;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> dfd</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mjs</span></span><br><span class="line"><span class="keyword">module</span>.exports = Promise;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>显然.then()需要返回一个 Promise，这样才能找到 then 方法链式调用，所以我们会把 then 方法的返回值包装成<br>Promise。 .then()的回调需要顺序执行，我们要等待当前 Promise 状态变更后，再执行下一个 then 收集的回调，这就要求我们对 then 的返回值分类讨论。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Promise/A+规范的三种状态</span></span><br><span class="line">const PENDING = 'pending'</span><br><span class="line">const FULFILLED = 'fulfilled'</span><br><span class="line">const REJECTED = 'rejected'</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> &#123;</span></span><br><span class="line">  <span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">  constructor(executor) &#123;<span class="comment">//executor是异步任务，才可以先then收集回调，再返回resolve  reject的结果</span></span><br><span class="line">    <span class="keyword">this</span>._status = PENDING     <span class="comment">// Promise状态</span></span><br><span class="line">    <span class="keyword">this</span>._resolveQueue = []    <span class="comment">// 成功队列, resolve时触发</span></span><br><span class="line">    <span class="keyword">this</span>._rejectQueue = []     <span class="comment">// 失败队列, reject时触发</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span></span><br><span class="line">    let _resolve = (val) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span>   <span class="comment">// 对应规范中的"状态只能由pending到fulfilled或rejected"</span></span><br><span class="line">      <span class="keyword">this</span>._status = FULFILLED              <span class="comment">// 变更状态</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这里之所以使用一个队列来储存回调,是为了实现规范要求的 "then 方法可以被同一个 promise 调用多次"</span></span><br><span class="line">      <span class="comment">// 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">this</span>._resolveQueue.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> callback = <span class="keyword">this</span>._resolveQueue.shift()</span><br><span class="line">        callback(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现同resolve</span></span><br><span class="line">    let _reject = (val) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span>   <span class="comment">// 对应规范中的"状态只能由pending到fulfilled或rejected"</span></span><br><span class="line">      <span class="keyword">this</span>._status = REJECTED               <span class="comment">// 变更状态</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">this</span>._rejectQueue.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> callback = <span class="keyword">this</span>._rejectQueue.shift()</span><br><span class="line">        callback(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// new Promise()时立即执行executor,并传入resolve和reject</span></span><br><span class="line">    executor(_resolve, _reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">  then(resolveFn, rejectFn) &#123;</span><br><span class="line">    <span class="keyword">this</span>._resolveQueue.push(resolveFn)</span><br><span class="line">    <span class="keyword">this</span>._rejectQueue.push(rejectFn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面实现了then方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then方法</span></span><br><span class="line">then(resolveFn, rejectFn) &#123;</span><br><span class="line">  <span class="comment">//return一个新的promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">    <span class="comment">//把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span></span><br><span class="line">    <span class="keyword">const</span> fulfilledFn = value =&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">        let x = resolveFn(value)</span><br><span class="line">        <span class="comment">//分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">        x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把后续then收集的依赖都push进当前Promise的成功回调队列中(_rejectQueue), 这是为了保证顺序调用</span></span><br><span class="line">    <span class="keyword">this</span>._resolveQueue.push(fulfilledFn)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//reject同理</span></span><br><span class="line">    <span class="keyword">const</span> rejectedFn  = error =&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        let x = rejectFn(error)</span><br><span class="line">        x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._rejectQueue.push(rejectedFn)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试可以满足面试官姐姐提出的需求场景。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(res)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(res)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(res)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 1 2 3</span></span><br></pre></td></tr></table></figure>

<h2 id="三、-then方法的几点注意"><a href="#三、-then方法的几点注意" class="headerlink" title="三、 then方法的几点注意"></a>三、 then方法的几点注意</h2><p>1、jquery能实现链式调用靠的就是返回this，promise不能返回this，promise实现链式调用靠的是返回一个新的promise。调用then时要返回一个新的promise。<br>2、Promise 是用来执行异步操作的。但有时一个异步操作需要等其他的异步操作完成，这时候就可以使用then来做。<br>3、使用 promise.then + 递归的方法异步转同步，我一直理解then().then()是一个chain，每一个then会返回一个promise，然后往后面传。但是我今天跑了一段代码，没有按照这个顺序执行，可能和异常错误处理有关。<br>4、then是会返回一个promise对象，但是这个promise对象的this是你前一个promise的，如果你return 一个新的promise，this则是这个promise，所以后面的then需要依据第二个promise是否resolve，才决定是否执行相应的then。<br>5、<strong>then，catch都是同步方法</strong>，假设执行b=new Promise(func)后里面的异步操作，已经开始但可能未处理完，同步执行下去是运行b.then(a)，b.then(aa)，b.then(aaa)…，假设运行到b.then(aa)方法时异步操作仍未处理完，那么then函数就会把aa push到b里面的一个callbacks数组中，假设运行b.then(aaa)前异步操作完成，首先将异步结果赋值给b里的result变量，然后循环调用callbacks数组里存好的方法：a(result),aa(result)，执行完毕后再运行b.then(aaa)，此时判断异步已执行完毕，不用将aaa push到callbacks数组里，而是直接运行aaa(result)，真正原因是res()内部设置了一个延时执行回调，延时setTimeout的最小值，<strong>也就是说res才是异步的，</strong>由于这点异步时间，导致最后一例中a.then(a)将a函数存放到callbacks里了，导致顺序发生错误，可以试着将a.then(a)延时执行，这就和浏览器时间频率有关系了，想一想怎么在秒杀系统处理呢？<br>6、在new promise(fn)中，<strong>new出来的函数是同步的，但是 fn的res() 函数是异步的，会挂起线程</strong>，执行到then的时候，顺利执行then的代码块，只是把成功的回调函数放到了resovledCallbacks中，但是就算state修改完毕为solved的时候，5中提到的执行then（aaa）的时候也是会异步操作，也不是立即执行aaa， 因为then的内部实现方式根据promiseA规范中也是有一个settimeout 在延时器内部执行aaa的。<br>再举个具体栗子！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">loadImageAsync</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Promise(function(resolve, reject) &#123;</span><br><span class="line">           var image = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">           image.onload = function() &#123;</span><br><span class="line">               console.<span class="built_in">log</span>(<span class="string">"load"</span>);</span><br><span class="line">               resolve(image);</span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line">           image.onerror = function() &#123;</span><br><span class="line">               reject(new Error('Could not load image at ' + url));</span><br><span class="line">           &#125;;</span><br><span class="line">           console.<span class="built_in">log</span>(<span class="string">"change src"</span>);</span><br><span class="line">           <span class="function">function <span class="title">init_img</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               image.src = url;</span><br><span class="line">           &#125;</span><br><span class="line">           setTimeout(init_img,<span class="number">5000</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>loadImageAsync 用来异步加载图片. setTimeout 人为地延迟5秒加载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">loadImageAsync2</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Promise(function(resolve, reject) &#123;</span><br><span class="line">            var image = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">            image.onload = function() &#123;</span><br><span class="line">                console.<span class="built_in">log</span>(<span class="string">"2load"</span>);</span><br><span class="line">                resolve(image);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            image.onerror = function() &#123;</span><br><span class="line">                reject(new Error('Could not load image at ' + url));</span><br><span class="line">            &#125;;</span><br><span class="line">            console.<span class="built_in">log</span>(<span class="string">"2change src"</span>);</span><br><span class="line">            <span class="function">function <span class="title">init_img</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                image.src = url;</span><br><span class="line">            &#125;</span><br><span class="line">            setTimeout(init_img,<span class="number">1000</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>loadImageAsync2 也是用来加载图片，人为地延迟1秒。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var p = loadImageAsync('http://img02.tooopen.com/images/20141231/sy_78327074576.jpg');</span><br><span class="line">    p.then(function (img) &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">"1:"</span>+img.src);</span><br><span class="line">    &#125;);</span><br><span class="line">    var h = loadImageAsync2('http://img02.tooopen.com/images/20141225/sy_77944235469.jpg');</span><br><span class="line">    h.then(function (img) &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">"2:"</span>+img.src);</span><br><span class="line">    &#125;);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"wqx"</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到 图片2先加载， 然后加载图片1 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s = loadImageAsync('http://img02.tooopen.com/images/20141231/sy_78327074576.jpg');</span><br><span class="line">  s.then(function (img) &#123;</span><br><span class="line">      console.<span class="built_in">log</span>(<span class="string">"1:"</span>+img.src);</span><br><span class="line">      return loadImageAsync2('http://img02.tooopen.com/images/20141225/sy_77944235469.jpg');</span><br><span class="line">  &#125;).then(function (img) &#123;</span><br><span class="line">      console.<span class="built_in">log</span>(<span class="string">"2:"</span>+img.src);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>创建新的promise 对象 s，我在s 的then 成功回调函数中 去调用 loadImageAsync2 函数。</p>
<p>这样就保证了 加载图片2 之前先加载图片1。</p>
<p>这里注意的是第二个then 其实是loadImageAsync2 返回的promise 实例调用的。这样就保证了加载完毕图片再去打印图片的解释说明。</p>
<p><strong>还要注意的两点：</strong><br>1、值穿透：根据规范，如果 then() 接收的参数不是 function，那么我们应该忽略它。如果没有忽略，当 then()回调不为 function 时将会抛出异常，导致链式调用中断。<br>2、处理状态为 resolve/reject 的情况：其实我们上边 then() 的写法是对应状态为padding的情况，但是有些时候resolve/reject 在 then() 之前就被执行（比如Promise.resolve().then()），如果这个时候还把 then()回调 push 进 resolve/reject 的执行队列里，那么回调将不会被执行，因此对于状态已经变为fulfilled或rejected的情况，我们直接执行 then 回调。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">  then(resolveFn, rejectFn) &#123;</span><br><span class="line">    <span class="comment">// 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span></span><br><span class="line">    typeof resolveFn !== 'function' ? resolveFn = value =&gt; value : null</span><br><span class="line">    typeof rejectFn !== 'function' ? rejectFn = reason =&gt; &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(reason instanceof Error? reason.message:reason);</span><br><span class="line">    &#125; : null</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return一个新的promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span></span><br><span class="line">      <span class="keyword">const</span> fulfilledFn = value =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">          let x = resolveFn(value)</span><br><span class="line">          <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// reject同理</span></span><br><span class="line">      <span class="keyword">const</span> rejectedFn  = error =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          let x = rejectFn(error)</span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">this</span>._status) &#123;</span><br><span class="line">        <span class="comment">// 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行</span></span><br><span class="line">        <span class="keyword">case</span> PENDING:</span><br><span class="line">          <span class="keyword">this</span>._resolveQueue.push(fulfilledFn)</span><br><span class="line">          <span class="keyword">this</span>._rejectQueue.push(rejectedFn)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 当状态已经变为resolve/reject时,直接执行then回调</span></span><br><span class="line">        <span class="keyword">case</span> FULFILLED:</span><br><span class="line">          fulfilledFn(<span class="keyword">this</span>._value)    <span class="comment">// this._value是上一个then回调return的值(见完整版代码)</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REJECTED:</span><br><span class="line">          rejectedFn(<span class="keyword">this</span>._value)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、catch、all、race、finally方法"><a href="#四、catch、all、race、finally方法" class="headerlink" title="四、catch、all、race、finally方法"></a>四、catch、all、race、finally方法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.<span class="keyword">catch</span>()</span><br><span class="line"><span class="keyword">catch</span>()方法返回一个 Promise，并且处理拒绝的情况。它的行为与调用 Promise.prototype.then(undefined, onRejected) 相同。</span><br><span class="line"><span class="comment">//catch方法其实就是执行一下then的第二个回调</span></span><br><span class="line"><span class="keyword">catch</span>(rejectFn) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(undefined, rejectFn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise.prototype.finally() finally()方法返回一个 Promise。在 promise 结束时，无论结果是 fulfilled 或者是 rejected，都会执行指定的回调函数。在 finally 之后，还可以继续then。并且会将值原封不动的传递给后面的 then。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//finally方法</span></span><br><span class="line">finally(callback) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    value =&gt; MyPromise.resolve(callback()).then(() =&gt; value),   <span class="comment">// MyPromise.resolve执行回调,并在then中return结果传递给后面的Promise</span></span><br><span class="line">    reason =&gt; MyPromise.resolve(callback()).then(() =&gt; &#123; <span class="keyword">throw</span> reason &#125;)  <span class="comment">// reject同理</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise.resolve() Promise.resolve(value)方法返回一个以给定值解析后的 Promise 对象。如果该值为 promise，返回这个 promise；如果这个值是 thenable（即带有”then” 方法)），返回的 promise 会“跟随”这个 thenable 的对象，采用它的最终状态；否则返回的 promise 将以此值完成。此函数将promise 对象的多层嵌套展平。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态的resolve方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">resolve</span><span class="params">(value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(value instanceof MyPromise) <span class="keyword">return</span> value <span class="comment">// 根据规范, 如果参数是Promise实例, 直接return这个实例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(resolve =&gt; resolve(value))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise.reject() Promise.reject()方法返回一个带有拒绝原因的 Promise 对象。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态的reject方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">reject</span><span class="params">(reason)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; reject(reason))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise.all() Promise.all(iterable)方法返回一个 Promise 实例，此实例在 iterable参数内所有的 promise 都“完成（resolved）”】或参数中不包含 promise 时回调完成（resolve）；<br>如果参数中promise 有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败 promise 的结果。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态的all方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">all</span><span class="params">(promiseArr)</span> </span>&#123;</span><br><span class="line">  let index = <span class="number">0</span></span><br><span class="line">  let result = []<span class="comment">//放在数组中</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">    promiseArr.forEach((p, i) =&gt; &#123;</span><br><span class="line">      <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">      MyPromise.resolve(p).then(</span><br><span class="line">        val =&gt; &#123;</span><br><span class="line">          index++</span><br><span class="line">          result[i] = val<span class="comment">//保证顺序到达</span></span><br><span class="line">          <span class="comment">//所有then执行后, resolve结果</span></span><br><span class="line">          <span class="keyword">if</span>(index === promiseArr.length) &#123;</span><br><span class="line">            resolve(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        err =&gt; &#123;</span><br><span class="line">          <span class="comment">//有一个Promise被reject时，MyPromise的状态变为reject</span></span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise.race() Promise.race(iterable)方法返回一个 promise，一旦迭代器中的某个 promise解决或拒绝，返回的 promise 就会解决或拒绝，找到最先完成的那个任务，数组中有一个完成就返回，没有顺序之分，看完成的速度。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">race</span><span class="params">(promiseArr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">    <span class="comment">//同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span></span><br><span class="line">    <span class="keyword">for</span> (let p of promiseArr) &#123;</span><br><span class="line">      MyPromise.resolve(p).then(  <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">        value =&gt; &#123;</span><br><span class="line">          resolve(value)        <span class="comment">//注意这个resolve是上边new MyPromise的</span></span><br><span class="line">        &#125;,</span><br><span class="line">        err =&gt; &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、Generator的秘密"><a href="#五、Generator的秘密" class="headerlink" title="五、Generator的秘密"></a>五、Generator的秘密</h2><p>下面这个代码可能就是面试官姐姐的问题初衷吧。我之前想到了用next方法，没有表达清楚，面完突然好像懂了吼吼吼。<br>所以终极方案就是：Promise+Generator<br>Generator的这种特性对于异步来说，意味着什么呢？<br>意味着，我们终于获得了一种在不阻塞主线程的前提下实现“同步等待”的方法！<br>为便于说明，先上一段直接使用回调的代码：<br>看下面这个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function* <span class="title">myGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  yield Promise.resolve(<span class="number">1</span>);</span><br><span class="line">  yield Promise.resolve(<span class="number">2</span>);</span><br><span class="line">  yield Promise.resolve(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = myGenerator()</span><br><span class="line">gen.next().value.then(val =&gt; &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(val)</span><br><span class="line">  gen.next().value.then(val =&gt; &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(val)</span><br><span class="line">    gen.next().value.then(val =&gt; &#123;</span><br><span class="line">      console.<span class="built_in">log</span>(val)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出1 2 3</span></span><br><span class="line"></span><br><span class="line">这就是面试官姐姐的问题，这是我的思路，下文深究一下这个问题的根源。</span><br><span class="line">```cpp</span><br><span class="line">function  gen1() &#123; </span><br><span class="line">let count = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123; </span><br><span class="line">let msg = yield ++count; </span><br><span class="line">console.<span class="built_in">log</span>(msg); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let iter = gen1(); <span class="comment">//获得迭代器</span></span><br><span class="line">console.<span class="built_in">log</span>(iter.next().value); </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line">console.<span class="built_in">log</span>(iter.next(‘magic’).value); </span><br><span class="line"><span class="comment">// ‘magic’ </span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">let it = gen1(); <span class="comment">// 获得迭代器</span></span><br><span class="line"><span class="function">function <span class="title">request</span><span class="params">()</span> </span>&#123; </span><br><span class="line">ajax(&#123; </span><br><span class="line">url: ‘www.someurl.com’, </span><br><span class="line">onSuccess(res)&#123; </span><br><span class="line">it.next(res); <span class="comment">// 恢复Generator运行，同时向其中塞入异步返回的结果 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">gen2</span><span class="params">()</span> </span>&#123; </span><br><span class="line">let response = yield request(); </span><br><span class="line">console.<span class="built_in">log</span>(response.text); </span><br><span class="line">&#125;</span><br><span class="line">it.next(); <span class="comment">// 启动Generator</span></span><br><span class="line">```cpp</span><br><span class="line">let it = gen2(); </span><br><span class="line">let p = it.next().value; <span class="comment">// p是yield返回的Promise </span></span><br><span class="line">p.then(res =&gt; it.next(res), </span><br><span class="line">err =&gt; it.<span class="keyword">throw</span>(err) <span class="comment">// 发生错误时，将错误抛入生成器 </span></span><br><span class="line">);</span><br><span class="line">```cpp</span><br><span class="line"><span class="function">function <span class="title">request</span><span class="params">()</span> </span>&#123; <span class="comment">// 此处的request返回的是一个Promise </span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve, reject) =&gt; &#123; </span><br><span class="line">ajax(&#123; </span><br><span class="line">url: ‘www.someurl.com’, </span><br><span class="line">onSuccess(res) &#123; </span><br><span class="line">resolve(res); </span><br><span class="line">&#125;, </span><br><span class="line">onFail(err) &#123; </span><br><span class="line">reject(err); </span><br><span class="line">&#125; </span><br><span class="line">&#125;); </span><br><span class="line">&#125;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">function* <span class="title">gen2</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">let response = yield request(); </span><br><span class="line">console.<span class="built_in">log</span>(response.text); </span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123; </span><br><span class="line">console.<span class="built_in">log</span>(“出错了”, error.message); <span class="comment">// 可以捕获Promise抛进来的错误！ </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>思考：gen是个function，执行它时却不执行里面的代码，而是返回一个Iterator对象，代码执行到yield处可以暂停，暂停以后，可以恢复继续执行，另外，暂停/恢复执行时，还可以传出/传入数据！<br>其实Generator并没有改变JS运行的基本规则。<br>思考let response = yield request()这行代码，我来仔细分析下这段代码是如何运行的。如有错误，欢迎大家指教。<br>1、首先，最后一行it.next()使得Generator内部的代码从头开始执行，执行到yield语句时，暂停，此时可以把yield想象成return，Generator的栈帧需要被弹出，会先计算yield右边的表达式，即执行request函数调用，以获得用于返回给上一级栈帧的值。<br>2、但是现在request函数没有返回值，但它发送了一个异步ajax请求，并注册了一个onSuccess回调，表示在请求返回结果时，恢复Generator的栈帧并继续运行代码，并把结果作为参数塞给Generator，准确地说是塞到yield所在的地方。<br>3、这response变量就获得了ajax的返回值。 可以看出，这里yield的功能设计得非常巧妙，好像它可以“赋值”给response。<br>4、更妙的是，迭代器不但可以.next，还可以.throw，即把错误也抛入Generator，让后者来处理。也就是说，在Generator里使用try-catch语句捕获异步错误。</p>
<blockquote>
<p>是不是只有.then方法这样的形式才能完成自动执行的功能呢？ 我去查阅了一些资料发现，yield 后边除了接 Promise，还可以接thunk函数， thunk 函数，就是单参的只接受回调的函数，详细介绍可以看阮一峰 Thunk。<br>函数的含义和用法，无论是 Promise 还是 thunk 函数，其核心都是通过传入回调的方式来实现 Generator 的自动执行。<br>总结一下：Generator 实现的核心在于上下文的保存，函数并没有真的被挂起，每一次 yield，其实都执行了一遍传入的生成器函数。<br>只是在这个过程中间用了一个 context 对象储存上下文，使得每次执行生成器函数的时候，都可以从上一个执行结果开始执行，看起来就像函数被挂起了一样。</p>
</blockquote>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">下面尝试封装一下自动迭代：</span><br><span class="line">这个run 方法里，可以把执行下一步的操作封装成 step()，每次 Promise.<span class="keyword">then</span>()的时候都去执行 step()，实现自动迭代的效果。在迭代的过程中，我们还把 resolve 的值传入gen.next()，使得 <span class="keyword">yield</span> 得以返回 Promise 的 resolve 的值。</span><br><span class="line">```<span class="javascript">cpp</span></span><br><span class="line"><span class="javascript"> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> g = gen()    <span class="comment">//由于每次gen()获取到的都是最新的迭代器,因此获取迭代器操作要放在step()之前,否则会进入死循环</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">val</span>) </span>&#123;              <span class="comment">//封装一个方法, 递归执行next()</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> res = g.next(val)           <span class="comment">//获取迭代器对象，并返回resolve的值</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>(res.done) <span class="keyword">return</span> res.value   <span class="comment">//递归终止条件</span></span></span><br><span class="line"><span class="javascript">    res.value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;         <span class="comment">//Promise的then方法是实现自动迭代的前提</span></span></span><br><span class="line"><span class="javascript">      step(val)                     <span class="comment">//等待Promise完成就自动执行下一个next，并传入resolve的值</span></span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">  step()  <span class="comment">//第一次执行</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br></pre></td></tr></table></figure>

<p>理解Generator的关键点在于理解函数执行时，内存里发生了什么。<br>一个JS程序的内存分为代码区、栈区、堆区和队列区，从MDN借图一张以说明（图中没有画出代码区）：<br><img src="https://img-blog.csdnimg.cn/20200414013448793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>1、队列（Queue）就是事件循环队列，分为了宏任务和微任务。<br>2、代码区保存着全部JS源代码被引擎编译成的机器码（以V8为例）。<br>3、栈（stack）保存着每个函数执行所需的上下文，一个栈元素被称为一个栈帧，一个栈帧对应一个函数。<br>4、对于引用类型的数据，在栈帧里只保存引用，而真正的数据存放在堆（Heap）里。<br>5、堆与栈不同的是，栈内存由JS引擎自动管理，入栈时分配空间，出栈时回收，非常清楚明了。<br>6、堆是程序员通过new操作符手动向操作系统申请的内存空间（当然，用字面量语法创建对象也算），何时该回收没那么明晰，所以需要一套垃圾收集（GC）算法来专门做这件事。<br>以上是预备知识，现在 回到Generator的正题：<br>1、普通函数在被调用时，JS引擎会创建一个栈帧，在里面准备好局部变量、函数参数、临时值、代码执行的位置（也就是说这个函数的第一行对应到代码区里的第几行机器码），在当前栈帧里设置好返回位置，然后将新帧压入栈顶。<br>2、待函数执行结束后，这个栈帧将被弹出栈然后销毁，返回值会被传给上一个栈帧。<br>3、当执行到yield语句时，Generator的栈帧同样会被弹出栈外，但Generator在这里耍了个花招——它在堆里保存了栈帧的引用（或拷贝）！<br>4、这样当iter.next方法被调用时，JS引擎便不会重新创建一个栈帧，而是把堆里的栈帧直接入栈。因为栈帧里保存了函数执行所需的全部上下文以及当前执行的位置，所以当任务调度来临时，就好像程序从原本暂停的地方继续向前执行了。 因为每次yield和iter.next都对应一次出栈和入栈，所以可以直接利用已有的栈机制，实现值的传出和传入。<br>终于揭开了Generator背后的神秘！</p>
<p>上述写法完美结合了Promise和Generator的优点，写法套路非常固定，当Promise对象一多时，就需要写许多类似p.then(res =&gt; …., err =&gt; …)这样的重复语句，所以就把这种套路给提炼成了一个更加精简的语法，那就是传说中的async/await，六中梳理一下hhh。</p>
<h2 id="六、async，await是解决异步操作的终极方案"><a href="#六、async，await是解决异步操作的终极方案" class="headerlink" title="六、async，await是解决异步操作的终极方案"></a>六、async，await是解决异步操作的终极方案</h2><p>场景：在多个回调依赖的场景中，尽管 Promise 通过链式调用取代了回调嵌套，但过多的链式调用可读性仍然不佳，流程控制也不方便，ES7 提出的 async 函数，终于让 JS 对于异步操作有了终极解决方案，简洁优美地解决了以上两个问题。</p>
<blockquote>
<p>设想一个这样的场景，异步任务 a-&gt;b-&gt;c 之间存在依赖关系，如果我们通过 then链式调用来处理这些关系，可读性并不是很好，如果我们想控制其中某个过程，比如在某些条件下，b 不往下执行到 c，那么也不是很方便控制。比如读取完了文件再去写，等待一段时间后再去执行，类似于我们会中断流程，然后再接着原来的任务去做。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> a = await Promise.resolve(a);</span><br><span class="line">  <span class="keyword">const</span> b = await Promise.resolve(b);</span><br><span class="line">  <span class="keyword">const</span> c = await Promise.resolve(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">async funtion <span class="title">fetch</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">let response = await request(); <span class="comment">// request定义同上一端段示例代码 </span></span><br><span class="line">console.<span class="built_in">log</span>(response.text); </span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123; </span><br><span class="line">console.<span class="built_in">log</span>(“wqx”, error.message); </span><br><span class="line">&#125; ;</span><br><span class="line">fetch();</span><br></pre></td></tr></table></figure>
<p>下面做一下总结：<br>1、MDN上说，async/await 实际上是对 Generator（生成器）的封装，是一个语法糖。<br>2、ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，通过 next()方法可以切换到下一个状态，为改变执行流程提供了可能，从而为异步编程提供解决方案。<br>3、Generator 函数也可以通过给next()传参, 让 yield 具有返回值。<br>4、async/await自带执行器，不需要手动调用 next()就能自动执行下一步。<br>5、async函数返回值是 Promise 对象，而 Generator 返回的是生成器对象。<br>6、await能够返回 Promise 的 resolve/reject 的值。<br>7、在代码中也可以通过给gen.next()传值的方式，让 yield 能返回 resolve 的值。<br>8、async解决了生成器函数能自动往下执行，且 yield 能返回 resolve 的值这两个问题。<br>就靠拢同步风格的程度而言，感觉async/await已经到了炉火纯青的地步，以后在项目中要积极思考，合理应用到不同的场景！</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF%E5%92%8C%E6%80%BB%E7%BB%93/" rel="tag">个人成长和总结</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E8%AE%A4%E7%9C%9F%E5%89%96%E6%9E%90Promise/" rel="tag">认真剖析Promise</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="page/2/">2</a><a class="page-number" href="page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="page/6/">6</a><a class="extend next" rel="next" href="page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2020
        Wangqiuxia
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    <aside class="sidebar">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="index.html"><img src="/images/ayer-side.svg" alt="爱产品，爱前端！"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="index.html">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%8A%80%E6%9C%AF/">小程序</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://shenyu-vip.lofter.com/" target="_blank" rel="noopener">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="https://v.xiumi.us/stage/v5/4IeLH/197507179" target="_blank" rel="noopener">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<script src="/js/share.js"></script>



<script src="fancybox/jquery.fancybox.min.js"></script>




<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['做一个有情怀懂产品的程序媛！','业精于勤荒于嬉！行成于思毁于随！','越努力越幸运'],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script>
  var ayerConfig = {
    mathjax: false
  }
</script>


<script src="js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=518895142&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>