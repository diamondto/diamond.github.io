<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     爱产品，爱前端！
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="css/style.css">

  
<script src="/js/pace.min.js"></script>


  

  

<link rel="alternate" href="atom.xml" title="爱产品，爱前端！" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/diamondto.github.io"
        target="_blank"><img width="149" height="149" src="images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="index.html">爱产品，爱前端！</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-从五个维度总结_金三银四_的点滴感受" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/04/23/%E4%BB%8E%E4%BA%94%E4%B8%AA%E7%BB%B4%E5%BA%A6%E6%80%BB%E7%BB%93_%E9%87%91%E4%B8%89%E9%93%B6%E5%9B%9B_%E7%9A%84%E7%82%B9%E6%BB%B4%E6%84%9F%E5%8F%97/"
    >从五个维度总结“金三银四”的点滴感受！</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/04/23/%E4%BB%8E%E4%BA%94%E4%B8%AA%E7%BB%B4%E5%BA%A6%E6%80%BB%E7%BB%93_%E9%87%91%E4%B8%89%E9%93%B6%E5%9B%9B_%E7%9A%84%E7%82%B9%E6%BB%B4%E6%84%9F%E5%8F%97/" class="article-date">
  <time datetime="2020-04-22T16:00:00.000Z" itemprop="datePublished">2020-04-23</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="categories/%E4%B8%AA%E4%BA%BA%E7%BB%8F%E5%8E%86%E4%B8%8E%E7%94%9F%E6%B4%BB%E6%80%9D%E8%80%83/">个人经历与生活思考</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>记录一下这段时间的回顾梳理，每天收集好关于个人成长、职业规划的一些想法。<br>月结一下hhh，希望能给找实习的朋友们带来一些帮助！小霞也要及时反馈、复盘反思！<br>朋友们，让我们一起加油！实现从0到1到X的突破！<br>offer会有的，不要焦虑、保持初心、你若盛开，清风自来，桃李不言、下自成蹊！<br>接下来小霞从<strong>技能叠加+视野破圈+删繁就简+独立思考+保持初心</strong>五个维度分享一些感受，希望对阅读的您有所帮助！<br>您的收获和支持是小霞最大的动力！</p>
<h2 id="1、技能叠加"><a href="#1、技能叠加" class="headerlink" title="1、技能叠加"></a>1、技能叠加</h2><blockquote>
<p><strong>面试就是对自身知识掌握程度的一次搜索：分为宽搜、深搜 。<br>我们常常要考虑企业为什么招我？<br>我的独特之处是什么？<br>我有哪些不可替代性？<br>或者核心竞争力？说的简单一些：别人没有，只有我独有。<br>记得三月份有一次面试，对方说：你的简历为什么要写产品思考？我面的是前端。<br>我下来思考了很久，有一句话叫：人人都是产品经理。<br>可能它更好的表达是：人人都要有产品思维。（个人思考，请勿喷）<br>可能每个人都要想想STAR法则。<br>可能每个人多问一下自己：为什么？是什么？怎么办？好不好？</strong> </p>
</blockquote>
<p>1、JobDescription就是我们查漏补缺的<strong>映射表。</strong><br>2、T型模式重点还是在于<strong>垂直领域深耕，一直挖、挖到底。</strong><br>3、毕竟技术的关键是<strong>按时落地、多做多想、拿出实实在在的成绩。</strong><br>4、作为应届生、我们很难接触到亿万流量的项目，所以多想想前后端的业务逻辑是什么。<br>5、仔细思考一下、项目需求千变万化，难道做一个Demo就能带给企业价值吗？<br>6、<strong>技术沉淀可以靠时间、靠现有的模型；但技术突破只能靠思考、靠破圈、靠独创。</strong><br>7、我时常在想，为什么分社招？校招？实习生？<br>从这半个月的经历来看，总结可能是以下三点：<br>根本原因是：</p>
<ul>
<li>人是DNA基因、角色、环境的综合产物，带有个性化标签，<strong>是组件</strong>。</li>
<li>而企业需要不同角色的分工、协调、团结合作、<strong>需要兼容并蓄、汇集河流，是容器</strong>。 </li>
<li>打个比方：<strong>招聘就是古代招兵买马、带兵打仗、攻城略地。</strong></li>
<li>社招要的是<strong>身经百战、经常带兵打仗</strong>的将士、团长。比如关羽、张飞、林冲。</li>
<li>优点：经验丰富、业务熟练。</li>
<li>缺点：限于商业化气氛、思维可能局限、<strong>长期专攻某一项技术、可能视野不够广。</strong></li>
<li>校招要的是<strong>上知天文、下知地理、韬光养晦、运筹帷幄</strong>的军师。比如诸葛亮、周瑜。</li>
<li>优点：<strong>校园气氛单纯、科技感浓厚、善于思辨、创新、是源头活水、新鲜血液。</strong></li>
<li>缺点：缺乏大项目的经验、缺乏商业思维、业务理解。</li>
<li>实习生就是<strong>中间件，起承转合，最后留下的，是上述两者的取长补短。</strong></li>
<li>所以作为应届生，<strong>核心竞争力是创新的思维模式、反思总结的习惯。</strong></li>
<li>积极投入实习，<strong>找到自己稀缺的品质和特长、对个人、对企业，都有利于长远发展。</strong></li>
</ul>
<p>8、马云爸爸非常成功，我很崇拜他。他说自己不懂计算机，<strong>但他是一位高瞻远瞩的策划家、激情飞扬的演说家。</strong><br>9、<strong>所以说，没有人万能，但总有突破垂直领域的可能。</strong><br>10、<strong>现在很多企业，起步都是从非常小的入口划开一道口子（垂直深挖），然后横向扩展企业的生态圈。（横向延申）</strong><br>11、<strong>比如微信开始只做社交、支付宝开始只做交易、微博开始只做资讯、爱奇艺开始只做娱乐。</strong><br>12、<strong>后来都慢慢建立自己的用户圈、横向发展相关联的业务，发展一站式闭环联合生态。</strong><br>13、<strong>企业拆分一下，就是个人，都要用好T性思维，建立自己稳固的护城河。</strong><br>14、<strong>个人先垂直深挖发展成某一个行业的专家、接着打败所有人、然后去横向发展其他能力、最后谁都代替不了你。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200423140109380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt></p>
<h2 id="2、视野破圈"><a href="#2、视野破圈" class="headerlink" title="2、视野破圈"></a>2、视野破圈</h2><blockquote>
<p><strong>昨天我的闺蜜和我诉苦，她说，一场视频面试，好多问题不会，心态很崩，但是面试官一直引导。<br>我们聊了聊菜鸟到大牛的进阶之路，也分享了很多面试体验，这让我很感动。<br>越是Leader面，越能感受到视野和胸襟的魅力。<br>可能大牛就是：一颗心在流血、一颗心在宽容吧。<br>整理了以下八条总结：现阶段搭了个骨头框架，希望实习时填上丰富的血肉之躯！<br>毕竟嘛，中国人喜欢听故事。</strong></p>
</blockquote>
<p>1、前端领域、对照现有的书本、互联网资源<strong>查漏补缺</strong>是必备的环节、可是做到一本<strong>活字典</strong>却很难。<br>2、<strong>没有最标准的答案、只有特定场景下最合适的解法。</strong><br>3、术业有专攻、涉及未知领域时、<strong>最好的办法就是用自己的方法论快速掌握核心要点。</strong><br>4、<strong>大牛=天赋+方法论+时间管理+情怀+眼光</strong><br>5、很多时候、不是我们知识不渊博、能力不优秀、只是信息不匹配、视野不够广。<br>6、所以、世界级的技术很难、成功的个人、成功的团队、成功的企业、需要<strong>破圈。</strong><br>7、<strong>视野、格局、情怀</strong>在某种程度上决定了一个个体、团队、企业的调性。<br>8、<strong>调性影响文化、文化催生品牌、品牌决定影响力、影响力成就世界级的技术成果。</strong><br><img src="https://img-blog.csdnimg.cn/20200423140334408.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="3、删繁就简"><a href="#3、删繁就简" class="headerlink" title="3、删繁就简"></a>3、删繁就简</h2><blockquote>
<p><strong>有次面试我balabala了一大堆，但对方没有回应，尴尬了10秒，我当时也懵了，下来反思之后明白：<br>我们的信息不对称，更精准的说法就是：我没有满足对方的迫切需要。<br>沟通效率的提升对双方都很重要，所以我要常常反思，做到结构化表达、准确、高效输出。<br>这一点很难，我的路很长。<br>所以现在锻炼写博客、日记、迅速理好逻辑、金字塔原理、结构化表达。<br>所以简单点、再简单点、浓缩、再浓缩、突出重点、一针见血。<br>想做好真的很难，小霞加油！<br>陌生人冷启动可以话多、但是快节奏生活里、删繁就简！</strong></p>
</blockquote>
<p>1、知道的多（输入多）、说明的少（输出少）、在某些场景下，是一种明智。<br>2、这是我还要努力完善的地方，我应该学会精简化表达，让自己的想法更准确的输出、更高效的表达。<br>3、<strong>很多名人演讲非常通俗、简单。简单是一种美。</strong><br>4、浓缩就是精华。<br>5、<strong>世界上最解渴的是水、最昂贵的是免费、最难得的是精华。</strong><br>6、说到点子上。<br>7、交流是相互的，<strong>学会倾听</strong>、学会揣摩、想好了再说，输出要有价值。<br>8、<strong>加快沟通的办法：同步精神认知、保障信息对称。</strong><br>9、<strong>耐心、细心、不要轻易对一个人下结论，性格没有好坏之分。</strong><br>10、个体差异性的最大因素是环境，<strong>多站在对方的角度换位思考</strong>，Leader想要的是什么？我怎么做可以优化？</p>
<h2 id="4、深入思考"><a href="#4、深入思考" class="headerlink" title="4、深入思考"></a>4、深入思考</h2><blockquote>
<p><strong>为什么网上出现这么多面经？为什么我们只想要标准答案？面试是我拿着题库，你来背吗？<br>好像我挑着水，你拿着担耶，写到这里，莫名有点喜感，哈哈哈。<br>记得有一次面试，我说了HTTPS的通信流程：它的历史、发展、优缺点、存在的问题、怎么解决、优缺点、设计思想balabala。。。。。。<br>腾讯小哥哥听完，顿了一下：同学你记性太好了，故事情节生动（当时听到实在控制不住，笑出了鼻涕enenen）你是咋记住这么多稀奇古怪的名词的？<br>面试官哥哥独白：同学啊，我也好难，我选哪个题考你呢？这题我好像也不太会啊，哈哈哈。(面试官哥哥太可爱了吧hhh)<br>后面就感觉面试像聊聊天，聊聊学校和公司的区别，聊到了前端埋点，我觉得这样就很好啊，因为我们突破围城，看到了不同环境下的技术追求。<br>只要我们获得了超越成见的信息、丰富了固有的认知、看见了圈外的另一面、就是有效的交流。<br>因为它突破了信息茧房，消除了信息不对称，这就是改变、升华呀。<br>比起选题、背题、交流想法和认知，更加难能可贵。<br>我们呆在不同的环境、不同的圈子、不同的围城、难免忘记了，多看看更深远、广大、有差异化的另一边。<br>我们要多一些独立思考，思考是进步、升华、破圈的源泉。</strong></p>
</blockquote>
<p>1、一切问题都有标准答案吗？<br>2、答案是什么？<br>3、<strong>答案是主观人类对客观物质的解读和思考。</strong><br>4、答案是一成不变的吗？<br>5、<strong>当然不是，就算客观物质没有发生Change、主观人类的进化每分每秒都在Update。</strong><br>6、<strong>大概这个世界上99%的东西都Etag吧。</strong><br>7、<strong>基础JS知识、数据结构堆、栈、树、链表、图、框架设计Vue、React、Node、Koa、O(N)最小的算法</strong><br>   <strong>分治、归并、快排、深广遍历、层次遍历二叉树、链表成环、贪心算法、动态规划、设计模式、框架思想、前端行业发展等等等等…</strong><br>   <strong>基础知识是分散的血肉、框架搭建是连接的骨架、我们需要去深入思考组件化、模块化、工程化的发展意义、因为发展史是血液！</strong><br>   <strong>血液是流动、变化的，我们要思考、把控、检测、优化前端血液、所流向的方向、速度和频率。</strong><br>   <strong>有了坚硬的骨头、丰富的血肉、动态的血液、才有健康、完整、生动、蓬勃向上的前端，才能破圈、做出世界级的技术。</strong><br>   <strong>所有的一切、都需要技术改革、破圈。像我们的国家一样、改革开放是第一生产力。</strong><br>   <strong>要让技术有情怀、要让科技向善、人文向美。这是品牌的生命力、是企业的美好愿景和希望。</strong><br>8、本质上也是由物质组成的、物质由原子组成。<strong>而原子是时刻运动、变化的。</strong><br>9、<strong>性能优化的本质是：<br>**时间上：让技术创新的速度Match上原子运动的速度。</strong><br><strong>空间上：让容器承受的数据Contain上人类信息的爆发。</strong><br><strong>这是低频—》同频—》高频的进化，也是破圈的关键。</strong><br><strong>D2前端技术的日程里，我们看到了前端的巨大能量！</strong><br><strong>AI智能化、机器学习弄潮于技术之巅，怎能不让人期待和心动？如何结合小程序真正落地、解决痛点是我们要深入思考的角度。</strong><br><strong>Severless体系的不断完善，让上云变得充满了诗情画意的想象，新链路怎么样才能构建各大厂商线下线上业务的有效闭环？</strong><br><strong>工程化的巨变要怎么样监控、优化、才能重构业务形态？风险和收益并存，我们要怎么样衡量成本和获利？保留抑或抛弃过去的框架？</strong><br><strong>微前端的价值是什么？迁移是否存在生物学中的排异反应？是否能带来化学中的催化剂效力？要怎么模型匹配，才能共生共存，和谐并进？</strong><br><strong>技术的背后暗藏了深厚的中国哲学。哲学是打造世界级技术的根本。</strong><br><strong>质对量、快对慢、新对旧、多对少，如何把控？</strong><br><strong>思考“度”的破圈。</strong><br><strong>思考《老子》的中庸之道。</strong><br><strong>小霞相信历史的判断力、经典著作的权威力。</strong><br><strong>以史为镜，真的，可以做决策。</strong><br>（可能不成熟，小霞缺乏亿万流量级别的实习经验、但小霞相信技术与人文的强大爆发力）<br>（很多时候，不是我们经历了什么，而是我们从大大小小的经历中总结了什么，反思了什么，决定了我们的定位。）<br>记得初中那会上历史课时，恩师神采飞扬的说：<strong>人类最大的差异化优势就是懂得思考，思考是与其他动物的最大区别。</strong><br>未来充满了挑战和期待！真正能帮助我们勇敢接受、直面困难、解决问题的：<strong>是无所畏惧的激情、是磨练的底气、是总结的方法论。</strong><br>而这一切、都来自思考！<br>思考的造字、意境很美！</p>
<ul>
<li><p>思：</p>
</li>
<li><p>田:</p>
</li>
<li><p>代表方圆之中的规律之美，没有规矩，不成方圆。</p>
</li>
<li><p>田是全包围结构。</p>
</li>
<li><p>古往今来、规矩是本、社会、企业需要规章制度、这是和谐、不乱套的基本原则。</p>
</li>
<li><p>心：</p>
</li>
<li><p>心代表方圆之中的想象之美，海阔天空、有容乃大。</p>
</li>
<li><p>心是半包围结构。</p>
</li>
<li><p>沧海桑田、夸父逐日、社会、<strong>企业需要心心相印、齐心协力，这是突破、不流俗的升华破圈。</strong></p>
</li>
<li><p>考：</p>
</li>
<li><p><strong>土:土代表萌芽、原生、质朴、抗压、浪里淘沙、亘古不变、土承载了韧性的基因、父辈的传承。</strong></p>
</li>
<li><p><strong>丐:丐代表空无、白纸、困境、窘迫、白手起家、从0到1，丐象征了DNA的钙铁锌硒、破圈的坚韧。</strong></p>
</li>
<li><p>至于这一丿，<strong>小霞就理解为时代的风向吧，象征着机遇和挑战，怎么把握、怎么挖掘、怎么价值最大化是我们思考的结晶！</strong></p>
</li>
<li><p>就如雷军先生所说：学会机智、及时的站在风口上。（小霞改编一下，原话很接地气，嘿嘿，这里的意境偏古风~）</p>
</li>
</ul>
<blockquote>
<p>谈谈如何选择？如何刷新？</p>
</blockquote>
<p><strong>没有最标准的答案、只有特定场景下最合适的解法。</strong></p>
<blockquote>
<p>我们呆在不同的环境、不同的圈子、不同的围城。<br>难免忘记了，多看看更深远、广大、有差异化的另一边。<br>我们要多一些独立思考，思考是进步、升华、破圈的源泉。<br>进程、线程、协程需要想办法通信。人与人、人与物、物与物之间是一个道理，破圈第一步就是通信！<br>10、<strong>我们总是试图在随机事件中寻找规律，但这种倾向很有可能会使我们误入歧途。</strong><br>    <strong>对错评判的标准需要更多复杂的维度、创新的角度、突破信息茧房的深度。</strong><br>11、<strong>机器学习为什么梯度下降？为什么要修改损失函数？</strong><br>12、<strong>根本原因就是调整方向、扭转局势、悬崖勒马。</strong><br>13、我们避免不了误判、所以要经常检测、如果<strong>不及时止损、后果不堪设想。</strong><br>14、一个坑不解决、后面<strong>会有很多很多坑、连累很多很多人。</strong><br>15、当做出重要决策以后，我们经常会<strong>过高地评价自己的选择</strong>而<strong>贬低放弃的选择。</strong><br>16、所以<strong>当局者迷、旁观者清，我们需要第三方的公正评价。</strong><br>17、人类大部分的<strong>冲突和争论</strong>都源于人们过于关注自己的意见而<strong>并非去寻找问题的真正答案。 -</strong><br>18、<strong>信息爆炸的时代，独立思考真的，难能可贵。</strong><br>19、<strong>每天需要半个小时，思考一下，我今天做的事情，有价值吗？</strong><br>20、<strong>多照镜子、多从他人眼中，看到自己的影子。</strong><br>21、<strong>学的越多、越发现、知识海洋的深广、信息迭代的神速。</strong><br>22、<strong>你的兴趣很大程度上决定了你钻研的深度。认清自己、找准定位、T型发展。</strong><br>23、总有不会、不懂的，不要焦虑，不要烦躁，<strong>控制情绪是成功的第一步。</strong><br>24、世界这么大，社会需要不同领域的专家。<strong>每个人做好USB接口，能正常通信、汲取借鉴，就非常棒了。</strong><br>25、保持孩子般天真的求知欲，总之，活到老，学到老。学习是投资最低、收益最大的生意。<br>26、伟大的诗人歌德说：我没有一天是闲下来的。<br>27、<strong>跳出舒适圈、信息茧房、越早越好。</strong><br>28、21世纪的字典里，<strong>没有稳定</strong>，真的没有骗你。<br>29、<strong>所谓岁月静好，是有人为你遮风挡雨、负重前行，但总有一天，我们要独立面对狂风暴雨、晴天霹雳。</strong><br>30、<strong>我们可以有潦倒的困境，但不能有潦草的内心。</strong><br><img src="https://img-blog.csdnimg.cn/20200423140222712.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<h2 id="5、保持初心"><a href="#5、保持初心" class="headerlink" title="5、保持初心"></a>5、保持初心</h2><blockquote>
<p><strong>世界很大，小霞不能迷失了自己。<br>追梦路上、初心一直，与我同在。<br>退缩很愚蠢、灾难来临，总有人要挺身而出。<br>困难降临、不被认可只是说明：<br>天将降大任于斯人也，上帝要苦我心志、让我涅槃重生。<br>他选了我，说明我有潜质成为与众不同的人！<br>坦然接受，勇敢面对，拥抱变化、保持激情和乐观！<br>别忘了！你还有家人和朋友，你还有明天的朝霞、明天的起飞。<br>总有一天，会找到光亮、它在美丽的远方闪闪发光。</strong></p>
</blockquote>
<p>1、<strong>时常看看镜子里的自己：眼神是否还清澈？</strong><br>2、时常摸摸自己的心脏：是否还有激情？<br>3、时常和父母谈心：我是不是当初那个单纯的孩子？<br>4、<strong>时常回顾日记：我的赤诚、坦率、热心、良善、还在吗？还有温度吗？</strong><br>5、初心让我们回归<strong>简单、质朴、简单是一种力量，强大的力量。</strong><br>6、初心可以省去很多烦恼。<br>7、<strong>海纳百川、有容乃大；壁破千仞，无欲则刚。</strong><br>8、<strong>初心里承载着正直、良善、宽容。</strong><br>9、<strong>企业有了初心，会更有温度和情怀，会走的长远、稳健。</strong><br>10 <strong>企业做前端、做产品，根本是解决人的真需求，要带上初心、情怀、灵魂。</strong><br>11 <strong>初心带来心心相印，用户喜欢和我们相似的人。</strong><br>12、<strong>水能载舟、亦能覆舟。得民心者得天下，古往今来、无一例外。阿里的信念是用户第一！</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200423140046512.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200423140411854.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200423142800156.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200423142846387.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200423142941467.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E4%B8%AA%E4%BA%BA%E6%97%A5%E8%AE%B0%E6%80%BB%E7%BB%93/" rel="tag">个人日记总结</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E5%B1%95%E6%9C%9B%E6%9C%AA%E6%9D%A5%E5%8D%81%E5%B9%B4/" rel="tag">展望未来十年</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-深入总结Leader对小霞的终极灵魂十问！附上小霞名字解析_" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/04/21/%E6%B7%B1%E5%85%A5%E6%80%BB%E7%BB%93Leader%E5%AF%B9%E5%B0%8F%E9%9C%9E%E7%9A%84%E7%BB%88%E6%9E%81%E7%81%B5%E9%AD%82%E5%8D%81%E9%97%AE%EF%BC%81%E9%99%84%E4%B8%8A%E5%B0%8F%E9%9C%9E%E5%90%8D%E5%AD%97%E8%A7%A3%E6%9E%90_/"
    >深入总结Leader对小霞的终极灵魂十问！附上小霞生活思考~</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/04/21/%E6%B7%B1%E5%85%A5%E6%80%BB%E7%BB%93Leader%E5%AF%B9%E5%B0%8F%E9%9C%9E%E7%9A%84%E7%BB%88%E6%9E%81%E7%81%B5%E9%AD%82%E5%8D%81%E9%97%AE%EF%BC%81%E9%99%84%E4%B8%8A%E5%B0%8F%E9%9C%9E%E5%90%8D%E5%AD%97%E8%A7%A3%E6%9E%90_/" class="article-date">
  <time datetime="2020-04-20T16:00:00.000Z" itemprop="datePublished">2020-04-21</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="categories/%E4%B8%AA%E4%BA%BA%E7%BB%8F%E5%8E%86%E4%B8%8E%E7%94%9F%E6%B4%BB%E6%80%9D%E8%80%83/">个人经历与生活思考</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>突如其来的一个电话让小霞创作了这篇文章，记录很有深度的Leader问，感谢这次机会，也算是一次自己对过往生活和学习的深入思考。<br>吾日三省吾身，为人谋而不忠乎？与朋友交而不信乎?传不习乎？<br>夫以铜为镜，可以正衣冠；以史为镜，可以知兴替；以人为镜，可以明得失！<br>Welcome to share creative thoughts!<br>第七部分的技术思考欢迎大家多多交流指教！</p>
<h2 id="一、为什么学产品？"><a href="#一、为什么学产品？" class="headerlink" title="一、为什么学产品？"></a>一、为什么学产品？</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 小霞复盘思考</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>做产品的初衷？</strong></p>
</blockquote>
<ul>
<li>本科参加很多社团活动、喜欢和不同角色的人打交道。</li>
<li>本科双学位是英语、享受演讲的过程、希望自己有一天可以站在讲台上、普及自己的产品思维和理念。</li>
<li>看了很多心理学和哲学的书、想挖掘产品背后的人性层面的原理。</li>
<li>做产品可以进一步提高思辨能力、抽象能力、逻辑能力。</li>
</ul>
<blockquote>
<p><strong>实习干了什么？</strong></p>
</blockquote>
<p>1、实践出真知，大三实习时我撰写需求文档—》设计流程图—》沟通前端、后台、UI、运维—》加快产品上线。<br>2、实习总结后，我幡然大悟：<strong>产品思维</strong>是一种<strong>挖掘问题—》拆分问题—》解决问题—》优化产出</strong>的能力。</p>
<blockquote>
<p><strong>产品实习的收获？</strong></p>
</blockquote>
<ul>
<li>更长远的<strong>大局观</strong></li>
<li>更专业的<strong>商业思维</strong></li>
<li>更敏锐的<strong>洞察力</strong></li>
<li>更准确的<strong>判断力</strong></li>
<li>更有温度的<strong>同理心</strong></li>
<li>更有效的<strong>沟通力</strong></li>
</ul>
<blockquote>
<p> <strong>B\C端有什么区别？</strong></p>
</blockquote>
<ul>
<li>C端产品服务于用户，成功的关键是根据<strong>马斯洛法则</strong>分辨需求真伪、从人性角度深入挖掘。</li>
<li>C端产品要考虑怎么样让用户在最短路径，最快时间满足自己的需求，<strong>提升用户体验</strong>。</li>
<li>B端产品服务于组织，组织的需求不是从单个用户需求点出发，而是一种<strong>生产关系的连接和延伸</strong>。</li>
<li>B端产品的重点是基本信息流的传递，梳理<strong>业务流和逻辑链条</strong>、关注商业模式、企业文化、沟通效率、平台盈利。</li>
</ul>
<blockquote>
<p> <strong>我总结了哪些解决问题的办法？</strong><br> <strong>这一部分从宏观角度阐述、在研究生方法论中以科研经历为例子具体展开谈。</strong></p>
</blockquote>
<ul>
<li>分治法：拆分大问题—》解决子问题—》<strong>各个击破</strong>—》合并归一。   </li>
<li>破冰法：<strong>千里之堤、溃于蚁穴</strong>。有些问题只是窗户纸（表面很难、本质很容易）一针见血便可迎刃而解。   </li>
<li>二轴四象限法：二轴是<strong>时间和空间</strong>、四象限根据具体问题去设计、<strong>规划优先级、先解决最迫切的问题</strong>。   </li>
<li>经验借鉴法：问渠那得清如许，为有源头活水来？<strong>从企业、团队、个人成功或者失败的例子中找到答案</strong>。   </li>
<li>头脑风暴法：开会、交流、集思广益、<strong>群谋划策</strong>、借助团队的力量。</li>
<li><strong>Apple法则： 取首英文字母串联起流程，小霞的Apple法则来自实践—实践出真知</strong></li>
<li>确定产品定位、项目目标、针对哪些<strong>场景优化</strong>到什么数量级？(Ambition）</li>
<li>收集用户需求、<strong>辨别真伪、确定优先级</strong>、做好项目排期（Accumulation)</li>
<li>预测方案A/B/C哪个性能更好？哪个框架更优？<strong>技术选型比较</strong>（Prediction)</li>
<li>确定方案后、团队合作、<strong>深耕细耘</strong>、一万小时的努力成就辉煌(Persistence)</li>
<li>前端科技日新月异、保持热情、终身学习、<strong>T型发展</strong>（Learn）</li>
<li>提高<strong>沟通表达效率</strong>、把自己打磨成<strong>USB一个接口</strong>，适配不同角色的人群、对接后台、UI、产品（Link）</li>
<li>及时复盘、定期总结、<strong>虚心求教、自我评估</strong>（Evaluation）</li>
<li>产品上线、<strong>数据分析</strong>、预测商业价值、<strong>盘活商业模式</strong>（Estimation）</li>
</ul>
<blockquote>
<p><strong>这些方法论的原理是什么？</strong></p>
</blockquote>
<ul>
<li><strong>知己知彼，百战不殆</strong>。</li>
<li>旁观者清、身居者迷。 </li>
<li>一千个人眼中有一千个哈姆雷特。</li>
<li>横看成岭侧成峰、远近高低各不同。 </li>
<li><strong>不做什么，比做什么更重要</strong>。</li>
<li>富人思维是一种多变量思维。 </li>
<li><strong>以铜为镜，可以正衣冠；以史为镜，可以知兴替；以人为镜，可以知得失</strong>。</li>
<li>沟通失败的本质有两点：<strong>一是精神层面的认知不同，二是物质层面的信息不对称。</strong></li>
</ul>
<blockquote>
<p><strong>什么样的产品是好产品？</strong></p>
</blockquote>
<p><strong>微观层面：</strong><br>你若盛开，清风自来；桃李不言，下自成蹊。<br>清风细雨，润物无声；上善若水，干净纯粹。<br>己所不欲，勿施于人；删繁就简，大智若愚。<br><strong>宏观层面：</strong></p>
<ul>
<li>有使命：解决用户痛点、提高企业效率、扩大平台盈利  </li>
<li>美好愿景：用户个性化定制、企业品牌化策略 </li>
<li>价值观：<strong>互联网最稀缺的是信任和注意力、好的产品一定是普惠众生的、免费的产品本质上是最贵的</strong> </li>
<li>（价值观的原理很深，日后展开谈背后的真相）</li>
</ul>
<blockquote>
<p> 举例说明？<br> 请见博客实习总结，爱奇艺实习总结社区文化的规律、视频号源自社区建设的思考。<br> 不成熟之处小霞虚心求教，写博客的目的是记录当下22岁的思考，等我长大了细细回顾。<br> 小霞想记录不同年龄、不同阅历、不同人生阶段的自我成长、并乐意和阅读的您分享，愿每一个人都珍惜成长的记录！</p>
</blockquote>
<h2 id="二、为什么做前端？"><a href="#二、为什么做前端？" class="headerlink" title="二、为什么做前端？"></a>二、为什么做前端？</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 小霞复盘思考</span><br></pre></td></tr></table></figure>
<p>1、做产品时很注重<strong>用户体验</strong>，经常和前端打交道、页面的效果让我感到<strong>神奇和惊叹</strong>、激发了学习欲望。<br>2、本身是工科出身、有技术基础、<strong>学好技术是个人学业的必备要求，也让我有底气和踏实感</strong>。<br>3、从去年开始学习HTML、CSS、JS、VUE、React，写了很多笔记看了很多书籍、小霞要<strong>做好职业规划和成长目标</strong>。<br>4、前端专家是<strong>综合性人才</strong>，高屋建瓴，兼顾<strong>商业背景、技术架构、产品体验</strong>。<br>5、<strong>企业理念是导向，用户体验是目标、技术框架是基石，技术与人文结合才有巨大的蝴蝶效应。</strong><br>6、<strong>读研</strong>的深入学习让我对前端有了更大的热情和动力，<strong>AI的研究经历</strong>让我产生很多关于前端的思考。<br>7、未来十年、前端拥有无限的发展空间、<strong>聪明的选择要紧密契合时代发展、独到的眼光决定个人成长路线的走向。</strong><br>8、<strong>学习热情的高低决定职业发展瓶颈的大小、持续的动力来自内心真正的热爱，它决定我们到底能走多远。</strong><br>9、<strong>没有任何一份职业是轻松的，生活的本质是苦难，成长的真相是蜕变、快乐来自自我的破圈、认知的进化。</strong><br>10、这个博客是自己搭建的、申请域名、Github账号、设计博客页面、插入小音乐、小程序、喜欢的摄影家、个人相册、搭建时很有成就感，也激发了学习前端、做好设计的强烈欲望。<strong>它让我快乐、踏实、持续高产、精神充实。</strong></p>
<h2 id="三、你在团队项目中是一个什么样的角色？"><a href="#三、你在团队项目中是一个什么样的角色？" class="headerlink" title="三、你在团队项目中是一个什么样的角色？"></a>三、你在团队项目中是一个什么样的角色？</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本科阶段</span><br></pre></td></tr></table></figure>
<blockquote>
<p>商务英语方面：”点亮英语” 社团—我的角色是<strong>社团Leader</strong>，专注于策划活动方案、社团招新、管理</p>
</blockquote>
<p><strong>项目背景</strong>：刚入大学的萌新们学习有些放松、没有了早读、首课八点半才开始、大把时间浪费在寝室睡懒觉。<br><strong>项目策划：</strong></p>
<ul>
<li>点亮社团推出”朝花夕拾”活动。 </li>
<li>引导大家早起晨读英语、模拟对话练习。 </li>
<li>与留学生社团合作举办英语角、英语演讲比赛。</li>
</ul>
<p> <strong>我的角色是Leader，做了以下三点：</strong><br> 1、做为项目策划人、我设计了以上三点策划方案、借教室、借场地、<strong>招新纳才、和校方沟通联合</strong>、全校宣传社团活动。<br> 2、邀请留学生作客演讲、解决<strong>活动冷启动</strong>的问题、通过大型宣传<strong>打破同学认知、跳出被窝舒适圈、激发学习热情。</strong><br> 3、做好团队文化管理，定期开会<strong>集思广益、处理反馈建议、迭代优化</strong>团队的活动方案、在校内做到社团活跃度TOP1。</p>
<blockquote>
<p>大学生kmust “飞思卡尔”  智能机器人大赛</p>
</blockquote>
<p><strong>项目背景</strong> ：选取任意一组、团队合作完成机器人赛道流程、包含自动循迹、弯道减速、绕过障碍物、定点踢球功能。</p>
<ul>
<li>基础四轮组 </li>
<li>双车组 </li>
<li>AI电磁组</li>
<li>摄像头循迹组 （我们选了这个组别，难度比较大）</li>
</ul>
<p><strong>我的角色：USB接口</strong>（我分为对内和对外两个角度）</p>
<blockquote>
<p>对内： 个人专攻于<strong>路径循迹模块</strong>：</p>
</blockquote>
<p>1、我采用了八个红外线传感器，安装在机器人的头部电机，采用<strong>并排的方式</strong>扩大视野范围。<br>2、设计程序、控制机器人及时检测对面路况信息、及时接受反馈回来的信号、将传感器的数据送到CPU主核处理器。<br>3、看论文、看官方文档、创新提出<strong>优化PID算法，进行积分、加权、微分</strong>、得出下一步路劲的方向、速度、转角大小。<br>4、优化程序设计<strong>不断调试参数</strong>、历经两个月、每天坚持在实验室测试、最终保证机器人正常检测路况自动跑完”S”赛道。</p>
<blockquote>
<p>对外：<strong>对接其他模块接口、团队完成一整套流程：</strong></p>
</blockquote>
<p>1、其他同学不太精通的地方，我凭借自己的专业能力帮助他人：<br>比如有同学英语不太好，我帮助他完成<strong>翻译、解析、让他获取更多有效的资源和解决方案。</strong><br>（因为有一些资源是英文版的，比较复杂，涉及很多专业名词，有一些同学存在阅读和理解上的困难）<br>2、及时和大家沟通交流，接口对不上的话，整个流程的效率都会降低，所以经常开会讨论方案、优化机器人的跑步速度，同时还要<strong>减小路线判断的失误、提高检查路况的准确度。</strong></p>
<h2 id="四、研究生做了哪些项目，有哪些学习方法？"><a href="#四、研究生做了哪些项目，有哪些学习方法？" class="headerlink" title="四、研究生做了哪些项目，有哪些学习方法？"></a>四、研究生做了哪些项目，有哪些学习方法？</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">研究生阶段：医疗图像处理、人体姿态估计</span><br></pre></td></tr></table></figure>

<blockquote>
<p>医疗图像处理：对接华科同济医学院，利用深度学习帮助医生诊断脑血栓、脑瘤的病历。</p>
</blockquote>
<p>项目需求：解决诊断周期长、设备成本高、医疗人才短缺、诊断效率低的问题。<br>项目成员：两位同济医生、一位博士、两位研究生（包括我）、一位本科生<br><strong>我的角色：</strong><br><strong>沟通层面</strong>：和医生对接、每周去三次医院、拷贝病人电子病历、和医生交流待解决的诊断难题。<br><strong>技术层面</strong>：利用Pytorch框架做数据集的筛选、清洗、预处理、数据标注、数据集训练等技术问题。<br><strong>克服的困难：</strong><br><strong>医疗方面</strong>：<strong>短时间内</strong>要学习大量脑部结构的依赖关系、学习各种诊断病历的医院专用软件。<br>我的方案：<strong>勤学多问</strong>、牺牲娱乐和休息时间、因为资料比较多、所以采用了<strong>时间压缩法，缩小间隙、排挡比较满。</strong><br><strong>算法方面</strong>：学习各种深度学习的<strong>复杂</strong>计算公式、框架应用、网络模型。<br>我的方案：<strong>多听学术分享会、多看前人的经验总结、要从历史规律中找寻答案</strong>、多看视频网课、看精华分享。</p>
<h2 id="五、当下的研究生技术困难，怎么解决，为什么这样做？"><a href="#五、当下的研究生技术困难，怎么解决，为什么这样做？" class="headerlink" title="五、当下的研究生技术困难，怎么解决，为什么这样做？"></a>五、当下的研究生技术困难，怎么解决，为什么这样做？</h2><blockquote>
<p>人体姿态估计：华科新兴领域、很多技术层面的体系不太完善、技术突破需要有新思路、新灵感、破功难。</p>
</blockquote>
<p><strong>项目目标：</strong></p>
<ol>
<li><p>基于<strong>自底向上</strong>的多人人体姿态估计方案，设计系统并实现<strong>功能需求。</strong></p>
</li>
<li><p>结合<strong>新科研成果</strong>对卷积神经网络结构进行改造，使得网络中的<strong>参数量得以大幅缩减</strong>，<strong>计算复杂度得以大幅降低。</strong></p>
</li>
<li><p>在卷积神经网络的参数量和计算量都大幅减小情况下，对方案进行改进以<strong>接近原始网络结构的精度。</strong></p>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为什么选择自底向上的方案？</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200421222036296.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>项目难点：</strong></p>
<ol>
<li>网络的<strong>计算量太大</strong>，硬件计算资源难以支持。在实验室的计算资源丰富的环境下训练出来的网络，一旦部署到计算资源紧缺的移动终端上就会导致<strong>运行时间太长而难以接受</strong>。</li>
<li>网络的<strong>参数量太大</strong>，部署在硬件上会占用大量的内存，对于内存较小的移动终端来说，很容易出现<strong>内存溢出</strong>问题。</li>
</ol>
<p><strong>解决思路：</strong></p>
<p>最直观的做法：训练出一种<strong>计算复杂度更低、参数量更少</strong>的网络以满足实际的生产环境部署的要求。</p>
<p>以下是详细流程：来自日常汇报的部分截图，流程比较复杂，选取一部分代表</p>
<blockquote>
<p>实验部分偏技术，下面板块会总结方法论！</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200421222725727.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200421222931608.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200421223151262.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200421223401718.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200421223452391.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200421223633782.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200421223940958.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200421223807609.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="六、你总结了哪些科研方法论？"><a href="#六、你总结了哪些科研方法论？" class="headerlink" title="六、你总结了哪些科研方法论？"></a>六、你总结了哪些科研方法论？</h2><blockquote>
<p>这里举了一些实验方案和例子，在《小霞看前端》中也有很多最新成果的展示。<br>第一板块的Apple法则是从宏观角度，下面的方法是从微观角度 。</p>
<p> <strong>我总结一下，科研的方法论就是：<br>  调研最新论文、开源项目、多看论文，</strong>找到还可以优化的点**<br>     汲取历史经验、<strong>判断未来发展方向**</strong><br><strong>做实验前先把以下问题搞明白、搞透彻再去部署实践。</strong></p>
</blockquote>
<p><strong>预判断部分：好的方向和起点是成功的一半！</strong></p>
<blockquote>
<p> <strong>我们要解决什么问题？<br> 这个问题是真需求还是伪需求？<br> 如果解决了，它真的能带来很多性能优化吗？<br> 能发出创新论文吗？</strong></p>
</blockquote>
<p><strong>调研部分：</strong>      <strong>知己知彼、百战不殆+认清形势、抛弃不切实际的幻想！</strong></p>
<blockquote>
<p><strong>这些问题前人做过没有？<br> 其他实验室做过没有？<br> 或者说竞争对手做过没有？<br> 他们做的怎么样？<br> 有一定成果吗？<br> 我们的服务器资源能支持吗？<br>导师支持吗？<br>投入产出比是多少？<br>现阶段的技术水平能否完成？<br>实验周期能否加快？</strong></p>
</blockquote>
<p><strong>落实部分：协调沟通+定期分享！</strong></p>
<blockquote>
<p><strong>团队人员是否意见一致？<br> 团队合作是否高效、协调？<br> 每个人的价值是否充分发挥？<br> 每个人是不是在做自己擅长的领域？<br>大家有没有互相借鉴的思想？<br>多久安排一次分享会来集思广益？<br>项目排期是否合理？<br>导师的任务是否高效运转？<br>能否完成导师的预期目标？</strong></p>
</blockquote>
<p><strong>优化部分：循环迭代+持之以恒！</strong></p>
<p> <strong>没有人随随便便成功，实验问题是不可避免的，保持乐观和热情。<br>及时和导师交流，经验这个东西，和年纪、阅历有关，不能急于求成。<br>不论成功、失败、都有可以挖掘的价值，关键是如何思考、如何复盘总结。<br>规律是个很神奇的东西、多看、多听、多想、就有思路和灵感了。<br>经过切分、拆解、大问题就是你经常遇到的小问题。<br>创新的前提的有一定的理论基础、天马行空并不能实时落地。<br>真正打败自己的是没有热情和信心。<br>如果你真的花光了所有力气，你要相信，这时候，全世界都会为你助力。真的。<br>万物之上、希望之美，我们应该对未来有所期待。<br>真正的勇士、是看清了生活的真相、但依然热爱它。<br>天下没有绝境、除非自己放弃了自己。<br>要相信一万小时成功定律、没有成绩是因为还不够专业、努力。</strong></p>
<h2 id="七、谈谈你对研究生的技术思考？"><a href="#七、谈谈你对研究生的技术思考？" class="headerlink" title="七、谈谈你对研究生的技术思考？"></a>七、谈谈你对研究生的技术思考？</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 综合前端技术和<span class="selector-tag">AI</span>技术、我有以下理解，纯属个人观点，毕竟年纪有限，不到位之处请点评指教~</span><br></pre></td></tr></table></figure>
<p>1、<strong>计算机世界是二进制的、离散型的。人类世界是多进制的、连续型的。</strong><br>2、深度学习是在模拟现实世界，神经网络就是模拟人的原生大脑。<br>3、<strong>科技的溯源是生活、一切科技、艺术的底层来源于丰富、细微的生活场景！</strong><br>4、好的科技人员应该是个<strong>艺术家。</strong><br>5、<strong>工具</strong>推动了人类历史的发展。从蛮荒时代到21世纪，没有例外！<br>6、Webpack的Tree-Shaking可能来自一场突然的倾盆大雨。<br>7、VUE的发布订阅模式可能起源于生活中的订购牛奶、报纸。<br>8、Node中的单线程模式可能来自于早餐店中的点钞员，点钞员一直接待客人、客人拿号就走、异步处理单个客户的需求！<br>9、<strong>前后端分离、数据与视图的分离</strong>可能来自于美国的联邦制度、<strong>下放集权、划分州市、分块统治。</strong><br>10、<strong>组件划分、Loader单一职责</strong>可能来自于社会演变中<strong>角色的划分、职场上职业的分类、评级等思想！</strong><br>11、React的<strong>单一数据流思想</strong>可能来自于一江春水向东流、大声吼啊！不回头。<br>12、<strong>可逆与不可逆是我们常要思考的问题。（哈希算法）</strong><br>13、HTTPS的CA证书、洋葱模型的中间件、Redux的中间件都体现着<strong>第三方（代理）的魅力。</strong><br>14、当我们手足无措、绞尽脑汁时、多想想代理，代理就是你的帮手、秘书！<br>15、<strong>代理的本质有三类：缓存（保留状态）、公正（安全认证）、传递（消息同步异步）。</strong><br>16、分久必合、合久必分是历史的规律、也是科技的回流。<br>17、<strong>拆分、解耦、归并、融合、归并排序很好的阐释了上述原理。</strong><br>18、比如时间分片（拆分）、批量更新（合并）。<br>19、时间和空间同样是很好的两个维度。<br>20、<strong>我们常常在其中做平衡、做选择、牺牲时间换取空间、或者逆向操作。</strong><br>21、比如Token的加密解密耗费了时间、但是解决了Session存储压力大的空间问题。<br>22、0和1是两个很奇妙的数字，它代表了选择和抛弃，<strong>工程师要敢于舍弃、有舍才有得。</strong><br>23、做权衡的时候我们可以想一想0-1的蜕变，<strong>多思考0-1之间的权重分配。</strong><br>24、前端发展就是一部<strong>性能优化的历史。</strong><br>25、优化来自两部分：减少计算的框架和工具（Webpack、Flutter）、加快传输的通信协议。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 再谈谈深度学习方向的思考：</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p>1、卷积网络CNN的起源来自于模拟人类的大脑神经元。<br>2、RNN网络的思想有点像人类的<strong>七天记忆遗忘曲线。</strong><br>3、Attention（注意力）机制就是模拟了人类的<strong>视野感受差。</strong><br>4、人类总喜欢关注中心化的、有差异的、有视觉冲击力的。<br>5、<strong>整体与局部、分支与合并、权重分配</strong>、是优化神经网络的三大角度。</p>
<h2 id="八、你怎么看前端？"><a href="#八、你怎么看前端？" class="headerlink" title="八、你怎么看前端？"></a>八、你怎么看前端？</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">今天简单划分一下方向，还有很多科研任务要完成，日后小霞来细细剖析！</span><br><span class="line">这个话题很深远、广大、小霞还需要默默沉淀、积累！</span><br><span class="line">目前输出是《小霞看前端》——从研究生生活与科研的视角</span><br></pre></td></tr></table></figure>

<h2 id="九、有哪些习惯和生活思考？"><a href="#九、有哪些习惯和生活思考？" class="headerlink" title="九、有哪些习惯和生活思考？"></a>九、有哪些习惯和生活思考？</h2><p>1、吾日三省吾身<strong>为人谋而不忠乎，与朋友交而不信乎，传不习乎?</strong><br>（搞笑版的三反省：看脸看体重秤看余额宝，哈哈小霞都会反省啦~）<br>2、背单词！这是小霞从小学一年级开始的习惯（在次艾特我亲爱的老妈，感谢她老人家的严格要求）<br>3、写日记或者博客，原因很简单：<strong>反思自己、记录自己和世界的变化、联系。</strong><br>4、我相信这是宝贵的数字资产、我也相信时间不可逆、灵感不可逆。<br>5、好习惯成就不平凡的人生。<strong>平凡人要有不平凡的精神寄托。</strong><br>6、<strong>人最难的是认清自己、很多进步和优化来自梳理、复盘、总结。</strong><br>7、<strong>每个独立个体都需要性能优化。</strong><br>8、写日记就是照镜子、不带滤镜的那种，<strong>你需要时刻倾听内心真实的想法。</strong><br>9、临渊羡鱼、不如退而结网。<strong>在每个人的坐标差里、你从未静止。</strong><br>10、很多东西都有保质期、但我们总贪恋持久化。<br>11、<strong>认清这个真实的世界、然后微笑着用尽全力去爱她。</strong></p>
<h2 id="十、小霞名字的渊源？"><a href="#十、小霞名字的渊源？" class="headerlink" title="十、小霞名字的渊源？"></a>十、小霞名字的渊源？</h2><blockquote>
<p>落霞与孤鹜齐飞、秋水共长天一色！</p>
</blockquote>
<p>这有什么深厚的秘密和涵义吗？<br>当然有！来自文化人姥爷的精雕细琢！<br>欲知后事如何，请听小霞下次分解~</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E4%B8%AA%E4%BA%BA%E6%97%A5%E8%AE%B0%E6%80%BB%E7%BB%93/" rel="tag">个人日记总结</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E5%B1%95%E6%9C%9B%E6%9C%AA%E6%9D%A5%E5%8D%81%E5%B9%B4/" rel="tag">展望未来十年</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-React学习小结（一）" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/04/20/React%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"
    >React学习小结（一）</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/04/20/React%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/" class="article-date">
  <time datetime="2020-04-19T16:00:00.000Z" itemprop="datePublished">2020-04-20</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="categories/React%E6%80%9D%E6%83%B3%E8%AE%BE%E8%AE%A1/">React思想设计</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>本文旨在以精简、通俗的语言传达React的思想<br>来自阅读源码、《深入浅出React》的一些提炼！<br>来自个人梳理总结，重在设计思想的探索，新版迭代快，可能有某些API的细微差别，欢迎指出不到位的地方。<br>欢迎大家一起讨论学习，集思广益！<br>Welcome to share creative thoughts!</p>
<h2 id="1-React独特思想"><a href="#1-React独特思想" class="headerlink" title="1.React独特思想"></a>1.React独特思想</h2><pre><code>1.UI =render(data)
纯函数：最终的用户界面，在 render 函数确定的情况下完全取决于输入数据。
2.函数式编程、响应式展示、拆分数据data和视图render。</code></pre><h2 id="2-虚拟DOM"><a href="#2-虚拟DOM" class="headerlink" title="2.虚拟DOM"></a>2.虚拟DOM</h2><pre><code>1.DOM 是结构化文本（HTML文本）的抽象表达形式，HTML中的每个元素都对应 DOM中某个节点，树状关系，层级嵌套。
2.虚拟DOM不涉及浏览器、本质是JS对象，存在于JS内存中的树形结构。
3.每次比较，Diff算法，找出真假差异，批量更新（Fiber的创新之处后期更新）</code></pre><h2 id="3-框架流程"><a href="#3-框架流程" class="headerlink" title="3.框架流程"></a>3.框架流程</h2><pre><code>1.单向数据流思想：数据驱动---&gt;N个事件触发render函数---&gt;虚拟DOM改变---&gt;Diff差异---&gt;更新视图（真实DOM）。
2.充分解耦、组件拆分。
3.关注输入、输出、有点面向对象编程的思想。
4.借助虚拟DOM，重复渲染来实现动态更新效果，实际上减少了DOM操作，渲染效率高。
5.（React花了很多心思来解决渲染问题，后期一一剖析）</code></pre><h2 id="4-React中的容器组件和傻瓜（展示）组件"><a href="#4-React中的容器组件和傻瓜（展示）组件" class="headerlink" title="4.React中的容器组件和傻瓜（展示）组件"></a>4.React中的容器组件和傻瓜（展示）组件</h2><pre><code>1.拆分业务、一个组件专注做一件事。
2.外层（父聪明）容器组件负责和 Redux Store 打交道的组件。容器组件监听商店状态、通过props告知展示组件重新渲染。
3.内层（子傻瓜）组件只专心负责渲染界面，傻瓜组件是纯函数，只需要根据props来渲染结果，不需要state，state都交给容器组件去打理
4.傻瓜组件没有状态，不需要用对象表示，所以连类都不需要了，对于一个只有 render法的组件，缩略为一个函数就OK，性能优化！</code></pre><p> <img src="https://img-blog.csdnimg.cn/20200420104708974.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="5-props"><a href="#5-props" class="headerlink" title="5.props"></a>5.props</h2><pre><code>1.prop外部传入的数据，对外接口，支持任意数据类型，不是字符串类型必须要用花括号｛｝把 prop 值包住。
2.style两层花括号，外层花括号代表是JSX语法，内层花括号代表这是一个对象常量。
3.函数类型的 prop 就是让父组件交给了子组件一个回调函数。
4.子组件可以恰当的调用函数类型的prop，带上必要的参数，反过来把信息传递给外部世界。
4.组件定义自己的构造函数，必须加上super(props),才可以后续通过this.props访问到父组件传递过来的 props 值。</code></pre><h2 id="6-state"><a href="#6-state" class="headerlink" title="6.state"></a>6.state</h2><pre><code>1.prop不能修改，记录自己的状态只能用state，state存在的意义是被修改。
2.比如计数器初始值是prop传递，加减之后的状态变化由state存储。
3.state 必须是一个 JavaScript 对象，不能是 string 或者 number 这样的简单数据类型。
4.当我们需要存储的只是一个数字类型的数据时，应该把它存作 state 某个字段对应的值。
5.this.state 可以读取到组件的当前 state，this.setState 函数才可以修改数据。</code></pre><h2 id="7-React组件间通信方式"><a href="#7-React组件间通信方式" class="headerlink" title="7.React组件间通信方式"></a>7.React组件间通信方式</h2><pre><code>1.父组件向子组件通讯: 父组件可以向⼦组件通过传 props 的⽅式，向子组件进⾏通讯 。
2.子组件向父组件通讯: props+回调的方式，父组件向子组件传递props进行通讯，此props的作用域为父组件自身的函数。
子组件调用该函数，将子组件想要传递的信息，作为参数，传递到父组件的作用域中 。
3.兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信息进行通信。
4.跨层级通信: Context 设计目的是为了共享那些对于⼀个组件树而言是“全局”的数据。
例如当前认证的用户、主题或首选语⾔,对于跨越多层的全局数据可以通过 Context 通信。
5.发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应。
我们可以通过引⼊event模块进行通信全局状态管理工具: 
借助Redux或者Mobx等全局状态管理⼯具进行通信---&gt;这种工具会维护⼀个全局状态中心Store---&gt;Store根据不同的事件产生新的状态。</code></pre><h2 id="8-React中的context"><a href="#8-React中的context" class="headerlink" title="8.React中的context"></a>8.React中的context</h2><p><strong>为什么有context?</strong><br>1、React 组件是用 props 来传递父子组件之间的数据的。<br>2、在一个嵌套多层的组件结构中，如果只有最里层的组件才需要使用 store，但是为了把store从外面传到最里面，所有的中间组件都要支持store prop，层级太深时用 prop 传递 store 不是一个好方法。<br><strong>context做了什么？</strong><br>1、context让一个树状组件上所有组件都能访问一个共同的对象。<br>2、上级组件要宣称自己支持 context ，并且提供一个函数来返回代表 Context的对象。<br>3、这个上级组件之下的所有子孙组件，只要宣称自己需要这个 context ，然后通过 this.context 访问到这个共同的环境对象<br><strong>使用context要注意什么？</strong><br>1、Context 相当于提供了一个全局可以访问的对象，但是只要有一个地方改变了全局对象的值，应用中其他部分就会受影响<br>2、只有对那些每个组件都可能使用，但是中间组件又可能不使用的对象才有必要使用Context 。</p>
<p><img src="https://img-blog.csdnimg.cn/20200420105841440.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="9-设计好Store-属性，是规划好-Redux流程的基础"><a href="#9-设计好Store-属性，是规划好-Redux流程的基础" class="headerlink" title="9. 设计好Store 属性，是规划好 Redux流程的基础"></a>9. 设计好Store 属性，是规划好 Redux流程的基础</h2><p>生动的说就是：<br>你想看到最新的报纸消息（信息同步），Flux是一个快递员(Dispatcher)送货，你必须要记住快递员的电话（注册订阅），由快递员来通知你，给你送最新的报纸。<br>但是！在Redux中,设置了一个信息中心store，全世界只有一个Onlyone！<br>没有快递员，但是你有自己的手机（dispatch）你想信息同步，直接打开手机，刷刷每日最新就OK！<br>由一部手机（这个手机就是store绑定在自己身上的函数dispatch）来实现信息同步。<br>这个函数帮你完成了一切复杂的分发信息流程！（函数式编程思想的体现）</p>
<p>   1.数据不一致怎么办？—&gt;靠Redux中的store来解决，全局状态就是唯一可靠的数据源。<br>    Redux Store 状态设计的一个主要原则：唯一数据源<br>    2.仅仅在构造组件时根据 store 来初始化 this.state 远远不够，还要保持 store 上状态和 this .state 的同步。<br>    3.在Flux中有多个store，分发功能由一个Dispatcher 对象完成（这个Dispatcher对象把一个 action 对象分发给多个注册了的 Store)。<br>    4.但是！Redux 全局只有一个Store，废弃了Dispatcher对象，在全局Store上绑定自己的函数dispatch，调用这个函数就可以拿到新的数据。<br>    5.通过 store.getState （）能够获得 store 上存储的所有状态，但是当我们只想获取组件的某一部分数据时，要在getOwnState函数中设计好逻   辑，以后任何关联 Store 状态的地方都可以重用getOwnState这个函数。<br>     6.在componentDidMount设计监听函数，通过 Store subscribe 监听其变化，只要 Store状态发生变化，就会调用这个组件的 onChange 方法。<br>     7.在 componentWillUnmount函数中，我们必须把这个监听注销掉，这个清理动作和 componentDidMount 中的动作对应。<br>     8.除了从 store 同步状态，视图中可能会想要改变 store 中的状态，但是改变store 中状态的唯一方法就是派发action。<br>     9.在 Redux 中，action 构造函数只负责创建对象，要派发 action需要调用 store.dispatch 函数。</p>
<h2 id="10-redux的工作流程？"><a href="#10-redux的工作流程？" class="headerlink" title="10.redux的工作流程？"></a>10.redux的工作流程？</h2><p>源码版：建议配合源码食用，比较复杂但是可以啃下来<br><img src="https://img-blog.csdnimg.cn/20200420124530161.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200420113519742.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">核心概念：</span><br><span class="line">    <span class="selector-tag">Store</span>：保存数据的地方，可以把它看成一个容器，整个应用只能有⼀个<span class="selector-tag">Store</span>。</span><br><span class="line">    <span class="selector-tag">State</span>：<span class="selector-tag">Store</span>对象包含的所有数据，如果想得到某个时点的数据，就要对<span class="selector-tag">Store</span>生成快照，某一时间的数据集合就是<span class="selector-tag">state</span> </span><br><span class="line">    <span class="selector-tag">Action</span>：<span class="selector-tag">State</span>的变化，会导致<span class="selector-tag">View</span>的变化。</span><br><span class="line">    注意！用户接触不到<span class="selector-tag">State</span>，只能接触到<span class="selector-tag">View</span>。所以<span class="selector-tag">State</span>的变化必须 是<span class="selector-tag">View</span>导致的。</span><br><span class="line">    <span class="selector-tag">Action</span>就是<span class="selector-tag">View</span>发出的通知，表示<span class="selector-tag">State</span>应该要发生变化了。</span><br></pre></td></tr></table></figure>

<p>梳理简洁版：思想是通用的</p>
<blockquote>
<p>Action Creator：View要发送多少种消息，就会有多少种Action。我们定义⼀个函数Action Creator来生成Action。<br>Reducer：一个函数，它接受Action和当前State作为参数，返回⼀个新的State。<br>当Store收到Action以后，必须返回⼀个新的State，这样View才会发生变化。这种State的计算过程就是Reducer。<br>dispatch：是View发出Action的唯⼀方法。<br>    然后我们对照上图梳理一下整个工作流程：<br>    1. 首先，⽤户（通过View）发出Action，触发store.dispatch(action)方法，将状态变化通知到中间件。<br>    2. 然后，Store自动调用Reducer函数，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State<br>    3. State⼀旦有变化，Store就会调用监听函数，来更新View。<br>    4. 到此回到View层，⼀次用户交互流程结束。<br>   总结：在整个流程中数据都是单向流动的，这种方式保证了流程的清晰。</p>
</blockquote>
<p>**</p>
<h2 id="11-redux中如何进行异步操作"><a href="#11-redux中如何进行异步操作" class="headerlink" title="11.redux中如何进行异步操作?"></a>11.redux中如何进行异步操作?</h2><blockquote>
<p>借助redux的异步中间件进行异步处理.  redux异步流中间件分类：<br>redux-thunk<br>redux-saga<br> redux-effects<br> redux-side-effects<br> redux-loop<br> redux-observable</p>
</blockquote>
<h2 id="12-redux异步中间件之间的优劣对比"><a href="#12-redux异步中间件之间的优劣对比" class="headerlink" title="12.redux异步中间件之间的优劣对比"></a>12.redux异步中间件之间的优劣对比</h2><p> <strong>redux-thunk</strong><br> 优点:<br> 1、体积小<br> 2、实现方式很简单<br> 3、 redux-thunk没有引入像redux-saga或者redux-observable额外的范式，上手简单<br> 缺陷:<br> 1、样板代码过多、与redux本身一样，通常一个请求需要大量的代码，而且很多都是重复性质的、耦合严重<br> 2、异步操作与redux的action偶合在⼀起，不方便管理 ，功能孱弱</p>
<p> <strong>redux-saga</strong><br> 优点:<br> 1、异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js 中<br> 2、action摆脱thunk function: dispatch 的参数依然是⼀个纯粹的 action (FSA)<br> 3、function 异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败都可以直接通过 try/catch 语法直接捕获    4、redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用，封装方便<br> 5、redux-saga可以将多个Saga可以串行/并行组合起来,形成⼀个非常实用的异步flow<br> 6、易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等<br>  缺陷:<br>  1、额外的学习成本: 反正我还没有学完，API好多，上手有一定困难<br>   redux-observable<br>   优点:<br>   1、功能最强，背靠rxjs这个强大的响应式编程库<br>   2、借助rxjs的操作符，几乎可以完成异步处理的需求<br>   剩下的还没有了解到，暂不介绍，一入前端深似海。。。</p>
<h2 id="13-Redux-终极小结"><a href="#13-Redux-终极小结" class="headerlink" title="13.Redux 终极小结"></a>13.Redux 终极小结</h2><pre><code>1. 唯一数据源：状态数据应该只存储在唯一的一个 Store上，这个store是一个树形的对象，每个组件往往只是用树形对象上一部
    分的数据。
2. 保持状态只读：不能去直接修改状态，要修改 Store 的状态，必须要通过派发action 对象完成。UI =render( state )
    改变状态的方法不是去修改状态上值，而是创建一个新的状态对象返回给 Redux ，由 Redux 完成新的状态的组装。
3. 数据改变只能通过纯函数完成：reducer(state , action)，函数的返回结果必须完全由参数 state action 决定，而且不产生任何副
   作用，也绝对不能修改参数 state action 对象，改变store中状态的方法就是派发action。
4. Redux中，action 构造函数只负责创建对象，要派发 action，需要调用 store.dispatch 函数。
5. 每个 action 构造函数都返回一个action 对象。
6. 组件的 render 函数所显示的动态内容，要么来自于 props ，要么来自于自身状态。
7. Redux中的reducer 只负责计算状态，却并不负责存储状态，在 reducer 中，绝对不能去修改数中的 state，它是纯函数，是一个计算公式。
8. React Redux 本质上是两个独立的产品， 一个应用可以使用React而不使用Redux，也可以使用 Redux 而不使用 React。
9. 在 Redux 中，很多函数都是不做产生副作用的动作，而是返回一个对象，把如何处理这个对象的工作交给调用者。
10.Redux 中把 state 作抽取出交给 Redux 框架本身， reducer 只用关心如何更新 state 而不要管 state 怎么存。</code></pre><h2 id="14-react-redux是如何工作的"><a href="#14-react-redux是如何工作的" class="headerlink" title="14.react-redux是如何工作的?"></a>14.react-redux是如何工作的?</h2><p><img src="https://img-blog.csdnimg.cn/20200420120213681.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>react-redux将所有的组件分成两大类：</strong></p>
<p><strong>UI组件：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">只负责<span class="selector-tag">UI</span>的呈现，不带有任何业务逻辑</span><br><span class="line">通过<span class="selector-tag">props</span>接受属性（非函数属性）</span><br><span class="line">不使用任何<span class="selector-tag">redux</span>的<span class="selector-tag">API</span></span><br><span class="line">一般保存在<span class="selector-tag">components</span>文件夹下</span><br></pre></td></tr></table></figure>

<p><strong>容器组件:</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">负责管理数据和业务逻辑，不负责<span class="selector-tag">UI</span>的呈现</span><br><span class="line">使用<span class="selector-tag">redux</span>的<span class="selector-tag">API</span></span><br><span class="line">一般保存在<span class="selector-tag">containers</span>文件夹下</span><br></pre></td></tr></table></figure>

<p><strong>mapStateToProps</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">基本语法：<span class="selector-tag">mapStateToProps</span>(<span class="selector-tag">state</span>, <span class="selector-tag">ownProps</span>)</span><br><span class="line"></span><br><span class="line">参数含义：<span class="selector-tag">state</span> 全局状态 、 <span class="selector-tag">ownProps</span>代表组件本身的<span class="selector-tag">props</span>。</span><br><span class="line">（如果写了第二个参数<span class="selector-tag">ownProps</span>，那么当<span class="selector-tag">prop</span>发生变化的时候，<span class="selector-tag">mapStateToProps</span>也会被调用）。</span><br><span class="line"></span><br><span class="line">作用：将<span class="selector-tag">store</span>中的数据作为<span class="selector-tag">props</span>绑定到组件中。</span><br><span class="line"></span><br><span class="line">调用：只要<span class="selector-tag">store</span>更新了就会调用<span class="selector-tag">mapStateToProps</span>方法。</span><br><span class="line"></span><br><span class="line">返回结果：<span class="selector-tag">mapStateToProps</span>返回的结果必须是<span class="selector-tag">object</span>对象，该对象中的值将会更新到组件中。</span><br></pre></td></tr></table></figure>
<p><strong>mapDispatchToProps</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">基本语法：<span class="selector-tag">mapDispatchToProps</span>(<span class="selector-tag">dispatch</span>, <span class="selector-attr">[ownProps]</span>)</span><br><span class="line"></span><br><span class="line">参数：<span class="selector-tag">dispatch</span>  <span class="selector-tag">store</span><span class="selector-class">.dispatch</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ownProps</span>代表组件本身的<span class="selector-tag">props</span>，如果写了第二个参数<span class="selector-tag">ownProps</span>，那么当<span class="selector-tag">prop</span>发生变化的时候，<span class="selector-tag">mapDispatchToProps</span>也会被调用。</span><br><span class="line"></span><br><span class="line">作用：定义<span class="selector-tag">UI</span>组件如何发出<span class="selector-tag">action</span>，实际上就是要调用<span class="selector-tag">dispatch</span>这个方法。</span><br><span class="line">调用：<span class="selector-tag">props</span>改变。</span><br><span class="line"></span><br><span class="line">返回结果：返回包含对应<span class="selector-tag">action</span>的<span class="selector-tag">object</span>对象。</span><br></pre></td></tr></table></figure>

<p><strong>Provider</strong>：让所有组件都可以使用state数据</p>
<p><strong>Connect: 负责连接React和Redux</strong> </p>
<p>1、获取state：<br>Connect通过context获取Provider中的store，通过store.getState()获取整个store tree 上所有state  。</p>
<p>2、包装原组件:<br>将state和action通过props的方式传入到原组件内部—&gt;<br>WrapWithConnect返回⼀个ReactComponent对象Connect—&gt;<br>Connect重新render外部传入的原组件WrappedComponent—&gt;<br>把connect中传入的mapStateToProps、mapDispatchToProps与组件上原有的props合并—&gt;<br>合并之后通过props的方式一起传给WrappedComponent </p>
<p>3、监听store tree变化:<br>connect缓存了store tree中state的状态—&gt;<br>通过当前state状态和变更前state状态进行比较—&gt;<br>从而确定是否调用this.setState()方法触发Connect及其子组件的重新渲染。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/React/" rel="tag">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E7%90%86%E8%A7%A3%E2%80%94%E2%80%94%E6%8F%90%E7%82%BC%E7%89%88/" rel="tag">源码分析与理解——提炼版</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-前端发展：一云多端、智能化、AI+" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/04/19/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%EF%BC%9A%E4%B8%80%E4%BA%91%E5%A4%9A%E7%AB%AF%E3%80%81%E6%99%BA%E8%83%BD%E5%8C%96%E3%80%81AI+/"
    >小霞看前端</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/04/19/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%EF%BC%9A%E4%B8%80%E4%BA%91%E5%A4%9A%E7%AB%AF%E3%80%81%E6%99%BA%E8%83%BD%E5%8C%96%E3%80%81AI+/" class="article-date">
  <time datetime="2020-04-18T16:00:00.000Z" itemprop="datePublished">2020-04-19</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="categories/%E5%B1%95%E6%9C%9B%E5%89%8D%E7%AB%AF/">展望前端</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="思考背景："><a href="#思考背景：" class="headerlink" title="思考背景："></a>思考背景：</h2><p>面试官哥哥(亲切、帅气、耐心倾听)延申的健康码、小程序、校园生活应用。</p>
<h2 id="面试总结："><a href="#面试总结：" class="headerlink" title="面试总结："></a>面试总结：</h2><p>1、技术的背后是人文，好的技术专注用户体验、性能优化、AI创新。</p>
<p>2、前端专家是综合性人才，高屋建瓴，兼顾商业背景、技术架构、产品体验</p>
<p>3、挖掘需求、解决痛点。</p>
<p>健康码：疫情下保障安全出行。（时代背景）</p>
<p>校园生活：打通支付闭环、热点引流、用户留存、丰富平台生态。</p>
<p>小程序：前端智能化、生活化、数字化。（移动时代碎片化、数字化）</p>
<p>4、企业理念是导向，用户体验是目标、技术框架是基石。缺一不可！~</p>
<p>6、反思：背了四年主持稿，英语演讲、辩论赛思维不适合面试场景</p>
<p>7、面试的语速要减慢、精简复杂流程、结构化表达、放轻松。</p>
<p>TIPS：企业和学校不同，工作之后汇报时要精炼、简洁</p>
<p>学校教育喜欢刨根问底追究细节，工作要注重高效率、高产出、浓缩精华。</p>
<p>8、解决问题的方法论、团队协作能力要从点线面的角度举例说明。</p>
<p>9、关注支付宝小程序，从商业环境、技术架构升级思考前端发展。</p>
<p>10、关注前沿技术、多比较JS、TS、Dart的异同，沉淀技术实力。</p>
<p>11、关注移动端发展曲线、想想怎么做好小程序，打造自己的差异化优势。</p>
<p>12、关于Node.js底层原理、Koa中间件、JS内存管理、V8引擎、性能优化、VUE、React设计思想我都有私下做过功课</p>
<p>以后把纸质笔记本的内容输出到公众号奈何公众号一天只能发一次</p>
<p>附上小霞22岁方法论：<br><img src="https://img-blog.csdnimg.cn/20200419132255688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>Apple法则：  取首英文字母串联起流程像乔布斯一样做前端</p>
<p>确定产品定位、项目目标、针对哪些场景优化到什么数量级？(Ambition）</p>
<p>收集用户需求、辨别真伪、确定优先级、做好项目排期（Accumulation)</p>
<p>预测方案A/B/C哪个性能更好？哪个框架更优？技术选型比较（Prediction)</p>
<p>确定方案后、团队合作、深耕细耘、一万小时的努力成就辉煌(Persistence)</p>
<p>前端科技日新月异、保持热情、终身学习、T型发展（Learn）</p>
<p>提高沟通表达效率、把自己打磨成一个接口，对接后台、UI、产品（Link）</p>
<p>及时复盘、定期总结、虚心求教、自我评估（Evaluation）</p>
<p>产品上线、数据分析、预测商业价值、盘活商业模式（Estimation）</p>
</blockquote>
<p>因为面试官哥哥提到了小程序的前端发展。所以有了下文~</p>
<h2 id="今日目标：调研资料、梳理逻辑、提炼总结"><a href="#今日目标：调研资料、梳理逻辑、提炼总结" class="headerlink" title="今日目标：调研资料、梳理逻辑、提炼总结"></a>今日目标：调研资料、梳理逻辑、提炼总结</h2><p>调研资源来自搜索引擎、阿里云，经过逻辑思考之后输出如下</p>
<p>以小程序为主题，从业务逻辑、技术架构、学习成果、前端思考上写个总结！</p>
<p>主要是帮助自己梳理业务逻辑，做好前端要和后台、运营、产品紧密对接</p>
<p>毕竟团队合作，众人拾柴才能提高企业发展的效率</p>
<p>小程序架构图先存储起来，后面好好梳理，阿里技术团队真的厉害</p>
<p>借助目前的知识沉淀能大概理解其中的原理，不过精细之处还要多多学习、细细研究</p>
<p>前端智能化发展一个很棒的例证！  链接如下：</p>
<p>商家应用 + AR : 助力虚拟试妆引擎落地手淘（2019/12/19)</p>
<p>最后附上研究生AI人体姿态估计成果</p>
<p>（流程复杂，面试难以讲好，不过面试官哥哥很耐心听我balabala）</p>
<p>（最后还鼓励了我，感动只要被肯定，就要坚持不懈）</p>
<p>总之，AI+前端让未来充满了希望和可能！</p>
<p>OK，吾日三省吾身，欲知细节，请看下文~</p>
<h2 id="一、业务逻辑"><a href="#一、业务逻辑" class="headerlink" title="一、业务逻辑:"></a>一、业务逻辑:</h2><p>718+X 模式打通线上线下场景 + 助力中小商家+  全球最佳B2B服务</p>
<p><img src="https://img-blog.csdnimg.cn/20200419132321364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200419132333400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p> 七大入口为小程序引流：</p>
<p>扫一扫、搜索、朋友tab主入口、支付成功页、小程序收藏、生活号、卡包</p>
<p>一个闭环构造商业生态：</p>
<p>构成服务、拉新、留存、促活的完整闭环。</p>
<p>八大API接口激活冷启动：</p>
<p>芝麻信用、资金管理、金融服务、高德定位、导航、路线规划、菜鸟和1688的配送、溯源、供应链。</p>
<p>X场景提升用户体验：</p>
<p>助力小程序一次开发，在阿里app中多端透出、多端运行。</p>
<p>企业核心：建立一套交易和信用机制    </p>
<p>小程序特点：高可用、性能优化、多端输出</p>
<p>阿里商业要素：信任+口碑+体验</p>
<p><img src="https://img-blog.csdnimg.cn/20200419132351900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>二、技术架构：</p>
<p>一云多端、借助AI、AR、VR、5G构建丰富场景</p>
<p>一云多端<br><img src="https://img-blog.csdnimg.cn/20200419132406969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>系统架构<br><img src="https://img-blog.csdnimg.cn/20200419132424100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>开发者：编程模型简洁、官方文档详细、学习门槛低、快速开发。</p>
<p>渲染引擎：</p>
<p>JavaScript+Webview 的方式</p>
<p>JavaScript+Native 的方式</p>
<p>研发支撑、运维支撑服务：提升开发者效率、上线管理等等。</p>
<p>运行架构<br><img src="https://img-blog.csdnimg.cn/20200419132442297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>浏览器内核<br><img src="https://img-blog.csdnimg.cn/20200419132449168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>离线缓存优化流程图<br><img src="https://img-blog.csdnimg.cn/20200419132459154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>虚拟DOM优化流程图<br><img src="https://img-blog.csdnimg.cn/20200419132513975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>技术架构部分的图片来自支付宝小程序首席架构师白招拒老师的分享</p>
<p>在次表示感谢，我会在后续日记中仔细梳理细节、输出自己的独立思考</p>
<p>今天先揭开小程序的面纱，后面再庖丁解牛、条分缕析</p>
<p>放上我的前端笔记：我取名叫四库全书、葵花宝典</p>
<p>涵盖了前端的汪洋知识星海，纯手写画图够真诚<br><img src="https://img-blog.csdnimg.cn/20200419132529800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>前端小程序怎么做？：</p>
<blockquote>
<p>现阶段我的理解：先记录五点，随着不断学习补充提升，请大家多多指教</p>
<p>1、业务流程场景化、优化渲染效果、打造极致体验（AR   VR   WebGL） </p>
<p>2、针对需求做好性能优化(技术框架、打包工具、CDN加速、5G、云端计算）</p>
<p>3、每一点都很不容易，扩大视野的同时要关注细节。</p>
<p>4、前端人要心有猛虎、细嗅蔷薇。</p>
<p>5、水能载舟、亦能覆舟。企业是舟、用户是水，打造企业品牌、追求极致体验</p>
<p>是前端人的目标和初心！</p>
</blockquote>
<p>三、学习成果   AI姿态估计（我的毕业设计方案）</p>
<p>研究生团队目前成果：<br><img src="https://img-blog.csdnimg.cn/20200419132557989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>（我们实验室的团队~第一排右2是小霞）</p>
<pre><code>华科女子军最多的团队</code></pre><p><img src="https://img-blog.csdnimg.cn/20200419132607972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>多人上肢关键点识别：<br><img src="https://img-blog.csdnimg.cn/20200419132616214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200419132628629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/2020041913264017.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们还能做什么？</p>
<p>人脸检测、手势识别、手势交互、目标追踪</p>
<p>四、前端行业未来思考 ：AI智能、图形学、云计算、蓬勃生态<br><img src="https://img-blog.csdnimg.cn/20200419132656608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>前端发展行情？</p>
<p>Webpack推陈出新Module Federation</p>
<p>Severless函数应用架构升级</p>
<p>基于FAAS实现NPM CDN同步</p>
<p>电商直播+AR技能应用升级</p>
<p>支付宝新春活动3D特效</p>
</blockquote>
<p>引领时代潮流、打造极致体验、开源助力分享、智能重构升级！</p>
<p>理科生眼中的前端情怀：</p>
<blockquote>
<p>舍我其谁、无惧挑战是每一个前端人的Map</p>
<p>心有猛虎、细嗅蔷薇是每一个前端人的Key</p>
<p>拥抱变化、精雕细琢是每一个前端人的Value</p>
<p>前端是一汪浩瀚星海，一片神奇星空！</p>
<p>一切皆有可能万物之上、希望至美 !</p>
</blockquote>
<p>我眼中的阿里内涵：</p>
<p>左耳旁是太阳：原子碰撞、光芒万丈、阿里蒸蒸日上！（阿）</p>
<p>右部首是可能：创造时机、人才济济、阿里充满希冀 !（阿）</p>
<p>一横一竖、刚正坚挺、阿里用信任建设芊芊江山 !（里）</p>
<p>一田一土、返璞归真、阿里用赤诚打动亿万客户!（里）</p>
<p>为了平仄相生、韵脚别致</p>
<p>本研究僧深度优先、广度优先搜了N遍残留的文学细胞</p>
<p>亲爱的阿里</p>
<p>我愿赴汤蹈火、在所不辞</p>
<p>永葆热情、虚心求教</p>
<p>遇见前端，我想遇见更好的自己 !</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E4%B8%AA%E4%BA%BA%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/" rel="tag">个人职业规划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E6%9C%AA%E6%9D%A5%E5%8D%81%E5%B9%B4/" rel="tag">未来十年</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-阿里面试总结" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/04/17/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"
    >阿里面试复盘总结！</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/04/17/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2020-04-16T16:00:00.000Z" itemprop="datePublished">2020-04-17</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/">经验总结</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="一、动画方案"><a href="#一、动画方案" class="headerlink" title="一、动画方案"></a>一、动画方案</h2><p>如何设置一个节日动画，推陈出新，提升用户体验？<strong>（技术选型）</strong></p>
<p>1.requestAnimationFrame<br>本质：传入的回调函数执行异步任务、属于宏任务队列、由系统刷新率决定回调函数的时间间隔。</p>
<p><strong>优点：</strong></p>
<p>系统决定回调函数执行时机，动画更流畅，不掉帧。</p>
<p>窗口没激活时，动画将停止，节省计算资源。</p>
<p>存在兼容性问题，自己可以封装。</p>
<p>按帧对网页动画进行重绘，可以并发渲染。</p>
<p><strong>动画方案：</strong></p>
<p>1.大图动画性能消耗大，使用translate3D实现GPU加速。</p>
<p>2.动画结束、暂停时，切换回2D，取消加速。</p>
<p>3.按需加载，必要时卸载。</p>
<p>4.简化函数计算，减少回流、重绘。</p>
<p>5.采用Web  Workers 开启多线程，提供更好的动画效果。</p>
<p><strong>用户体验优化：</strong></p>
<p>1.首屏优先加载，所以图片loaded以后，再启动主动画资源加载。</p>
<p>2.图片优化：雪碧图、压缩、Base64。</p>
<p>3.存储DOM变量，减少DOM tree的查找。</p>
<p>4.限频。</p>
<p><strong>场景应用：</strong></p>
<p>1.Three.js+requestAnimationFrame实现3D动态效果。</p>
<p>2.WebGL+Webpack 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var globalID;</span><br><span class="line"><span class="function">function <span class="title">animate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Do whatever</span></span><br><span class="line">  globalID=requestAnimationFrame(animate);</span><br><span class="line">  <span class="comment">// Do something animate，返回一个ID</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//when ot start</span></span><br><span class="line">  globalID=requestAnimationFrame(animate);</span><br><span class="line"><span class="comment">//when to stop</span></span><br><span class="line">  cancelAnimationFrame(globalID);<span class="comment">//取消回调函数</span></span><br></pre></td></tr></table></figure>

<p>2.setTimeout</p>
<p>本质：异步任务、宏任务队列、有最小执行时间。</p>
<p><strong>缺点：</strong></p>
<p>1.H5标准规定：setTimeout()的第二个参数的最小值（）最短间隔不得低于4毫秒，当我们把延迟时间设置为0，实际上会4毫秒后才把事件推入任务队列。</p>
<p>2.时间不精准，误差与代码执行时间有关。</p>
<p>3.队列中所有的代码都要等到JS进程空闲后才能执行，不论它们是如何添加到队列的。</p>
<p>3.setInterval</p>
<p>本质：以指定周期调用函数，隔一段时间推入一个事件。异步循环任务。</p>
<p><strong>缺点：</strong></p>
<p>事件执行时间不一定准确，有可能当前事件还没有执行完毕，下一个事件来临。</p>
<p>某些间隔被跳过。</p>
<p>多个定时器的代码执行之间的间隔可能比预期小。</p>
<p><strong>解决方案：</strong>使用setTimeout构造轮询可以保证每次轮询的间隔。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function  fn()&#123;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"我被调用了"</span>);</span><br><span class="line">setTimeout(fn,<span class="number">100</span>);</span><br><span class="line">&#125;,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>这个模式链式调用了setTimeout()，每次函数执行的时候都会创建一个新的定时器。第二个setTimeout()调用当前执行的函数，并为其设置另外一个定时器。</p>
<p>这样做的好处是，在前一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。而且，它可以保证在下一次定时器代码执行前，至少要等待指定的间隔，避免了连续的运行。</p>
<p><strong>我的延申思考：</strong></p>
<p>requestIdleCallback()</p>
<p>1、MDN解释：该方法在浏览器的空闲阶段内调用函数排队。使开发者在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，比如动画和输入响应。</p>
<p>2、利用这个特性做性能优化：在每帧的空闲时间进行数据发送操作，或者低优先级的工作，不会影响动画的性能。</p>
<p>3、想到的应用：React  Fiber 架构思想：切割长任务，利用空闲时间执行，避免主线程长时间阻塞。</p>
<p>4、Fiber核心：树的深度遍历变成链表遍历+时间分片+任务调度。</p>
<p>其他实现方案：</p>
<p>GSAP:</p>
<p>优点：</p>
<p>1、运行速度快，多个动画可以同时执行。</p>
<p>2、轻量、模块化、按需使用、无需依赖。</p>
<p>3、零插件依赖。</p>
<p>4、灵活控制，代码量少，可以设置精确时间控制。</p>
<p>5、任何对象都可以实现动画。</p>
<p>6、实现重复：repeat设为-1就OK。</p>
<h2 id="二、Promise的理解"><a href="#二、Promise的理解" class="headerlink" title="二、Promise的理解"></a>二、Promise的理解</h2><p><strong>优点：</strong></p>
<p>1、对象状态不受外界影响。状态一旦改变，就不会再变。</p>
<p>2、解决了回调地狱。</p>
<p>3、提供统一接口，方便异步操作。</p>
<p><strong>缺点：</strong></p>
<p>1、无法中途取消。</p>
<p>2、处于pending无法知道进展到了哪一个阶段。（刚开始还是要完成）</p>
<p><strong>流程：观察者模式</strong></p>
<p>Promise的构造方法接收一个executor()，在new Promise()时就立刻执行这个executor回调</p>
<p>executor()内部的异步任务被放入宏/微任务队列，等待执行</p>
<p>then()被执行，收集成功/失败回调，放入成功/失败队列</p>
<p>executor()的异步任务被执行，触发resolve/reject，从成功/失败队列中取出回调依次执行</p>
<p>细节问题：</p>
<p>promise的then()放入了微任务队列。</p>
<p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获。</p>
<p>如果没有使用 catch 方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。</p>
<p>Node 有一个 unhandledRejection 事件，专门监听未捕获的 reject 错误。</p>
<p>Catch 方法返回的还是一个 Promise 对象，因此后面还可以接着调用 then 方法。</p>
<blockquote>
<p>then 方法</p>
</blockquote>
<ul>
<li><p>1、可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 resolved 时调用，第二个回调函数是<br>Promise 对象的状态变为 rejected 时调用。</p>
<p>2、第二个函数是可选的，不一定要提供。这两个函数都接受 Promise 对象传出的值作为参数。</p>
<p>3、采用链式的 then ，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个 Promise<br>对象（即有异步操作），这时后一个回调函数，就会等待该 Promise 对象的状态发生变化，才会被调用。</p>
<p>（异步变同步的思路）</p>
<p>4、then(）回调不是函数时要忽略，否则会导致链式调用中断。</p>
<p>5、一个Promise依赖于另外一个Promise，异步变同步。简化3的说法</p>
</li>
</ul>
<blockquote>
<p>异步加载图片：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">loadImageAsync</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> Promise(function(resolve, reject) &#123; </span><br><span class="line"> var image = <span class="keyword">new</span> Image();</span><br><span class="line">  image.onload = function() &#123;</span><br><span class="line">   resolve(image); </span><br><span class="line">   &#125;;</span><br><span class="line">   image.onerror = function() &#123; </span><br><span class="line">   reject(new Error('Could not load image at ' + url)); </span><br><span class="line">   &#125;;</span><br><span class="line">   image.src = url; </span><br><span class="line">   &#125;); </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>All方法</p>
</blockquote>
<p>1、接受的参数是数组（里面有多个Promise实例）或者具有iterable接口的对象，但必须使返回的成员是promise的实例。</p>
<p>2、数组中每一项都执行成功才会成功，有一个失败就失败。</p>
<p>3、可以用到前后端加载数据、解决乱序渲染的问题。</p>
<p>（数组下标迭代保证了顺序）</p>
<p>4、异步处理的好帮手，比如ajax请求多个数据，在此之前显示loading图标，使加载全部完成再显示页面，区分懒加载和预加载，看具体场景需求。</p>
<p>5、即使响应时间不同，也可以保证接受到的数据与原始数据顺序一致。</p>
<p>6、一个操作需要所有的Promise一起运行才能解决问题。</p>
<p>Race方法</p>
<p>1、不管结果成功还是失败，数组中哪一个结果最先执行完成就返回哪个结果。</p>
<p>2、具体场景还没有想到，业务里有这种需求吗？后续脑补。</p>
<p>我的延申思考：</p>
<p>1、Promise解决了异步编程的一些问题，但是链式调用不能取消执行，无法获取执行进度怎么办？</p>
<p>2、实际开发，我们如何做好状态管理，兼顾好同步和异步的切换？</p>
<p>3、上述解答可以从其他的框架中挖掘答案。</p>
<p>方案对比和思考：</p>
<p>Generator:</p>
<p>1、generator函数返回一个遍历器对象，是函数的内部指针。</p>
<p>2、每次调用遍历器对象的next方法，就会返回有value和done两个属性的对象。</p>
<p>3、value属性表示当前内部状态的值，等于yield语句后面的值。</p>
<p>4、done属性是布尔值，表示是否遍历结束。</p>
<p>优点：控制函数的暂停和继续，向外输出结果，下次继续执行可以传入参数。</p>
<p>缺点：不能自动执行，遇到yield暂停，要手动控制。</p>
<p>控制Generator函数流程的关键：</p>
<p>是接受传入的值，并且可以把执行的权力还给程序。</p>
<blockquote>
<p>yield*</p>
</blockquote>
<p>yield委托，让出迭代控制。</p>
<p>co:</p>
<p>返回一个Promise对象，让generator自动执行，类比执行器。</p>
<p>thunk函数</p>
<p>自动执行Generator函数。</p>
<blockquote>
<p>for  of :</p>
</blockquote>
<p>遍历Generator函数运行生成的Iterator对象。</p>
<p>不用调用next 方法，可以通过break return 暂停遍历。</p>
<p>实战应用：</p>
<p>1、购物车每订购一件商品就调用next()实现库存的减一，记录库存状态。</p>
<p>2、三次抽奖活动，点击按钮调用next()实现次数减一，转动转盘的时候，让按钮禁止点击，转盘结束之后再调用next()进行下一次的抽奖，然后打开按钮的开关，记录按钮状态。</p>
<p>3、支付场景：付款之后通过定时器询问接口，是否处理完成订单流程。</p>
<p>4、总结一下就是在中断某一个操作时，要保留当时的状态，下次执行时回到当初的状态，比如我们做饭中途取了一个快递，然后保持菜的状态不改变，取完快递回来，接着做饭。</p>
<p>由Generator引发的协程原理思考：</p>
<blockquote>
<p>协程：</p>
</blockquote>
<p>1、协程有自己的上下文和栈，当任务切换时，会将当前的上下文和栈保存到其他地方，再被切回来的时候，恢复之前保存的上下文和栈。</p>
<p>2、我的理解就是：保留上一次的状态，重新进入时恢复到上次离开的状态。</p>
<p>3、按需生成返回结果，而不是一次性的return所有的结果。</p>
<blockquote>
<p>场景应用：</p>
</blockquote>
<p>1、用户登录状态，切换某个页面之后，再次回来，保留上一次的状态。</p>
<p>2、按需读取大文件，一段段的读取，不用一次遍历整个列表。</p>
<p>3、类比流的思想，这里还要多学习一下stream的知识。</p>
<p>4、直接读取大文件容易造成内存溢出，Generator不会造成内存溢出。</p>
<p>5、使用中还可以向yield中传入值。</p>
<p>6、协程开销远小于线程，yield让协程暂停，和线程的阻塞有本质的区别。</p>
<p>7、协程的暂停由程序控制、线程的阻塞状态由操作系统的内核来进行切换。</p>
<blockquote>
<p>由Generator引发的Koa中的原理思考：</p>
</blockquote>
<p>1、首先执行一次 dispatch(0) 也就是默认返回第一个 app.use 传入的函数， 使用 Promise 函数封装返回。</p>
<p>2、其中第一个参数是 ctx，第二个参数就是 next 参数，next 每次执行之后都会等于下一个中间件函数，如果下一个中间件函数不为真则返回一个成功的 Promise。</p>
<p>3、Koa V1  基于Generator   Koa V2 利用async函数。</p>
<p>4、洋葱模型的执行顺序类似捕获和冒泡的过程。</p>
<p>5、由堆栈这种先进后出的模型可以类比Koa框架自外到内的Request和由里到外的Response的数据流。</p>
<p>6、context的保存和传递、中间件的管理、next的实现要深入理解。</p>
<p>7、源码中调用App.use（）把一个中间件push到一个列表中，每次执行use函数，就在函数数组中添加了一个函数，然后通过compose来遍历整个中间件，最终将context和dispatch(i+1)传给了middleware。</p>
<p>8、一个中间件不能调用两次next()，调用时类比async函数，此时并不是表示中间件函数执行完毕了，调用了next()之后主程序还可以执行其他代码，类似于让next函数异步处理。（我对源码是这样理解的，有错误请大家指教）</p>
<p>9、compose将多个中间件函数合并成一个大的中间件函数，然后依次调用单独的每一层。</p>
<p>10、由compose处理中间件想到了redux，redux是利用数组的reducer对数组参数进行迭代。</p>
<p>11、Koa的思想是不是继承了Emitter？为了在任意时间处理抛出的异常，订阅了error事件，Koa有一个app-onerror事件输出错误的日志。</p>
<p>12、error处理有两个层面：APP层面负责log，一次响应过程中的error处理负责排查每次响应的结果。</p>
<h2 id="三、秒杀活动设计的思考方案"><a href="#三、秒杀活动设计的思考方案" class="headerlink" title="三、秒杀活动设计的思考方案"></a>三、秒杀活动设计的思考方案</h2><blockquote>
<p>背景：疫情枪口罩</p>
</blockquote>
<p>前端设计：防抖、节流减少请求次数、降低服务器压力</p>
<p>后端设计：Node玩法高级，开启Master+Worker模式</p>
<p>优点：</p>
<p>Node本身的特性是单线程、事件驱动、异步非阻塞。</p>
<p>没有多线程的切换上下文、加锁、销毁等复杂操作，之前博客也接触学习过。</p>
<p>线程安全、数据读写一致性好。</p>
<p>缺点：</p>
<p>单线程无法利用多核CPU</p>
<p>当时面试想到的方案：</p>
<p>1、<strong>首先进程通信在本科学过有信号量、共享内存、消息队列、管道、套接字等，不过Node是基于管道实现的。</strong></p>
<p>2、Node可以跨平台，libuv会针对不同的平台，采用不同的方式实现进程的通信。</p>
<p>3、开启child_process模块，利用child_process模块直接创建子进程。</p>
<p>暂时取名叫单线程+多进程模式吧</p>
<p>（这和H5提出的Web  Worker有异曲同工之妙，相当于另辟蹊径，解决了JS主线程和UI渲染共用一个线程所引发的相互阻塞问题）。</p>
<p>4、fork线程的开销还是比较大的，是为了利用CPU的资源。</p>
<p>5、口罩请求打到主进程上面，主进程进行代理，转发到不同端口的子进程上。</p>
<p>下来思考复盘之后可能出现的问题：</p>
<p>代理请求转发不友好</p>
<p>1、操作系统的文件描述符是有限的，维护需要成本。</p>
<p>2、比如：当客户端连接到主进程的时候，用完了一个操作符，当主进程连接到子进程时，又用掉了一个，从数量上看，代理方案不节省资源。</p>
<p>解决办法：（办法是查阅Node.js  9.2.3得出的）</p>
<blockquote>
<p>句柄传递-去除代理</p>
</blockquote>
<p>句柄传递可以代替代理的方案，原理是主进程收到客户端的请求之后，将这个请求直接发送到工作进程，而不是重新与子进程之间建立新的连接来转发数据。（又好像发布订阅模式）<br><img src="https://img-blog.csdnimg.cn/20200419125338865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200419125357754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>问题来了</p>
<p>为何通过发送句柄之后，多个进程可以监听到相同的端口而不引起异常？</p>
<p>官方解答：</p>
<p>1、因为独立启动的进程中，TCP服务器端socket套接字的文件描述符并不相同，导致监听到相同的端口时会抛出异常。</p>
<p>2、Node底层对每个端口监听设置了SO_REUSEADDR选项，不同进程可以对相同的网卡和端口进行监听，服务器套接字可以被不同的进程复用。</p>
<p>3、对于send(）发送的句柄还原出来的服务而言，文件描述符是相同的，所以监听相同的端口不会引起异常。</p>
<p>4、网络请求向服务器发送时，只有一个幸运的进程可以抢到连接，本质上一个请求的进程对应服务是抢占式的。</p>
<p>好了，这个问题终于解决啦</p>
<p>还有可能出现的问题：（简单给出思路和方案，日后再深入分析~）</p>
<p>1、数据共享？</p>
<p>答：Node本身不支持数据共享，所以我们要引入第三方Redis缓存，写一个定时脚本，在秒杀还没有开始之前，把口罩的库存数量写到Redis，从Redis拿数据处理。</p>
<p>2、多人抢一只口罩，库存来不及更新？</p>
<p>答：使用check-and-set实现乐观锁操作。（这个下去再仔细研究一下）</p>
<h2 id="四、项目梳理：每个项目选了一个点来切入"><a href="#四、项目梳理：每个项目选了一个点来切入" class="headerlink" title="四、项目梳理：每个项目选了一个点来切入"></a>四、项目梳理：每个项目选了一个点来切入</h2><h2 id="项目一"><a href="#项目一" class="headerlink" title="项目一"></a>项目一</h2><p>问题：给学校水果商店做的小程序，计算金额的时候，浮点数的精度问题。</p>
<p>举例子： 源自浮点数误差</p>
<p>0.1+0.2   //0.30000000000000004<br>1-0.9     //0.09999999999999998<br>9007199254740993-9007199254740992  //0<br>Math.pow(2,1023) //8.98846567431158e+307<br>//但是<br>Math.pow(2,1024)  //Infinity<br>0.1 &gt;&gt; 0.0001 1001 1001 1001…（1001无限循环）<br>0.2 &gt;&gt; 0.0011 0011 0011 0011…（0011无限循环）<br>原因分析：</p>
<p>JavaScript 里的数字是采用 IEEE 754 标准的 64 位双精度浮点数。</p>
<p>这个规范定义了浮点数的格式，对于64位的浮点数在内存中的表示：</p>
<p>最高的1位是符号位，接着的11位是指数，剩下的52位为有效数字。</p>
<p>第0位：符号位， s 表示 ，0表示正数，1表示负数；</p>
<p>第1位到第11位：储存指数部分， e 表示 ；</p>
<p>第12位到第63位：储存小数部分（即有效数字），f 表示；</p>
<p>根本原因：计算机底层只能二进制存储，所有的语言都存在这个问题。</p>
<blockquote>
<p>解决办法：</p>
</blockquote>
<p>1、引入两个库</p>
<p>Math.js<br> 适用于JavaScript 和 Node.js </p>
<p>具有灵活的表达式解析器，支持符号计算。</p>
<p>配有大量内置函数和常量</p>
<p>支持大数字(超出安全数的数字)，复数，分数，单位和矩阵的运算。</p>
<p>decimal.js<br>可以方便 JavaScript 进行十进制类型的任意精度数值计算。</p>
<p>2调用误差检查函数number.epsilon（）  兼容方法：math.abs(2，-52)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">withinErrorMargin</span> <span class="params">(left, right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.<span class="built_in">abs</span>(left - right) &lt; Number.EPSILON</span><br><span class="line">&#125;</span><br><span class="line">withinErrorMargin(<span class="number">0.1</span>+<span class="number">0.2</span>, <span class="number">0.3</span>)</span><br></pre></td></tr></table></figure>

<p>3、自己封装</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 核心方法，实现加减乘除运算，确保不丢失精度</span></span><br><span class="line"><span class="comment">     * 思路：把小数放大为整数（乘），进行算术运算，再缩小为小数（除）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param a &#123;number&#125; 运算数1</span></span><br><span class="line"><span class="comment">     * @param b &#123;number&#125; 运算数2</span></span><br><span class="line"><span class="comment">     * @param op &#123;string&#125; 运算类型，有加减乘除（add/subtract/multiply/divide）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">function <span class="title">operation</span><span class="params">(a, b, op)</span> </span>&#123;</span><br><span class="line">        var o1 = toInteger(a);</span><br><span class="line">        var o2 = toInteger(b);</span><br><span class="line">        var n1 = o1.num;</span><br><span class="line">        var n2 = o2.num;</span><br><span class="line">        var t1 = o1.times;</span><br><span class="line">        var t2 = o2.times;</span><br><span class="line">        var max = t1 &gt; t2 ? t1 : t2;</span><br><span class="line">        var result = null;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            case 'add':</span><br><span class="line">                <span class="keyword">if</span> (t1 === t2) &#123; <span class="comment">// 两个小数位数相同</span></span><br><span class="line">                    result = n1 + n2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t1 &gt; t2) &#123; <span class="comment">// o1 小数位 大于 o2</span></span><br><span class="line">                    result = n1 + n2 * (t1 / t2);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// o1 小数位 小于 o2</span></span><br><span class="line">                    result = n1 * (t2 / t1) + n2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result / max</span><br><span class="line">            case 'subtract':</span><br><span class="line">                <span class="keyword">if</span> (t1 === t2) &#123;</span><br><span class="line">                    result = n1 - n2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t1 &gt; t2) &#123;</span><br><span class="line">                    result = n1 - n2 * (t1 / t2);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = n1 * (t2 / t1) - n2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result / max;</span><br><span class="line">            case 'multiply':</span><br><span class="line">                result = (n1 * n2) / (t1 * t2);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            case 'divide':</span><br><span class="line">                result = (n1 / n2) * (t2 / t1);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加减乘除的四个接口</span></span><br><span class="line">    <span class="function">function <span class="title">add</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">        return operation(a, b, 'add');</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">function <span class="title">subtract</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">        return operation(a, b, 'subtract');</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">function <span class="title">multiply</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">        return operation(a, b, 'multiply');</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">function <span class="title">divide</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">        return operation(a, b, 'divide');</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exports</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        add: add, <span class="comment">// 加</span></span><br><span class="line">        subtract: subtract, <span class="comment">// 减</span></span><br><span class="line">        multiply: multiply, <span class="comment">// 乘</span></span><br><span class="line">        divide: divide <span class="comment">// 除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p>学习反思：</p>
<p>1、下去学习了千位分隔符（用正则可以解决）的解决办法。</p>
<p>2、学习了大数相加的办法：转换成字符串进行操作，按位遍历，执行加减乘除，使用变量来保存进位。</p>
<p>3、了解了底层数据的存储方式。</p>
<p>4、涉及到金额要格外细心铭感。</p>
<h2 id="项目二："><a href="#项目二：" class="headerlink" title="项目二："></a>项目二：</h2><p>学习了VUE的框架原理，通过项目有了一些框架体会和思考。</p>
<p>问题：坑挺多，一般查阅MDN和stackoverflow和社区可以解决bug。</p>
<p>收获：VUE-Router的源码学习。</p>
<p>导航守卫的执行过程。</p>
<p>URL变化逻辑切换不同页面的原理。（出栈入栈）</p>
<blockquote>
<p>原理概括分析：</p>
</blockquote>
<p>1当点击router-link时，最终会执行router.push(this.history.push）入栈。</p>
<p>2通过transitionTo做路劲切换，成功的回调会执行pushHash(roote.fullPath</p>
<p>方法，后面根据路劲变化去做入栈出栈操作，完成pop,place,replace功能。</p>
<p>3在 history 的初始化中，会设置一个监听器，监听历史栈的变化。</p>
<p>4当点击浏览器返回按钮的时候，如果已经有 url 被压入历史栈，则会触发 popstate 事件，然后拿到当前要跳转的 hash，执行 transtionTo 方法做一次路径转换。</p>
<blockquote>
<p>阅读源码笔记：</p>
</blockquote>
<p>1、导航守卫就是发生在路由路径切换时，执行的一系列钩子函数。</p>
<p>2、这些钩子函数执行的逻辑：首先构造一个队列 queue，这个队列实际上是一个数组。</p>
<p>3、然后再定义一个迭代器函数 iterator；最后再执行 runQueue 方法执行这个队列。</p>
<p>4、一个非常经典的异步函数队列化执行的模式，queue 是一个NavigationGuard 类型的数组，源码定义了 step 函数，每次根据 index 从 queue 中取一个 guard，然后执行 fn 函数，并且把 guard 作为参数传入，第二个参数是一个函数，当这个函数执行的时候再递归执行 step 函数，前进到下一个，其实这里的 fn 就是非常经典的 iterator 函数</p>
<p>5、iterator 函数逻辑就是去执行每一个导航守卫 hook，并传入 route、current 和匿名函数，这些参数对应源码中的 to、from、next。</p>
<p>6、当执行了匿名函数，会根据一些条件执行 abort 或 next，只有执行 next 的时候，才会前进到下一个导航守卫钩子函数中，这也就是为什么官方文档会说只有执行 next 方法才 resolve 这个钩子函数。</p>
<p>下面举例一个比较经典的，其他就不上图啦</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 经典的同步执行异步函数</span></span><br><span class="line">  runQueue(<span class="built_in">queue</span>, iterator, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> postEnterCbs = []</span><br><span class="line">    <span class="keyword">const</span> isValid = () =&gt; <span class="keyword">this</span>.current === route</span><br><span class="line">    <span class="comment">// 当所有异步组件加载完成后，会执行这里的回调，也就是 runQueue 中的 cb()</span></span><br><span class="line">    <span class="comment">// 接下来执行 需要渲染组件的导航守卫钩子</span></span><br><span class="line">    <span class="keyword">const</span> enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">queue</span> = enterGuards.concat(<span class="keyword">this</span>.router.resolveHooks)</span><br><span class="line">    runQueue(<span class="built_in">queue</span>, iterator, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 跳转完成</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.pending !== route) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abort</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.pending = null</span><br><span class="line">      onComplete(route)</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.router.app) &#123;</span><br><span class="line">        <span class="keyword">this</span>.router.app.$nextTick(() =&gt; &#123;</span><br><span class="line">          postEnterCbs.forEach(cb =&gt; &#123;</span><br><span class="line">            cb()</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">export</span> function <span class="title">runQueue</span> <span class="params">(<span class="built_in">queue</span>: Array&lt;?NavigationGuard&gt;, fn: Function, cb: Function)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> step = index =&gt; &#123;</span><br><span class="line">  <span class="comment">// 队列中的函数都执行完毕，就执行回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="built_in">queue</span>.length) &#123;</span><br><span class="line">      cb()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">queue</span>[index]) &#123;</span><br><span class="line">      <span class="comment">// 执行迭代器，用户在钩子函数中执行 next() 回调</span></span><br><span class="line">      <span class="comment">// 回调中判断传参，没有问题就执行 next()，也就是 fn 函数中的第二个参数</span></span><br><span class="line">        fn(<span class="built_in">queue</span>[index], () =&gt; &#123;</span><br><span class="line">          step(index + <span class="number">1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        step(index + <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取出队列中第一个钩子函数</span></span><br></pre></td></tr></table></figure>

<h2 id="项目三：还在完善中"><a href="#项目三：还在完善中" class="headerlink" title="项目三：还在完善中"></a>项目三：还在完善中</h2><blockquote>
<p>优化一：封装函数</p>
</blockquote>
<p>/*<br>封装的能发ajax请求的函数, 向外暴露的本质是axios</p>
<ol>
<li>解决post请求携带参数的问题: 默认是json, 需要转换成urlencode格式</li>
<li>让请求成功的结果不再是response, 而是response.data的值</li>
<li>统一处理所有请求的异常错误</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">*/</span><br><span class="line">import axios from 'axios'</span><br><span class="line">import qs from 'qs'</span><br><span class="line">import &#123;message&#125; from 'antd'</span><br><span class="line"><span class="comment">// 添加请求拦截器: 让post请求的请求体格式为urlencoded格式 a=1&amp;b2</span></span><br><span class="line"><span class="comment">// 在真正发请求前执行</span></span><br><span class="line">axios.interceptors.request.use(function (config) &#123;</span><br><span class="line">  <span class="comment">// 得到请求方式和请求体数据</span></span><br><span class="line">  <span class="keyword">const</span> &#123;method, data&#125; = config</span><br><span class="line">  <span class="comment">// 处理post请求, 将data对象转换成query参数格式字符串</span></span><br><span class="line">  if (method.toLowerCase() === 'post' &amp;&amp; typeof data==='object') &#123;</span><br><span class="line">    config.data = qs.stringify(data) <span class="comment">// username=admin&amp;password=admin</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">  <span class="comment">// 功能1: 让请求成功的结果不再是response, 而是response.data的值</span></span><br><span class="line">  <span class="comment">// 功能2: 统一处理所有请求的异常错误</span></span><br><span class="line"><span class="comment">// 在请求返回之后且在我们指定的请求响应回调函数之前</span></span><br><span class="line">axios.interceptors.response.use(function (response) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response.data <span class="comment">// 返回的结果就会交给我们指定的请求响应的回调</span></span><br><span class="line">  <span class="comment">// return response // 返回的结果就会交给我们指定的请求响应的回调</span></span><br><span class="line">&#125;, function (error) &#123; <span class="comment">// 统一处理所有请求的异常错误</span></span><br><span class="line">  message.error('请求出错 ' + error.message)</span><br><span class="line">  <span class="comment">// return Promise.reject(error);</span></span><br><span class="line">  <span class="comment">// 返回一个pending状态的promise, 中断promise链</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(() =&gt; &#123;&#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> axios</span><br></pre></td></tr></table></figure>

<blockquote>
<p>优化二：减少Render次数</p>
</blockquote>
<p>Component与PureComponent</p>
<p> 原因分析：Component存在的问题?</p>
<p> 父组件重新render(), 子组件也会重新执行render(), 即使没有任何变化</p>
<p> 解决Component存在的问题</p>
<p> 原因: 组件的shouldComponentUpdate()默认返回true, 即使数据没有变化render()都会重新执行</p>
<p> 办法1: 重写shouldComponentUpdate(), 判断如果数据有变化返回true, 否则返回false</p>
<p> 办法2: 使用PureComponent代替Component</p>
<p> 办法3：使用React.memo()高阶函数</p>
<p>PureComponent的基本原理：</p>
<p>（1）重写实现shouldComponentUpdate()</p>
<p>（2）对组件的新/旧state和props中的数据进行浅比较, 如果都没有变化, 返回false, 否则返回true</p>
<p>（3）一旦ShouldComponentUpdate()返回false，就不再执行用于更新的render()</p>
<blockquote>
<p>优化三：缓存HTTP请求和数据</p>
</blockquote>
<p>原因：</p>
<p>当用户再次请求相同的搜索内容时，可以不必发送网络请求，从缓存中取。</p>
<p>思路：</p>
<p>创建一个资源对象来缓存结果，当每次向网络发出新请求时，检查缓存中有没有上次的相同查询结果，存在就直接返回，不存在再发送网络请求，并将最新的请求数据保存到缓存中。</p>
<blockquote>
<p>优化四：用好Key</p>
</blockquote>
<p>虚拟DOM的key的地位:</p>
<p>1、其实key就是一个是虚拟DOM对象的标识, Key把页面上的DOM和虚拟DOM做了一层关联映射。</p>
<p>2、虚拟DOM是真实DOM在内存中的一个表示。在更新显示时key是一个唯一的标签，就像我们现实生活中的身份证，在生命周期中如果变化了，React会销毁原来的真实DOM，创建新的真实DOM。</p>
<p>3、当列表数组中的数据发生变化生成新的虚拟DOM后, React会逐层做Diff算法，分为TreeDiff  Component Diff  Element Diff </p>
<p>（1）key没有变</p>
<pre><code>item数据没变, 直接使用原来的真实DOM。

item数据变了, 对原来的真实DOM进行数据更新。</code></pre><p>（2）key变了：</p>
<p>销毁原来的真实DOM, 根据item数据创建新的真实DOM显示。</p>
<p>(即使item数据没有变)</p>
<p>4、key为index存在的问题</p>
<p>（1）添加/删除/排序 =&gt; 产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低</p>
<p>（2）如果item界面还有输入框 =&gt; 产生错误的真实DOM更新 ==&gt; 界面有问题</p>
<p>5、使用总结：问题的关键就是一定要用唯一属性作为Key</p>
<p>（1）如果不存在添加/删除/排序/过滤操作, 用index作为keys是可以的。</p>
<p>（2）列表不可以变动时，可以用index作为key。</p>
<p>（3）列表添加删除时，可能导致某一部分的商品下标（key）改变被销毁，导致数据错乱或者不必要的重复渲染。</p>
<p>（4）用唯一属性作为key，比如商品的出厂号码等，在生命周期中唯一不变</p>
<blockquote>
<p>优化小细节总结五：</p>
</blockquote>
<p>1、JS事件中节流。</p>
<p>比如即时搜索功能，节流到输入字段结束之后再去请求数据。</p>
<p>2、避免在map 方法中使用index作为组件的Key。</p>
<p>3、采用记忆化的React组件：存储复杂函数的计算结果，比如优化三中的缓存组件。</p>
<p>4、使用Web  Workers扩展任务。</p>
<p>5、根据需要采用服务端渲染。</p>
<p>6、在服务器启动Gzip压缩，在Node端安装Compression并调用。</p>
<blockquote>
<p>目前计划和挑战：</p>
</blockquote>
<p>1、学习移动消息推送中一键免密登录、第三方登录的原理，尝试实现这个功能。</p>
<p>2、深化前端模块化、工程化的理念和实践，关注智能化的新方向。</p>
<p>3、学习Flutter技术，做好研究生的深度学习毕设。</p>
<p>4、关注前端领域、做好T型学习模式，视野要广，对于某方向的技术要好好沉淀，多思考，多锻炼，坚持不懈，做到精益求精。</p>
<p>5、保持热情和动力、科技改变美丽人生、打造极致体验</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E4%B8%AA%E4%BA%BA%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/" rel="tag">个人职业规划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E6%80%9D%E8%80%83%E5%A4%8D%E7%9B%98/" rel="tag">思考复盘</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-认真剖析Promise" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/04/14/%E8%AE%A4%E7%9C%9F%E5%89%96%E6%9E%90Promise/"
    >认真剖析Promise</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/04/14/%E8%AE%A4%E7%9C%9F%E5%89%96%E6%9E%90Promise/" class="article-date">
  <time datetime="2020-04-13T17:00:54.646Z" itemprop="datePublished">2020-04-14</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>今天面试官小姐姐问了一个很好的问题，Promise怎么异步转同步？<br>当时有点紧张想复杂了，下来好好梳理一下，小姐姐人很好，激发了小霞打下坚实基础，投身大前端的激情和动力，hhh，话不多说，<strong>追根溯源，脚踏实地，勤恳思辨就是学习最好的方法</strong>，路漫漫，加油干！</p>
<h2 id="一、同步异步场景需求剖析："><a href="#一、同步异步场景需求剖析：" class="headerlink" title="一、同步异步场景需求剖析："></a>一、同步异步场景需求剖析：</h2><p>1、RunAsync.add(new Task())//task1<br>    .add(new Task())//task2<br>    .add(new Task())//task3<br>    .start();<br>我们希望task1完成之后task2再启动，task2完成后task3再启动，也即异步串联。<br>2、把异步变成同步。<br>3、页面倒计时，10、9、8、7、6依次输出。<br>首先拆解一下题意，不能曲解了嘿嘿嘿，我当时就是紧张了，想到了Promise.all和Promise.race去解决多个并行任务，设计逻辑，判断返回函数的顺序的场景。其实我们要解决的是异步串联问题，也就是把异步变成同步，注意这里不要曲解字面意思哦。<br>让我娓娓道来！后来我又想了一个方法，除了.then异步串联，好像还可以用自动迭代去next()。目前想到这两种解决方案。<br>首先，什么是同步？什么是异步？</p>
<blockquote>
<p>字面误区：1、js单线程，同步操作任务，并非一起操作之意，而是你执行完了我再去执行；2、js异步操作任务，也并非是指在不同线程里做不同的事情。</p>
</blockquote>
<p><strong>本质理解：</strong>首页js的语言执行环境是单线程的，也就是一次只能完成一个任务，多个任务就必须按照时间先后排队，前面完成后才能完成后一个任务。这个是js的常规模式，也就也是同步操作任务。</p>
<p><strong>弊端：</strong>同步操作任务带来的问题是，只要一个任务执行时间过程，后面的任务都会排队等待，拖延整个程序的执行。<br>如：常见的浏览器假死很可能就是js任务执行时间太长导致。</p>
<p>为了解决同步操作带来的弊端，js语言增加了异步任务的操作模式：<br>1、当前任务可以携带回一个回调函数（当前任务执行时间过长，把需要提前执行的任务放在回掉中）。<br>2、可以利用setTimeout构建异步任务，让主逻辑优先执行，对于耗时间长的任务可以放在setTimeout中异步执行。<br>3、所以异步操作任务主要是改变了程序的正常执行操作顺序。<br>举个栗子吧！<br>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"1"</span>)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"2"</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"3"</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"4"</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"5"</span>)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>执行结果为：</p>
<p>1<br>5<br>2<br>3<br>4</p>
<p>那么大致的运行机制如下：<br>（1）在js主程序（单线程）上的同步任务形成了一个主任务执行栈。<br>（2）主线程之外还存在一个任务队列，这个队列存在一些按时间顺序存放的事件，<strong>如鼠标点击、计时触发等，主线程中每出现一个异步任务，任务队列就会增加一个异步任务的事件。</strong><br>（3）一般执行栈中的同步任务执行完毕，系统就会读取任务队列，看看哪些事件是可以执行的，一旦可以执行将进入执行栈开始执行，后面分析Generator再区别微任务和宏任务。<br>（4）不断重复以上动作。<br>严肃剖析一下：</p>
<p><strong>同步</strong>：百度的名词解释是： 同步指两个或两个以上随时间变化的量在变化过程中保持一定的相对关系。<br> 例如：你去饭店去吃饭。当你叫服务员点餐时，服务员正在别的桌服务，这时你要等待服务员，把别人的事情处理完成以后，才可以到你这服务。不能同时进行，是要有排队顺序的，所以会阻塞进程，简单的说，只有一条主任务工作。<br>总结：就是一个任务完成之后，才能执行下一个任务。我们可以将同步看成是单线的执行，即要么执行成功，要么执行失败，反正就是要返回一个结果，在没有得到这个结果之前什么都不干，就傻傻的等着。任务提交后不向系统交出控制权，持续等待。<br><strong>异步</strong>：执行一个任务的同时，中间去执行其它的事件，最终在回来执行这个任务，不连续，node最大的特点就是支持异步，例如：node虽然是单线程，但是CPU利用率非常高，它就是一个日夜不息的接单员，一直在流水线工作。其实这样好处也很多，不用处理开辟线程、销毁线程的任务，而且不用设计资源抢占、读写锁的问题，对I/O密集友好。<br>总结：异步则是当你的任务提交了之后，不用管任务的结果是什么，可以继续执行别的任务，任务提交后将控制权交予系统，系统可以进行其他任务的执行。<br>两者比较<br>1、同步的执行效率会比较低，耗费时间，但有利于我们对流程进行控制，避免很多不可掌控的意外情况。<br>2、异步的执行效率高，节省时间，但是会占用更多的资源，也不利于我们对进程进行控制。<br><strong>优缺点及使用场景</strong><br>异步优点<br>1、异步流程可以立即给调用方返回初步的结果。</p>
<p>2、异步流程可以延迟给调用方最终的结果数据，在此期间可以做更多额外的工作，例如结果记录等等。</p>
<p>3、异步流程在执行的过程中，可以释放占用的线程等资源，避免阻塞，等到结果产生再重新获取线程处理。</p>
<p>4、异步流程可以等多次调用的结果出来后，再统一返回一次结果集合，提高响应效率。</p>
<p><strong>异步使用场景：</strong></p>
<p>1、不涉及共享资源，或对共享资源只读，即非互斥操作。</p>
<p>2、没有时序上的严格关系。</p>
<p>3、不需要原子操作，或可以通过其他方式控制原子性。</p>
<p>4、常用于IO操作等耗时操作，因为比较影响客户体验和使用性能。</p>
<p>5、不影响主线程逻辑。</p>
<p><strong>同步优点：</strong></p>
<p>1、同步流程对结果处理通常更为简单，可以就近处理。</p>
<p>2、同步流程对结果的处理始终和前文保持在一个上下文内。同步是一步一步来操作，等待请求返回的数据，再执行下一步，那么一定会有一些情况，只有这一步执行完，拿到数据，通过获取到这一步的数据来执行下一步的操作。</p>
<p>3、同步流程可以很容易捕获、处理异常。</p>
<p>4、同步流程是最天然的控制过程顺序执行的方式。</p>
<h2 id="二、异步串联"><a href="#二、异步串联" class="headerlink" title="二、异步串联"></a>二、异步串联</h2><p>其实面试官小姐姐的答案就是：.then()来异步串联。<br>下面是我的思考和解答：<br>首先是一个简单版的手撸Promise:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">Promise</span><span class="params">(executor)</span></span>&#123; <span class="comment">//executor执行器</span></span><br><span class="line">    let self = <span class="keyword">this</span>;</span><br><span class="line">    self.status = 'pending'; //等待态</span><br><span class="line">    self.value  = undefined; <span class="comment">// 表示当前成功的值</span></span><br><span class="line">    self.reason = undefined; <span class="comment">// 表示是失败的值</span></span><br><span class="line">    <span class="function">function <span class="title">resolve</span><span class="params">(value)</span></span>&#123; <span class="comment">// 成功的方法</span></span><br><span class="line">        if(self.status === 'pending')&#123;</span><br><span class="line">            self.status = 'resolved';</span><br><span class="line">            self.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">function <span class="title">reject</span><span class="params">(reason)</span></span>&#123; <span class="comment">//失败的方法</span></span><br><span class="line">        if(self.status === 'pending')&#123;</span><br><span class="line">            self.status = 'rejected';</span><br><span class="line">            self.reason = reason;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    executor(resolve,reject);</span><br><span class="line">&#125;</span><br><span class="line">Promise.prototype.then = function(onFufiled,onRejected)&#123;</span><br><span class="line">    let self = <span class="keyword">this</span>;</span><br><span class="line">    if(self.status === 'resolved')&#123;</span><br><span class="line">        onFufiled(self.value);</span><br><span class="line">    &#125;</span><br><span class="line">    if(self.status === 'rejected')&#123;</span><br><span class="line">        onRejected(self.reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">module</span>.exports = Promise;</span><br></pre></td></tr></table></figure>
<p>使用方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let Promise = require('./m2.Promise');</span><br><span class="line">let p = <span class="keyword">new</span> Promise((resolve, reject) =&gt;&#123;</span><br><span class="line">          setTimeout(()=&#123;</span><br><span class="line">    resolve('zfpx')</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.then(function(data)&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"data"</span>,data)</span><br><span class="line">&#125;,function(err)&#123;</span><br><span class="line">  console.log('err',err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200413232504760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200413232526253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>观察这个例子，我来分析 一下Promise 的调用流程：</p>
<ul>
<li>Promise的构造方法接收一个executor()，在new Promise()时就立刻执行这个 executor 回调   </li>
<li>executor()内部的异步任务被放入宏/微任务队列，等待执行 then()被执行，收集成功/失败回调，放入成功/失败队列   </li>
<li>executor()的异步任务被执行，触发resolve/reject，从成功/失败队列中取出回调依次执行</li>
</ul>
<p>我理解这是个观察者模式，是一种收集依赖=》触发通知 =》取出依赖执行 的方式。<br>new Promise时（）会立即执行executor，并传入resolve和reject，由于他们是在executor内部被调用，所以要使用箭头函数去固定this指向，否则会找不到成功resolve之后的this.resolveQueue。<br>在 Promise 里，执行顺序是then收集依赖 ，异步触发resolve ， resolve执行依赖。then方法的回调里取到异步操作的返回值，then返回一个新的promise，分别对应状态改变的时候触发的回调，到了时间我们就返回Promise的结果，类似于依赖执行完毕。then方法可以被同一个promise调用多次，要实现这个功能，我们可以用一个队列来存储回调。<br>依此，我们可以勾勒出 Promise 的大致形状：其实就是一个单向变更的状态机，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">Promise</span><span class="params">(executor)</span> </span>&#123; <span class="comment">// executor是一个执行函数</span></span><br><span class="line">    let self = <span class="keyword">this</span>;</span><br><span class="line">    self.status = 'pending';</span><br><span class="line">    self.value = undefined; <span class="comment">// 默认成功的值</span></span><br><span class="line">    self.reason = undefined; <span class="comment">// 默认失败的原因</span></span><br><span class="line">    self.onResolvedCallbacks = []; <span class="comment">// 存放then成功的回调</span></span><br><span class="line">    self.onRejectedCallbacks = []; <span class="comment">// 存放then失败的回调</span></span><br><span class="line">    <span class="function">function <span class="title">resolve</span><span class="params">(value)</span> </span>&#123; <span class="comment">// 成功状态</span></span><br><span class="line">        if (self.status === 'pending') &#123;</span><br><span class="line">            self.status = 'resolved';</span><br><span class="line">            self.value = value;</span><br><span class="line">            self.onResolvedCallbacks.forEach(function (fn) &#123;</span><br><span class="line">                fn();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">function <span class="title">reject</span><span class="params">(reason)</span> </span>&#123; <span class="comment">// 失败状态</span></span><br><span class="line">        if (self.status === 'pending') &#123;</span><br><span class="line">            self.status = 'rejected';</span><br><span class="line">            self.reason = reason;</span><br><span class="line">            self.onRejectedCallbacks.forEach(function (fn) &#123;</span><br><span class="line">                fn();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executor(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123; <span class="comment">// 捕获的时候发生异常,就直接失败了</span></span><br><span class="line">        reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">resolvePromise</span><span class="params">(promise2, x, resolve, reject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有可能这里返回的x是别人的promise</span></span><br><span class="line">    <span class="comment">// 尽可能允许其他乱写</span></span><br><span class="line">    <span class="keyword">if</span> (promise2 === x) &#123; <span class="comment">//这里应该报一个类型错误，有问题</span></span><br><span class="line">        return reject(new TypeError('循环引用了'))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 看x是不是一个promise,promise应该是一个对象</span></span><br><span class="line">    let called; <span class="comment">// 表示是否调用过成功或者失败</span></span><br><span class="line">    if (x !== null &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123;</span><br><span class="line">        <span class="comment">// 可能是promise &#123;&#125;,看这个对象中是否有then方法，如果有then我就认为他是promise了</span></span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">// &#123;then:1&#125;</span></span><br><span class="line">            let then = x.then;</span><br><span class="line">            if (typeof then === 'function') &#123;</span><br><span class="line">                <span class="comment">// 成功</span></span><br><span class="line">                then.call(x, function (y) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">                    called = <span class="literal">true</span></span><br><span class="line">                    <span class="comment">// y可能还是一个promise，在去解析直到返回的是一个普通值</span></span><br><span class="line">                    resolvePromise(promise2, y, resolve, reject)</span><br><span class="line">                &#125;, function (err) &#123; <span class="comment">//失败</span></span><br><span class="line">                    <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">                    called = <span class="literal">true</span></span><br><span class="line">                    reject(err);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(x)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 说明是一个普通值1</span></span><br><span class="line">        resolve(x); <span class="comment">// 表示成功了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Promise.prototype.then = function (onFulfilled, onRjected) &#123;</span><br><span class="line">    <span class="comment">//成功和失败默认不传一个函数</span></span><br><span class="line">    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : function (value) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    onRjected = typeof onRjected === 'function' ? onRjected : function (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    let self = <span class="keyword">this</span>;</span><br><span class="line">    let promise2; <span class="comment">//返回的promise</span></span><br><span class="line">    if (self.status === 'resolved') &#123;</span><br><span class="line">        promise2 = <span class="keyword">new</span> Promise(function (resolve, reject) &#123;</span><br><span class="line">            <span class="comment">// 当成功或者失败执行时有异常那么返回的promise应该处于失败状态</span></span><br><span class="line">            <span class="comment">// x可能是一个promise 也有可能是一个普通的值</span></span><br><span class="line">            setTimeout(function () &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    let x = onFulfilled(self.value);</span><br><span class="line">                    <span class="comment">// x可能是别人promise，写一个方法统一处理</span></span><br><span class="line">                    resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.status === 'rejected') &#123;</span><br><span class="line">        promise2 = <span class="keyword">new</span> Promise(function (resolve, reject) &#123;</span><br><span class="line">            setTimeout(function () &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    let x = onRjected(self.reason);</span><br><span class="line">                    resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"> </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当调用then时可能没成功 也没失败</span></span><br><span class="line">    if (self.status === 'pending') &#123;</span><br><span class="line">        promise2 = <span class="keyword">new</span> Promise(function (resolve, reject) &#123;</span><br><span class="line">            <span class="comment">// 此时没有resolve 也没有reject</span></span><br><span class="line">            self.onResolvedCallbacks.push(function () &#123;</span><br><span class="line">                setTimeout(function () &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        let x = onFulfilled(self.value);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">            self.onRejectedCallbacks.push(function () &#123;</span><br><span class="line">                setTimeout(function () &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        let x = onRjected(self.reason);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 捕获错误的方法</span></span><br><span class="line">Promise.prototype.<span class="keyword">catch</span> = function (callback) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(null, callback)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解析全部方法</span></span><br><span class="line"><span class="comment">// let arr = [];</span></span><br><span class="line"><span class="comment">// arr[1] = 100;</span></span><br><span class="line"><span class="comment">// console.log(arr.length)</span></span><br><span class="line">Promise.all = function (promises) &#123;</span><br><span class="line">    <span class="comment">//promises是一个promise的数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise(function (resolve, reject) &#123;</span><br><span class="line">        let arr = []; <span class="comment">//arr是最终返回值的结果</span></span><br><span class="line">        let i = <span class="number">0</span>; <span class="comment">// 表示成功了多少次</span></span><br><span class="line">        function processData(index, y) &#123;</span><br><span class="line">            arr[index] = y;</span><br><span class="line">            <span class="keyword">if</span> (++i === promises.length) &#123;</span><br><span class="line">                resolve(arr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">            promises[i].then(function (y) &#123;</span><br><span class="line">                processData(i, y)</span><br><span class="line">            &#125;, reject)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只要有一个promise成功了 就算成功。如果第一个失败了就失败了</span></span><br><span class="line">Promise.race = function (promises) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise(function (resolve, reject) &#123;</span><br><span class="line">        <span class="keyword">for</span> (var i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">            promises[i].then(resolve,reject)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成一个成功的promise</span></span><br><span class="line">Promise.resolve = function(value)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise(function(resolve,reject)&#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成一个失败的promise</span></span><br><span class="line">Promise.reject = function(reason)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise(function(resolve,reject)&#123;</span><br><span class="line">        reject(reason);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">Promise.defer = Promise.deferred = function () &#123;</span><br><span class="line">    let dfd = &#123;&#125;;</span><br><span class="line">    dfd.promise = <span class="keyword">new</span> Promise(function (resolve, reject) &#123;</span><br><span class="line">        dfd.resolve = resolve;</span><br><span class="line">        dfd.reject = reject;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> dfd</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mjs</span></span><br><span class="line"><span class="keyword">module</span>.exports = Promise;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>显然.then()需要返回一个 Promise，这样才能找到 then 方法链式调用，所以我们会把 then 方法的返回值包装成<br>Promise。 .then()的回调需要顺序执行，我们要等待当前 Promise 状态变更后，再执行下一个 then 收集的回调，这就要求我们对 then 的返回值分类讨论。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Promise/A+规范的三种状态</span></span><br><span class="line">const PENDING = 'pending'</span><br><span class="line">const FULFILLED = 'fulfilled'</span><br><span class="line">const REJECTED = 'rejected'</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> &#123;</span></span><br><span class="line">  <span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">  constructor(executor) &#123;<span class="comment">//executor是异步任务，才可以先then收集回调，再返回resolve  reject的结果</span></span><br><span class="line">    <span class="keyword">this</span>._status = PENDING     <span class="comment">// Promise状态</span></span><br><span class="line">    <span class="keyword">this</span>._resolveQueue = []    <span class="comment">// 成功队列, resolve时触发</span></span><br><span class="line">    <span class="keyword">this</span>._rejectQueue = []     <span class="comment">// 失败队列, reject时触发</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span></span><br><span class="line">    let _resolve = (val) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span>   <span class="comment">// 对应规范中的"状态只能由pending到fulfilled或rejected"</span></span><br><span class="line">      <span class="keyword">this</span>._status = FULFILLED              <span class="comment">// 变更状态</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这里之所以使用一个队列来储存回调,是为了实现规范要求的 "then 方法可以被同一个 promise 调用多次"</span></span><br><span class="line">      <span class="comment">// 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">this</span>._resolveQueue.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> callback = <span class="keyword">this</span>._resolveQueue.shift()</span><br><span class="line">        callback(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现同resolve</span></span><br><span class="line">    let _reject = (val) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span>   <span class="comment">// 对应规范中的"状态只能由pending到fulfilled或rejected"</span></span><br><span class="line">      <span class="keyword">this</span>._status = REJECTED               <span class="comment">// 变更状态</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">this</span>._rejectQueue.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> callback = <span class="keyword">this</span>._rejectQueue.shift()</span><br><span class="line">        callback(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// new Promise()时立即执行executor,并传入resolve和reject</span></span><br><span class="line">    executor(_resolve, _reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">  then(resolveFn, rejectFn) &#123;</span><br><span class="line">    <span class="keyword">this</span>._resolveQueue.push(resolveFn)</span><br><span class="line">    <span class="keyword">this</span>._rejectQueue.push(rejectFn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面实现了then方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then方法</span></span><br><span class="line">then(resolveFn, rejectFn) &#123;</span><br><span class="line">  <span class="comment">//return一个新的promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">    <span class="comment">//把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span></span><br><span class="line">    <span class="keyword">const</span> fulfilledFn = value =&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">        let x = resolveFn(value)</span><br><span class="line">        <span class="comment">//分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">        x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把后续then收集的依赖都push进当前Promise的成功回调队列中(_rejectQueue), 这是为了保证顺序调用</span></span><br><span class="line">    <span class="keyword">this</span>._resolveQueue.push(fulfilledFn)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//reject同理</span></span><br><span class="line">    <span class="keyword">const</span> rejectedFn  = error =&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        let x = rejectFn(error)</span><br><span class="line">        x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._rejectQueue.push(rejectedFn)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试可以满足面试官姐姐提出的需求场景。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(res)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(res)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(res)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 1 2 3</span></span><br></pre></td></tr></table></figure>

<h2 id="三、-then方法的几点注意"><a href="#三、-then方法的几点注意" class="headerlink" title="三、 then方法的几点注意"></a>三、 then方法的几点注意</h2><p>1、jquery能实现链式调用靠的就是返回this，promise不能返回this，promise实现链式调用靠的是返回一个新的promise。调用then时要返回一个新的promise。<br>2、Promise 是用来执行异步操作的。但有时一个异步操作需要等其他的异步操作完成，这时候就可以使用then来做。<br>3、使用 promise.then + 递归的方法异步转同步，我一直理解then().then()是一个chain，每一个then会返回一个promise，然后往后面传。但是我今天跑了一段代码，没有按照这个顺序执行，可能和异常错误处理有关。<br>4、then是会返回一个promise对象，但是这个promise对象的this是你前一个promise的，如果你return 一个新的promise，this则是这个promise，所以后面的then需要依据第二个promise是否resolve，才决定是否执行相应的then。<br>5、<strong>then，catch都是同步方法</strong>，假设执行b=new Promise(func)后里面的异步操作，已经开始但可能未处理完，同步执行下去是运行b.then(a)，b.then(aa)，b.then(aaa)…，假设运行到b.then(aa)方法时异步操作仍未处理完，那么then函数就会把aa push到b里面的一个callbacks数组中，假设运行b.then(aaa)前异步操作完成，首先将异步结果赋值给b里的result变量，然后循环调用callbacks数组里存好的方法：a(result),aa(result)，执行完毕后再运行b.then(aaa)，此时判断异步已执行完毕，不用将aaa push到callbacks数组里，而是直接运行aaa(result)，真正原因是res()内部设置了一个延时执行回调，延时setTimeout的最小值，<strong>也就是说res才是异步的，</strong>由于这点异步时间，导致最后一例中a.then(a)将a函数存放到callbacks里了，导致顺序发生错误，可以试着将a.then(a)延时执行，这就和浏览器时间频率有关系了，想一想怎么在秒杀系统处理呢？<br>6、在new promise(fn)中，<strong>new出来的函数是同步的，但是 fn的res() 函数是异步的，会挂起线程</strong>，执行到then的时候，顺利执行then的代码块，只是把成功的回调函数放到了resovledCallbacks中，但是就算state修改完毕为solved的时候，5中提到的执行then（aaa）的时候也是会异步操作，也不是立即执行aaa， 因为then的内部实现方式根据promiseA规范中也是有一个settimeout 在延时器内部执行aaa的。<br>再举个具体栗子！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">loadImageAsync</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Promise(function(resolve, reject) &#123;</span><br><span class="line">           var image = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">           image.onload = function() &#123;</span><br><span class="line">               console.<span class="built_in">log</span>(<span class="string">"load"</span>);</span><br><span class="line">               resolve(image);</span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line">           image.onerror = function() &#123;</span><br><span class="line">               reject(new Error('Could not load image at ' + url));</span><br><span class="line">           &#125;;</span><br><span class="line">           console.<span class="built_in">log</span>(<span class="string">"change src"</span>);</span><br><span class="line">           <span class="function">function <span class="title">init_img</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               image.src = url;</span><br><span class="line">           &#125;</span><br><span class="line">           setTimeout(init_img,<span class="number">5000</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>loadImageAsync 用来异步加载图片. setTimeout 人为地延迟5秒加载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">loadImageAsync2</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Promise(function(resolve, reject) &#123;</span><br><span class="line">            var image = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">            image.onload = function() &#123;</span><br><span class="line">                console.<span class="built_in">log</span>(<span class="string">"2load"</span>);</span><br><span class="line">                resolve(image);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            image.onerror = function() &#123;</span><br><span class="line">                reject(new Error('Could not load image at ' + url));</span><br><span class="line">            &#125;;</span><br><span class="line">            console.<span class="built_in">log</span>(<span class="string">"2change src"</span>);</span><br><span class="line">            <span class="function">function <span class="title">init_img</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                image.src = url;</span><br><span class="line">            &#125;</span><br><span class="line">            setTimeout(init_img,<span class="number">1000</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>loadImageAsync2 也是用来加载图片，人为地延迟1秒。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var p = loadImageAsync('http://img02.tooopen.com/images/20141231/sy_78327074576.jpg');</span><br><span class="line">    p.then(function (img) &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">"1:"</span>+img.src);</span><br><span class="line">    &#125;);</span><br><span class="line">    var h = loadImageAsync2('http://img02.tooopen.com/images/20141225/sy_77944235469.jpg');</span><br><span class="line">    h.then(function (img) &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">"2:"</span>+img.src);</span><br><span class="line">    &#125;);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"wqx"</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到 图片2先加载， 然后加载图片1 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s = loadImageAsync('http://img02.tooopen.com/images/20141231/sy_78327074576.jpg');</span><br><span class="line">  s.then(function (img) &#123;</span><br><span class="line">      console.<span class="built_in">log</span>(<span class="string">"1:"</span>+img.src);</span><br><span class="line">      return loadImageAsync2('http://img02.tooopen.com/images/20141225/sy_77944235469.jpg');</span><br><span class="line">  &#125;).then(function (img) &#123;</span><br><span class="line">      console.<span class="built_in">log</span>(<span class="string">"2:"</span>+img.src);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>创建新的promise 对象 s，我在s 的then 成功回调函数中 去调用 loadImageAsync2 函数。</p>
<p>这样就保证了 加载图片2 之前先加载图片1。</p>
<p>这里注意的是第二个then 其实是loadImageAsync2 返回的promise 实例调用的。这样就保证了加载完毕图片再去打印图片的解释说明。</p>
<p><strong>还要注意的两点：</strong><br>1、值穿透：根据规范，如果 then() 接收的参数不是 function，那么我们应该忽略它。如果没有忽略，当 then()回调不为 function 时将会抛出异常，导致链式调用中断。<br>2、处理状态为 resolve/reject 的情况：其实我们上边 then() 的写法是对应状态为padding的情况，但是有些时候resolve/reject 在 then() 之前就被执行（比如Promise.resolve().then()），如果这个时候还把 then()回调 push 进 resolve/reject 的执行队列里，那么回调将不会被执行，因此对于状态已经变为fulfilled或rejected的情况，我们直接执行 then 回调。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">  then(resolveFn, rejectFn) &#123;</span><br><span class="line">    <span class="comment">// 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span></span><br><span class="line">    typeof resolveFn !== 'function' ? resolveFn = value =&gt; value : null</span><br><span class="line">    typeof rejectFn !== 'function' ? rejectFn = reason =&gt; &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(reason instanceof Error? reason.message:reason);</span><br><span class="line">    &#125; : null</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return一个新的promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span></span><br><span class="line">      <span class="keyword">const</span> fulfilledFn = value =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">          let x = resolveFn(value)</span><br><span class="line">          <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// reject同理</span></span><br><span class="line">      <span class="keyword">const</span> rejectedFn  = error =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          let x = rejectFn(error)</span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">this</span>._status) &#123;</span><br><span class="line">        <span class="comment">// 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行</span></span><br><span class="line">        <span class="keyword">case</span> PENDING:</span><br><span class="line">          <span class="keyword">this</span>._resolveQueue.push(fulfilledFn)</span><br><span class="line">          <span class="keyword">this</span>._rejectQueue.push(rejectedFn)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 当状态已经变为resolve/reject时,直接执行then回调</span></span><br><span class="line">        <span class="keyword">case</span> FULFILLED:</span><br><span class="line">          fulfilledFn(<span class="keyword">this</span>._value)    <span class="comment">// this._value是上一个then回调return的值(见完整版代码)</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REJECTED:</span><br><span class="line">          rejectedFn(<span class="keyword">this</span>._value)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、catch、all、race、finally方法"><a href="#四、catch、all、race、finally方法" class="headerlink" title="四、catch、all、race、finally方法"></a>四、catch、all、race、finally方法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.<span class="keyword">catch</span>()</span><br><span class="line"><span class="keyword">catch</span>()方法返回一个 Promise，并且处理拒绝的情况。它的行为与调用 Promise.prototype.then(undefined, onRejected) 相同。</span><br><span class="line"><span class="comment">//catch方法其实就是执行一下then的第二个回调</span></span><br><span class="line"><span class="keyword">catch</span>(rejectFn) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(undefined, rejectFn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise.prototype.finally() finally()方法返回一个 Promise。在 promise 结束时，无论结果是 fulfilled 或者是 rejected，都会执行指定的回调函数。在 finally 之后，还可以继续then。并且会将值原封不动的传递给后面的 then。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//finally方法</span></span><br><span class="line">finally(callback) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    value =&gt; MyPromise.resolve(callback()).then(() =&gt; value),   <span class="comment">// MyPromise.resolve执行回调,并在then中return结果传递给后面的Promise</span></span><br><span class="line">    reason =&gt; MyPromise.resolve(callback()).then(() =&gt; &#123; <span class="keyword">throw</span> reason &#125;)  <span class="comment">// reject同理</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise.resolve() Promise.resolve(value)方法返回一个以给定值解析后的 Promise 对象。如果该值为 promise，返回这个 promise；如果这个值是 thenable（即带有”then” 方法)），返回的 promise 会“跟随”这个 thenable 的对象，采用它的最终状态；否则返回的 promise 将以此值完成。此函数将promise 对象的多层嵌套展平。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态的resolve方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">resolve</span><span class="params">(value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(value instanceof MyPromise) <span class="keyword">return</span> value <span class="comment">// 根据规范, 如果参数是Promise实例, 直接return这个实例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(resolve =&gt; resolve(value))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise.reject() Promise.reject()方法返回一个带有拒绝原因的 Promise 对象。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态的reject方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">reject</span><span class="params">(reason)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; reject(reason))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise.all() Promise.all(iterable)方法返回一个 Promise 实例，此实例在 iterable参数内所有的 promise 都“完成（resolved）”】或参数中不包含 promise 时回调完成（resolve）；<br>如果参数中promise 有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败 promise 的结果。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态的all方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">all</span><span class="params">(promiseArr)</span> </span>&#123;</span><br><span class="line">  let index = <span class="number">0</span></span><br><span class="line">  let result = []<span class="comment">//放在数组中</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">    promiseArr.forEach((p, i) =&gt; &#123;</span><br><span class="line">      <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">      MyPromise.resolve(p).then(</span><br><span class="line">        val =&gt; &#123;</span><br><span class="line">          index++</span><br><span class="line">          result[i] = val<span class="comment">//保证顺序到达</span></span><br><span class="line">          <span class="comment">//所有then执行后, resolve结果</span></span><br><span class="line">          <span class="keyword">if</span>(index === promiseArr.length) &#123;</span><br><span class="line">            resolve(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        err =&gt; &#123;</span><br><span class="line">          <span class="comment">//有一个Promise被reject时，MyPromise的状态变为reject</span></span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise.race() Promise.race(iterable)方法返回一个 promise，一旦迭代器中的某个 promise解决或拒绝，返回的 promise 就会解决或拒绝，找到最先完成的那个任务，数组中有一个完成就返回，没有顺序之分，看完成的速度。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">race</span><span class="params">(promiseArr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">    <span class="comment">//同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span></span><br><span class="line">    <span class="keyword">for</span> (let p of promiseArr) &#123;</span><br><span class="line">      MyPromise.resolve(p).then(  <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">        value =&gt; &#123;</span><br><span class="line">          resolve(value)        <span class="comment">//注意这个resolve是上边new MyPromise的</span></span><br><span class="line">        &#125;,</span><br><span class="line">        err =&gt; &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、Generator的秘密"><a href="#五、Generator的秘密" class="headerlink" title="五、Generator的秘密"></a>五、Generator的秘密</h2><p>下面这个代码可能就是面试官姐姐的问题初衷吧。我之前想到了用next方法，没有表达清楚，面完突然好像懂了吼吼吼。<br>所以终极方案就是：Promise+Generator<br>Generator的这种特性对于异步来说，意味着什么呢？<br>意味着，我们终于获得了一种在不阻塞主线程的前提下实现“同步等待”的方法！<br>为便于说明，先上一段直接使用回调的代码：<br>看下面这个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function* <span class="title">myGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  yield Promise.resolve(<span class="number">1</span>);</span><br><span class="line">  yield Promise.resolve(<span class="number">2</span>);</span><br><span class="line">  yield Promise.resolve(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = myGenerator()</span><br><span class="line">gen.next().value.then(val =&gt; &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(val)</span><br><span class="line">  gen.next().value.then(val =&gt; &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(val)</span><br><span class="line">    gen.next().value.then(val =&gt; &#123;</span><br><span class="line">      console.<span class="built_in">log</span>(val)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出1 2 3</span></span><br><span class="line"></span><br><span class="line">这就是面试官姐姐的问题，这是我的思路，下文深究一下这个问题的根源。</span><br><span class="line">```cpp</span><br><span class="line">function  gen1() &#123; </span><br><span class="line">let count = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123; </span><br><span class="line">let msg = yield ++count; </span><br><span class="line">console.<span class="built_in">log</span>(msg); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let iter = gen1(); <span class="comment">//获得迭代器</span></span><br><span class="line">console.<span class="built_in">log</span>(iter.next().value); </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line">console.<span class="built_in">log</span>(iter.next(‘magic’).value); </span><br><span class="line"><span class="comment">// ‘magic’ </span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">let it = gen1(); <span class="comment">// 获得迭代器</span></span><br><span class="line"><span class="function">function <span class="title">request</span><span class="params">()</span> </span>&#123; </span><br><span class="line">ajax(&#123; </span><br><span class="line">url: ‘www.someurl.com’, </span><br><span class="line">onSuccess(res)&#123; </span><br><span class="line">it.next(res); <span class="comment">// 恢复Generator运行，同时向其中塞入异步返回的结果 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">gen2</span><span class="params">()</span> </span>&#123; </span><br><span class="line">let response = yield request(); </span><br><span class="line">console.<span class="built_in">log</span>(response.text); </span><br><span class="line">&#125;</span><br><span class="line">it.next(); <span class="comment">// 启动Generator</span></span><br><span class="line">```cpp</span><br><span class="line">let it = gen2(); </span><br><span class="line">let p = it.next().value; <span class="comment">// p是yield返回的Promise </span></span><br><span class="line">p.then(res =&gt; it.next(res), </span><br><span class="line">err =&gt; it.<span class="keyword">throw</span>(err) <span class="comment">// 发生错误时，将错误抛入生成器 </span></span><br><span class="line">);</span><br><span class="line">```cpp</span><br><span class="line"><span class="function">function <span class="title">request</span><span class="params">()</span> </span>&#123; <span class="comment">// 此处的request返回的是一个Promise </span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve, reject) =&gt; &#123; </span><br><span class="line">ajax(&#123; </span><br><span class="line">url: ‘www.someurl.com’, </span><br><span class="line">onSuccess(res) &#123; </span><br><span class="line">resolve(res); </span><br><span class="line">&#125;, </span><br><span class="line">onFail(err) &#123; </span><br><span class="line">reject(err); </span><br><span class="line">&#125; </span><br><span class="line">&#125;); </span><br><span class="line">&#125;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">function* <span class="title">gen2</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">let response = yield request(); </span><br><span class="line">console.<span class="built_in">log</span>(response.text); </span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123; </span><br><span class="line">console.<span class="built_in">log</span>(“出错了”, error.message); <span class="comment">// 可以捕获Promise抛进来的错误！ </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>思考：gen是个function，执行它时却不执行里面的代码，而是返回一个Iterator对象，代码执行到yield处可以暂停，暂停以后，可以恢复继续执行，另外，暂停/恢复执行时，还可以传出/传入数据！<br>其实Generator并没有改变JS运行的基本规则。<br>思考let response = yield request()这行代码，我来仔细分析下这段代码是如何运行的。如有错误，欢迎大家指教。<br>1、首先，最后一行it.next()使得Generator内部的代码从头开始执行，执行到yield语句时，暂停，此时可以把yield想象成return，Generator的栈帧需要被弹出，会先计算yield右边的表达式，即执行request函数调用，以获得用于返回给上一级栈帧的值。<br>2、但是现在request函数没有返回值，但它发送了一个异步ajax请求，并注册了一个onSuccess回调，表示在请求返回结果时，恢复Generator的栈帧并继续运行代码，并把结果作为参数塞给Generator，准确地说是塞到yield所在的地方。<br>3、这response变量就获得了ajax的返回值。 可以看出，这里yield的功能设计得非常巧妙，好像它可以“赋值”给response。<br>4、更妙的是，迭代器不但可以.next，还可以.throw，即把错误也抛入Generator，让后者来处理。也就是说，在Generator里使用try-catch语句捕获异步错误。</p>
<blockquote>
<p>是不是只有.then方法这样的形式才能完成自动执行的功能呢？ 我去查阅了一些资料发现，yield 后边除了接 Promise，还可以接thunk函数， thunk 函数，就是单参的只接受回调的函数，详细介绍可以看阮一峰 Thunk。<br>函数的含义和用法，无论是 Promise 还是 thunk 函数，其核心都是通过传入回调的方式来实现 Generator 的自动执行。<br>总结一下：Generator 实现的核心在于上下文的保存，函数并没有真的被挂起，每一次 yield，其实都执行了一遍传入的生成器函数。<br>只是在这个过程中间用了一个 context 对象储存上下文，使得每次执行生成器函数的时候，都可以从上一个执行结果开始执行，看起来就像函数被挂起了一样。</p>
</blockquote>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">下面尝试封装一下自动迭代：</span><br><span class="line">这个run 方法里，可以把执行下一步的操作封装成 step()，每次 Promise.<span class="keyword">then</span>()的时候都去执行 step()，实现自动迭代的效果。在迭代的过程中，我们还把 resolve 的值传入gen.next()，使得 <span class="keyword">yield</span> 得以返回 Promise 的 resolve 的值。</span><br><span class="line">```<span class="javascript">cpp</span></span><br><span class="line"><span class="javascript"> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> g = gen()    <span class="comment">//由于每次gen()获取到的都是最新的迭代器,因此获取迭代器操作要放在step()之前,否则会进入死循环</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">val</span>) </span>&#123;              <span class="comment">//封装一个方法, 递归执行next()</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> res = g.next(val)           <span class="comment">//获取迭代器对象，并返回resolve的值</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>(res.done) <span class="keyword">return</span> res.value   <span class="comment">//递归终止条件</span></span></span><br><span class="line"><span class="javascript">    res.value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;         <span class="comment">//Promise的then方法是实现自动迭代的前提</span></span></span><br><span class="line"><span class="javascript">      step(val)                     <span class="comment">//等待Promise完成就自动执行下一个next，并传入resolve的值</span></span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">  step()  <span class="comment">//第一次执行</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br></pre></td></tr></table></figure>

<p>理解Generator的关键点在于理解函数执行时，内存里发生了什么。<br>一个JS程序的内存分为代码区、栈区、堆区和队列区，从MDN借图一张以说明（图中没有画出代码区）：<br><img src="https://img-blog.csdnimg.cn/20200414013448793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>1、队列（Queue）就是事件循环队列，分为了宏任务和微任务。<br>2、代码区保存着全部JS源代码被引擎编译成的机器码（以V8为例）。<br>3、栈（stack）保存着每个函数执行所需的上下文，一个栈元素被称为一个栈帧，一个栈帧对应一个函数。<br>4、对于引用类型的数据，在栈帧里只保存引用，而真正的数据存放在堆（Heap）里。<br>5、堆与栈不同的是，栈内存由JS引擎自动管理，入栈时分配空间，出栈时回收，非常清楚明了。<br>6、堆是程序员通过new操作符手动向操作系统申请的内存空间（当然，用字面量语法创建对象也算），何时该回收没那么明晰，所以需要一套垃圾收集（GC）算法来专门做这件事。<br>以上是预备知识，现在 回到Generator的正题：<br>1、普通函数在被调用时，JS引擎会创建一个栈帧，在里面准备好局部变量、函数参数、临时值、代码执行的位置（也就是说这个函数的第一行对应到代码区里的第几行机器码），在当前栈帧里设置好返回位置，然后将新帧压入栈顶。<br>2、待函数执行结束后，这个栈帧将被弹出栈然后销毁，返回值会被传给上一个栈帧。<br>3、当执行到yield语句时，Generator的栈帧同样会被弹出栈外，但Generator在这里耍了个花招——它在堆里保存了栈帧的引用（或拷贝）！<br>4、这样当iter.next方法被调用时，JS引擎便不会重新创建一个栈帧，而是把堆里的栈帧直接入栈。因为栈帧里保存了函数执行所需的全部上下文以及当前执行的位置，所以当任务调度来临时，就好像程序从原本暂停的地方继续向前执行了。 因为每次yield和iter.next都对应一次出栈和入栈，所以可以直接利用已有的栈机制，实现值的传出和传入。<br>终于揭开了Generator背后的神秘！</p>
<p>上述写法完美结合了Promise和Generator的优点，写法套路非常固定，当Promise对象一多时，就需要写许多类似p.then(res =&gt; …., err =&gt; …)这样的重复语句，所以就把这种套路给提炼成了一个更加精简的语法，那就是传说中的async/await，六中梳理一下hhh。</p>
<h2 id="六、async，await是解决异步操作的终极方案"><a href="#六、async，await是解决异步操作的终极方案" class="headerlink" title="六、async，await是解决异步操作的终极方案"></a>六、async，await是解决异步操作的终极方案</h2><p>场景：在多个回调依赖的场景中，尽管 Promise 通过链式调用取代了回调嵌套，但过多的链式调用可读性仍然不佳，流程控制也不方便，ES7 提出的 async 函数，终于让 JS 对于异步操作有了终极解决方案，简洁优美地解决了以上两个问题。</p>
<blockquote>
<p>设想一个这样的场景，异步任务 a-&gt;b-&gt;c 之间存在依赖关系，如果我们通过 then链式调用来处理这些关系，可读性并不是很好，如果我们想控制其中某个过程，比如在某些条件下，b 不往下执行到 c，那么也不是很方便控制。比如读取完了文件再去写，等待一段时间后再去执行，类似于我们会中断流程，然后再接着原来的任务去做。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> a = await Promise.resolve(a);</span><br><span class="line">  <span class="keyword">const</span> b = await Promise.resolve(b);</span><br><span class="line">  <span class="keyword">const</span> c = await Promise.resolve(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">async funtion <span class="title">fetch</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">let response = await request(); <span class="comment">// request定义同上一端段示例代码 </span></span><br><span class="line">console.<span class="built_in">log</span>(response.text); </span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123; </span><br><span class="line">console.<span class="built_in">log</span>(“wqx”, error.message); </span><br><span class="line">&#125; ;</span><br><span class="line">fetch();</span><br></pre></td></tr></table></figure>
<p>下面做一下总结：<br>1、MDN上说，async/await 实际上是对 Generator（生成器）的封装，是一个语法糖。<br>2、ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，通过 next()方法可以切换到下一个状态，为改变执行流程提供了可能，从而为异步编程提供解决方案。<br>3、Generator 函数也可以通过给next()传参, 让 yield 具有返回值。<br>4、async/await自带执行器，不需要手动调用 next()就能自动执行下一步。<br>5、async函数返回值是 Promise 对象，而 Generator 返回的是生成器对象。<br>6、await能够返回 Promise 的 resolve/reject 的值。<br>7、在代码中也可以通过给gen.next()传值的方式，让 yield 能返回 resolve 的值。<br>8、async解决了生成器函数能自动往下执行，且 yield 能返回 resolve 的值这两个问题。<br>就靠拢同步风格的程度而言，感觉async/await已经到了炉火纯青的地步，以后在项目中要积极思考，合理应用到不同的场景！</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-深入浅析浏览器动画（一）" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/04/13/%E6%B7%B1%E5%85%A5%E6%B5%85%E6%9E%90%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A8%E7%94%BB%EF%BC%88%E4%B8%80%EF%BC%89/"
    >深入浅析浏览器动画（一）</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/04/13/%E6%B7%B1%E5%85%A5%E6%B5%85%E6%9E%90%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A8%E7%94%BB%EF%BC%88%E4%B8%80%EF%BC%89/" class="article-date">
  <time datetime="2020-04-13T11:32:33.954Z" itemprop="datePublished">2020-04-13</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h2 id="需求思考：让动画流畅无阻，提升用户体验"><a href="#需求思考：让动画流畅无阻，提升用户体验" class="headerlink" title="需求思考：让动画流畅无阻，提升用户体验"></a>需求思考：让动画流畅无阻，提升用户体验</h2><p>在Web应用中，实现动画效果的方法比较多。<br>Javascript 中可以通过定时器 setTimeout 来实现，css3 可以使用 transition 和 animation 来实现，html5 中的 canvas 也可以实现。<br>除此之外，html5 还提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是请求动画帧。 </p>
<p><strong>如果有一个需求，要设置动画不停播放移动，怎么做最好呢？</strong><br>我们经常面临一个抉择：到底使用哪种动画方式？怎么符合业务场景？下面做一下对比。</p>
<h2 id="1、JS动画与CSS3动画的区别和使用场景"><a href="#1、JS动画与CSS3动画的区别和使用场景" class="headerlink" title="1、JS动画与CSS3动画的区别和使用场景"></a>1、JS动画与CSS3动画的区别和使用场景</h2><p><strong>JS动画</strong><br>缺点：<br>(1)JavaScript在浏览器的主线程中运行，而主线程中还有其它需要运行的JavaScript脚本、样式计算、布局、绘制任务等,对其干扰导致线程可能出现阻塞，从而造成丢帧的情况。<br>(2)代码的复杂度高于CSS动画。</p>
<p>优点：<br>(1)JavaScript动画控制能力很强, 可以在动画播放过程中对动画进行控制：开始、暂停、回放、终止、取消都是可以做到的。<br>(2)动画效果比css3动画丰富,有些动画效果，比如曲线运动,冲击闪烁,视差滚动效果，只有JavaScript动画才能完成<br>(3)CSS3有兼容性问题，而JS大多时候没有兼容性问题。</p>
<p><strong>CSS动画</strong><br>缺点：<br> (1)运行过程控制较弱,无法附加事件绑定回调函数。<br> (2)CSS动画只能暂停,不能在动画中寻找一个特定的时间点，不能在半路反转动画，不能变换时间尺度，不能在特定的位置添加回调函数或是绑定回放事件,无进度报告。<br> (3)CSS比较简单，性能调优方向固定，对于帧速表现不好的低版本浏览器，CSS3可以做到自然降级，而JS则需要撰写额外代码。<br>优点：<br>(1)浏览器可以对动画进行优化。<br>(2)浏览器使用与 requestAnimationFrame 类似的机制。<br>(3)css3后来添加了transform动画函数。</p>
<p><strong>CSS动画流畅的原因</strong><br><strong>渲染线程分为main thread(主线程)和compositor thread(合成器线程)。</strong><br>如果CSS动画只是改变transform和opacity，这时整个CSS动画得以在compositor thread完成<br>（而JS动画则会在main thread执行，然后触发compositor进行下一步操作）<br>在JS执行一些昂贵的任务时，main thread繁忙，CSS动画由于使用了compositor thread可以保持流畅，在主线程中，维护了一棵Layer树（LayerTreeHost），管理了TiledLayer，在compositor thread，维护了同样一颗LayerTreeHostImpl，管理了LayerImpl，这两棵树的内容是拷贝关系。因此可以彼此不干扰，当Javascript在main thread操作LayerTreeHost的同时，compositor thread可以用LayerTreeHostImpl做渲染。当Javascript繁忙导致主线程卡住时，合成到屏幕的过程也是流畅的。<br>为了实现防假死，鼠标键盘消息会被首先分发到compositor thread，然后再到main thread。这样，当main thread繁忙时，compositor thread还是能够响应一部分消息。<br>例如，鼠标滚动时，加入main thread繁忙，compositor thread也会处理滚动消息，滚动已经被提交的页面部分（未被提交的部分将被刷白）。</p>
<p><strong>CSS动画比JS流畅的前提：</strong><br>1、JS在执行一些昂贵的任务。<br>2、同时CSS动画不触发layout或paint。<br>3、在CSS动画或JS动画触发了paint或layout时，需要main thread进行Layer树的重计算，这时CSS动画或JS动画都会阻塞后续操作。<br>4、只有如下属性的修改才符合“仅触发Composite，不触发layout或paint：<br>backface-visibility<br>opacity<br>perspective<br>perspective-origin<br>transfrom<br>所以只有用上了3D加速或修改opacity时，css3动画的优势才会体现出来。</p>
<p><strong>总结：</strong><br> 1、如果动画只是简单的状态切换，不需要中间过程控制，在这种情况下，css动画是优选方案。它可以让你将动画逻辑放在样式文件里面，而不会让你的页面充斥 Javascript 库。<br> 2、如果要设计很复杂的富客户端界面或者在开发一个有着复杂UI状态的 APP，应该使用js动画，这样动画可以保持高效，并且工作流也更可控。<br> 3、综上，在实现一些小的交互动效的时候，就多考虑考虑CSS动画。对于一些复杂控制的动画，使用javascript比较可靠。</p>
<h2 id="2、RequestAnimationFrame有哪些好处和优化？"><a href="#2、RequestAnimationFrame有哪些好处和优化？" class="headerlink" title="2、RequestAnimationFrame有哪些好处和优化？"></a>2、RequestAnimationFrame有哪些好处和优化？</h2><p>为了深入理解 requestAnimationFrame 背后的原理，我们首先需要了解一下与之相关的几个概念：<br>1、屏幕刷新频率<br>即图像在屏幕上更新的速度，也即屏幕上的图像每秒钟出现的次数，它的单位是赫兹(Hz)。 对于一般笔记本电脑，这个频率大概是60Hz， 可以在桌面上右键-&gt;屏幕分辨率-&gt;高级设置-&gt;监视器 中查看和设置。这个值的设定受屏幕分辨率、屏幕尺寸和显卡的影响，原则上设置成让眼睛看着舒适的值都行。</p>
<p>市面上常见的显示器有两种，即CRT和LCD， CRT就是传统显示器，LCD就是我们常说的液晶显示器。</p>
<p>CRT是一种使用阴极射线管的显示器，屏幕上的图形图像是由一个个因电子束击打而发光的荧光点组成，由于显像管内荧光粉受到电子束击打后发光的时间很短，所以电子束必须不断击打荧光粉使其持续发光。电子束每秒击打荧光粉的次数就是屏幕刷新频率。</p>
<p>而对于LCD来说，则不存在刷新频率的问题，它根本就不需要刷新。因为LCD中每个像素都在持续不断地发光，直到不发光的电压改变并被送到控制器中，所以LCD不会有电子束击打荧光粉而引起的闪烁现象。</p>
<p>因此，当你对着电脑屏幕什么也不做的情况下，显示器也会以每秒60次的频率正在不断的更新屏幕上的图像。为什么你感觉不到这个变化？ 那是因为人的眼睛有视觉停留效应，即前一副画面留在大脑的印象还没消失，紧接着后一副画面就跟上来了，这中间只间隔了16.7ms(1000/60≈16.7)， 所以会让你误以为屏幕上的图像是静止不动的。而屏幕给你的这种感觉是对的，试想一下，如果刷新频率变成1次/秒，屏幕上的图像就会出现严重的闪烁，这样就很容易引起眼睛疲劳、酸痛和头晕目眩等症状。</p>
<p>2、动画原理<br>根据上面的原理我们知道，你眼前所看到图像正在以每秒60次的频率刷新，由于刷新频率很高，因此你感觉不到它在刷新。而动画本质就是要让人眼看到图像被刷新而引起变化的视觉效果，这个变化要以连贯的、平滑的方式进行过渡。 那怎么样才能做到这种效果呢？</p>
<p>刷新频率为60Hz的屏幕每16.7ms刷新一次，我们在屏幕每次刷新前，将图像的位置向左移动一个像素，即1px。这样一来，屏幕每次刷出来的图像位置都比前一个要差1px，因此你会看到图像在移动；由于我们人眼的视觉停留效应，当前位置的图像停留在大脑的印象还没消失，紧接着图像又被移到了下一个位置，因此你才会看到图像在流畅的移动，这就是视觉效果上形成的动画。</p>
<p>3、setTimeout<br>理解了上面的概念以后，我们不难发现，setTimeout 其实就是通过设置一个间隔时间来不断的改变图像的位置，从而达到动画效果的。但我们会发现，利用setTimeout实现的动画在某些低端机上会出现卡顿、抖动的现象。<br>这里是MDN的阐述：<br><img src="https://img-blog.csdnimg.cn/20200413185804863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/20200413190019842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 这种现象的产生有两个原因：</p>
<p>setTimeout的执行时间并不是确定的。在Javascript中，</p>
<blockquote>
<p>1、 <strong>setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，因此<br>setTimeout 的实际执行时间一般要比其设定的时间晚一些。</strong><br>2、<strong>刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的屏幕刷新频率可能会不同，而setTimeout只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。</strong></p>
</blockquote>
<p>以上两种情况都会导致setTimeout的执行步调和屏幕的刷新步调不一致，从而引起丢帧现象。 那为什么步调不一致就会引起丢帧呢？</p>
<p>首先要明白，setTimeout的执行只是在内存中对图像属性进行改变，这个变化必须要等到屏幕下次刷新时才会被更新到屏幕上。如果两者的步调不一致，就可能会导致中间某一帧的操作被跨越过去，而直接更新下一帧的图像。假设屏幕每隔16.7ms刷新一次，而setTimeout每隔10ms设置图像向左移动1px， 就会出现如下绘制过程：</p>
<p>第0ms: 屏幕未刷新，等待中，setTimeout也未执行，等待中；</p>
<p>第10ms: 屏幕未刷新，等待中，setTimeout开始执行并设置图像属性left=1px；</p>
<p>第16.7ms: 屏幕开始刷新，屏幕上的图像向左移动了1px， setTimeout 未执行，继续等待中；</p>
<p>第20ms: 屏幕未刷新，等待中，setTimeout开始执行并设置left=2px;</p>
<p>第30ms: 屏幕未刷新，等待中，setTimeout开始执行并设置left=3px;</p>
<p>第33.4ms:屏幕开始刷新，屏幕上的图像向左移动了3px， setTimeout未执行，继续等待中；</p>
<p>…<br>从上面的绘制过程中可以看出，屏幕没有更新left=2px的那一帧画面，图像直接从1px的位置跳到了3px的的位置，这就是丢帧现象，这种现象就会引起动画卡顿。</p>
<p>4、requestAnimationFrame</p>
<blockquote>
<p>与setTimeout相比，<strong>requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机</strong>。<br>具体一点讲<strong>，如果屏幕刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms</strong>，换句话说就是，requestAnimationFrame的步伐跟着系统的刷新步伐走。<br><strong>它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。</strong></p>
</blockquote>
<p><strong>总结一下，requestAnimationFrame有以下优势：</strong></p>
<p>1、CPU节能：使用setTimeout实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，<strong>完全是浪费CPU资源。而requestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统步伐走的requestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。</strong></p>
<p>2、函数节流：在高频率事件(resize,scroll等)中，为了防止在一个刷新间隔内发生多次函数执行，使用<strong>requestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。一个刷新间隔内函数执行多次时没有意义的，因为显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。</strong></p>
<p>3、兼容性：requestAnimationFrame 是专门为实现高性能的帧动画而设计的一个API，目前已在多个浏览器得到了支持，包括IE10+，Firefox，Chrome，Safari，Opera等，在移动设备上，ios6以上版本以及IE mobile 10以上也支持requestAnimationFrame，唯一比较遗憾的是目前安卓上的原生浏览器并不支持requestAnimationFrame，不过对requestAnimationFrame的支持应该是大势所趋了，安卓版本的chrome 16+也是支持requestAnimationFrame的。</p>
<p>4、<strong>requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。</strong></p>
<p>5、<strong>在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，会暂停渲染，保证我们设计的动画函数的每一次调用都对应着一次屏幕重绘，这当然就意味着更少的的cpu，gpu和内存使用量。</strong></p>
<p>像setTimeout、setInterval一样，requestAnimationFrame是一个全局函数<strong>。调用requestAnimationFrame后，它会要求浏览器根据自己的频率进行一次重绘，它接收一个回调函数作为参数，在即将开始的浏览器重绘时，会调用这个函数，并会给这个函数传入调用回调函数时的时间作为参数。</strong>由于requestAnimationFrame的功效只是一次性的，所以若想达到动画效果，则必须连续不断的调用requestAnimationFrame，就像我们使用setTimeout来实现动画所做的那样。<strong>requestAnimationFrame函数会返回一个资源标识符，可以把它作为参数传入cancelAnimationFrame函数来取消requestAnimationFrame的回调。</strong>怎么样，是不是也跟setTimeout的clearTimeout很相似啊。</p>
<p>所以，可以这么说，requestAnimationFrame就是一个性能优化版、专为动画量身打造的setTimeout，不同的是requestAnimationFrame不是自己指定回调函数运行的时间，而是跟着浏览器内建的刷新频率来执行回调，这当然就能达到浏览器所能实现动画的最佳效果了。</p>
<p>目前，各个支持requestAnimationFrame的浏览器有些还是自己的私有实现，所以必须加前缀，对于不支持requestAnimationFrame的浏览器，我们只能使用setTimeout，因为两者的使用方式几近相同，所以这两者的兼容并不难。对于支持requestAnimationFrame的浏览器，我们使用requestAnimationFrame，而不支持的我们优雅降级使用传统的setTimeout。<strong>下面我把它们封装一下，就能得到一个统一兼容各大浏览器的API了hhh</strong></p>
<h2 id="3、RequestAnimationFrame使用语法："><a href="#3、RequestAnimationFrame使用语法：" class="headerlink" title="3、RequestAnimationFrame使用语法："></a>3、RequestAnimationFrame使用语法：</h2><p>以下来自MDN：<br>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。<br>注意：若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调window.requestAnimationFrame()<br>当你准备更新动画时你应该调用此方法。这将使浏览器在下一次重绘之前调用你传入给该方法的动画函数(即你的回调函数)。回调函数执行次数通常是每秒60次，但在大多数遵循W3C建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。回调函数会被传入DOMHighResTimeStamp参数，DOMHighResTimeStamp指示当前被 requestAnimationFrame() 排序的回调函数被触发的时间。在同一个帧中的多个回调函数，它们每一个都会接受到一个相同的时间戳，即使在计算上一个回调函数的工作负载期间已经消耗了一些时间。该时间戳是一个十进制数，单位毫秒，最小精度为1ms(1000μs)。</p>
<blockquote>
<p>使用语法是window.requestAnimationFrame(callback);<br>callback参数表示下一次重绘之前更新动画帧所调用的函数(即上面所说的回调函数)。该回调函数会被传入DOMHighResTimeStamp参数，该参数与performance.now()的返回值相同。<br>它表示requestAnimationFrame() 开始去执行回调函数的时刻。<br> callback的返回值是一个 long整数，表示一个请求 ID ，是回调列表中唯一的标识（是个非零值），我们可以传这个值给window.cancelAnimationFrame()以取消回调函数。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">范例</span><br><span class="line"><span class="keyword">var</span> start = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'SomeElementYouWantToAnimate'</span>);</span><br><span class="line">element.style.position = <span class="string">'absolute'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!start) start = timestamp;</span><br><span class="line">  <span class="keyword">var</span> progress = timestamp - start;</span><br><span class="line">  element.style.left = <span class="built_in">Math</span>.min(progress / <span class="number">10</span>, <span class="number">200</span>) + <span class="string">'px'</span>;</span><br><span class="line">  <span class="keyword">if</span> (progress &lt; <span class="number">2000</span>) &#123;</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(step);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.requestAnimationFrame(step);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">这个API的调用很简单，如下所示：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">var progress = 0;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//回调函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function render() &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    progress += 1; //修改图像的位置</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (progress &lt; 100) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           //在动画没有结束前，递归渲染</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           window.requestAnimationFrame(render);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">//第一帧渲染</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">window.requestAnimationFrame(render);</span></span><br></pre></td></tr></table></figure>
<p>下面是一个小Demo:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        #box&#123;</span></span><br><span class="line"><span class="regexp">            background-color: rebeccapurple;</span></span><br><span class="line"><span class="regexp">            width: 100px;</span></span><br><span class="line"><span class="regexp">            height: 100px;    </span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>style&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div id="box"&gt;&lt;/</span>div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> duration = <span class="number">4000.0</span>;</span><br><span class="line">        <span class="keyword">var</span> startTime = <span class="number">-1.0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">currentTime</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> h1 = <span class="built_in">document</span>.getElementById(<span class="string">"box"</span>);</span><br><span class="line">            <span class="keyword">var</span> opacity = currentTime/duration;</span><br><span class="line">            h1.style.opacity = opacity;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">eachFrame</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> timeElapse = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()-startTime;</span><br><span class="line">            <span class="keyword">if</span>(startTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                startTime = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">                render(<span class="number">0.0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(timeElapse &lt; duration) &#123;</span><br><span class="line">                render(timeElapse);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="built_in">window</span>.requestAnimationFrame(eachFrame);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame(eachFrame);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="4、实战动画和处理兼容性的封装"><a href="#4、实战动画和处理兼容性的封装" class="headerlink" title="4、实战动画和处理兼容性的封装"></a>4、实战动画和处理兼容性的封装</h2><p>下面是对动画函数的封装，可以处理浏览器的兼容问题哈：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> lastTime = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">var</span> vendors = [<span class="string">'webkit'</span>, <span class="string">'moz'</span>, <span class="string">'ms'</span>, <span class="string">'o'</span>];</span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">var</span> x=<span class="number">0</span> ; x&lt;vendors.length ; ++x)&#123;</span><br><span class="line">		<span class="keyword">if</span> ( <span class="built_in">window</span>.requestAnimationFrame &amp;&amp; <span class="built_in">window</span>.cancelAnimationFrame ) &#123;</span><br><span class="line">   			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">window</span>.requestAnimationFrame = <span class="built_in">window</span>[vendors[x]+<span class="string">'RequestAnimationFrame'</span>];</span><br><span class="line">		<span class="built_in">window</span>.cancelAnimationFrame = <span class="built_in">window</span>[vendors[x]+<span class="string">'CancelAnimationFrame'</span>] || <span class="built_in">window</span>[vendors[x]+<span class="string">'CancelRequestAnimationFrame'</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">window</span>.requestAnimationFrame)&#123; </span><br><span class="line">		<span class="built_in">window</span>.requestAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">callback, element</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">var</span> currTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">			<span class="keyword">var</span> timeToCall = <span class="built_in">Math</span>.max(<span class="number">0</span>, <span class="number">16</span> - (currTime - lastTime));</span><br><span class="line">			<span class="keyword">var</span> id = <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">				callback(currTime + timeToCall);</span><br><span class="line">			&#125;, timeToCall);</span><br><span class="line">			lastTime = currTime + timeToCall;</span><br><span class="line">			<span class="keyword">return</span> id;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">window</span>.cancelAnimationFrame)&#123;</span><br><span class="line">		<span class="built_in">window</span>.cancelAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line"> 			clearTimeout(id); </span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>下面举个简单的例子来说明怎么运用requestAnimationFrame进行动画，下面的代码会将id为demo的div以动画的形式向右移动到300px，上手实践一下，为日后更复杂的动画打基础！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;div id=<span class="string">"demo"</span> style=<span class="string">"position:absolute; width:100px; height:100px; background:#ccc; left:0; top:0;"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">	var demo = document.getElementById('demo');</span></span><br><span class="line"><span class="regexp">	function rander()&#123;</span></span><br><span class="line"><span class="regexp">		demo.style.left = parseInt(demo.style.left) + 1 + 'px'; /</span><span class="regexp">/每一帧向右移动1px</span></span><br><span class="line"><span class="regexp">	&#125;</span></span><br><span class="line"><span class="regexp">	requestAnimationFrame(function()&#123;</span></span><br><span class="line"><span class="regexp">		rander();</span></span><br><span class="line"><span class="regexp">		/</span><span class="regexp">/当超过300px后才停止</span></span><br><span class="line"><span class="regexp">		if(parseInt(demo.style.left)&lt;=300)&#123;			</span></span><br><span class="line"><span class="regexp">			requestAnimationFrame(arguments.callee);</span></span><br><span class="line"><span class="regexp">		&#125;</span></span><br><span class="line"><span class="regexp">	&#125;);</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>




      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-思考用户登录的加密解密" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/04/13/%E6%80%9D%E8%80%83%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E7%9A%84%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"
    >思考用户登录的加密解密</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/04/13/%E6%80%9D%E8%80%83%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E7%9A%84%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/" class="article-date">
  <time datetime="2020-04-12T16:00:00.000Z" itemprop="datePublished">2020-04-13</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%8C%96/">网络安全与工程化</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<p>最近做项目用到了Axios中的CancelToken，对加密解密等用户鉴权场景比较好奇，一番学习实践后，总结如下哈：</p>
<h2 id="1、数据库存储上的加密解密："><a href="#1、数据库存储上的加密解密：" class="headerlink" title="1、数据库存储上的加密解密："></a>1、数据库存储上的加密解密：</h2><blockquote>
<p><strong>1. 单向hash（MD5）</strong></p>
</blockquote>
<p>1、单向的hash加密，以MD5和SHA算法为代表，这类做法比明文直接存储看起来要安全，但是如果在DB被攻破的时候，以目前计算机的算力加之黑客的各种技术手段，其实跟明文是差别不大的。<br>2、本科学习时，了解到密码学里面破解密码最笨的一种方法是暴力破解，随着目前计算机硬件的发展，带来计算能力的提升，每秒钟上亿次的hash计算已经不是问题，直接暴力破解几乎是分秒的事情。<br>3、另外与之相近的有一种字典表/彩虹表破解的手段，原理很简单，黑客们会把常见密码以及各种hash算法加密后的字符串整理到一个表中，因为只要是<strong>同一明文密码同一hash算法</strong>得出的值就是一样的，也就是说黑客不断完善整理的彩虹表可以用来任何MD5加密系统的破解，带着破解的DB用户MD5密码那一列信息，<strong>直接循环去select 明文 from 字典表/彩虹表 where 密文 = 密码</strong>，基本可以破解目前多数人设置的普通密码。</p>
<blockquote>
<p><strong>2. hash+盐</strong></p>
</blockquote>
<p> 1、早期为了改进单向hash的缺陷，为了让彩虹表失效，引入了盐，盐是随机生成的一个唯一字符串，连在明文密码后增强密码的随机性，然后再做hash得到的加密密文存储在DB中，这样一个是相同的密码存在db中的值就不同了，另一个是彩虹表也不会再起作用了。<br> 2、但是同样以目前计算机的算力，暴力破解也是分分钟的事情，因为为了校验密码的原因，我们一般会把这种方法生成的密码和盐一块存在DB中，明文+盐 hash= 密码。<br> 3、黑客在拿到盐和加密密码后，只需要用计算机不断去生成明文，然后计算就可以很快破解。这种方法是避免了彩虹表，但是暴力破解还是避免不了。<br>4、 这种情况类似于目前比特币挖矿，以目前矿机的算力挖矿，<strong>加之比特币不断增加hash碰撞难度</strong>，暴力破解确实越来越困难，比特币越来越稀有，但是随着量子高性能计算机的发展，未来可能比特币这种hash碰撞的难度也是分秒钟的事。</p>
<blockquote>
<p><strong>3. PBKDF2, BCrypt 或 SCrypt 算法</strong></p>
</blockquote>
<p>1、这类算法有一个特点，<strong>算法中都有个因子，用于指明计算密码摘要所需要的资源和时间，也就是计算强度</strong>。<br>2、计算强度越大，攻击者建立rainbow table越困难，以至于不可继续。这类算法也可以保证即使计算能力不断提高，只要调整算法中的强度因子，密码仍然不可能被轻易的攻破。 后台密码存储的安全，可使用BCrypt或SCrypt进行保证，将计算迭代次数调高，增加计算时间，从而防止彩虹表与字典攻击。</p>
<blockquote>
<p><strong>4、第三方密码存储服务商</strong></p>
</blockquote>
<p>1、如果一个系统对于密码存储的要求实在很高，比如说如果用户密码泄露会造成大量现金流失，损失是毁灭性不可逆的，那么可以考虑第三方密码存储服务商。<br>2、在欧美金融界以及电商界，许多早期的大型银行，信用卡，金融机构的线上密码存储，就使用了比较靠谱的第三方存储服务。<br>3、原因有两个：一方面是自身去开发维护一套复杂的密码存储系统成本可能比整个线上系统还要高，另一方面为了风险规避。</p>
<h2 id="2、实战总结："><a href="#2、实战总结：" class="headerlink" title="2、实战总结："></a>2、实战总结：</h2><p>1、密码最好是以不可还原明文的方式来保存。否则攻击数据库很容易造成巨大危害，尤其是在金融行业和电商行业。<br>2、通常利用哈希算法的单向性来保证明文以不可还原的有损方式进行存储。<br>3、这类方法的各个具体操作方式按安全性由低到高依次为：</p>
<p>A：使用自己独创的哈希算法对密码进行哈希，存储哈希过的值。</p>
<p>B：使用 MD5 或 SHA-1 哈希算法：MD5 和 SHA-1 已破解。虽不能还原明文，但很容易找到能生成相同哈希值的替代明文。而且这两个算法速度较快，暴力破解相对省时，建议不要使用它们。</p>
<p>C ：使用更安全的 SHA-256 等成熟算法，更加复杂的算法增加了暴力破解的难度。但如果遇到简单密码，用彩虹字典的暴力破解法，很快就能得到密码原文。</p>
<p>D：加入随机 salt 的哈希算法。</p>
<p>密码原文（或经过 hash 后的值）和随机生成的 salt 字符串混淆，然后再进行 hash，最后把 hash 值和 salt 值一起存储。<br>验证密码的时候只要用 salt 再与密码原文做一次相同步骤的运算，比较结果与存储的 hash 值就可以了。这样一来哪怕是简单的密码，在进过 salt 混淆后产生的也是很不常见的字符串，根本不会出现在彩虹字典中。salt 越长暴力破解的难度越大。</p>
<p>E：具体的 hash 过程也可以进行若干次叠代，虽然 hash 叠代会增加碰撞率，但也增加暴力破解的资源消耗。<br>就算真被破解了，黑客掌握的也只是这个随机 salt 混淆过的密码，用户原始密码依然安全，不用担心其它使用相同密码的应用。</p>
<p>上面这几种方法都不可能得到密码的明文，就算是系统管理员也没办法。对于那些真的忘了密码的用户，网站只能提供重置密码的功能了。</p>
<p>下面的 python 程序演示了如何使用 salt 加 hash 来单向转换密码明文</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`cpp</span></span><br><span class="line"><span class="string">import os</span></span><br><span class="line"><span class="string">from hashlib import sha256</span></span><br><span class="line"><span class="string">from hmac import HMAC</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def encrypt_password(password, salt=None):</span></span><br><span class="line"><span class="string">    """Hash password on the fly."""</span></span><br><span class="line"><span class="string">    if salt is None:</span></span><br><span class="line"><span class="string">        salt = os.urandom(8) # 64 bits.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    assert 8 == len(salt)</span></span><br><span class="line"><span class="string">    assert isinstance(salt, str)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if isinstance(password, unicode):</span></span><br><span class="line"><span class="string">        password = password.encode('UTF-8')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    assert isinstance(password, str)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    result = password</span></span><br><span class="line"><span class="string">    for i in xrange(10):</span></span><br><span class="line"><span class="string">        result = HMAC(result, salt, sha256).digest()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return salt + result</span></span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">这里先随机生成 <span class="number">64</span> bits 的 salt，再选择 SHA-<span class="number">256</span> 算法使用 HMAC 对密码和 salt 进行 <span class="number">10</span> 次叠代混淆，最后将 salt 和 hash 结果一起返回。</span><br><span class="line"></span><br><span class="line">使用的方法很简单：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">hashed = encrypt<span class="constructor">_password('<span class="params">secret</span> <span class="params">password</span>')</span></span><br><span class="line">下面是验证函数，它直接使用 encrypt_password 来对密码进行相同的单向转换并比较</span><br><span class="line"></span><br><span class="line">def validate<span class="constructor">_password(<span class="params">hashed</span>, <span class="params">input_password</span>)</span>:</span><br><span class="line">    return hashed<span class="operator"> == </span>encrypt<span class="constructor">_password(<span class="params">input_password</span>, <span class="params">salt</span>=<span class="params">hashed</span>[:8])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> validate<span class="constructor">_password(<span class="params">hashed</span>, '<span class="params">secret</span> <span class="params">password</span>')</span></span><br><span class="line">虽然只有简短几行，但借助 python 标准库帮助，这已经是一个可用于生产环境的高安全密码加密验证算法了。</span><br></pre></td></tr></table></figure>

<h2 id="3、-密码传输问题"><a href="#3、-密码传输问题" class="headerlink" title="3、 密码传输问题"></a>3、 密码传输问题</h2><p>学习总结了密码的存储问题，接下来再记录一下密码的传输问题，好好消化，为以后工作打下坚实基础，感谢一面小姐姐，我会继续深入思考！</p>
<p>对于在线系统，密码的传输要经过下面几个步骤：</p>
<blockquote>
<p>用户在浏览器中输入原始密码：键盘 ——&gt; 操作系统 ——&gt; 浏览器内存<br>程序对原始密码进行转换：内存中的原始密码 ——&gt;内存中的转换后的密码<br> 转换后的密码在线上传输：内存中转换后的密码 ——&gt; 网络 ——&gt; 系统<br>这其中每一步都可能泄露原始密码，当然也有相应的保护措施。</p>
</blockquote>
<p>千里之行始于足下，接下来让我一步步剖析！:</p>
<blockquote>
<p><strong>用户输入密码</strong></p>
</blockquote>
<p>常用的攻击方法包括：</p>
<p>1、偷看输入的密码</p>
<p>在公共场合输入密码很容易被偷看，例如使用 ATM 机取款的时候。输入密码时密码明文用 星号代替就是为了防止偷窥。<br>但这样正常用户也不能直接用眼睛确认输入密码是否正确，通常在设置新密码时就要输入两遍来确保输入无误。<br>iPhone 在这点做了改进，每输入一个密码字符先显示半秒钟的明文再转成 * 显示，鉴于使用 iPhone 虚拟键盘输入时，按错键的概率还是比较高的，这个折中也是在可用性和安全性上做了妥协。<br>还有些系统为了最大限度的防偷窥，在输入密码时屏幕没有任何输出，比如 Unix/Linux 的命令行登录界面。这样就连输入的密码长度都看不出来。</p>
<p>2、用木马程序记录键盘输入</p>
<p>现在比较流行的 QQ 或网络游戏的盗号就常用这种方式进行。安装杀毒软件来防盗号自不必说，还可以用屏幕软键盘输入密码，这样木马就记录不到键盘事件，只能通过分析鼠标点击和当时屏幕图象来破解密码。如果再进一步，软键盘的字符布局每次都随计产生，那就更加重了分析破解的难度。</p>
<p>3、感染应用程序或使用钓鱼手法，直接得到内存中的密码值</p>
<p>不管如何防范输入的过程，一旦密码到程序里，就会以明文的形式呈现在内存中，只要恶意软件模仿安全程序（或模仿网站的外观）直接套取密码就轻而易举。<br>现在出现的假 ATM 机诈骗也是这种手法的衍生。<br>还有一种，不是替换或模仿程序，而是用病毒感染原程序将内存中的值读到。<br>要防范这种攻击，必须要对原程序的完整性和合法性进行验证，只有在验证通过后，才能进行正常的登录交互操作。<br>这个验证可以用数字签名来实现。比如 Windows 10中所有微软的可执行文件都带有微软的数字签名。<br>在网站上则是 HTTPS 的验证。当然，这个验证过程还牵扯到人的判断，在社会工程学上，软件要配合一些强制的措施，才能保证人不会麻痹大意中招。<br>比如浏览器在访问非信任机构签发的数字签名的 HTTPS 站点时，会警告并且阻止用户进行访问。Windows 10 现在所有的驱动程序也都必须要有微软的数字签名才能运行。</p>
<blockquote>
<p><strong>密码转换</strong></p>
<p>原始密码会经过一些转换，才能在线上传输。这跟密码的存储类似。<br>直接传输密码明文是最不安全的。而用简单的可逆变换，或者固定密钥加密也只是增加了破解难度。<br>最好是每次服务器随机产生一个密钥，送给客户端进行加密。</p>
</blockquote>
<p>1、如果使用 HTTPS，那所有通过 SSL 通道的信息都经过了随机密钥加密。<br>2、HTTPS 虽然安全，可它最大的问题是性能。连接初始时密钥的协商是通过非对称加密的体系进行的，这会造成连接较慢（密钥协商好后的数据加密是纯耗 CPU 的工作，在现在的硬件条件下，并不是瓶颈）。<br>金融在线系统一般都使用 HTTPS ，但大部分在线应用出于性能的考虑，会选择使用 HTTP 交换随机密码的方式。<br>3、随机密钥由服务器生成并发送给客户端。客户端用此密钥将密码加密，送给服务器。这里不要求加密方法是可逆的。一个较安全的做法是客户端使用 MD5 或 SHA-1 算法对密码进行不可逆转换，再用密钥加密送到 Server。现在已经有很多 Javascript 的加密库可以在浏览器端进行这样的转换工作。</p>
<blockquote>
<p><strong>密码在线传输</strong></p>
</blockquote>
<p>1、使用 HTTPS 加密传输，HTTPS 对服务器性能要求高，也影响登录速度。一般用在高安全性的登录上面。Google 和微软的登录都强制使用 HTTPS 确保安全第一。使用随机密钥对密码进行变换后再传输，相对安全。密码明文很安全，但仍可能发生重放攻击。这种方式是性能和安全性的折中。一般的服务使用足亦。<br>2、不做任何修饰，直接将密码通过 HTTP 传输。这种方式实现起来非常简单，但却可能是对用户隐私和数据的不负责任。<br><strong>常用服务分析</strong><br>这里用抓包方式分析一下常用的网络服务的密码传输，看看它们在安全性方面做的如何：</p>
<p>网站    密码传输方式    安全性<br>bitbucket.org    HTTPS 加密传输    高<br>微软 live.com    HTTPS 加密传输    高<br>google.com    HTTPS 加密传输    高<br>csdn.net    HTTP Javascript 加密传输    中<br>javaeye.com    HTTP 明文传输    低</p>
<p>思考：登录网站时，输入登录名、密码，用抓包工具抓一下包就知道密码是否进行加密。<br>网站用的是https，为什么抓包用户名密码还是明文传输？<br>为什么站点使用了https加密之后，还是能够用firebug之类的软件查看到提交到的信息，密码显示的还是明文的?<br>学习之后找到答案：<br>这是因为:<br>1、https(ssl)加密是发生在应用层与传输层之间，所以在传输层看到的数据才是经过加密的，而我们捕捉到的http post，是应用层的数据，此时还没有经过加密。这些明文信息，其实就是你的本地数据。<br>2、加密数据只有客户端和服务器端才能得到明文，客户端到服务端的通信过程是安全的。<br>深挖：这样的话密码不是会被本地恶意软件截获么?<br>解决：银行电商等安全防护程度较高的网站，除了https加密外，还有安全控件加密，用户必须下载安全控件后才能输入密码。</p>
<blockquote>
<p><strong>加盐哈希</strong></p>
</blockquote>
<p> 这个方案也是大多数公司目前使用的方案，一般流程是将用户随机盐发送给客户端，客户端再使用SHA256(SALT+PASSWORD)计算之后将结果传送给服务器，服务器直接与数据库中的匹配。<br> <strong>至于哈希算法的话，普遍都采用MD5、SHA1、SHA256等算法。</strong><br> 加盐的方式也各不相同，<strong>比如在密码尾部、在密码中间、在密码头部增加随机盐，有的甚至会使用多次HASH。</strong><br>不仅如此，甚至可以每次用户设置密码的时候，都为每一个用户生成随机盐，并将随机盐与用户信息一并存储（有时为了混淆，最好将随机盐与密码分表存储，也不要起SALT之类的列名）如此相信即使攻破的数据库，想要破解用户密码也是相当困难的。<br>后续如果收到用户登陆请求，取出用户随机盐并通过相同的算法进行计算，将结果和数据库中密码相对比就可以判断用户密码是否输入正确。 <strong>由于摘要算法的不可逆性，其实一定程度上就限制了登陆过程中用户密码的传输方式。</strong></p>
<p><strong>解决方案：</strong></p>
<blockquote>
<p>使用复杂些的HASH算法，例如MD5(SALT + MD5(C-SALT +PASSWORD))，C-SALT可理解为服务器固定的盐，此处仅仅是为了使破解者的字典更难构造一些。<br>如此客户端只需要将MD5(C-SALT+PASSWORD)的值发送到服务器，服务器再将随机盐取出，进行MD5即可。<br>更高级别的安全需要建议可使用SHA256来替代。 </p>
</blockquote>
<p>方法一<br>1、服务器端存储密码为Hash(Random-Salt + Hash(Constant-SALT + Pasword))<br>2、客户端传输密码为Hash(Constant-SALT + Password)<br>3、Random-Salt为用户的随机盐，每个用户均不同，服务器端收到客户端的hash密码后，在将其与用户随机盐一起Hash运算，从而将结果与数据库存储值相比较。<br><strong>优点</strong>：数据库存储的密码经过两层哈希，且其中包含了固定盐和用户随机盐，安全性较高。<br><strong>缺点</strong>：客户端传输的密码虽然经过了一层哈希，但是使用固定盐值，因此相同密码生成的结果均一致，容易收到重放攻击。<br>方法二<br>1、服务器端存储密码为Hash(Constant-SALT + Pasword)<br>2、客户端传输密码为Hash(Random-Salt + Hash(Constant-SALT + Password))<br><strong>Random-Salt为每次进入登陆页面时生成的随机盐，此处主要是为了防止重放攻击。<br>服务器收到客户端上传的hash之后的密码，根据用户ID取出服务器存储的密码，并通过与之前返回客户端的Random-Salt（可存储于Session中）进行Hash运算，从而与客户端上传的密码进行比较。</strong><br><strong>优点</strong>：客户端有效的防止了重放攻击<br><strong>缺点</strong>：在前端代码中，固定盐值暴露，一旦后台数据库被攻破，用户密码信息将有危险。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/" rel="tag">前端安全</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E9%89%B4%E6%9D%83/" rel="tag">用户登录鉴权</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-短视频流量大战的四大法宝——精准产品定位、打磨垂直内容、完善监管激励、优化创新服务" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/04/03/%E7%9F%AD%E8%A7%86%E9%A2%91%E6%B5%81%E9%87%8F%E5%A4%A7%E6%88%98%E7%9A%84%E5%9B%9B%E5%A4%A7%E6%B3%95%E5%AE%9D%E2%80%94%E2%80%94%E7%B2%BE%E5%87%86%E4%BA%A7%E5%93%81%E5%AE%9A%E4%BD%8D%E3%80%81%E6%89%93%E7%A3%A8%E5%9E%82%E7%9B%B4%E5%86%85%E5%AE%B9%E3%80%81%E5%AE%8C%E5%96%84%E7%9B%91%E7%AE%A1%E6%BF%80%E5%8A%B1%E3%80%81%E4%BC%98%E5%8C%96%E5%88%9B%E6%96%B0%E6%9C%8D%E5%8A%A1/"
    >短视频流量大战的四大法宝——精准产品定位、打磨垂直内容、完善监管激励、优化创新服务</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/04/03/%E7%9F%AD%E8%A7%86%E9%A2%91%E6%B5%81%E9%87%8F%E5%A4%A7%E6%88%98%E7%9A%84%E5%9B%9B%E5%A4%A7%E6%B3%95%E5%AE%9D%E2%80%94%E2%80%94%E7%B2%BE%E5%87%86%E4%BA%A7%E5%93%81%E5%AE%9A%E4%BD%8D%E3%80%81%E6%89%93%E7%A3%A8%E5%9E%82%E7%9B%B4%E5%86%85%E5%AE%B9%E3%80%81%E5%AE%8C%E5%96%84%E7%9B%91%E7%AE%A1%E6%BF%80%E5%8A%B1%E3%80%81%E4%BC%98%E5%8C%96%E5%88%9B%E6%96%B0%E6%9C%8D%E5%8A%A1/" class="article-date">
  <time datetime="2020-04-02T16:00:00.000Z" itemprop="datePublished">2020-04-03</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<blockquote>
<p>行业竞争激烈、人口红利见顶，在这场短视频流量大战中，如何打出漂亮一战？</p>
</blockquote>
<h2 id="行业背景调查"><a href="#行业背景调查" class="headerlink" title="行业背景调查"></a>行业背景调查</h2><p>1、TikTok（抖音海外版）在海外取得极大成功，对于其它视频应用产生了强烈冲击。此举招致了不少制裁，但也从一个侧面反映出TikTok在海外的影响力。据外媒报道，为了应对TikTok强势崛起，谷歌旗下视频网站YouTube将作出应对，并计划在今年年末推出名为Shorts的短视频功能，参与到TikTok的直接竞争中来。不过，与TikTok独立的APP模式相比，Shorts将成为YouTube主应用中的一部分，这或许会使Shorts的竞争力受到影响。</p>
<p>2、疫情当前，各大电影院都纷纷关门。流媒体似乎迎来了百年难得一遇的暖春，尤其是Netflix，凭借最为丰富的剧集资源库，在流媒体中称王，甚至将自己多部作品提前上线，吸取流量。下个月，又有一家全新平台入局流媒体——Quibi。Quibi ，Quickbites 的缩写，译为“速食”，这是一家还未上线便已获得十亿美元融资的短视频平台。 仅服务于手机端用户，内容专注于时下最热的短视频。Quibi的野心是成为「短视频界的Netflix」。在内容播放上，Quibi的每部剧集的总时长控制在2小时左右。</p>
<p>每集大约7-10分钟，每部约10-16集。至于更新频率——采用日更，每部剧每日更新一集。每隔一周就会有26个原创项目上线。这意味着每个礼拜都会有100来集短视频播出。当然，Quibi创办人杰弗里·卡森伯格也说了，“这不是短视频，而是一个个短视频章节组成的长视频。”他们想做的是“Quick bites. Big stories”，用一个零食时间，讲述大故事。</p>
<p>3、中新经纬客户端 4 月 2 日发布新闻，” 爱奇艺随刻版 “App 正式上线。爱奇艺对外宣称，” 爱奇艺随刻版 “App 是爱奇艺全新推出的海量精彩、多元化的综合视频社区产品，并要打造中国版的YouTube。随着 5G 和 AI 商用的发展，爱奇艺加入短视频赛道或许将给视频行业带来新的格局变化。爱奇艺创始人、CEO 龚宇认为，” 迄今为止，由于多种复杂因素的综合影响，YouTube 模式尚未在中国发展成规模，随着 5G 和 AI 技术的部署不断加强，类似 App 的市场潜力将在未来 2-3 年显著增长。为了抓住机遇，爱奇艺已开始做出初步的努力并投资建立规模化的业务模式。”</p>
<p>4、最近一段时间，正在内测的微信视频号引起了全行业的关注，诸多内容创作者纷纷开始研究微信视频号。一时间，微信视频号究竟会不会成为下一个风口，微信视频号能不能顺利突围，也成为大家热议的话题。视频号定位于“人人皆可创作的平台”，与朋友圈并驾齐驱，可见地位的重要性。它是微信的破圈——长短互补，强弱交织，蝴蝶效应，生态闭环——避免微信不被新生的短视频文化需求边缘化。猜想未来，视频号可能是所有市场中，唯一可以实现去中心化的、并且借助微信熟人社交链来打造电商基因 、金融科技、 闭环支付的短内容平台。毕竟，微信得天独厚的强大关系链牵动着十亿中国人的社交网络，这是其他APP望尘莫及的独特优势。</p>
<p>龙头齐聚，纷纷引发头脑风暴，打出自家品牌，如何才能脱颖而出呢？</p>
<p>笔者认为，以史为镜，可以知兴替，想要勇敢破圈、打出漂亮一战，</p>
<p>从产品定位的宏观策略上需要做好以下几点。</p>
<h2 id="精准产品定位"><a href="#精准产品定位" class="headerlink" title="精准产品定位"></a>精准产品定位</h2><p><strong>1、一切从用户出发，从用户中来，到用户中去。</strong></p>
<p>“水能载舟、异能覆舟”。水是用户，古往今来，得民心者得天下！比如汉武帝的成功、共产党的胜利、流芳百世的产品一定是为了满足用户的根本需求，在服务和体验上全身心为用户着想的产品。</p>
<p>抖音让你欲罢不能，为什么呢？全屏沉浸、精准分发、高清流畅、时髦新颖。（短视频）</p>
<p>微信不可替代，为什么呢？简单快捷、轻便舒适、不推销广告、自主订阅、功能齐全。（社交）</p>
<p>支付宝每天必开，为什么呢？花呗消费、余额盈利、风险投资、线下服务，一应俱全。（支付)</p>
<p>所有的成功，都来自合适的场景下，合适的满足了用户的迫切需求，并做到了这个领域的最佳应用体验。所以，流量不是目标，只是用户信任的附属品，赢得用户最根本、持续性的信任，才是高明之策！</p>
<p>互联网时代，从不缺人口和流量。我们缺啥？注意力和信任。注意力是招揽用户的法宝，信任是扩大生态的根本。</p>
<p><strong>2、深挖人性需求、细分使用场景。</strong></p>
<p>很多人说，微视没有打赢抖音，我们仔细去体验一下，真的是内容不好，设计不潮吗？</p>
<p>我想说，其实不是的，微视有自己的特色，主张探索和发现，提供自拍模板，其实也是腾讯的良心之作了。它是家庭影院，需要我们搬好小凳，拿好遥控器、和家人朋友互动，发掘自己的创造力，主打“创造、互动”。</p>
<p>抖音，凭借新潮的音乐和酷炫的节拍、场景，全身心为用户打造极致观看体验，不用用户思考，解放双手，它是3D影院，黑色环境下，你坐好就完事了，啥也不用管，我放啥你看啥，只要推荐算法精准，你肯定不想走，主打“沉浸、消费”。</p>
<p>从人性角度讲，用户是懒惰、贪婪的，所以，他们在巨大的工作、学习压力下想逃避现实的繁琐，选择了抖音，傻瓜式享受，人性所趋。</p>
<p><strong>总结一下，互联网时代，获取用户的两种方法：</strong></p>
<p>1、逃避现实，提供愉悦。打造虚拟世界快感，满足用户虚荣心、在虚拟世界找到更美更有钱更有权利的自己。</p>
<p>比如美拍、抖音、快手、全民K歌、王者荣耀、各大等级游戏。</p>
<p>2、直面现实、抵御恐惧、激励用户成长，跳出舒适圈、看清变化的世界、防止被世界抛弃。</p>
<p>通过线上打卡好友支持，坚持线上flag，目的是改变现实生活的自己，实现现实生活中在学习、工作上的实用价值，关注的是个人现实生活成长体验。</p>
<p>比如得到、微信读书、喜马拉雅、KEEP、薄荷健康、有道云笔记、英语流利说等各大教育机构APP。</p>
<p>下图是马斯洛的需求分级：<img src="https://img-blog.csdnimg.cn/20200403135554265.jpeg#pic_center" alt="在这里插入图片描述"></p>
<p>行业情况告诉我们，以上两种方式，各有玩法，就看怎么制定高级策略了，我认为区别有两点。</p>
<p><strong>提供快感、愉悦，快餐文化消费（最低层次的需求）</strong></p>
<p>1、提供快感（最低层次的需求）根源是逃避现实，是短期消费，利用碎片化时代用户的孤独和无聊情绪，最容易成功吸引，变现容易，但产品生命周期短，如果没有特点，只能昙花一现。</p>
<p>2、入门门槛低，但是不长久，比如，我身边玩抖音的人少了，因为新鲜感没有了。确实是这样，人是矛盾的，需求是动态的，上瘾是一时新鲜，如果没有现实生活的成长，很难长久。</p>
<p>2、一般靠群体实现，基于群体认同感，出发点是人关心虚拟世界中自己在群体中的地位。</p>
<p><strong>直面现实、抵御恐惧、长期习惯消费（自我实现的需求）</strong></p>
<p>1、根源是自我认同感。个人认同追求优越感，我们想要标新立异、想要出类拔萃，打卡、改变、去实现自我价值。</p>
<p>2、成功是上瘾的，当人通过努力获得了现实世界的超脱和破圈后，得到荣誉和赞赏，他会对成功上瘾。人性所趋，古往今来，不曾改变。</p>
<p>3、产品周期长，养成习惯难，但一旦过了缓冲期，产生数字资产的沉淀，用户就不会轻易放弃，用户黏度高。</p>
<p>比如，你写了很久的日记本，你不会轻易丢掉（文字积淀）；你谈了很久的男朋友，你舍不得忘不掉（情感积淀）；你的微信，不可能卸载（那里有您的社交关系链沉淀）。</p>
<p><strong>3、认清行业形势，把握合适时机。</strong></p>
<p>古语云：先下手为强。微视在很早就开始规划了，起了大早，却赶了晚集，可见市场、运营对产品的重要性。</p>
<p>产品从0到1 ，运营从1到100，好的产品是苗子，需要运营来及时呵护、养育，否则，很难茁壮成长。字节跳动的宣传和运营抢占了市场的先机，抖音先入为主，抢占了一部分用户的产品认知。</p>
<p>产品认知是很可怕的，甚至可以扭曲现实，一旦品牌深入人心之后，用户很难再去接受新的认知，尤其是相似性的同质化的产品。</p>
<p>所以，第一印象非常重要，这也是微信步步谨慎、每次改版都要深思熟虑的原理。</p>
<p>反思一下微博出品的绿洲，火不起来是因为没有达到精良设计时就横空出世，好牌也打乱了，很可惜。</p>
<p>所以最好的时机是合适，不是抢占更不是拖延。</p>
<p>因为，第一印象、决定了你在我心中的定位。比如，初次约会~</p>
<p>客观分析，这是市场决策的重要一环。以微视为例子：</p>
<p>2018年春节，腾讯微视通过QQ 走运红包合作发放微视礼包，新增数百万用户。黄子韬、刘昊然、张天爱、迪玛西等数十位明星助阵拜年并入驻微视。 [3]<br>2018年4月2日，腾讯微视发布2018年首次重大更新，推出三大首创功能，视频跟拍、歌词字幕、一键美型， [4]  并打通QQ音乐千万正版曲库，进行全面的品牌及产品升级。增加歌词字幕玩法，用户在选择背景音乐之后，录制视频时可选择显示歌词字幕，实现轻松跟唱。 [5]<br>2019年1月，微视在春节期间推出视频红包的创新玩法，从2月4日（除夕）00:00至2月6日（大年初一）24:00，共有7809万个视频红包在微信、QQ和微视里被领取。 [6-7]<br>2019年2月，微视上线测试个人视频红包玩法，用户可以通过微视制作视频红包，并且分享到微信和QQ，邀请好友领取。[8]<br>2019年4月，微视上线新版本，推出 “创造营助力”、“解锁技能”等全新模板。用户可通过微视的模板制作互动视频，并通过微信、QQ等社交平台分享给好友；好友可直接在微信、QQ里浏览该互动视频，并进行互动操作 [9]<br>2019年6月，微视开启了 30 秒朋友圈视频能力内测。用户在微视发布界面勾选“同步到朋友圈（最长可发布30秒）”按钮，即可将最长30秒的视频同步到朋友圈。<br>从上面的推广流程上看，腾讯也是大力扶持，花费了很多心思，可是还是晚了一点。<br>争夺大战中，规则有三点。<br>1、内容为王，多元全面，但垂直领域又足够精准优质。<br>2、创新为源，玩法新、巧、稀缺、有特色。<br>3、天时、地利、人和。</p>
<h2 id="打磨垂直内容"><a href="#打磨垂直内容" class="headerlink" title="打磨垂直内容"></a>打磨垂直内容</h2><p>现在各大视频主打娱乐、搞笑、影视、资讯，内容同质化严重。</p>
<p>很多内容型产品没有品牌意识，仍处于早期的用户和内容原始积累阶段，因此被克隆后并没有反抗能力。</p>
<p>产品是躯干、内容是血肉，需要产品本身的调性和机制去调节。总的来说、突出明确定位、品牌特色、</p>
<p>突出差异性和稀缺性，就是让用户只能来我们这看，别的地方没有，仅此一家！</p>
<p>其他APP比较泛滥，拿视频号说说我的看法。我认为主攻一下几点。</p>
<p><strong>视频号的垂直化领域区分：</strong><br>1.<strong>基于哲学</strong>：一个基于特定文化或者主题来交流、互动并持续产生内容的空间，简称“同好互动空间”。<br>弱关系社区中，关键是你对和你建立联系的事物，是否产生了感应。比如点赞、评论、分享等互动操作。<br>类比视频版的知乎，缩略般的B站、去中心化版的微博。<br>意义：<br>一部基于物的生活知识的百科全书（好物推荐、种草合集、生活小常识）、一部基于人的经验分享和情感解惑（关乎学习、职场、恋爱）。<br>2.<strong>基于个人</strong>：记录自己，记录世界，记录自己与世界的联系。重要的是减小朋友圈发文的人设压力，在陌生人关系中大胆释放自己。<br>意义：<br>记下生活的灵感和感动，类比个人精炼的成长日记，关乎生活的辛酸苦辣，关乎个人成长历程、心路轨迹。<br>（游戏规则是带有个人简介，我们要清晰自己的定位，也是帮助我们找到自己的差异化优势和稀缺性特质）<br>3.<strong>基于品牌</strong>：记录中小型企业生产品牌的流程，全程拍摄品牌打造、精雕细琢的细节，传达企业的真诚和品牌的优质，让用户亲眼可见、增强对企业的关注度、对品牌的认知度。比如现有的内测的钻石、服装、无人机产业。<br>意义：<br>对于品牌，打通公众号宣传、小程序直播、实现商业化变现的通道。<br>对于用户，真实、快速、立体、全面感知产品的差异化优势，丰富知识面，扩展视野格局，更方便更快速买到更放心的优质产品。<br>4.<strong>基于媒体</strong>：记录时事热点、媒体资讯、关乎天下大事、家国情怀。<br>意义：<br>为社会热点留白，等待时机造势，当媒体活动宣发时，这是很好的流量入口 。<br>（说不定下一个微信红包的热点降临、健康码、出行公交码的热潮会借助视频号来引爆支付产业瓜分半壁江山)。</p>
<h2 id="完善监管激励"><a href="#完善监管激励" class="headerlink" title="完善监管激励"></a>完善监管激励</h2><p>社区监管和激励体系是为了引导内容生产者不去产出同质化内容。</p>
<p>1、<strong>激励是赏</strong>、对创作者的原创内容进行精神鼓励和物质奖励，精神鼓励来自朋友和陌生人的关注、点赞、评论，人都有攀比心和虚荣心，精神奖励甚至超乎了物质奖励。</p>
<p>2、物质奖励来自更多特权和升级，助力创作者升级，当粉丝达到一定数量赋予特权、平台给予更多推送机会、曝光率、传播量、扩大个人影响力。</p>
<p>3、对创作者本人来说，以上措施激发更多创造。对同行业的人来说鼓励原创、激发新鲜点子，类似学校里面的年级排名、职场中的评级等等，都是为了激励同行业的人去打开自己的创造源泉，拿出自己的绝活，拉开和同行人的差距，这样就发挥了每一个个体的创造力和想象力，我们平台方，只需要做好舞台背景、打好灯光，让人们去尽情表演吧，相信大众的创造力和想象力，这是一套完整的闭环法则。</p>
<p>4、<strong>监管是控</strong>，禁止同质内容、加大剽窃账号的惩罚力度，打击平台内侵犯版权的行为，对疑似剽窃的账号封禁、减少曝光机会、降低推送频率、降低等级。</p>
<p>5、禁止使用虚假的信息创建帐号、故意误导他人、干扰真实的平台数据以及其他弄虚作假的行为，保障平台每一个用户的核心利益。</p>
<p>6、<strong>鼓励原创</strong>，提倡分享优质的内容信息，向广大自媒体作者普及版权意识，要求内容不能是旧文、或者全网已有的传播的同质内容。</p>
<p>7、<strong>净化环境。</strong>不允许传播对他人有害、令人极度不适、不利于青少年身心健康等不良信息。禁止传播侵扰用户安宁、造成用户使用体验减损或者影响软件正常使用和运行的内容。</p>
<p>如频繁发送骚扰信息、垃圾信息、广告信息，过度营销或商业推广。</p>
<h2 id="优化创新服务"><a href="#优化创新服务" class="headerlink" title="优化创新服务"></a>优化创新服务</h2><p>用户体验包含了内容和形式。</p>
<p>例子：知乎主打问答模式、简书注重创作形式、爱奇艺推出5G  VR  360度旋转体验。</p>
<p>从内容和形式这两个维度入手，打造更有特色的体验才能塑造好产品的风格、调性、差异性，优化品牌意识。</p>
<p>具体可以从结构层的信息架构、框架层的信息设计、表现层的视觉设计入手。</p>
<p>以下是我的三点想法：</p>
<p>1、<strong>载体上</strong>：找到合适的形式。比如文字、图片、语言、视频，各种形式可以主打或者组合。</p>
<p>比如“得到”推荐音频、B站长视频、视频号一分钟短视频、知乎文字、朋友圈图文。</p>
<p>2、<strong>分发上：</strong>确定算法推荐、热点搜索、个性化推荐还是主动订阅。这个比较复杂，以后专门谈。</p>
<p>3、<strong>互动形式上</strong>：深挖用户场景和习惯，不一样的互动形式会打造不同使用体验。</p>
<p>比如：快手双击666，新浪微博站内转载、视频号折叠评论等等。</p>
<p>4、<strong>播放形式上</strong>：瀑布流怎么布局，全屏还是小屏、评论是否隐藏、5G  VR怎么利用。</p>
<p>比如：</p>
<p>快手双列信息流，因为算法推荐更关注了长尾小号，所以怕用户不喜欢，分发不精准，采用双列让用户多了选择，减小平台的分发误判率。</p>
<p>抖音全屏体验，因为算法精准，平台分发定位准确，误判率小，所以不用担心用户不喜欢当前视频，主打观看体验。</p>
<p>视频号：中间区域播放，不支持暂停，分割视频区域和评论区域，既可以评论互动又可以专注看视频。</p>
<p><strong>为什么不能暂停播放？</strong></p>
<p>1、<strong>从产品调性思考</strong>：因为内容短、精致、所以一分一秒都有干货，提醒用户节奏慢下来细细品味，提倡慢文化，与倍速对比，打造不同观看体验，也算是一个差异化特色。</p>
<p>2、<strong>从用户角度思考</strong>：若用户可以看完，说明他是感兴趣的，下次可以继续关注此类视频的动态，基于主动订阅的，用户有兴趣，所以不会影响体验，不会反感内容。假如不喜欢此类视频，可以取消关注，下次不再推送，所以更加精准了，很巧妙的办法。</p>
<p>3、<strong>从创作者思考</strong>：每一分每一秒都要高品质，否则用户取消关注，自己粉丝骤减，得不偿失。</p>
<p>4、<strong>从平台思考</strong>：无为而治，“看不见的手”，非常高明，让双方相互监管激励，可以说设计思维很缜密，很精心。</p>
<p>5、能不能结合VR打造立体观看体验呢？</p>
<p>6、横屏竖屏怎么设计？</p>
<p>7、基于中国人的生活规律和习惯，能否不同时间推荐不同视频？</p>
<p>“同城”和“附近的人”都是从空间角度思考，我们是不是可以从时间角度入手？</p>
<p>比如早上音乐类、中午美食类、晚上新闻资讯、职场干货类 。</p>
<p>以上是个人深入思考的想法，绞尽脑汁了，很喜欢头脑风暴，若有不足或疑虑，请大家多多交流指教。</p>
<p>视频号，<strong>未来可期，万物之上，希望至美！</strong></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E7%9F%AD%E8%A7%86%E9%A2%91%E6%80%8E%E4%B9%88%E5%81%9A/" rel="tag">短视频怎么做?</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E8%A7%86%E9%A2%91%E5%8F%B7%E6%80%9D%E8%80%83/" rel="tag">视频号思考</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-视频号—— 一部2020下凡人间的动态史记" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="2020/04/02/%E8%A7%86%E9%A2%91%E5%8F%B7%E2%80%94%E2%80%94%20%E4%B8%80%E9%83%A82020%E4%B8%8B%E5%87%A1%E4%BA%BA%E9%97%B4%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%B2%E8%AE%B0/"
    >视频号——一部2020下凡人间的动态史记</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="2020/04/02/%E8%A7%86%E9%A2%91%E5%8F%B7%E2%80%94%E2%80%94%20%E4%B8%80%E9%83%A82020%E4%B8%8B%E5%87%A1%E4%BA%BA%E9%97%B4%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%B2%E8%AE%B0/" class="article-date">
  <time datetime="2020-04-01T16:00:00.000Z" itemprop="datePublished">2020-04-02</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="categories/%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E8%A7%86%E9%A2%91%E5%8F%B7/">我眼中的视频号</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<blockquote>
<p>我一直由衷地崇拜张小龙老师，他是一片星辰大海，神圣而神秘。<br>这位华科电信系的“学长前辈”把善良、真理想到了极致，把简单、纯粹做到了极致。<br>他是上帝派落到凡间的天使，剖析犀利的视角，出谋划策、牵动宇宙。<br>他是时光洪流的掌舵人，引领标新立异的潮流，深挖特立独行的思考。<br>他是纷繁世态的独行侠，心怀普惠众生的悲悯，救济着每一个孤独的灵魂。<br>张小龙，传承中国龙人的基因、一颦一簇、一举一动、推动着时代的奇迹。</p>
</blockquote>
<h2 id="一、关于微信的个人思考"><a href="#一、关于微信的个人思考" class="headerlink" title="一、关于微信的个人思考"></a>一、关于微信的个人思考</h2><p>高山仰止,景行行止,虽不能至,心向往之。我知道，张小龙老师一直在路上思考，他的高度，我们无法抵达。<br>这篇文章构思了很久，其中可能有不太成熟的想法，但都是我深入思考的结晶。<br>这些文字就当做管窥蠡测一下我眼中的微信和视频号吧，我坚信微信的力量，坚信视频号的能量。<br>我始终认为，微信是一个艺术品。微信基于普惠理念发展出了工具、简单自然等产品哲学。<br>产品最深入人心的部分是认知，认知甚至可以扭曲现实，微信从真正意义上讲，改变了一个时代人的生活方式。<br>微信最初是为了提高通讯效率的一个工具，切入口足够垂直细分，从而很好的保护了自己，这为日后发展壮大，强大的地基和丰富的生态做足了铺垫。<br>白色象征干净、纯粹、人的出生就是一张白纸，白色泡泡象征每一个富有个性的人（因为每个人的DNA是不同的，人是基因、环境、角色的产物。）<br>绿色泡泡象征大自然的生态，它和谐、环保、包容、真实、承载着每一条人与人、人与物、物与物的连接。绿色泡泡的体积是更大的，因为人类征服不了自然，人类应该是大自然的敬畏者，白云飘飘，绿水青山，简单的意境，清新的格调，微信传达的是遥远山谷的一缕回音。<br>这轻轻的一声，敲响了十亿人沉沉的关系链。<br>微信的开屏首页，是苍茫星球中个体对万物的思考。时间不可逆，所有人类命运体最终都会走向必然，都将流向同一条河流。命运宿命论虽然悲哀却很真实。地心引力带着神秘的磁场运转着渺小的独立个体，构成庞大的社交网络。<br>熟人关系的朋友圈是一轮五彩斑斓的小圆圈，亲密无间的每分每秒循环播放，构成一个个闭环的圆圈广场。<br>陌生人关系的视频号，像极了蝶舞联翩的大蝴蝶，带着强IP属性的点点滴滴，散部在茫茫的星辰大海。<br>一强一弱，横纵交织，并驾齐驱，对立统一，这是多么和谐美好的设计。<br>微信，从盘古开天地的蛮荒时代降临，经历夸父逐日的兴衰荣辱，无数个十年后，它将直通浩瀚星海的宇宙。<br>个人设计的slogan提议：<br>微信视频号：拒绝蹉跎度日，记录朝花夕拾，人间贵在真实，你我载入历史。<br>微信支付：如影随形，安全经营，绿色贴心，福利降临。<br>微信读书：生活不止粗茶淡饭的琐碎，还有云淡风轻的诗和远方。<br>小程序：便捷生活的万花筒，疑难杂症的万金油。<br>搜一搜：世界日新月异，评论针尖利弊，掌舵风云资讯，天地与你同行。<br>附近的人：经纬交错，田园脉络，不用陌陌，桃花朵朵。<br>我眼中的产品：<br>你若盛开，清风自来；桃李不言，下自成蹊。<br>清风细雨，润物无声；上善若水，干净纯粹。<br>己所不欲，勿施于人；删繁就简，大智若愚。<br>从婴儿的视角观察，用哲人的大脑思考。<br>虚心求教，Stay  hungry，Stay  young。<br>从实践中总结的方法论：乔布斯Apple法则：<br>ambition–accumulation–persistence–prediction–learn–link–estimation–evaluation</p>
<h2 id="二、初识宇宙新物种——视频号大驾光临"><a href="#二、初识宇宙新物种——视频号大驾光临" class="headerlink" title="二、初识宇宙新物种——视频号大驾光临"></a>二、初识宇宙新物种——视频号大驾光临</h2><p><strong>产品定位：</strong><br>1、视频号定位于“<strong>人人皆可创作的平台</strong>”<br>2、微信作为一个基础的信息传递的工具或者说平台，任何一个不经意的动作，可能会引起信息洪流流向的变化。<br>3、微信的价值观是“再小的个体，也有自己的品牌”。<br>4、视频号是为了弥补当年短内容的失误。<br>5、微信是一个开放的平台，致力于提供给用户有价值的服务，来搭建一个动态的生态系统，从而消除中介、消除地理限制。<br>6、我们希望建造一个森林，而不是一座宫殿，而所有这一切实现的前提就是用户价值第一。<br><strong>表层现象</strong><br>1.仔细想想，我们是不是习惯了在朋友圈虚构好自己的人设？我们P图，精修，记录点滴美好，它是熟人社交中一张光鲜亮丽的名片，代表着我们的身份、地位和人设。<br>2.我们不敢轻易点赞，点在看，因为我们幻想着别人对我们的看法，“好看”文章的属性似乎反应了我们朋友圈人设的认知观，于是，我们变得小心翼翼了，害怕亲密的朋友发现了我们细腻的小心思，害怕隐私被揭开，害怕人设坍塌，形象受损，这一切的根源都是隐私风险和信任背书。不过，要知道任何表层需求上的驱动，剖析到底还是人性底层的驱动。<br><strong>深层需求分析：</strong><br>1.人作为一个社交动物，生而社交，但面对着如今充斥着焦虑和压力的社会，每个人都在极力逃避着那一颗社交压力的尘埃。<br>2.相对于社交产品或者IM工具的社交压力来说，陌生人社区产品逐渐成为了现代人缓解压力、寻找同好并获得兴趣满足的窗口。<br>3.根本渊源就是：马斯洛常说的，人性最底层的社交、尊重和自我实现的需求。<br><strong>人性角度：</strong><br>人性是两面的，一方面，我们贪婪，懒惰，迷恋舒适和稳定，基础物质的快乐来自规避风险，逃离现实。<br>另一方面，我们又渴望他人的赞赏和认可，为了荣誉和奖赏，我们诚惶诚恐，殚精竭虑，迫切打破舒适圈，刷新认知，走向新的台阶展现自己。<br><strong>精神层面：</strong><br>世界日新月异，如果不分年龄、性别、角色、人类最本质的需求是什么？<br>我认为，是恐惧。<br>世界太快了，它加速旋转，日夜不息，我们忙碌地从一座围城跳到另一座围城。<br>年轻时我们没有家室之累，无所畏惧，因为一无所有，所以能慷慨地舍弃一切。但我们恐惧被新鲜事物抛弃。到了中年，我们肩负老小，为谋生繁衍，奔波忙碌，劳耕累耘。我们恐惧贫穷、家庭破裂、事业风险。终于奋斗了很久，我们老了，然后被迫恐惧疾病和孤独。<br>总之，我们害怕自我更新的速度小于社会发展的速度，害怕被时代抛弃，害怕失去核心竞争力，于是我们产生了焦虑和恐惧 ，进而衍生了深层次的需求。它凌驾于安全、生理、社交、渴望被尊重、直接蹭升到自我实现的需求。<br><strong>现实层面：</strong><br>罗曼罗兰说：世界上只有一种英雄主义，那就是看清了生活的真相，但依然热爱它。<br>鲁迅说：真正的勇士敢于直面惨淡的人生，敢于正视淋漓的鲜血。<br>没错，人生本质上是不美好的，苦难是生命的常态，但我们依然可以在这个星球上猩猩相惜，肆意生长。<br>真正让我们快乐的，是克服重重险阻之后的喜悦，是破圈带给我们的蜕变。<br>基于上述人性角度的分析，人最珍贵的是清楚的认识自己，坦诚的记录自己，接受生活的真相和真实的自己，认清形势、珍惜当下。<br>所以，成长的酸甜苦辣，破圈的兴衰荣辱，都需要这样一个没有创作压力的平台。<br>以铜为镜，可以正衣冠；以史为镜，可以知兴替；以人为镜，可以知得失。<br>简单说，它就是一面干净的镜子，一把简单的工具，记录自己，记录世界，记录自己和世界的联系。它真实、便捷、随时可拍、触手可及。<br>对于每一个人来说，它好像我们的移动日记本，随时随地用视频记录自己的灵感和思考。从上帝视角观察，视频号就是一个个鲜活人物在茫茫星辰大海中一生的足迹呀，历史风云变幻，时代沧桑变迁，时代的巨轮承载了一代代人平凡又伟大的冒险，一代代鲜活的生命在这里上演人间的茶米油盐、爱恨情仇、辛酸苦辣、兴衰荣辱、这是一件多么美好、多少真实、多少有意义的流动数字资产啊！<br>我承认，这世上有数不完的艰辛、苦楚、失败与遗憾；总有平凡的人儿们喝着醍醐灌顶的烈酒，唱着声嘶力竭的热歌；偌大的星球上，形形色色，各行各业的人们穿梭在不同的轨道，企盼着平衡、探索着真理、追寻着真爱、万有引力很强大，生存法则很残酷，奋然前行，需要每一个平凡个体的勇气和信心！<br>肉体或精神的折磨，或许才是成熟的淬炼、成长的真相。<br>即使我们都是无名之辈，那又怎么样呢？世界很大，苦痛很大，但我们依然企盼着希望，带着茕茕孑立的孤独和猩猩相惜的点赞。<br>即使我们渺小如蝼蚁，那又如何呢？庞大的社交网络上，我们点头触碰，为千千万万平凡真实的VLOG热泪盈眶，为时空交错下心怀一致的赤诚与朝圣而欢呼雀跃！<br>多少年之后，我们的子孙后代，依然可以翻阅到我们的点点滴滴，它可能是简单平凡的日常琐事，也可能是阳春白雪的鸿篇巨著，但他们，都是我们曾经一分钟的感动啊，春夏秋冬，我们都曾真实记录过，年岁轮回，我们都曾认真体验过。<br>很多年之后，它们像罗马时代的墓碑一样，隐秘而神圣，这个大大的平台，跨越了岁月的交替和时空的变迁，多么伟大，多么难得。</p>
<p><strong>视频号的诞生原因：</strong><br><strong>行业背景：</strong><br>1.短视频产品在用户量和用户使用时长上的飞速增长。<br>2.弥补腾讯系在短视频领域的缺失，借助私域流量+公域流量弥补微视的遗憾。<br>虽然公众号本身，已是一个完整的内容生态，但其也存在明显的缺陷，它的属性，会带来一连串的诺米骨牌效应：<br><strong>强订阅关系—&gt;被动获取能力的缺失—&gt;低创作门槛的缺失—&gt;移动化创作方式的缺失—&gt;长尾内容的缺失—&gt;非人人可以创作的平台。</strong><br>因此，要依靠更大陌生人社交圈子的短视频，导流到公众号。<br>鼓励<strong>长尾作者</strong>去发挥创造力，提供视频号引流带来粉丝积淀和回馈变现，让有价值的服务普惠众生。<br>3、微信的理念其实是普惠，它重视的是人人都可用，而不是某个特定的群体。短视频降低了创作门槛，鼓励人人可创造有价值的内容。<br><strong>一句话定位视频号对微信生态的巨大意义：</strong><br>1.微信的破圈——长短互补，强弱交织，蝴蝶效应，生态闭环——避免微信不被新生的短视频文化需求边缘化。<br>2.唯一可以实现去中心化的、并且借助微信熟人社交链来打造电商基因 、金融科技、 闭环支付的短内容平台。<br><img src="https://img-blog.csdnimg.cn/20200402045437941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>视频号的分解单元</strong><br>基于特定文化或者主题来交流互动并持续产生内容的小标签话题<br><strong>视频号的整体框架：</strong><br>横向内容优质多元、百花齐放，兼顾高质量和正能量，垂直化领域足够深入，IP定位属性精准的陌生人社交网络<br><strong>与朋友圈相比，视频号的特点：</strong><br>1.位置于二级入口朋友圈下层，并驾齐驱，可见地址很重要！<br>2.打破熟人关系链，将交流的平台扩大到陌生人的领域。<br>3.实现强关系社交的转换，打开弱关系社交的大圈。<br>4.将微信的私域流量扩大到公域流量，完成微信生态的扩容。<br>5.降低创造长内容公众号的门槛，实现便捷、迅速记录当下生活点滴的机会。<br>6.打破过于隐秘的私人社交小圈，搭建社区大圈，增加模块的主题性、内容性、互动性。<br><strong>视频号的垂直化领域区分：</strong><br>1.<strong>基于哲学</strong>：一个基于特定文化或者主题来交流、互动并持续产生内容的空间，简称“同好互动空间”。<br>弱关系社区中，关键是你对和你建立联系的事物，是否产生了感应。比如点赞、评论、分享等互动操作。<br>类比视频版的知乎，缩略般的B站、去中心化版的微博。<br>意义：<br>一部基于物的生活知识的百科全书（好物推荐、种草合集、生活小常识）、一部基于人的经验分享和情感解惑（关乎学习、职场、恋爱）。<br>2.<strong>基于个人</strong>：记录自己，记录世界，记录自己与世界的联系。重要的是减小朋友圈发文的人设压力，在陌生人关系中大胆释放自己。<br>意义：<br>记下生活的灵感和感动，类比个人精炼的成长日记，关乎生活的辛酸苦辣，关乎个人成长历程、心路轨迹。<br>（游戏规则是带有个人简介，我们要清晰自己的定位，也是帮助我们找到自己的差异化优势和稀缺性特质）<br>3.<strong>基于品牌</strong>：记录中小型企业生产品牌的流程，全程拍摄品牌打造、精雕细琢的细节，传达企业的真诚和品牌的优质，让用户亲眼可见、增强对企业的关注度、对品牌的认知度。比如现有的内测的钻石、服装、无人机产业。<br>意义：<br>对于品牌，打通公众号宣传、小程序直播、实现商业化变现的通道。<br>对于用户，真实、快速、立体、全面感知产品的差异化优势，丰富知识面，扩展视野格局，更方便更快速买到更放心的优质产品。<br>4.<strong>基于媒体</strong>：记录时事热点、媒体资讯、关乎天下大事、家国情怀。<br>意义：<br>为社会热点留白，等待时机造势，当媒体活动宣发时，这是很好的流量入口 。<br>（说不定下一个微信红包的热点降临、健康码、出行公交码的热潮会借助视频号来引爆支付产业瓜分半壁江山)。</p>
<h2 id="三、对视频号的多维创新思考"><a href="#三、对视频号的多维创新思考" class="headerlink" title="三、对视频号的多维创新思考"></a>三、对视频号的多维创新思考</h2><p><strong>1、宣传视频号的小创意</strong><br>slogan: 拒绝蹉跎度日，记录朝花夕拾，人间贵在真实，你我载入历史。<br>1.还在抖音刷视频虚度光阴吗？临渊羡鱼，不如退而结网，来视频号提升自己吧！人生还有更独特的诗意和远方！<br>2.还在快手看直播吗？你想要的，视频号都有！精挑细选，有你好看~<br>3.还在知乎海淘干货、面经吗？视频版的浓缩精华，视频号等你来分享~<br>4.还在B站倍速播放卡槽点吗？慢一点，让我们享受一分钟的干货精华。<br>5.还在微博海量信息中大海捞针吗？这里有专属优质小圈，用料考究，视听盛宴等你来哦~<br>6.这是一部修身、齐家、治国、平天下的短视频版《资治通鉴》！<br>7.我们终将老去，来视频号沉淀您的即刻视频！。<br>8.沉淀前世今生的数字资产！<br>9.时光一去不复返，视频号里转一转。<br>10.人要怎么度过这一生？<br>当他回首往事的时候，他不会因为虚度年华刷抖音而悔恨，也不会因为碌碌无为逛淘宝而羞耻；<br>这样，在临死的时候，他就能够说：“我的整个生命和全部回忆都已经献给世界上最壮丽的事业———在视频号和陌生的你相遇。<br><strong>2、用户获取分析</strong><br>在国内内容类产品的发展史中，有两个产品在用户获取方面是异常彪悍的。<br>1、移动互联网初始萌芽的今日头条，在早期还享有移动互联网用户红利的时候，用性价比超高的大规模推广手段（手机厂商预装应用等）获取了大量用户，为整个头条系的产品积累了丰富的用户启动资源。<br>2、只用了27个月就成功上市的趣头条，主要针对的是下沉市场人群，通过金币激励体系疯狂地获取用户，硬生生地在巨头林立的内容资讯类产品中占据了一席之地。<br>事实上，绝大多数内容类产品在获取用户方面都是一个非常大的难题，毕竟现在获取一个用户的流量成本非常之高，从早期的1.5-2元／个，变成了现在20-50元／个。<br>如果一个产品本身的变现能力不行的话，它其实是没有办法大规模、可持续地去获取用户的。<br>但对视频号而言，用户获取却是相对而言简单许多的事情，毕竟这是一款坐拥10亿日活的产品，开了二级菜单给视频号导流，怕也是绝大多数互联网产品望尘莫及的一个数量级。<br>目前微信的策略：<br>1、将视频号的位置放置在「发现」中，紧随「朋友圈」之后，可以借助熟人朋友圈实现破圈。<br>2、内测阶段，微信的每一步都要稳扎稳打。上线方案，一起头脑风暴，集思广益。<br><strong>3、内容生态构建——差异性、稀缺性——与长内容公众号互补引流</strong><br>对于平台：<br>（1）微信是一个巨大的生态系统，我们只要提供一个平台，最基本的道具和框架，就是最好的方式，不要局限大家的认知、眼界、格局。<br>（2）把舞台留出来，灯光打上，让观众们激发无限创意和想象，交给观众去创造吧，我们要相信十亿中国人的发明创造。<br>（3）内容监管审核：关键在于保真、优质、定位精准、独特、新鲜、激发情感共鸣。<br>（4）社区建设注重具体场景，基于弱关系链、推荐生活VLOG、新闻热点资讯、科普知识、个人经验干货。<br>（5）减少娱乐、搞笑、剧情、走高端路线，打造温情故事、家国情怀、中国文化。<br><strong>（6）关注00后、10后Z世代文化和老年人喜闻乐见的生活视频，这是目前比较稀缺的两块内容区域。</strong><br>（个人建议，有待数据分析考量，出于重点打造差异化、空白区域切入的思路）</p>
<p><strong>4、内容生产模式</strong><br>（1）UGC用户群体庞大、真实记录生活VLOG、个人号定位精准简介、帮助用户更好认识自己、记录自我、世界、自我与世界的情感联系。UGC里有我们承受生活的苦难后获得的生长，有看清生活的本质但依然热爱生活的勇气，有不加滤镜、真实鲜活的自我。<br>（2）PGC里有专业精致的干货，有利用有限时间创造无限价值的方法，内容足够垂直化，优质化，涵盖了正能量明星背后的奋斗故事、优质行业博主光环背后的辛酸、自媒体创作者对于人生的深刻思考、中小企业品牌创造的精致打磨。这类视频用户粘性高，变现能力也最强。<br>（3）PUGC：优势互补、取其精华、去其糟粕。</p>
<p><strong>5、内容分发——筛选优质精准内容、提升用户体验</strong><br>内容类产品／平台的一个共同特点：<br>（1）首先平台本身必须是一个好的工具型产品，可低门槛地提供体验良好的工具供普通用户创作内容使用。<br>（2）平台要有一个<strong>良好的机制</strong>可以从海量的内容中筛选出优质的内容供用户消费。（真的很想来实习，自己主动研究了推荐算法，不过张小龙老师说不太推荐，主攻社交推荐，可能两者结合？应该要数据分析来解答）<br>（3）用户要有好的成长体验，能真正帮助用户在这里察看人生百态，获取有用资讯，实现自我价值转化和成长。<br>目前主流的内容分发模式有三个：算法推荐、社交推荐、用户订阅。<br><strong>张小龙老师的经典看法：</strong><br>几年前，我说过一句话，“推送改变世界，因为用户更懒了”。包括微信，也是基于推送的。<br>你收到的每一条消息，都被你把优先级排得比你要真正获取的信息的优先级更高一些。<br>那么，推送什么信息，决定了用户会看什么信息，决定了他在一个什么样的世界里。<br>这是一个我们要经常思考的问题，也是我们在努力的方向。所以，我很少说分发这个词，我觉得推荐可能更尊重一些。<br>“我们并不认为一个规则百分百确定的系统就好，相反，一个动态的、自我完善规则能够让系统获得动态稳定，整个系统可能是我们和第三方一起定义出来的。<br><strong>头条：算法推荐：协调过滤、召回排序</strong><br>优点:  全屏体验、精准分发。<br>缺点：马太效应、头部集中、中心化严重、社交关系难沉淀。<br>快手：均分算法推荐和社交推荐，基于同城构建社交。<br>优点：部分去中心化，关注下沉市场，从用户细分打造差异化。<br>缺点：内容上有质量风险，导致品牌调性下降。<br>微信：未知，我猜想通过<strong>用户自主关注、社交推荐、个性化推荐</strong>等多种方式，展示更丰富优质、用户更感兴趣的内容。<br>张小龙老师主张推荐，他主张技术的背后是人，更注重朋友之间的信任背书（比如微信读书）<br>优点：强社交属性、特有私域流量<br>我的一点小思考：<strong>快手有同城推荐，是基于地域的，我们可不可以基于时间域呢？给内容打标签，让算法在时间域上加一些权重分配？</strong><br>原理：中国人喜欢晚上看新闻、中午看娱乐缓解工作压力、英国人下午4点甜点喝茶、妈妈辈喜欢晚上广场舞、职场人喜欢晚上看看书<br><strong>从用户角度思考：</strong><br>1、视频号真好玩，不同时间知道我想做不同的事情，难道会读心术？<br>2、哎呀，六点了，视频号有没有我想看的新闻？<br>3、中午打开视频号，看看种草推荐吧，嘻嘻，视频号懂我。<br>4、晚上结束了一天的工作，来点鸡汤激励一下自己吧，我想看看视频号有没有牛人干货技巧分享。<br>5、我的好朋友最近在朋友圈分享了很多优质视频，我去看看吧，不然下次聚会就OUT啦。<br><strong>6、商业变现</strong><br>方式：广告、电商、直播、游戏、会员等等。<br>方式选择：是否贴合产品的使用和服务场景，平台自身的产品定位、用户属性。<br>优势：<br>1、公众号和短视频互相倒流。<br>2、发送到朋友圈或者朋友，通过分享来传播。<br>3、下一步可能打开小程序？<br>想象一下，视频号+公众号+小程序+微信群+朋友圈可能带来微信生态的大繁荣 。<br>张老师语录：<br>1、如果不慢慢来，只会使得第一波进来的人作为一个红利滥用它的流量。<br>2、作为流量红利来用的人并没有创造价值，对用户没有好处，还对平台造成损伤。<br><strong>自我思考：</strong><br>1、视频号目前打通小程序做商业化可能是不太好的，<strong>流量是用户信任的附属品</strong>，当我们初次将产品传给用户认知时，应该本着一切从用户出发的角度，视频号首先是一个真实记录生活的平台，产品的初次认知和定位很重要 。<br>2、商业化不让用户反感的前提是用户金钱付出的成本足够承担带给用户的价值，如果我们目前还做不到，那就慢慢打磨。<br>3、互联网时代争取的不应该是流量，而应该是信任，信任是互联网的稀缺资源。<br>4、注意力也是互联网的稀缺资源，当我们拥有了差异性和稀缺性，我们就拥有了良好稳健的生态和护城河。</p>
<h2 id="四、关于社区文化的思考：社区三基石（文化、角色、内容）"><a href="#四、关于社区文化的思考：社区三基石（文化、角色、内容）" class="headerlink" title="四、关于社区文化的思考：社区三基石（文化、角色、内容）"></a>四、关于社区文化的思考：社区三基石（文化、角色、内容）</h2><p>社区从社会学的角度来谈，本质上是一个社会群体组织单位。当个人进入群体之后，理性、独立、客观等个人意识会逐步地被弱化，藏在群体之中，无意识的情况之下，群体意识会逐渐占据着心智上的主导地位，这种群体意识即社区意识。<br>群体意识可以给社区带来更强的凝聚力、更强的归属感等积极意义，也可能使社区陷入混论、盲目和无序，因此需要通过社区文化来引导和管理社区意识。<br>由此可见，文化对于社区来说十分重要。所以要想打造一个好的社区，必须先要有一个好的且强有力的文化作支撑。<br><strong>底层闭环逻辑：</strong><br>1、社区的定位决定了社区的文化，而社区的文化影响着社区角色的行为以及它们所生产和消费的内容。<br>2、内容作为文化的载体吸引着认同社区文化的用户进入社区。<br>3、用户使用这个产品，愿意留在这个社区的前提是认同社区的文化和价值。<br><strong>收益（社交红利）=信息×关系链×互动</strong><br><strong>•信息像肉</strong><br><strong>•关系链似骨</strong><br><strong>•互动则像血液一样造成流动</strong><br>自我思考：<br>1、用户的社交帐号中，都有或多或少的好友，这就是对关系链的简单理解。<br>2、用户们的好友对于企业而言是弱关系，但对于用户自身则是强关系。<br>3、强弱之间的影响力截然不同，只有用户主动分享和推荐，信任依附在流动的信息之上，关系链的力量才会充分爆发。<br>4、“互动”（评论和转发）的发生本身取决于“信息”文案质量，以及用户好友数量多寡和紧密程度。<br>5、互动也是最简单、最直接的激励，推动有价值的信息在人群中口口相传流动开来，形成口碑效应和病毒式的传播。<br>6、这个公式也可以凝练成一句话：“让信息在关系链中流动”，或者“让人们讨论你”。<br>7、对于实操中的企业而言，谋求建立一套持续、稳定、有效的分享体系/文化，则是在这个理解上可以采取的策略。<br>换句话说，是从基础、从每个细节、环节、流程开始的优化，牢牢地和社交网络结合起来。<br>不管是“信息”“关系链”“互动”，都是构建这套体系的最基础构件。<br>在日常工作中，企业对“信息”“关系链”“互动”三个环节的不同分解与侧重，衍生出不同风格。<br>8、强调信息的企业与创业团队，以策划和活动见长；强调大号的价值，微博营销多云集于此。<br>实际上，这些着力点，都是致力于构建一套有别于社交平台之外的第三方付费分享体系。<br>9、朴素的情感（炫耀、爱心、利己利他等）是引发作用差别的根本因素。<br>热点事件因此而起，人们围观、参与令自己开心或愤怒的事情，也由此产生了许多无聊的“自娱现象”。<br>10、当信息纵横流动开来，会将一个个原本分割独立的社交网络连成整体，论坛与微博、微信、QQ空间，在某种意义上成为同一事物的不同映射。<br><strong>1、让团队来建立强有力的社区明文化</strong><br> 从字面意思很好理解，明文化这就是摆在台面上的，社区所倡导的文化和氛围。<br>通常大家都认为明文化是由社区运营人员通过白纸黑字的形式来制定一套符合社区文化的行为规范而建立起来的，例如什么社区公告、圈子规范等。其实并不是这么简单，包括UI风格、活动专题、推荐机制等等都是在想用户传递社区的文化、价值和底线，明文化是由团队的每个人一同打造的。<br>明文化就如同社区里的法律一般，所有社区成员的言行举止都要受到明文化的约束，不遵守甚至使违规就会收到惩罚，它确保了社区机制的正常运行。<br><strong>2、让用户来养成社区的暗文化</strong><br> 如果说明文化是社区的法律，那么暗文化就是社区的道德。它是没有强制约束的，是社区群体意识下自主形成的产物，同时它也是一个社区是否充满活力的象征，也正是它的存在将社区成员和网络路人彻底隔绝开来。<br>互联网上古时期D吧的屌丝文化、或者是最近几年兴起的B站的弹幕文化等等这些都是暗文化的代表，当然暗文化最直白最浅显最具体的表现就是社区黑话，比如一星护体、刚下飞机、下次一定之类的，懂得就是社区人，不懂就是社会人。<br>所以成功的社区，光有明文化是不够的，还需要重视暗文化的养成。但是暗文化不像是明文化那样可以在一朝一夕建立起来的，而是需要运营小伙伴持续地经营，通过头部用户去示范去引导去带动，在潜移默化中慢慢建立起来。<br><strong>2、角色</strong><br>角色的内核实际上就是社区的用户，是社区组织下最小的有机单位。<br>在群体意识和社区文化的作用下，用户会无意识地陷入角色化，而社区角色化最重要的意义就是让用户之间自主地产生协同分工，来维持社区的正常运作和活力。<br>一个成熟的社区里不可能只有一种角色，角色越多恰恰是证明社区分工越为成熟。<br>为生产者提供工具，为消费者提供内容<br>内容生产者和内容消费者其实是一个社区众多角色中抽象出来最简单的两个角色。<br>顾名思义，内容生产者就是在社区里生产内容的用户，他们通过生产内容进行自我展示，得到其他用户的反馈，获得尊重和自我价值的实现，甚至可以获得实质的收益；<br>而内容消费者则是大多数普通用户，通过消费社区里的内容，来满足自己的需求，获取价值。当然两者之间可不是一分为二的绝对划分，会有一定的重合，正是两者之间的互动，使得社区焕发出活力。<br>对于内容生产者，要要尽可能降低他们内容生产的门槛，提供便利的内容创作的工具，让他们可以更加快捷地进行内容创作；<br>对于内容消费者，首先通过算法推荐或者社交推荐，将感兴趣的内容展示给他们，其次是通过内容的整合和分发，保证他们内容消费的连贯性，最后就是要注重他们内容消费的体验。<br><strong>注重KOL，更要注重KOC</strong><br>决定一个社区能够走多快的是它的KOL，但决定一个社区能走多远的是它的KOC。<br>对于任何社区来说，KOL的重要性都不言而喻，尤其是在社区的启动阶段，KOL可以在短期内为社区带来一大批忠实的流量，即便是社区的成熟期，KOL也可以稳定住社区流量的基本盘。<br>但是太过于依赖KOL，很容易造成社区被KOL所裹挟的局面，包括我自己负责的产品里也有前车之鉴。社区与KOL的两方博弈最终受伤的还是社区，而KOC这些腰部用户却是一股第三力量，有助于打破这种“零和博弈”的局面。KOC对于社区来说，首先它的基数大，其次它的潜力大，最关键的是在于社区的博弈中，KOC属于一种弱势，欠搭把手的状态，社区会有更多的话语权。<br>社区加上KOC自然要大于KOL。所以一个健康且成功的社区里，服务好KOL大佬的同时，需要把更多的帮助给予到KOC的成长之路中去。<br><strong>打造角色等级体系的上升通道</strong><br>上瘾模型中说，用户对于一款产品上瘾基本分为“触发-行动-赏酬-投入”四个步骤。从中可以看出，如果想让用户对社区进行脑力和体力的投入之前，需要让他们获得多变的赏酬，而角色等级体系或者特权体系就是一种最常见的精神赏酬方式。</p>
<p>不论是内容生产者还是内容消费者，只要是做出符合社区价值的行为，就可以获得对应的虚拟收益，虚拟收益可以累计成对应等级，让角色之间自然而然的出现等级差异，这样促使他们相互进行攀比、炫耀，去持续创造符合社区价值的内容，这对于社区的发展是非常有必要的。</p>
<p><strong>3、内容</strong><br>内容毫无疑问的是社区最重要的资产。有句话说“花钱是门学问”，同样的花好内容资产对于任何一个社区都是一门学问。<br><strong>没有时效性的内容最珍贵</strong><br>热点内容在短期内会对社区带来巨大的瞬时流量，但是具有时效性的命门，也让他的价值会随着时间推移很快就流失掉。<br>经常混迹不同社区的话，你会发现很多让你感慨“‘大清亡了”的内容，仍然对于比你年纪小的用户群体们充满着吸引力，有着不错的阅读量和互动量。<br>对于没有时效性要求的、非资讯类的社区而言，没有时效性的内容经得起沉淀，也更显珍贵。<br><strong>做好内容分层，明确内容主体</strong><br>对于任何一个内容而言，它都是有层次的，我们不能一概而论。举个例子，我发了一个动态，这就是这个动态的一级内容，那么有人评论了我，这就属于二级内容了，接着又有人回复了这条评论，这就属于这条动态的三级内容了。就这么简单地划分了三级内容，但要说明的一点就是不是每个社区都有三级内容，也不是每个社区只有这三级内容。<br>最关键的是不同的社区对于内容侧重的层级也可能是不一样的，这就产生了他们的内容特点，例如最右注重的是二级内容也就是常说的神论，而小红书的核心内容是它的一级内容。<br>所以在积累社区内容之前，我们必须要明确我们社区内容的主体在哪。<br><strong>内容生产需要看不见的手</strong><br>如果说内容生产者（侧重用户部分）是内容生产看得见的手，那么平台侧的内容生产就是那只看不见的手，特别是社区发展的初期，这只看不见的手尤为重要。<br>发挥平台的力量，主要有三种方式：</p>
<p>①内容搬运</p>
<p>社区从0到1，真的不是缺人，而是缺内容。社区的逻辑就是内容为王，只要有了内容，就一定可以找到消费你内容的用户，然后再分化出再创作内容的用户。</p>
<p>但是没有内容呢？那就得靠平台通过爬虫也好，人工也罢，去从外站搬运符合社区文化的内容过来完成内容资本的原始积累。像是最右，70%以上的内容都是官方或者用户进行搬运的。</p>
<p>②官方生产</p>
<p>官方生产的内容就其数量而言，相比于搬运的内容一定是少之又少的，主要是对于搬运内容的一个有效补充，但是就其内容价值而言，那就可能远高于搬运内容。</p>
<p>要注意的是，官方生产的内容不一定是要用官方账号去发表，更多地通过普通用户账号去发表，具有真实性、原创性、优质性，打造社区核心内容。</p>
<p>③活动引导</p>
<p>平台通过活动来引导、征集用户原创内容，这也是一个比较常见的社区内容生产方式。</p>
<p><strong>内容筛选“取精华弃糟粕”</strong><br>好了，基础的内容有了，那我们面对“河量”或者海量的内容，就要进行到下一步筛选内容了。<br>筛选的过程大致分为三个步骤：<br>首先可以通过机器过滤，把一些涉及到违法、色情、有害的内容过滤掉；<br>接着就是需要把不符合我们社区文化和价值的内容刨除掉；<br>最后就是要在剩余的内容里，通过智能算法或者人工筛选，把优质内容和普通内容区分开来分发，因此它们将会得到不同的流量灌溉。</p>
<p><strong>找到适合的节点去综合分发内容</strong><br>社区的内容分发要结合自身的特点，找到并设置合理的节点进行有效的内容分发，常见的节点有用户节点、关系节点、话题节点等等。<br>比如说你在外卖平台经常点炸鸡，就会给你推很多炸鸡的店铺，这就是基于用户行为的内容分发。再比如你关注了A，A点赞了某个内容，就将这个内容也推给你，这就是基于用户关系的分发。这里由于篇幅的关系也不展开来讲了。<br>除了分发的节点外，按照分发机制来划分的话，市面上最常见的就是算法分发和社交分发这两种。算法分发的好处不必多说，可能比你自己更了解自己，但坏处就是很容易形成信息茧房，而社交推荐因为基于社交关系，你和你的朋友之间的偏好有一定的差异，所以会让你看到很多新的差异化的内容，但弊端就是让你觉得推荐的不精准。<br>所以综合之下，算法分发与社交分发相结合，找到适合社区信息架构的节点去进行有效的内容分发是关键。</p>
<p><strong>根据内容价值进行合理排序</strong><br>内容排序的前提是内容价值的判断，通过价值来进行展示上的排序，就跟产品需求排优先级一样，价值越高越靠前。而社区内容的价值判断往往是基于用户的互动行为，比如说微博的转评赞，B站的一键三连，这都是基于用户行为对内容的价值和热度进行评判。<br>但是也不能只把价值高的放在前面，这样容易导致社区内容的马太效应严重，打击中小内容生产者的积极性，所以一般的内容排序规则是多个维度穿插在一起的，以此来降低单一维度的权重，实现一种合理排序。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E8%A7%86%E9%A2%91%E5%8F%B7/" rel="tag">视频号</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="page/2/">2</a><a class="page-number" href="page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="page/5/">5</a><a class="extend next" rel="next" href="page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2020
        Wangqiuxia
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    <aside class="sidebar">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="index.html"><img src="/images/ayer-side.svg" alt="爱产品，爱前端！"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="index.html">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%8A%80%E6%9C%AF/">小程序</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://shenyu-vip.lofter.com/" target="_blank" rel="noopener">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="https://v.xiumi.us/stage/v5/4IeLH/197507179" target="_blank" rel="noopener">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<script src="/js/share.js"></script>



<script src="fancybox/jquery.fancybox.min.js"></script>




<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['做一个有情怀懂产品的程序媛！','业精于勤荒于嬉！行成于思毁于随！','越努力越幸运'],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script>
  var ayerConfig = {
    mathjax: false
  }
</script>


<script src="js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=518895142&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>