<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    阿里面试总结（二）——认真剖析Promise |  爱产品，爱前端！
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="../../../../css/style.css">

  
<script src="../../../../js/pace.min.js"></script>


  

  

<link rel="alternate" href="atom.xml" title="爱产品，爱前端！" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content">
      <section class="outer">
  <article id="post-认真剖析Promise" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  阿里面试总结（二）——认真剖析Promise
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="" class="article-date">
  <time datetime="2020-04-13T16:00:00.000Z" itemprop="datePublished">2020-04-14</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../../../categories/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">阿里面试总结</a>
  </div>

      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">8.8k字</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">35分钟</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>今天面试官小姐姐问了一个很好的问题，Promise怎么异步转同步？<br>当时有点紧张想复杂了，下来好好梳理一下，小姐姐人很好，激发了小霞打下坚实基础，投身大前端的激情和动力，hhh，话不多说，<strong>追根溯源，脚踏实地，勤恳思辨就是学习最好的方法</strong>，路漫漫，加油干！</p>
<h2 id="一、同步异步场景需求剖析："><a href="#一、同步异步场景需求剖析：" class="headerlink" title="一、同步异步场景需求剖析："></a>一、同步异步场景需求剖析：</h2><p>1、RunAsync.add(new Task())//task1<br>    .add(new Task())//task2<br>    .add(new Task())//task3<br>    .start();<br>我们希望task1完成之后task2再启动，task2完成后task3再启动，也即异步串联。<br>2、把异步变成同步。<br>3、页面倒计时，10、9、8、7、6依次输出。<br>首先拆解一下题意，不能曲解了嘿嘿嘿，我当时就是紧张了，想到了Promise.all和Promise.race去解决多个并行任务，设计逻辑，判断返回函数的顺序的场景。其实我们要解决的是异步串联问题，也就是把异步变成同步，注意这里不要曲解字面意思哦。<br>让我娓娓道来！后来我又想了一个方法，除了.then异步串联，好像还可以用自动迭代去next()。目前想到这两种解决方案。<br>首先，什么是同步？什么是异步？</p>
<blockquote>
<p>字面误区：1、js单线程，同步操作任务，并非一起操作之意，而是你执行完了我再去执行；2、js异步操作任务，也并非是指在不同线程里做不同的事情。</p>
</blockquote>
<p><strong>本质理解：</strong>首页js的语言执行环境是单线程的，也就是一次只能完成一个任务，多个任务就必须按照时间先后排队，前面完成后才能完成后一个任务。这个是js的常规模式，也就也是同步操作任务。</p>
<p><strong>弊端：</strong>同步操作任务带来的问题是，只要一个任务执行时间过程，后面的任务都会排队等待，拖延整个程序的执行。<br>如：常见的浏览器假死很可能就是js任务执行时间太长导致。</p>
<p>为了解决同步操作带来的弊端，js语言增加了异步任务的操作模式：<br>1、当前任务可以携带回一个回调函数（当前任务执行时间过长，把需要提前执行的任务放在回掉中）。<br>2、可以利用setTimeout构建异步任务，让主逻辑优先执行，对于耗时间长的任务可以放在setTimeout中异步执行。<br>3、所以异步操作任务主要是改变了程序的正常执行操作顺序。<br>举个栗子吧！<br>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"1"</span>)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"2"</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"3"</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"4"</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"5"</span>)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>执行结果为：</p>
<p>1<br>5<br>2<br>3<br>4</p>
<p>那么大致的运行机制如下：<br>（1）在js主程序（单线程）上的同步任务形成了一个主任务执行栈。<br>（2）主线程之外还存在一个任务队列，这个队列存在一些按时间顺序存放的事件，<strong>如鼠标点击、计时触发等，主线程中每出现一个异步任务，任务队列就会增加一个异步任务的事件。</strong><br>（3）一般执行栈中的同步任务执行完毕，系统就会读取任务队列，看看哪些事件是可以执行的，一旦可以执行将进入执行栈开始执行，后面分析Generator再区别微任务和宏任务。<br>（4）不断重复以上动作。<br>严肃剖析一下：</p>
<p><strong>同步</strong>：百度的名词解释是： 同步指两个或两个以上随时间变化的量在变化过程中保持一定的相对关系。<br> 例如：你去饭店去吃饭。当你叫服务员点餐时，服务员正在别的桌服务，这时你要等待服务员，把别人的事情处理完成以后，才可以到你这服务。不能同时进行，是要有排队顺序的，所以会阻塞进程，简单的说，只有一条主任务工作。<br>总结：就是一个任务完成之后，才能执行下一个任务。我们可以将同步看成是单线的执行，即要么执行成功，要么执行失败，反正就是要返回一个结果，在没有得到这个结果之前什么都不干，就傻傻的等着。任务提交后不向系统交出控制权，持续等待。<br><strong>异步</strong>：执行一个任务的同时，中间去执行其它的事件，最终在回来执行这个任务，不连续，node最大的特点就是支持异步，例如：node虽然是单线程，但是CPU利用率非常高，它就是一个日夜不息的接单员，一直在流水线工作。其实这样好处也很多，不用处理开辟线程、销毁线程的任务，而且不用设计资源抢占、读写锁的问题，对I/O密集友好。<br>总结：异步则是当你的任务提交了之后，不用管任务的结果是什么，可以继续执行别的任务，任务提交后将控制权交予系统，系统可以进行其他任务的执行。<br>两者比较<br>1、同步的执行效率会比较低，耗费时间，但有利于我们对流程进行控制，避免很多不可掌控的意外情况。<br>2、异步的执行效率高，节省时间，但是会占用更多的资源，也不利于我们对进程进行控制。<br><strong>优缺点及使用场景</strong><br>异步优点<br>1、异步流程可以立即给调用方返回初步的结果。</p>
<p>2、异步流程可以延迟给调用方最终的结果数据，在此期间可以做更多额外的工作，例如结果记录等等。</p>
<p>3、异步流程在执行的过程中，可以释放占用的线程等资源，避免阻塞，等到结果产生再重新获取线程处理。</p>
<p>4、异步流程可以等多次调用的结果出来后，再统一返回一次结果集合，提高响应效率。</p>
<p><strong>异步使用场景：</strong></p>
<p>1、不涉及共享资源，或对共享资源只读，即非互斥操作。</p>
<p>2、没有时序上的严格关系。</p>
<p>3、不需要原子操作，或可以通过其他方式控制原子性。</p>
<p>4、常用于IO操作等耗时操作，因为比较影响客户体验和使用性能。</p>
<p>5、不影响主线程逻辑。</p>
<p><strong>同步优点：</strong></p>
<p>1、同步流程对结果处理通常更为简单，可以就近处理。</p>
<p>2、同步流程对结果的处理始终和前文保持在一个上下文内。同步是一步一步来操作，等待请求返回的数据，再执行下一步，那么一定会有一些情况，只有这一步执行完，拿到数据，通过获取到这一步的数据来执行下一步的操作。</p>
<p>3、同步流程可以很容易捕获、处理异常。</p>
<p>4、同步流程是最天然的控制过程顺序执行的方式。</p>
<h2 id="二、异步串联"><a href="#二、异步串联" class="headerlink" title="二、异步串联"></a>二、异步串联</h2><p>其实面试官小姐姐的答案就是：.then()来异步串联。<br>下面是我的思考和解答：<br>首先是一个简单版的手撸Promise:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">Promise</span><span class="params">(executor)</span></span>&#123; <span class="comment">//executor执行器</span></span><br><span class="line">    let self = <span class="keyword">this</span>;</span><br><span class="line">    self.status = 'pending'; //等待态</span><br><span class="line">    self.value  = undefined; <span class="comment">// 表示当前成功的值</span></span><br><span class="line">    self.reason = undefined; <span class="comment">// 表示是失败的值</span></span><br><span class="line">    <span class="function">function <span class="title">resolve</span><span class="params">(value)</span></span>&#123; <span class="comment">// 成功的方法</span></span><br><span class="line">        if(self.status === 'pending')&#123;</span><br><span class="line">            self.status = 'resolved';</span><br><span class="line">            self.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">function <span class="title">reject</span><span class="params">(reason)</span></span>&#123; <span class="comment">//失败的方法</span></span><br><span class="line">        if(self.status === 'pending')&#123;</span><br><span class="line">            self.status = 'rejected';</span><br><span class="line">            self.reason = reason;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    executor(resolve,reject);</span><br><span class="line">&#125;</span><br><span class="line">Promise.prototype.then = function(onFufiled,onRejected)&#123;</span><br><span class="line">    let self = <span class="keyword">this</span>;</span><br><span class="line">    if(self.status === 'resolved')&#123;</span><br><span class="line">        onFufiled(self.value);</span><br><span class="line">    &#125;</span><br><span class="line">    if(self.status === 'rejected')&#123;</span><br><span class="line">        onRejected(self.reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">module</span>.exports = Promise;</span><br></pre></td></tr></table></figure>
<p>使用方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let Promise = require('./m2.Promise');</span><br><span class="line">let p = <span class="keyword">new</span> Promise((resolve, reject) =&gt;&#123;</span><br><span class="line">          setTimeout(()=&#123;</span><br><span class="line">    resolve('zfpx')</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.then(function(data)&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"data"</span>,data)</span><br><span class="line">&#125;,function(err)&#123;</span><br><span class="line">  console.log('err',err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200413232504760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200413232526253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>观察这个例子，我来分析 一下Promise 的调用流程：</p>
<ul>
<li>Promise的构造方法接收一个executor()，在new Promise()时就立刻执行这个 executor 回调   </li>
<li>executor()内部的异步任务被放入宏/微任务队列，等待执行 then()被执行，收集成功/失败回调，放入成功/失败队列   </li>
<li>executor()的异步任务被执行，触发resolve/reject，从成功/失败队列中取出回调依次执行</li>
</ul>
<p>我理解这是个观察者模式，是一种收集依赖=》触发通知 =》取出依赖执行 的方式。<br>new Promise时（）会立即执行executor，并传入resolve和reject，由于他们是在executor内部被调用，所以要使用箭头函数去固定this指向，否则会找不到成功resolve之后的this.resolveQueue。<br>在 Promise 里，执行顺序是then收集依赖 ，异步触发resolve ， resolve执行依赖。then方法的回调里取到异步操作的返回值，then返回一个新的promise，分别对应状态改变的时候触发的回调，到了时间我们就返回Promise的结果，类似于依赖执行完毕。then方法可以被同一个promise调用多次，要实现这个功能，我们可以用一个队列来存储回调。<br>依此，我们可以勾勒出 Promise 的大致形状：其实就是一个单向变更的状态机，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">Promise</span><span class="params">(executor)</span> </span>&#123; <span class="comment">// executor是一个执行函数</span></span><br><span class="line">    let self = <span class="keyword">this</span>;</span><br><span class="line">    self.status = 'pending';</span><br><span class="line">    self.value = undefined; <span class="comment">// 默认成功的值</span></span><br><span class="line">    self.reason = undefined; <span class="comment">// 默认失败的原因</span></span><br><span class="line">    self.onResolvedCallbacks = []; <span class="comment">// 存放then成功的回调</span></span><br><span class="line">    self.onRejectedCallbacks = []; <span class="comment">// 存放then失败的回调</span></span><br><span class="line">    <span class="function">function <span class="title">resolve</span><span class="params">(value)</span> </span>&#123; <span class="comment">// 成功状态</span></span><br><span class="line">        if (self.status === 'pending') &#123;</span><br><span class="line">            self.status = 'resolved';</span><br><span class="line">            self.value = value;</span><br><span class="line">            self.onResolvedCallbacks.forEach(function (fn) &#123;</span><br><span class="line">                fn();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">function <span class="title">reject</span><span class="params">(reason)</span> </span>&#123; <span class="comment">// 失败状态</span></span><br><span class="line">        if (self.status === 'pending') &#123;</span><br><span class="line">            self.status = 'rejected';</span><br><span class="line">            self.reason = reason;</span><br><span class="line">            self.onRejectedCallbacks.forEach(function (fn) &#123;</span><br><span class="line">                fn();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executor(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123; <span class="comment">// 捕获的时候发生异常,就直接失败了</span></span><br><span class="line">        reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">resolvePromise</span><span class="params">(promise2, x, resolve, reject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有可能这里返回的x是别人的promise</span></span><br><span class="line">    <span class="comment">// 尽可能允许其他乱写</span></span><br><span class="line">    <span class="keyword">if</span> (promise2 === x) &#123; <span class="comment">//这里应该报一个类型错误，有问题</span></span><br><span class="line">        return reject(new TypeError('循环引用了'))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 看x是不是一个promise,promise应该是一个对象</span></span><br><span class="line">    let called; <span class="comment">// 表示是否调用过成功或者失败</span></span><br><span class="line">    if (x !== null &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123;</span><br><span class="line">        <span class="comment">// 可能是promise &#123;&#125;,看这个对象中是否有then方法，如果有then我就认为他是promise了</span></span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">// &#123;then:1&#125;</span></span><br><span class="line">            let then = x.then;</span><br><span class="line">            if (typeof then === 'function') &#123;</span><br><span class="line">                <span class="comment">// 成功</span></span><br><span class="line">                then.call(x, function (y) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">                    called = <span class="literal">true</span></span><br><span class="line">                    <span class="comment">// y可能还是一个promise，在去解析直到返回的是一个普通值</span></span><br><span class="line">                    resolvePromise(promise2, y, resolve, reject)</span><br><span class="line">                &#125;, function (err) &#123; <span class="comment">//失败</span></span><br><span class="line">                    <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">                    called = <span class="literal">true</span></span><br><span class="line">                    reject(err);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(x)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 说明是一个普通值1</span></span><br><span class="line">        resolve(x); <span class="comment">// 表示成功了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Promise.prototype.then = function (onFulfilled, onRjected) &#123;</span><br><span class="line">    <span class="comment">//成功和失败默认不传一个函数</span></span><br><span class="line">    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : function (value) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    onRjected = typeof onRjected === 'function' ? onRjected : function (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    let self = <span class="keyword">this</span>;</span><br><span class="line">    let promise2; <span class="comment">//返回的promise</span></span><br><span class="line">    if (self.status === 'resolved') &#123;</span><br><span class="line">        promise2 = <span class="keyword">new</span> Promise(function (resolve, reject) &#123;</span><br><span class="line">            <span class="comment">// 当成功或者失败执行时有异常那么返回的promise应该处于失败状态</span></span><br><span class="line">            <span class="comment">// x可能是一个promise 也有可能是一个普通的值</span></span><br><span class="line">            setTimeout(function () &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    let x = onFulfilled(self.value);</span><br><span class="line">                    <span class="comment">// x可能是别人promise，写一个方法统一处理</span></span><br><span class="line">                    resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.status === 'rejected') &#123;</span><br><span class="line">        promise2 = <span class="keyword">new</span> Promise(function (resolve, reject) &#123;</span><br><span class="line">            setTimeout(function () &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    let x = onRjected(self.reason);</span><br><span class="line">                    resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"> </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当调用then时可能没成功 也没失败</span></span><br><span class="line">    if (self.status === 'pending') &#123;</span><br><span class="line">        promise2 = <span class="keyword">new</span> Promise(function (resolve, reject) &#123;</span><br><span class="line">            <span class="comment">// 此时没有resolve 也没有reject</span></span><br><span class="line">            self.onResolvedCallbacks.push(function () &#123;</span><br><span class="line">                setTimeout(function () &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        let x = onFulfilled(self.value);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">            self.onRejectedCallbacks.push(function () &#123;</span><br><span class="line">                setTimeout(function () &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        let x = onRjected(self.reason);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 捕获错误的方法</span></span><br><span class="line">Promise.prototype.<span class="keyword">catch</span> = function (callback) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(null, callback)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解析全部方法</span></span><br><span class="line"><span class="comment">// let arr = [];</span></span><br><span class="line"><span class="comment">// arr[1] = 100;</span></span><br><span class="line"><span class="comment">// console.log(arr.length)</span></span><br><span class="line">Promise.all = function (promises) &#123;</span><br><span class="line">    <span class="comment">//promises是一个promise的数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise(function (resolve, reject) &#123;</span><br><span class="line">        let arr = []; <span class="comment">//arr是最终返回值的结果</span></span><br><span class="line">        let i = <span class="number">0</span>; <span class="comment">// 表示成功了多少次</span></span><br><span class="line">        function processData(index, y) &#123;</span><br><span class="line">            arr[index] = y;</span><br><span class="line">            <span class="keyword">if</span> (++i === promises.length) &#123;</span><br><span class="line">                resolve(arr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">            promises[i].then(function (y) &#123;</span><br><span class="line">                processData(i, y)</span><br><span class="line">            &#125;, reject)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只要有一个promise成功了 就算成功。如果第一个失败了就失败了</span></span><br><span class="line">Promise.race = function (promises) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise(function (resolve, reject) &#123;</span><br><span class="line">        <span class="keyword">for</span> (var i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">            promises[i].then(resolve,reject)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成一个成功的promise</span></span><br><span class="line">Promise.resolve = function(value)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise(function(resolve,reject)&#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成一个失败的promise</span></span><br><span class="line">Promise.reject = function(reason)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise(function(resolve,reject)&#123;</span><br><span class="line">        reject(reason);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">Promise.defer = Promise.deferred = function () &#123;</span><br><span class="line">    let dfd = &#123;&#125;;</span><br><span class="line">    dfd.promise = <span class="keyword">new</span> Promise(function (resolve, reject) &#123;</span><br><span class="line">        dfd.resolve = resolve;</span><br><span class="line">        dfd.reject = reject;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> dfd</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mjs</span></span><br><span class="line"><span class="keyword">module</span>.exports = Promise;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>显然.then()需要返回一个 Promise，这样才能找到 then 方法链式调用，所以我们会把 then 方法的返回值包装成<br>Promise。 .then()的回调需要顺序执行，我们要等待当前 Promise 状态变更后，再执行下一个 then 收集的回调，这就要求我们对 then 的返回值分类讨论。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Promise/A+规范的三种状态</span></span><br><span class="line">const PENDING = 'pending'</span><br><span class="line">const FULFILLED = 'fulfilled'</span><br><span class="line">const REJECTED = 'rejected'</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> &#123;</span></span><br><span class="line">  <span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">  constructor(executor) &#123;<span class="comment">//executor是异步任务，才可以先then收集回调，再返回resolve  reject的结果</span></span><br><span class="line">    <span class="keyword">this</span>._status = PENDING     <span class="comment">// Promise状态</span></span><br><span class="line">    <span class="keyword">this</span>._resolveQueue = []    <span class="comment">// 成功队列, resolve时触发</span></span><br><span class="line">    <span class="keyword">this</span>._rejectQueue = []     <span class="comment">// 失败队列, reject时触发</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span></span><br><span class="line">    let _resolve = (val) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span>   <span class="comment">// 对应规范中的"状态只能由pending到fulfilled或rejected"</span></span><br><span class="line">      <span class="keyword">this</span>._status = FULFILLED              <span class="comment">// 变更状态</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这里之所以使用一个队列来储存回调,是为了实现规范要求的 "then 方法可以被同一个 promise 调用多次"</span></span><br><span class="line">      <span class="comment">// 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">this</span>._resolveQueue.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> callback = <span class="keyword">this</span>._resolveQueue.shift()</span><br><span class="line">        callback(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现同resolve</span></span><br><span class="line">    let _reject = (val) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span>   <span class="comment">// 对应规范中的"状态只能由pending到fulfilled或rejected"</span></span><br><span class="line">      <span class="keyword">this</span>._status = REJECTED               <span class="comment">// 变更状态</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">this</span>._rejectQueue.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> callback = <span class="keyword">this</span>._rejectQueue.shift()</span><br><span class="line">        callback(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// new Promise()时立即执行executor,并传入resolve和reject</span></span><br><span class="line">    executor(_resolve, _reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">  then(resolveFn, rejectFn) &#123;</span><br><span class="line">    <span class="keyword">this</span>._resolveQueue.push(resolveFn)</span><br><span class="line">    <span class="keyword">this</span>._rejectQueue.push(rejectFn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面实现了then方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then方法</span></span><br><span class="line">then(resolveFn, rejectFn) &#123;</span><br><span class="line">  <span class="comment">//return一个新的promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">    <span class="comment">//把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span></span><br><span class="line">    <span class="keyword">const</span> fulfilledFn = value =&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">        let x = resolveFn(value)</span><br><span class="line">        <span class="comment">//分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">        x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把后续then收集的依赖都push进当前Promise的成功回调队列中(_rejectQueue), 这是为了保证顺序调用</span></span><br><span class="line">    <span class="keyword">this</span>._resolveQueue.push(fulfilledFn)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//reject同理</span></span><br><span class="line">    <span class="keyword">const</span> rejectedFn  = error =&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        let x = rejectFn(error)</span><br><span class="line">        x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._rejectQueue.push(rejectedFn)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试可以满足面试官姐姐提出的需求场景。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(res)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(res)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(res)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 1 2 3</span></span><br></pre></td></tr></table></figure>

<h2 id="三、-then方法的几点注意"><a href="#三、-then方法的几点注意" class="headerlink" title="三、 then方法的几点注意"></a>三、 then方法的几点注意</h2><p>1、jquery能实现链式调用靠的就是返回this，promise不能返回this，promise实现链式调用靠的是返回一个新的promise。调用then时要返回一个新的promise。<br>2、Promise 是用来执行异步操作的。但有时一个异步操作需要等其他的异步操作完成，这时候就可以使用then来做。<br>3、使用 promise.then + 递归的方法异步转同步，我一直理解then().then()是一个chain，每一个then会返回一个promise，然后往后面传。但是我今天跑了一段代码，没有按照这个顺序执行，可能和异常错误处理有关。<br>4、then是会返回一个promise对象，但是这个promise对象的this是你前一个promise的，如果你return 一个新的promise，this则是这个promise，所以后面的then需要依据第二个promise是否resolve，才决定是否执行相应的then。<br>5、<strong>then，catch都是同步方法</strong>，假设执行b=new Promise(func)后里面的异步操作，已经开始但可能未处理完，同步执行下去是运行b.then(a)，b.then(aa)，b.then(aaa)…，假设运行到b.then(aa)方法时异步操作仍未处理完，那么then函数就会把aa push到b里面的一个callbacks数组中，假设运行b.then(aaa)前异步操作完成，首先将异步结果赋值给b里的result变量，然后循环调用callbacks数组里存好的方法：a(result),aa(result)，执行完毕后再运行b.then(aaa)，此时判断异步已执行完毕，不用将aaa push到callbacks数组里，而是直接运行aaa(result)，真正原因是res()内部设置了一个延时执行回调，延时setTimeout的最小值，<strong>也就是说res才是异步的，</strong>由于这点异步时间，导致最后一例中a.then(a)将a函数存放到callbacks里了，导致顺序发生错误，可以试着将a.then(a)延时执行，这就和浏览器时间频率有关系了，想一想怎么在秒杀系统处理呢？<br>6、在new promise(fn)中，<strong>new出来的函数是同步的，但是 fn的res() 函数是异步的，会挂起线程</strong>，执行到then的时候，顺利执行then的代码块，只是把成功的回调函数放到了resovledCallbacks中，但是就算state修改完毕为solved的时候，5中提到的执行then（aaa）的时候也是会异步操作，也不是立即执行aaa， 因为then的内部实现方式根据promiseA规范中也是有一个settimeout 在延时器内部执行aaa的。<br>再举个具体栗子！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">loadImageAsync</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Promise(function(resolve, reject) &#123;</span><br><span class="line">           var image = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">           image.onload = function() &#123;</span><br><span class="line">               console.<span class="built_in">log</span>(<span class="string">"load"</span>);</span><br><span class="line">               resolve(image);</span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line">           image.onerror = function() &#123;</span><br><span class="line">               reject(new Error('Could not load image at ' + url));</span><br><span class="line">           &#125;;</span><br><span class="line">           console.<span class="built_in">log</span>(<span class="string">"change src"</span>);</span><br><span class="line">           <span class="function">function <span class="title">init_img</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               image.src = url;</span><br><span class="line">           &#125;</span><br><span class="line">           setTimeout(init_img,<span class="number">5000</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>loadImageAsync 用来异步加载图片. setTimeout 人为地延迟5秒加载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">loadImageAsync2</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Promise(function(resolve, reject) &#123;</span><br><span class="line">            var image = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">            image.onload = function() &#123;</span><br><span class="line">                console.<span class="built_in">log</span>(<span class="string">"2load"</span>);</span><br><span class="line">                resolve(image);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            image.onerror = function() &#123;</span><br><span class="line">                reject(new Error('Could not load image at ' + url));</span><br><span class="line">            &#125;;</span><br><span class="line">            console.<span class="built_in">log</span>(<span class="string">"2change src"</span>);</span><br><span class="line">            <span class="function">function <span class="title">init_img</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                image.src = url;</span><br><span class="line">            &#125;</span><br><span class="line">            setTimeout(init_img,<span class="number">1000</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>loadImageAsync2 也是用来加载图片，人为地延迟1秒。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var p = loadImageAsync('http://img02.tooopen.com/images/20141231/sy_78327074576.jpg');</span><br><span class="line">    p.then(function (img) &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">"1:"</span>+img.src);</span><br><span class="line">    &#125;);</span><br><span class="line">    var h = loadImageAsync2('http://img02.tooopen.com/images/20141225/sy_77944235469.jpg');</span><br><span class="line">    h.then(function (img) &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">"2:"</span>+img.src);</span><br><span class="line">    &#125;);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"wqx"</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到 图片2先加载， 然后加载图片1 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s = loadImageAsync('http://img02.tooopen.com/images/20141231/sy_78327074576.jpg');</span><br><span class="line">  s.then(function (img) &#123;</span><br><span class="line">      console.<span class="built_in">log</span>(<span class="string">"1:"</span>+img.src);</span><br><span class="line">      return loadImageAsync2('http://img02.tooopen.com/images/20141225/sy_77944235469.jpg');</span><br><span class="line">  &#125;).then(function (img) &#123;</span><br><span class="line">      console.<span class="built_in">log</span>(<span class="string">"2:"</span>+img.src);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>创建新的promise 对象 s，我在s 的then 成功回调函数中 去调用 loadImageAsync2 函数。</p>
<p>这样就保证了 加载图片2 之前先加载图片1。</p>
<p>这里注意的是第二个then 其实是loadImageAsync2 返回的promise 实例调用的。这样就保证了加载完毕图片再去打印图片的解释说明。</p>
<p><strong>还要注意的两点：</strong><br>1、值穿透：根据规范，如果 then() 接收的参数不是 function，那么我们应该忽略它。如果没有忽略，当 then()回调不为 function 时将会抛出异常，导致链式调用中断。<br>2、处理状态为 resolve/reject 的情况：其实我们上边 then() 的写法是对应状态为padding的情况，但是有些时候resolve/reject 在 then() 之前就被执行（比如Promise.resolve().then()），如果这个时候还把 then()回调 push 进 resolve/reject 的执行队列里，那么回调将不会被执行，因此对于状态已经变为fulfilled或rejected的情况，我们直接执行 then 回调。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">  then(resolveFn, rejectFn) &#123;</span><br><span class="line">    <span class="comment">// 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span></span><br><span class="line">    typeof resolveFn !== 'function' ? resolveFn = value =&gt; value : null</span><br><span class="line">    typeof rejectFn !== 'function' ? rejectFn = reason =&gt; &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(reason instanceof Error? reason.message:reason);</span><br><span class="line">    &#125; : null</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return一个新的promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span></span><br><span class="line">      <span class="keyword">const</span> fulfilledFn = value =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">          let x = resolveFn(value)</span><br><span class="line">          <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// reject同理</span></span><br><span class="line">      <span class="keyword">const</span> rejectedFn  = error =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          let x = rejectFn(error)</span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">this</span>._status) &#123;</span><br><span class="line">        <span class="comment">// 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行</span></span><br><span class="line">        <span class="keyword">case</span> PENDING:</span><br><span class="line">          <span class="keyword">this</span>._resolveQueue.push(fulfilledFn)</span><br><span class="line">          <span class="keyword">this</span>._rejectQueue.push(rejectedFn)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 当状态已经变为resolve/reject时,直接执行then回调</span></span><br><span class="line">        <span class="keyword">case</span> FULFILLED:</span><br><span class="line">          fulfilledFn(<span class="keyword">this</span>._value)    <span class="comment">// this._value是上一个then回调return的值(见完整版代码)</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REJECTED:</span><br><span class="line">          rejectedFn(<span class="keyword">this</span>._value)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、catch、all、race、finally方法"><a href="#四、catch、all、race、finally方法" class="headerlink" title="四、catch、all、race、finally方法"></a>四、catch、all、race、finally方法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.<span class="keyword">catch</span>()</span><br><span class="line"><span class="keyword">catch</span>()方法返回一个 Promise，并且处理拒绝的情况。它的行为与调用 Promise.prototype.then(undefined, onRejected) 相同。</span><br><span class="line"><span class="comment">//catch方法其实就是执行一下then的第二个回调</span></span><br><span class="line"><span class="keyword">catch</span>(rejectFn) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(undefined, rejectFn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise.prototype.finally() finally()方法返回一个 Promise。在 promise 结束时，无论结果是 fulfilled 或者是 rejected，都会执行指定的回调函数。在 finally 之后，还可以继续then。并且会将值原封不动的传递给后面的 then。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//finally方法</span></span><br><span class="line">finally(callback) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    value =&gt; MyPromise.resolve(callback()).then(() =&gt; value),   <span class="comment">// MyPromise.resolve执行回调,并在then中return结果传递给后面的Promise</span></span><br><span class="line">    reason =&gt; MyPromise.resolve(callback()).then(() =&gt; &#123; <span class="keyword">throw</span> reason &#125;)  <span class="comment">// reject同理</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise.resolve() Promise.resolve(value)方法返回一个以给定值解析后的 Promise 对象。如果该值为 promise，返回这个 promise；如果这个值是 thenable（即带有”then” 方法)），返回的 promise 会“跟随”这个 thenable 的对象，采用它的最终状态；否则返回的 promise 将以此值完成。此函数将promise 对象的多层嵌套展平。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态的resolve方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">resolve</span><span class="params">(value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(value instanceof MyPromise) <span class="keyword">return</span> value <span class="comment">// 根据规范, 如果参数是Promise实例, 直接return这个实例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(resolve =&gt; resolve(value))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise.reject() Promise.reject()方法返回一个带有拒绝原因的 Promise 对象。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态的reject方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">reject</span><span class="params">(reason)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; reject(reason))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise.all() Promise.all(iterable)方法返回一个 Promise 实例，此实例在 iterable参数内所有的 promise 都“完成（resolved）”】或参数中不包含 promise 时回调完成（resolve）；<br>如果参数中promise 有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败 promise 的结果。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态的all方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">all</span><span class="params">(promiseArr)</span> </span>&#123;</span><br><span class="line">  let index = <span class="number">0</span></span><br><span class="line">  let result = []<span class="comment">//放在数组中</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">    promiseArr.forEach((p, i) =&gt; &#123;</span><br><span class="line">      <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">      MyPromise.resolve(p).then(</span><br><span class="line">        val =&gt; &#123;</span><br><span class="line">          index++</span><br><span class="line">          result[i] = val<span class="comment">//保证顺序到达</span></span><br><span class="line">          <span class="comment">//所有then执行后, resolve结果</span></span><br><span class="line">          <span class="keyword">if</span>(index === promiseArr.length) &#123;</span><br><span class="line">            resolve(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        err =&gt; &#123;</span><br><span class="line">          <span class="comment">//有一个Promise被reject时，MyPromise的状态变为reject</span></span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise.race() Promise.race(iterable)方法返回一个 promise，一旦迭代器中的某个 promise解决或拒绝，返回的 promise 就会解决或拒绝，找到最先完成的那个任务，数组中有一个完成就返回，没有顺序之分，看完成的速度。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">race</span><span class="params">(promiseArr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">    <span class="comment">//同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span></span><br><span class="line">    <span class="keyword">for</span> (let p of promiseArr) &#123;</span><br><span class="line">      MyPromise.resolve(p).then(  <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">        value =&gt; &#123;</span><br><span class="line">          resolve(value)        <span class="comment">//注意这个resolve是上边new MyPromise的</span></span><br><span class="line">        &#125;,</span><br><span class="line">        err =&gt; &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、Generator的秘密"><a href="#五、Generator的秘密" class="headerlink" title="五、Generator的秘密"></a>五、Generator的秘密</h2><p>下面这个代码可能就是面试官姐姐的问题初衷吧。我之前想到了用next方法，没有表达清楚，面完突然好像懂了吼吼吼。<br>所以终极方案就是：Promise+Generator<br>Generator的这种特性对于异步来说，意味着什么呢？<br>意味着，我们终于获得了一种在不阻塞主线程的前提下实现“同步等待”的方法！<br>为便于说明，先上一段直接使用回调的代码：<br>看下面这个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function* <span class="title">myGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  yield Promise.resolve(<span class="number">1</span>);</span><br><span class="line">  yield Promise.resolve(<span class="number">2</span>);</span><br><span class="line">  yield Promise.resolve(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = myGenerator()</span><br><span class="line">gen.next().value.then(val =&gt; &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(val)</span><br><span class="line">  gen.next().value.then(val =&gt; &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(val)</span><br><span class="line">    gen.next().value.then(val =&gt; &#123;</span><br><span class="line">      console.<span class="built_in">log</span>(val)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出1 2 3</span></span><br><span class="line"></span><br><span class="line">这就是面试官姐姐的问题，这是我的思路，下文深究一下这个问题的根源。</span><br><span class="line">```cpp</span><br><span class="line">function  gen1() &#123; </span><br><span class="line">let count = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123; </span><br><span class="line">let msg = yield ++count; </span><br><span class="line">console.<span class="built_in">log</span>(msg); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let iter = gen1(); <span class="comment">//获得迭代器</span></span><br><span class="line">console.<span class="built_in">log</span>(iter.next().value); </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line">console.<span class="built_in">log</span>(iter.next(‘magic’).value); </span><br><span class="line"><span class="comment">// ‘magic’ </span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">let it = gen1(); <span class="comment">// 获得迭代器</span></span><br><span class="line"><span class="function">function <span class="title">request</span><span class="params">()</span> </span>&#123; </span><br><span class="line">ajax(&#123; </span><br><span class="line">url: ‘www.someurl.com’, </span><br><span class="line">onSuccess(res)&#123; </span><br><span class="line">it.next(res); <span class="comment">// 恢复Generator运行，同时向其中塞入异步返回的结果 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">gen2</span><span class="params">()</span> </span>&#123; </span><br><span class="line">let response = yield request(); </span><br><span class="line">console.<span class="built_in">log</span>(response.text); </span><br><span class="line">&#125;</span><br><span class="line">it.next(); <span class="comment">// 启动Generator</span></span><br><span class="line">```cpp</span><br><span class="line">let it = gen2(); </span><br><span class="line">let p = it.next().value; <span class="comment">// p是yield返回的Promise </span></span><br><span class="line">p.then(res =&gt; it.next(res), </span><br><span class="line">err =&gt; it.<span class="keyword">throw</span>(err) <span class="comment">// 发生错误时，将错误抛入生成器 </span></span><br><span class="line">);</span><br><span class="line">```cpp</span><br><span class="line"><span class="function">function <span class="title">request</span><span class="params">()</span> </span>&#123; <span class="comment">// 此处的request返回的是一个Promise </span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve, reject) =&gt; &#123; </span><br><span class="line">ajax(&#123; </span><br><span class="line">url: ‘www.someurl.com’, </span><br><span class="line">onSuccess(res) &#123; </span><br><span class="line">resolve(res); </span><br><span class="line">&#125;, </span><br><span class="line">onFail(err) &#123; </span><br><span class="line">reject(err); </span><br><span class="line">&#125; </span><br><span class="line">&#125;); </span><br><span class="line">&#125;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">function* <span class="title">gen2</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">let response = yield request(); </span><br><span class="line">console.<span class="built_in">log</span>(response.text); </span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123; </span><br><span class="line">console.<span class="built_in">log</span>(“出错了”, error.message); <span class="comment">// 可以捕获Promise抛进来的错误！ </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>思考：gen是个function，执行它时却不执行里面的代码，而是返回一个Iterator对象，代码执行到yield处可以暂停，暂停以后，可以恢复继续执行，另外，暂停/恢复执行时，还可以传出/传入数据！<br>其实Generator并没有改变JS运行的基本规则。<br>思考let response = yield request()这行代码，我来仔细分析下这段代码是如何运行的。如有错误，欢迎大家指教。<br>1、首先，最后一行it.next()使得Generator内部的代码从头开始执行，执行到yield语句时，暂停，此时可以把yield想象成return，Generator的栈帧需要被弹出，会先计算yield右边的表达式，即执行request函数调用，以获得用于返回给上一级栈帧的值。<br>2、但是现在request函数没有返回值，但它发送了一个异步ajax请求，并注册了一个onSuccess回调，表示在请求返回结果时，恢复Generator的栈帧并继续运行代码，并把结果作为参数塞给Generator，准确地说是塞到yield所在的地方。<br>3、这response变量就获得了ajax的返回值。 可以看出，这里yield的功能设计得非常巧妙，好像它可以“赋值”给response。<br>4、更妙的是，迭代器不但可以.next，还可以.throw，即把错误也抛入Generator，让后者来处理。也就是说，在Generator里使用try-catch语句捕获异步错误。</p>
<blockquote>
<p>是不是只有.then方法这样的形式才能完成自动执行的功能呢？ 我去查阅了一些资料发现，yield 后边除了接 Promise，还可以接thunk函数， thunk 函数，就是单参的只接受回调的函数，详细介绍可以看阮一峰 Thunk。<br>函数的含义和用法，无论是 Promise 还是 thunk 函数，其核心都是通过传入回调的方式来实现 Generator 的自动执行。<br>总结一下：Generator 实现的核心在于上下文的保存，函数并没有真的被挂起，每一次 yield，其实都执行了一遍传入的生成器函数。<br>只是在这个过程中间用了一个 context 对象储存上下文，使得每次执行生成器函数的时候，都可以从上一个执行结果开始执行，看起来就像函数被挂起了一样。</p>
</blockquote>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">下面尝试封装一下自动迭代：</span><br><span class="line">这个run 方法里，可以把执行下一步的操作封装成 step()，每次 Promise.<span class="keyword">then</span>()的时候都去执行 step()，实现自动迭代的效果。在迭代的过程中，我们还把 resolve 的值传入gen.next()，使得 <span class="keyword">yield</span> 得以返回 Promise 的 resolve 的值。</span><br><span class="line">```<span class="javascript">cpp</span></span><br><span class="line"><span class="javascript"> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> g = gen()    <span class="comment">//由于每次gen()获取到的都是最新的迭代器,因此获取迭代器操作要放在step()之前,否则会进入死循环</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">val</span>) </span>&#123;              <span class="comment">//封装一个方法, 递归执行next()</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> res = g.next(val)           <span class="comment">//获取迭代器对象，并返回resolve的值</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>(res.done) <span class="keyword">return</span> res.value   <span class="comment">//递归终止条件</span></span></span><br><span class="line"><span class="javascript">    res.value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;         <span class="comment">//Promise的then方法是实现自动迭代的前提</span></span></span><br><span class="line"><span class="javascript">      step(val)                     <span class="comment">//等待Promise完成就自动执行下一个next，并传入resolve的值</span></span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">  step()  <span class="comment">//第一次执行</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br></pre></td></tr></table></figure>

<p>理解Generator的关键点在于理解函数执行时，内存里发生了什么。<br>一个JS程序的内存分为代码区、栈区、堆区和队列区，从MDN借图一张以说明（图中没有画出代码区）：<br><img src="https://img-blog.csdnimg.cn/20200414013448793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>1、队列（Queue）就是事件循环队列，分为了宏任务和微任务。<br>2、代码区保存着全部JS源代码被引擎编译成的机器码（以V8为例）。<br>3、栈（stack）保存着每个函数执行所需的上下文，一个栈元素被称为一个栈帧，一个栈帧对应一个函数。<br>4、对于引用类型的数据，在栈帧里只保存引用，而真正的数据存放在堆（Heap）里。<br>5、堆与栈不同的是，栈内存由JS引擎自动管理，入栈时分配空间，出栈时回收，非常清楚明了。<br>6、堆是程序员通过new操作符手动向操作系统申请的内存空间（当然，用字面量语法创建对象也算），何时该回收没那么明晰，所以需要一套垃圾收集（GC）算法来专门做这件事。<br>以上是预备知识，现在 回到Generator的正题：<br>1、普通函数在被调用时，JS引擎会创建一个栈帧，在里面准备好局部变量、函数参数、临时值、代码执行的位置（也就是说这个函数的第一行对应到代码区里的第几行机器码），在当前栈帧里设置好返回位置，然后将新帧压入栈顶。<br>2、待函数执行结束后，这个栈帧将被弹出栈然后销毁，返回值会被传给上一个栈帧。<br>3、当执行到yield语句时，Generator的栈帧同样会被弹出栈外，但Generator在这里耍了个花招——它在堆里保存了栈帧的引用（或拷贝）！<br>4、这样当iter.next方法被调用时，JS引擎便不会重新创建一个栈帧，而是把堆里的栈帧直接入栈。因为栈帧里保存了函数执行所需的全部上下文以及当前执行的位置，所以当任务调度来临时，就好像程序从原本暂停的地方继续向前执行了。 因为每次yield和iter.next都对应一次出栈和入栈，所以可以直接利用已有的栈机制，实现值的传出和传入。<br>终于揭开了Generator背后的神秘！</p>
<p>上述写法完美结合了Promise和Generator的优点，写法套路非常固定，当Promise对象一多时，就需要写许多类似p.then(res =&gt; …., err =&gt; …)这样的重复语句，所以就把这种套路给提炼成了一个更加精简的语法，那就是传说中的async/await，六中梳理一下hhh。</p>
<h2 id="六、async，await是解决异步操作的终极方案"><a href="#六、async，await是解决异步操作的终极方案" class="headerlink" title="六、async，await是解决异步操作的终极方案"></a>六、async，await是解决异步操作的终极方案</h2><p>场景：在多个回调依赖的场景中，尽管 Promise 通过链式调用取代了回调嵌套，但过多的链式调用可读性仍然不佳，流程控制也不方便，ES7 提出的 async 函数，终于让 JS 对于异步操作有了终极解决方案，简洁优美地解决了以上两个问题。</p>
<blockquote>
<p>设想一个这样的场景，异步任务 a-&gt;b-&gt;c 之间存在依赖关系，如果我们通过 then链式调用来处理这些关系，可读性并不是很好，如果我们想控制其中某个过程，比如在某些条件下，b 不往下执行到 c，那么也不是很方便控制。比如读取完了文件再去写，等待一段时间后再去执行，类似于我们会中断流程，然后再接着原来的任务去做。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> a = await Promise.resolve(a);</span><br><span class="line">  <span class="keyword">const</span> b = await Promise.resolve(b);</span><br><span class="line">  <span class="keyword">const</span> c = await Promise.resolve(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">async funtion <span class="title">fetch</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">let response = await request(); <span class="comment">// request定义同上一端段示例代码 </span></span><br><span class="line">console.<span class="built_in">log</span>(response.text); </span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123; </span><br><span class="line">console.<span class="built_in">log</span>(“wqx”, error.message); </span><br><span class="line">&#125; ;</span><br><span class="line">fetch();</span><br></pre></td></tr></table></figure>
<p>下面做一下总结：<br>1、MDN上说，async/await 实际上是对 Generator（生成器）的封装，是一个语法糖。<br>2、ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，通过 next()方法可以切换到下一个状态，为改变执行流程提供了可能，从而为异步编程提供解决方案。<br>3、Generator 函数也可以通过给next()传参, 让 yield 具有返回值。<br>4、async/await自带执行器，不需要手动调用 next()就能自动执行下一步。<br>5、async函数返回值是 Promise 对象，而 Generator 返回的是生成器对象。<br>6、await能够返回 Promise 的 resolve/reject 的值。<br>7、在代码中也可以通过给gen.next()传值的方式，让 yield 能返回 resolve 的值。<br>8、async解决了生成器函数能自动往下执行，且 yield 能返回 resolve 的值这两个问题。<br>就靠拢同步风格的程度而言，感觉async/await已经到了炉火纯青的地步，以后在项目中要积极思考，合理应用到不同的场景！</p>

      
      <!-- reward -->
      
      <div id="reward-btn">
        打赏
      </div>
      
    </div>
    
    
      <!-- copyright -->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>版权声明： </strong s>
              本博客所有文章除特别声明外，均采用 <a href="https://www.apache.org/licenses/LICENSE-2.0.html" rel="external nofollow"
                target="_blank">Apache License 2.0</a> 许可协议。转载请注明出处！
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://yoursite.com/2020/04/14/%E8%AE%A4%E7%9C%9F%E5%89%96%E6%9E%90Promise/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../../../tags/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF%E5%92%8C%E6%80%BB%E7%BB%93/" rel="tag">个人成长和总结</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../../../tags/%E8%AE%A4%E7%9C%9F%E5%89%96%E6%9E%90Promise/" rel="tag">认真剖析Promise</a></li></ul>


    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="../../17/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            阿里面试复盘总结（三）——动画方案+秒杀系统+项目难题
          
        </div>
      </a>
    
    
      <a href="../../13/%E6%80%9D%E8%80%83%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E7%9A%84%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">思考用户登录的加密解密</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        app_id: '',
        app_key: '',
        path: window.location.pathname,
        notify: 'false',
        verify: 'false',
        avatar: 'mp',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2020
        Wangqiuxia
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    <aside class="sidebar">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="../../../../index.html"><img src="/images/ayer-side.svg" alt="爱产品，爱前端！"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../../../index.html">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../../../archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../../../categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../../../tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../../../tags/%E6%8A%80%E6%9C%AF/">小程序</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../../../http:/shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../../../https:/v.xiumi.us/stage/v5/4IeLH/197507179">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="../../../../atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="../../../../images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="../../../../images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="../../../../js/jquery-2.0.3.min.js"></script>


<script src="../../../../js/jquery.justifiedGallery.min.js"></script>


<script src="../../../../js/lazyload.min.js"></script>


<script src="../../../../js/busuanzi-2.3.pure.min.js"></script>


<script src="../../../../js/share.js"></script>



<script src="../../../../fancybox/jquery.fancybox.min.js"></script>




<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['做一个有情怀懂产品的程序媛！','业精于勤荒于嬉！行成于思毁于随！','越努力越幸运'],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script src="../../../../js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer:'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    onClick: (e) => {
      $('.toc-link').removeClass('is-active-link');
      $(`a[href=${e.target.hash}]`).addClass('is-active-link');
      $(e.target.hash).scrollIntoView();
      return false;
    }
  });
</script>


<script>
  var ayerConfig = {
    mathjax: false
  }
</script>


<script src="../../../../js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=518895142&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>