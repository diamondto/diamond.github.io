<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    阿里面试复盘总结（三）——动画方案+秒杀系统+项目难题 |  爱产品，爱前端！
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="../../../../css/style.css">

  
<script src="../../../../js/pace.min.js"></script>


  

  

<link rel="alternate" href="atom.xml" title="爱产品，爱前端！" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content">
      <section class="outer">
  <article id="post-阿里面试总结" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  阿里面试复盘总结（三）——动画方案+秒杀系统+项目难题
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="" class="article-date">
  <time datetime="2020-04-16T16:00:00.000Z" itemprop="datePublished">2020-04-17</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="../../../../categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/">经验总结</a>
  </div>

      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">7.1k字</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">26分钟</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>Welcome to share creative thoughts!</p>
<h2 id="一、动画方案"><a href="#一、动画方案" class="headerlink" title="一、动画方案"></a>一、动画方案</h2><p>如何设置一个节日动画，推陈出新，提升用户体验？<strong>（技术选型）</strong></p>
<p>1.requestAnimationFrame<br>本质：传入的回调函数执行异步任务、属于宏任务队列、由系统刷新率决定回调函数的时间间隔。</p>
<p><strong>优点：</strong></p>
<p>系统决定回调函数执行时机，动画更流畅，不掉帧。</p>
<p>窗口没激活时，动画将停止，节省计算资源。</p>
<p>存在兼容性问题，自己可以封装。</p>
<p>按帧对网页动画进行重绘，可以并发渲染。</p>
<p><strong>动画方案：</strong></p>
<p>1.大图动画性能消耗大，使用translate3D实现GPU加速。</p>
<p>2.动画结束、暂停时，切换回2D，取消加速。</p>
<p>3.按需加载，必要时卸载。</p>
<p>4.简化函数计算，减少回流、重绘。</p>
<p>5.采用Web  Workers 开启多线程，提供更好的动画效果。</p>
<p><strong>用户体验优化：</strong></p>
<p>1.首屏优先加载，所以图片loaded以后，再启动主动画资源加载。</p>
<p>2.图片优化：雪碧图、压缩、Base64。</p>
<p>3.存储DOM变量，减少DOM tree的查找。</p>
<p>4.限频。</p>
<p><strong>场景应用：</strong></p>
<p>1.Three.js+requestAnimationFrame实现3D动态效果。</p>
<p>2.WebGL+Webpack 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var globalID;</span><br><span class="line"><span class="function">function <span class="title">animate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Do whatever</span></span><br><span class="line">  globalID=requestAnimationFrame(animate);</span><br><span class="line">  <span class="comment">// Do something animate，返回一个ID</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//when ot start</span></span><br><span class="line">  globalID=requestAnimationFrame(animate);</span><br><span class="line"><span class="comment">//when to stop</span></span><br><span class="line">  cancelAnimationFrame(globalID);<span class="comment">//取消回调函数</span></span><br></pre></td></tr></table></figure>

<p>2.setTimeout</p>
<p>本质：异步任务、宏任务队列、有最小执行时间。</p>
<p><strong>缺点：</strong></p>
<p>1.H5标准规定：setTimeout()的第二个参数的最小值（）最短间隔不得低于4毫秒，当我们把延迟时间设置为0，实际上会4毫秒后才把事件推入任务队列。</p>
<p>2.时间不精准，误差与代码执行时间有关。</p>
<p>3.队列中所有的代码都要等到JS进程空闲后才能执行，不论它们是如何添加到队列的。</p>
<p>3.setInterval</p>
<p>本质：以指定周期调用函数，隔一段时间推入一个事件。异步循环任务。</p>
<p><strong>缺点：</strong></p>
<p>事件执行时间不一定准确，有可能当前事件还没有执行完毕，下一个事件来临。</p>
<p>某些间隔被跳过。</p>
<p>多个定时器的代码执行之间的间隔可能比预期小。</p>
<p><strong>解决方案：</strong>使用setTimeout构造轮询可以保证每次轮询的间隔。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function  fn()&#123;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"我被调用了"</span>);</span><br><span class="line">setTimeout(fn,<span class="number">100</span>);</span><br><span class="line">&#125;,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>这个模式链式调用了setTimeout()，每次函数执行的时候都会创建一个新的定时器。第二个setTimeout()调用当前执行的函数，并为其设置另外一个定时器。</p>
<p>这样做的好处是，在前一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。而且，它可以保证在下一次定时器代码执行前，至少要等待指定的间隔，避免了连续的运行。</p>
<p><strong>我的延申思考：</strong></p>
<p>requestIdleCallback()</p>
<p>1、MDN解释：该方法在浏览器的空闲阶段内调用函数排队。使开发者在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，比如动画和输入响应。</p>
<p>2、利用这个特性做性能优化：在每帧的空闲时间进行数据发送操作，或者低优先级的工作，不会影响动画的性能。</p>
<p>3、想到的应用：React  Fiber 架构思想：切割长任务，利用空闲时间执行，避免主线程长时间阻塞。</p>
<p>4、Fiber核心：树的深度遍历变成链表遍历+时间分片+任务调度。</p>
<p>其他实现方案：</p>
<p>GSAP:</p>
<p>优点：</p>
<p>1、运行速度快，多个动画可以同时执行。</p>
<p>2、轻量、模块化、按需使用、无需依赖。</p>
<p>3、零插件依赖。</p>
<p>4、灵活控制，代码量少，可以设置精确时间控制。</p>
<p>5、任何对象都可以实现动画。</p>
<p>6、实现重复：repeat设为-1就OK。</p>
<h2 id="二、Promise的理解"><a href="#二、Promise的理解" class="headerlink" title="二、Promise的理解"></a>二、Promise的理解</h2><p><strong>优点：</strong></p>
<p>1、对象状态不受外界影响。状态一旦改变，就不会再变。</p>
<p>2、解决了回调地狱。</p>
<p>3、提供统一接口，方便异步操作。</p>
<p><strong>缺点：</strong></p>
<p>1、无法中途取消。</p>
<p>2、处于pending无法知道进展到了哪一个阶段。（刚开始还是要完成）</p>
<p><strong>流程：观察者模式</strong></p>
<p>Promise的构造方法接收一个executor()，在new Promise()时就立刻执行这个executor回调</p>
<p>executor()内部的异步任务被放入宏/微任务队列，等待执行</p>
<p>then()被执行，收集成功/失败回调，放入成功/失败队列</p>
<p>executor()的异步任务被执行，触发resolve/reject，从成功/失败队列中取出回调依次执行</p>
<p>细节问题：</p>
<p>promise的then()放入了微任务队列。</p>
<p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获。</p>
<p>如果没有使用 catch 方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。</p>
<p>Node 有一个 unhandledRejection 事件，专门监听未捕获的 reject 错误。</p>
<p>Catch 方法返回的还是一个 Promise 对象，因此后面还可以接着调用 then 方法。</p>
<blockquote>
<p>then 方法</p>
</blockquote>
<ul>
<li><p>1、可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 resolved 时调用，第二个回调函数是<br>Promise 对象的状态变为 rejected 时调用。</p>
<p>2、第二个函数是可选的，不一定要提供。这两个函数都接受 Promise 对象传出的值作为参数。</p>
<p>3、采用链式的 then ，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个 Promise<br>对象（即有异步操作），这时后一个回调函数，就会等待该 Promise 对象的状态发生变化，才会被调用。</p>
<p>（异步变同步的思路）</p>
<p>4、then(）回调不是函数时要忽略，否则会导致链式调用中断。</p>
<p>5、一个Promise依赖于另外一个Promise，异步变同步。简化3的说法</p>
</li>
</ul>
<blockquote>
<p>异步加载图片：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">loadImageAsync</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> Promise(function(resolve, reject) &#123; </span><br><span class="line"> var image = <span class="keyword">new</span> Image();</span><br><span class="line">  image.onload = function() &#123;</span><br><span class="line">   resolve(image); </span><br><span class="line">   &#125;;</span><br><span class="line">   image.onerror = function() &#123; </span><br><span class="line">   reject(new Error('Could not load image at ' + url)); </span><br><span class="line">   &#125;;</span><br><span class="line">   image.src = url; </span><br><span class="line">   &#125;); </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>All方法</p>
</blockquote>
<p>1、接受的参数是数组（里面有多个Promise实例）或者具有iterable接口的对象，但必须使返回的成员是promise的实例。</p>
<p>2、数组中每一项都执行成功才会成功，有一个失败就失败。</p>
<p>3、可以用到前后端加载数据、解决乱序渲染的问题。</p>
<p>（数组下标迭代保证了顺序）</p>
<p>4、异步处理的好帮手，比如ajax请求多个数据，在此之前显示loading图标，使加载全部完成再显示页面，区分懒加载和预加载，看具体场景需求。</p>
<p>5、即使响应时间不同，也可以保证接受到的数据与原始数据顺序一致。</p>
<p>6、一个操作需要所有的Promise一起运行才能解决问题。</p>
<p>Race方法</p>
<p>1、不管结果成功还是失败，数组中哪一个结果最先执行完成就返回哪个结果。</p>
<p>2、具体场景还没有想到，业务里有这种需求吗？后续脑补。</p>
<p>我的延申思考：</p>
<p>1、Promise解决了异步编程的一些问题，但是链式调用不能取消执行，无法获取执行进度怎么办？</p>
<p>2、实际开发，我们如何做好状态管理，兼顾好同步和异步的切换？</p>
<p>3、上述解答可以从其他的框架中挖掘答案。</p>
<p>方案对比和思考：</p>
<p>Generator:</p>
<p>1、generator函数返回一个遍历器对象，是函数的内部指针。</p>
<p>2、每次调用遍历器对象的next方法，就会返回有value和done两个属性的对象。</p>
<p>3、value属性表示当前内部状态的值，等于yield语句后面的值。</p>
<p>4、done属性是布尔值，表示是否遍历结束。</p>
<p>优点：控制函数的暂停和继续，向外输出结果，下次继续执行可以传入参数。</p>
<p>缺点：不能自动执行，遇到yield暂停，要手动控制。</p>
<p>控制Generator函数流程的关键：</p>
<p>是接受传入的值，并且可以把执行的权力还给程序。</p>
<blockquote>
<p>yield*</p>
</blockquote>
<p>yield委托，让出迭代控制。</p>
<p>co:</p>
<p>返回一个Promise对象，让generator自动执行，类比执行器。</p>
<p>thunk函数</p>
<p>自动执行Generator函数。</p>
<blockquote>
<p>for  of :</p>
</blockquote>
<p>遍历Generator函数运行生成的Iterator对象。</p>
<p>不用调用next 方法，可以通过break return 暂停遍历。</p>
<p>实战应用：</p>
<p>1、购物车每订购一件商品就调用next()实现库存的减一，记录库存状态。</p>
<p>2、三次抽奖活动，点击按钮调用next()实现次数减一，转动转盘的时候，让按钮禁止点击，转盘结束之后再调用next()进行下一次的抽奖，然后打开按钮的开关，记录按钮状态。</p>
<p>3、支付场景：付款之后通过定时器询问接口，是否处理完成订单流程。</p>
<p>4、总结一下就是在中断某一个操作时，要保留当时的状态，下次执行时回到当初的状态，比如我们做饭中途取了一个快递，然后保持菜的状态不改变，取完快递回来，接着做饭。</p>
<p>由Generator引发的协程原理思考：</p>
<blockquote>
<p>协程：</p>
</blockquote>
<p>1、协程有自己的上下文和栈，当任务切换时，会将当前的上下文和栈保存到其他地方，再被切回来的时候，恢复之前保存的上下文和栈。</p>
<p>2、我的理解就是：保留上一次的状态，重新进入时恢复到上次离开的状态。</p>
<p>3、按需生成返回结果，而不是一次性的return所有的结果。</p>
<blockquote>
<p>场景应用：</p>
</blockquote>
<p>1、用户登录状态，切换某个页面之后，再次回来，保留上一次的状态。</p>
<p>2、按需读取大文件，一段段的读取，不用一次遍历整个列表。</p>
<p>3、类比流的思想，这里还要多学习一下stream的知识。</p>
<p>4、直接读取大文件容易造成内存溢出，Generator不会造成内存溢出。</p>
<p>5、使用中还可以向yield中传入值。</p>
<p>6、协程开销远小于线程，yield让协程暂停，和线程的阻塞有本质的区别。</p>
<p>7、协程的暂停由程序控制、线程的阻塞状态由操作系统的内核来进行切换。</p>
<blockquote>
<p>由Generator引发的Koa中的原理思考：</p>
</blockquote>
<p>1、首先执行一次 dispatch(0) 也就是默认返回第一个 app.use 传入的函数， 使用 Promise 函数封装返回。</p>
<p>2、其中第一个参数是 ctx，第二个参数就是 next 参数，next 每次执行之后都会等于下一个中间件函数，如果下一个中间件函数不为真则返回一个成功的 Promise。</p>
<p>3、Koa V1  基于Generator   Koa V2 利用async函数。</p>
<p>4、洋葱模型的执行顺序类似捕获和冒泡的过程。</p>
<p>5、由堆栈这种先进后出的模型可以类比Koa框架自外到内的Request和由里到外的Response的数据流。</p>
<p>6、context的保存和传递、中间件的管理、next的实现要深入理解。</p>
<p>7、源码中调用App.use（）把一个中间件push到一个列表中，每次执行use函数，就在函数数组中添加了一个函数，然后通过compose来遍历整个中间件，最终将context和dispatch(i+1)传给了middleware。</p>
<p>8、一个中间件不能调用两次next()，调用时类比async函数，此时并不是表示中间件函数执行完毕了，调用了next()之后主程序还可以执行其他代码，类似于让next函数异步处理。（我对源码是这样理解的，有错误请大家指教）</p>
<p>9、compose将多个中间件函数合并成一个大的中间件函数，然后依次调用单独的每一层。</p>
<p>10、由compose处理中间件想到了redux，redux是利用数组的reducer对数组参数进行迭代。</p>
<p>11、Koa的思想是不是继承了Emitter？为了在任意时间处理抛出的异常，订阅了error事件，Koa有一个app-onerror事件输出错误的日志。</p>
<p>12、error处理有两个层面：APP层面负责log，一次响应过程中的error处理负责排查每次响应的结果。</p>
<h2 id="三、秒杀活动设计的思考方案"><a href="#三、秒杀活动设计的思考方案" class="headerlink" title="三、秒杀活动设计的思考方案"></a>三、秒杀活动设计的思考方案</h2><blockquote>
<p>背景：疫情枪口罩</p>
</blockquote>
<p>前端设计：防抖、节流减少请求次数、降低服务器压力</p>
<p>后端设计：Node玩法高级，开启Master+Worker模式</p>
<p>优点：</p>
<p>Node本身的特性是单线程、事件驱动、异步非阻塞。</p>
<p>没有多线程的切换上下文、加锁、销毁等复杂操作，之前博客也接触学习过。</p>
<p>线程安全、数据读写一致性好。</p>
<p>缺点：</p>
<p>单线程无法利用多核CPU</p>
<p>当时面试想到的方案：</p>
<p>1、<strong>首先进程通信在本科学过有信号量、共享内存、消息队列、管道、套接字等，不过Node是基于管道实现的。</strong></p>
<p>2、Node可以跨平台，libuv会针对不同的平台，采用不同的方式实现进程的通信。</p>
<p>3、开启child_process模块，利用child_process模块直接创建子进程。</p>
<p>暂时取名叫单线程+多进程模式吧</p>
<p>（这和H5提出的Web  Worker有异曲同工之妙，相当于另辟蹊径，解决了JS主线程和UI渲染共用一个线程所引发的相互阻塞问题）。</p>
<p>4、fork线程的开销还是比较大的，是为了利用CPU的资源。</p>
<p>5、口罩请求打到主进程上面，主进程进行代理，转发到不同端口的子进程上。</p>
<p>下来思考复盘之后可能出现的问题：</p>
<p>代理请求转发不友好</p>
<p>1、操作系统的文件描述符是有限的，维护需要成本。</p>
<p>2、比如：当客户端连接到主进程的时候，用完了一个操作符，当主进程连接到子进程时，又用掉了一个，从数量上看，代理方案不节省资源。</p>
<p>解决办法：（办法是查阅Node.js  9.2.3得出的）</p>
<blockquote>
<p>句柄传递-去除代理</p>
</blockquote>
<p>句柄传递可以代替代理的方案，原理是主进程收到客户端的请求之后，将这个请求直接发送到工作进程，而不是重新与子进程之间建立新的连接来转发数据。（又好像发布订阅模式）<br><img src="https://img-blog.csdnimg.cn/20200419125338865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200419125357754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc3MzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>问题来了</p>
<p>为何通过发送句柄之后，多个进程可以监听到相同的端口而不引起异常？</p>
<p>官方解答：</p>
<p>1、因为独立启动的进程中，TCP服务器端socket套接字的文件描述符并不相同，导致监听到相同的端口时会抛出异常。</p>
<p>2、Node底层对每个端口监听设置了SO_REUSEADDR选项，不同进程可以对相同的网卡和端口进行监听，服务器套接字可以被不同的进程复用。</p>
<p>3、对于send(）发送的句柄还原出来的服务而言，文件描述符是相同的，所以监听相同的端口不会引起异常。</p>
<p>4、网络请求向服务器发送时，只有一个幸运的进程可以抢到连接，本质上一个请求的进程对应服务是抢占式的。</p>
<p>好了，这个问题终于解决啦</p>
<p>还有可能出现的问题：（简单给出思路和方案，日后再深入分析~）</p>
<p>1、数据共享？</p>
<p>答：Node本身不支持数据共享，所以我们要引入第三方Redis缓存，写一个定时脚本，在秒杀还没有开始之前，把口罩的库存数量写到Redis，从Redis拿数据处理。</p>
<p>2、多人抢一只口罩，库存来不及更新？</p>
<p>答：使用check-and-set实现乐观锁操作。（这个下去再仔细研究一下）</p>
<h2 id="四、项目梳理：每个项目选了一个点来切入"><a href="#四、项目梳理：每个项目选了一个点来切入" class="headerlink" title="四、项目梳理：每个项目选了一个点来切入"></a>四、项目梳理：每个项目选了一个点来切入</h2><h2 id="项目一"><a href="#项目一" class="headerlink" title="项目一"></a>项目一</h2><p>问题：给学校水果商店做的小程序，计算金额的时候，浮点数的精度问题。</p>
<p>举例子： 源自浮点数误差</p>
<p>0.1+0.2   //0.30000000000000004<br>1-0.9     //0.09999999999999998<br>9007199254740993-9007199254740992  //0<br>Math.pow(2,1023) //8.98846567431158e+307<br>//但是<br>Math.pow(2,1024)  //Infinity<br>0.1 &gt;&gt; 0.0001 1001 1001 1001…（1001无限循环）<br>0.2 &gt;&gt; 0.0011 0011 0011 0011…（0011无限循环）<br>原因分析：</p>
<p>JavaScript 里的数字是采用 IEEE 754 标准的 64 位双精度浮点数。</p>
<p>这个规范定义了浮点数的格式，对于64位的浮点数在内存中的表示：</p>
<p>最高的1位是符号位，接着的11位是指数，剩下的52位为有效数字。</p>
<p>第0位：符号位， s 表示 ，0表示正数，1表示负数；</p>
<p>第1位到第11位：储存指数部分， e 表示 ；</p>
<p>第12位到第63位：储存小数部分（即有效数字），f 表示；</p>
<p>根本原因：计算机底层只能二进制存储，所有的语言都存在这个问题。</p>
<blockquote>
<p>解决办法：</p>
</blockquote>
<p>1、引入两个库</p>
<p>Math.js<br> 适用于JavaScript 和 Node.js </p>
<p>具有灵活的表达式解析器，支持符号计算。</p>
<p>配有大量内置函数和常量</p>
<p>支持大数字(超出安全数的数字)，复数，分数，单位和矩阵的运算。</p>
<p>decimal.js<br>可以方便 JavaScript 进行十进制类型的任意精度数值计算。</p>
<p>2调用误差检查函数number.epsilon（）  兼容方法：math.abs(2，-52)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">withinErrorMargin</span> <span class="params">(left, right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.<span class="built_in">abs</span>(left - right) &lt; Number.EPSILON</span><br><span class="line">&#125;</span><br><span class="line">withinErrorMargin(<span class="number">0.1</span>+<span class="number">0.2</span>, <span class="number">0.3</span>)</span><br></pre></td></tr></table></figure>

<p>3、自己封装</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 核心方法，实现加减乘除运算，确保不丢失精度</span></span><br><span class="line"><span class="comment">     * 思路：把小数放大为整数（乘），进行算术运算，再缩小为小数（除）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param a &#123;number&#125; 运算数1</span></span><br><span class="line"><span class="comment">     * @param b &#123;number&#125; 运算数2</span></span><br><span class="line"><span class="comment">     * @param op &#123;string&#125; 运算类型，有加减乘除（add/subtract/multiply/divide）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">function <span class="title">operation</span><span class="params">(a, b, op)</span> </span>&#123;</span><br><span class="line">        var o1 = toInteger(a);</span><br><span class="line">        var o2 = toInteger(b);</span><br><span class="line">        var n1 = o1.num;</span><br><span class="line">        var n2 = o2.num;</span><br><span class="line">        var t1 = o1.times;</span><br><span class="line">        var t2 = o2.times;</span><br><span class="line">        var max = t1 &gt; t2 ? t1 : t2;</span><br><span class="line">        var result = null;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            case 'add':</span><br><span class="line">                <span class="keyword">if</span> (t1 === t2) &#123; <span class="comment">// 两个小数位数相同</span></span><br><span class="line">                    result = n1 + n2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t1 &gt; t2) &#123; <span class="comment">// o1 小数位 大于 o2</span></span><br><span class="line">                    result = n1 + n2 * (t1 / t2);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// o1 小数位 小于 o2</span></span><br><span class="line">                    result = n1 * (t2 / t1) + n2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result / max</span><br><span class="line">            case 'subtract':</span><br><span class="line">                <span class="keyword">if</span> (t1 === t2) &#123;</span><br><span class="line">                    result = n1 - n2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t1 &gt; t2) &#123;</span><br><span class="line">                    result = n1 - n2 * (t1 / t2);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = n1 * (t2 / t1) - n2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result / max;</span><br><span class="line">            case 'multiply':</span><br><span class="line">                result = (n1 * n2) / (t1 * t2);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            case 'divide':</span><br><span class="line">                result = (n1 / n2) * (t2 / t1);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加减乘除的四个接口</span></span><br><span class="line">    <span class="function">function <span class="title">add</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">        return operation(a, b, 'add');</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">function <span class="title">subtract</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">        return operation(a, b, 'subtract');</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">function <span class="title">multiply</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">        return operation(a, b, 'multiply');</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">function <span class="title">divide</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">        return operation(a, b, 'divide');</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exports</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        add: add, <span class="comment">// 加</span></span><br><span class="line">        subtract: subtract, <span class="comment">// 减</span></span><br><span class="line">        multiply: multiply, <span class="comment">// 乘</span></span><br><span class="line">        divide: divide <span class="comment">// 除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p>学习反思：</p>
<p>1、下去学习了千位分隔符（用正则可以解决）的解决办法。</p>
<p>2、学习了大数相加的办法：转换成字符串进行操作，按位遍历，执行加减乘除，使用变量来保存进位。</p>
<p>3、了解了底层数据的存储方式。</p>
<p>4、涉及到金额要格外细心铭感。</p>
<h2 id="项目二："><a href="#项目二：" class="headerlink" title="项目二："></a>项目二：</h2><p>学习了VUE的框架原理，通过项目有了一些框架体会和思考。</p>
<p>问题：坑挺多，一般查阅MDN和stackoverflow和社区可以解决bug。</p>
<p>收获：VUE-Router的源码学习。</p>
<p>导航守卫的执行过程。</p>
<p>URL变化逻辑切换不同页面的原理。（出栈入栈）</p>
<blockquote>
<p>原理概括分析：</p>
</blockquote>
<p>1当点击router-link时，最终会执行router.push(this.history.push）入栈。</p>
<p>2通过transitionTo做路劲切换，成功的回调会执行pushHash(roote.fullPath</p>
<p>方法，后面根据路劲变化去做入栈出栈操作，完成pop,place,replace功能。</p>
<p>3在 history 的初始化中，会设置一个监听器，监听历史栈的变化。</p>
<p>4当点击浏览器返回按钮的时候，如果已经有 url 被压入历史栈，则会触发 popstate 事件，然后拿到当前要跳转的 hash，执行 transtionTo 方法做一次路径转换。</p>
<blockquote>
<p>阅读源码笔记：</p>
</blockquote>
<p>1、导航守卫就是发生在路由路径切换时，执行的一系列钩子函数。</p>
<p>2、这些钩子函数执行的逻辑：首先构造一个队列 queue，这个队列实际上是一个数组。</p>
<p>3、然后再定义一个迭代器函数 iterator；最后再执行 runQueue 方法执行这个队列。</p>
<p>4、一个非常经典的异步函数队列化执行的模式，queue 是一个NavigationGuard 类型的数组，源码定义了 step 函数，每次根据 index 从 queue 中取一个 guard，然后执行 fn 函数，并且把 guard 作为参数传入，第二个参数是一个函数，当这个函数执行的时候再递归执行 step 函数，前进到下一个，其实这里的 fn 就是非常经典的 iterator 函数</p>
<p>5、iterator 函数逻辑就是去执行每一个导航守卫 hook，并传入 route、current 和匿名函数，这些参数对应源码中的 to、from、next。</p>
<p>6、当执行了匿名函数，会根据一些条件执行 abort 或 next，只有执行 next 的时候，才会前进到下一个导航守卫钩子函数中，这也就是为什么官方文档会说只有执行 next 方法才 resolve 这个钩子函数。</p>
<p>下面举例一个比较经典的，其他就不上图啦</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 经典的同步执行异步函数</span></span><br><span class="line">  runQueue(<span class="built_in">queue</span>, iterator, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> postEnterCbs = []</span><br><span class="line">    <span class="keyword">const</span> isValid = () =&gt; <span class="keyword">this</span>.current === route</span><br><span class="line">    <span class="comment">// 当所有异步组件加载完成后，会执行这里的回调，也就是 runQueue 中的 cb()</span></span><br><span class="line">    <span class="comment">// 接下来执行 需要渲染组件的导航守卫钩子</span></span><br><span class="line">    <span class="keyword">const</span> enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">queue</span> = enterGuards.concat(<span class="keyword">this</span>.router.resolveHooks)</span><br><span class="line">    runQueue(<span class="built_in">queue</span>, iterator, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 跳转完成</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.pending !== route) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abort</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.pending = null</span><br><span class="line">      onComplete(route)</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.router.app) &#123;</span><br><span class="line">        <span class="keyword">this</span>.router.app.$nextTick(() =&gt; &#123;</span><br><span class="line">          postEnterCbs.forEach(cb =&gt; &#123;</span><br><span class="line">            cb()</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">export</span> function <span class="title">runQueue</span> <span class="params">(<span class="built_in">queue</span>: Array&lt;?NavigationGuard&gt;, fn: Function, cb: Function)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> step = index =&gt; &#123;</span><br><span class="line">  <span class="comment">// 队列中的函数都执行完毕，就执行回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="built_in">queue</span>.length) &#123;</span><br><span class="line">      cb()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">queue</span>[index]) &#123;</span><br><span class="line">      <span class="comment">// 执行迭代器，用户在钩子函数中执行 next() 回调</span></span><br><span class="line">      <span class="comment">// 回调中判断传参，没有问题就执行 next()，也就是 fn 函数中的第二个参数</span></span><br><span class="line">        fn(<span class="built_in">queue</span>[index], () =&gt; &#123;</span><br><span class="line">          step(index + <span class="number">1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        step(index + <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取出队列中第一个钩子函数</span></span><br></pre></td></tr></table></figure>

<h2 id="项目三：还在完善中"><a href="#项目三：还在完善中" class="headerlink" title="项目三：还在完善中"></a>项目三：还在完善中</h2><blockquote>
<p>优化一：封装函数</p>
</blockquote>
<p>/*<br>封装的能发ajax请求的函数, 向外暴露的本质是axios</p>
<ol>
<li>解决post请求携带参数的问题: 默认是json, 需要转换成urlencode格式</li>
<li>让请求成功的结果不再是response, 而是response.data的值</li>
<li>统一处理所有请求的异常错误</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">*/</span><br><span class="line">import axios from 'axios'</span><br><span class="line">import qs from 'qs'</span><br><span class="line">import &#123;message&#125; from 'antd'</span><br><span class="line"><span class="comment">// 添加请求拦截器: 让post请求的请求体格式为urlencoded格式 a=1&amp;b2</span></span><br><span class="line"><span class="comment">// 在真正发请求前执行</span></span><br><span class="line">axios.interceptors.request.use(function (config) &#123;</span><br><span class="line">  <span class="comment">// 得到请求方式和请求体数据</span></span><br><span class="line">  <span class="keyword">const</span> &#123;method, data&#125; = config</span><br><span class="line">  <span class="comment">// 处理post请求, 将data对象转换成query参数格式字符串</span></span><br><span class="line">  if (method.toLowerCase() === 'post' &amp;&amp; typeof data==='object') &#123;</span><br><span class="line">    config.data = qs.stringify(data) <span class="comment">// username=admin&amp;password=admin</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">  <span class="comment">// 功能1: 让请求成功的结果不再是response, 而是response.data的值</span></span><br><span class="line">  <span class="comment">// 功能2: 统一处理所有请求的异常错误</span></span><br><span class="line"><span class="comment">// 在请求返回之后且在我们指定的请求响应回调函数之前</span></span><br><span class="line">axios.interceptors.response.use(function (response) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response.data <span class="comment">// 返回的结果就会交给我们指定的请求响应的回调</span></span><br><span class="line">  <span class="comment">// return response // 返回的结果就会交给我们指定的请求响应的回调</span></span><br><span class="line">&#125;, function (error) &#123; <span class="comment">// 统一处理所有请求的异常错误</span></span><br><span class="line">  message.error('请求出错 ' + error.message)</span><br><span class="line">  <span class="comment">// return Promise.reject(error);</span></span><br><span class="line">  <span class="comment">// 返回一个pending状态的promise, 中断promise链</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(() =&gt; &#123;&#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> axios</span><br></pre></td></tr></table></figure>

<blockquote>
<p>优化二：减少Render次数</p>
</blockquote>
<p>Component与PureComponent</p>
<p> 原因分析：Component存在的问题?</p>
<p> 父组件重新render(), 子组件也会重新执行render(), 即使没有任何变化</p>
<p> 解决Component存在的问题</p>
<p> 原因: 组件的shouldComponentUpdate()默认返回true, 即使数据没有变化render()都会重新执行</p>
<p> 办法1: 重写shouldComponentUpdate(), 判断如果数据有变化返回true, 否则返回false</p>
<p> 办法2: 使用PureComponent代替Component</p>
<p> 办法3：使用React.memo()高阶函数</p>
<p>PureComponent的基本原理：</p>
<p>（1）重写实现shouldComponentUpdate()</p>
<p>（2）对组件的新/旧state和props中的数据进行浅比较, 如果都没有变化, 返回false, 否则返回true</p>
<p>（3）一旦ShouldComponentUpdate()返回false，就不再执行用于更新的render()</p>
<blockquote>
<p>优化三：缓存HTTP请求和数据</p>
</blockquote>
<p>原因：</p>
<p>当用户再次请求相同的搜索内容时，可以不必发送网络请求，从缓存中取。</p>
<p>思路：</p>
<p>创建一个资源对象来缓存结果，当每次向网络发出新请求时，检查缓存中有没有上次的相同查询结果，存在就直接返回，不存在再发送网络请求，并将最新的请求数据保存到缓存中。</p>
<blockquote>
<p>优化四：用好Key</p>
</blockquote>
<p>虚拟DOM的key的地位:</p>
<p>1、其实key就是一个是虚拟DOM对象的标识, Key把页面上的DOM和虚拟DOM做了一层关联映射。</p>
<p>2、虚拟DOM是真实DOM在内存中的一个表示。在更新显示时key是一个唯一的标签，就像我们现实生活中的身份证，在生命周期中如果变化了，React会销毁原来的真实DOM，创建新的真实DOM。</p>
<p>3、当列表数组中的数据发生变化生成新的虚拟DOM后, React会逐层做Diff算法，分为TreeDiff  Component Diff  Element Diff </p>
<p>（1）key没有变</p>
<pre><code>item数据没变, 直接使用原来的真实DOM。

item数据变了, 对原来的真实DOM进行数据更新。</code></pre><p>（2）key变了：</p>
<p>销毁原来的真实DOM, 根据item数据创建新的真实DOM显示。</p>
<p>(即使item数据没有变)</p>
<p>4、key为index存在的问题</p>
<p>（1）添加/删除/排序 =&gt; 产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低</p>
<p>（2）如果item界面还有输入框 =&gt; 产生错误的真实DOM更新 ==&gt; 界面有问题</p>
<p>5、使用总结：问题的关键就是一定要用唯一属性作为Key</p>
<p>（1）如果不存在添加/删除/排序/过滤操作, 用index作为keys是可以的。</p>
<p>（2）列表不可以变动时，可以用index作为key。</p>
<p>（3）列表添加删除时，可能导致某一部分的商品下标（key）改变被销毁，导致数据错乱或者不必要的重复渲染。</p>
<p>（4）用唯一属性作为key，比如商品的出厂号码等，在生命周期中唯一不变</p>
<blockquote>
<p>优化小细节总结五：</p>
</blockquote>
<p>1、JS事件中节流。</p>
<p>比如即时搜索功能，节流到输入字段结束之后再去请求数据。</p>
<p>2、避免在map 方法中使用index作为组件的Key。</p>
<p>3、采用记忆化的React组件：存储复杂函数的计算结果，比如优化三中的缓存组件。</p>
<p>4、使用Web  Workers扩展任务。</p>
<p>5、根据需要采用服务端渲染。</p>
<p>6、在服务器启动Gzip压缩，在Node端安装Compression并调用。</p>
<blockquote>
<p>目前计划和挑战：</p>
</blockquote>
<p>1、学习移动消息推送中一键免密登录、第三方登录的原理，尝试实现这个功能。</p>
<p>2、深化前端模块化、工程化的理念和实践，关注智能化的新方向。</p>
<p>3、学习Flutter技术，做好研究生的深度学习毕设。</p>
<p>4、关注前端领域、做好T型学习模式，视野要广，对于某方向的技术要好好沉淀，多思考，多锻炼，坚持不懈，做到精益求精。</p>
<p>5、保持热情和动力、科技改变美丽人生、打造极致体验</p>

      
      <!-- reward -->
      
      <div id="reward-btn">
        打赏
      </div>
      
    </div>
    
    
      <!-- copyright -->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>版权声明： </strong s>
              本博客所有文章除特别声明外，均采用 <a href="https://www.apache.org/licenses/LICENSE-2.0.html" rel="external nofollow"
                target="_blank">Apache License 2.0</a> 许可协议。转载请注明出处！
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://yoursite.com/2020/04/17/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../../../tags/%E4%B8%AA%E4%BA%BA%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/" rel="tag">个人职业规划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../../../tags/%E6%80%9D%E8%80%83%E5%A4%8D%E7%9B%98/" rel="tag">思考复盘</a></li></ul>


    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="../../19/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%EF%BC%9A%E4%B8%80%E4%BA%91%E5%A4%9A%E7%AB%AF%E3%80%81%E6%99%BA%E8%83%BD%E5%8C%96%E3%80%81AI+/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            阿里面试总结（四）——小霞看前端——一云多端、智能化、AI+
          
        </div>
      </a>
    
    
      <a href="../../14/%E8%AE%A4%E7%9C%9F%E5%89%96%E6%9E%90Promise/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">阿里面试总结（二）——认真剖析Promise</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        app_id: '',
        app_key: '',
        path: window.location.pathname,
        notify: 'false',
        verify: 'false',
        avatar: 'mp',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2020
        Wangqiuxia
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    <aside class="sidebar">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="../../../../index.html"><img src="/images/ayer-side.svg" alt="爱产品，爱前端！"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../../../index.html">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../../../archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../../../categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../../../tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../../../tags/%E6%8A%80%E6%9C%AF/">小程序</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../../../http:/shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="../../../../https:/v.xiumi.us/stage/v5/4IeLH/197507179">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="../../../../atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="../../../../images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="../../../../images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="../../../../js/jquery-2.0.3.min.js"></script>


<script src="../../../../js/jquery.justifiedGallery.min.js"></script>


<script src="../../../../js/lazyload.min.js"></script>


<script src="../../../../js/busuanzi-2.3.pure.min.js"></script>


<script src="../../../../js/share.js"></script>



<script src="../../../../fancybox/jquery.fancybox.min.js"></script>




<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['做一个有情怀懂产品的程序媛！','业精于勤荒于嬉！行成于思毁于随！','越努力越幸运'],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script src="../../../../js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer:'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    onClick: (e) => {
      $('.toc-link').removeClass('is-active-link');
      $(`a[href=${e.target.hash}]`).addClass('is-active-link');
      $(e.target.hash).scrollIntoView();
      return false;
    }
  });
</script>


<script>
  var ayerConfig = {
    mathjax: false
  }
</script>


<script src="../../../../js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=518895142&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>